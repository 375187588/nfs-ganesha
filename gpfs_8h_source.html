<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>nfs-ganesha: gpfs.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">nfs-ganesha&#160;<span id="projectnumber">1.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>gpfs.h</h1>  </div>
</div>
<div class="contents">
<a href="gpfs_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*                                                                              */</span>
<a name="l00002"></a>00002 <span class="comment">/* Copyright (C) 2001 International Business Machines                           */</span>
<a name="l00003"></a>00003 <span class="comment">/* All rights reserved.                                                         */</span>
<a name="l00004"></a>00004 <span class="comment">/*                                                                              */</span>
<a name="l00005"></a>00005 <span class="comment">/* This file is part of the GPFS user library.                                  */</span>
<a name="l00006"></a>00006 <span class="comment">/*                                                                              */</span>
<a name="l00007"></a>00007 <span class="comment">/* Redistribution and use in source and binary forms, with or without           */</span>
<a name="l00008"></a>00008 <span class="comment">/* modification, are permitted provided that the following conditions           */</span>
<a name="l00009"></a>00009 <span class="comment">/* are met:                                                                     */</span>
<a name="l00010"></a>00010 <span class="comment">/*                                                                              */</span>
<a name="l00011"></a>00011 <span class="comment">/*  1. Redistributions of source code must retain the above copyright notice,   */</span>
<a name="l00012"></a>00012 <span class="comment">/*     this list of conditions and the following disclaimer.                    */</span>
<a name="l00013"></a>00013 <span class="comment">/*  2. Redistributions in binary form must reproduce the above copyright        */</span>
<a name="l00014"></a>00014 <span class="comment">/*     notice, this list of conditions and the following disclaimer in the      */</span>
<a name="l00015"></a>00015 <span class="comment">/*     documentation and/or other materials provided with the distribution.     */</span>
<a name="l00016"></a>00016 <span class="comment">/*  3. The name of the author may not be used to endorse or promote products    */</span>
<a name="l00017"></a>00017 <span class="comment">/*     derived from this software without specific prior written                */</span>
<a name="l00018"></a>00018 <span class="comment">/*     permission.                                                              */</span>
<a name="l00019"></a>00019 <span class="comment">/*                                                                              */</span>
<a name="l00020"></a>00020 <span class="comment">/* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR         */</span>
<a name="l00021"></a>00021 <span class="comment">/* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES    */</span>
<a name="l00022"></a>00022 <span class="comment">/* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.      */</span>
<a name="l00023"></a>00023 <span class="comment">/* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, */</span>
<a name="l00024"></a>00024 <span class="comment">/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, */</span>
<a name="l00025"></a>00025 <span class="comment">/* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  */</span>
<a name="l00026"></a>00026 <span class="comment">/* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,     */</span>
<a name="l00027"></a>00027 <span class="comment">/* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR      */</span>
<a name="l00028"></a>00028 <span class="comment">/* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF       */</span>
<a name="l00029"></a>00029 <span class="comment">/* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                   */</span>
<a name="l00030"></a>00030 <span class="comment">/*                                                                              */</span>
<a name="l00031"></a>00031 <span class="comment">/* @(#)42       1.1.9.1  src/avs/fs/mmfs/ts/util/gpfs.h, mmfs, avs_rhrz 4/26/12 10:33:43 */</span>
<a name="l00032"></a>00032 <span class="comment">/*</span>
<a name="l00033"></a>00033 <span class="comment"> *  Library calls for GPFS interfaces</span>
<a name="l00034"></a>00034 <span class="comment"> */</span>
<a name="l00035"></a>00035 <span class="preprocessor">#ifndef H_GPFS</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define H_GPFS</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/* Define GPFS_64BIT_INODES to map the default interface definitions</span>
<a name="l00041"></a>00041 <span class="comment">   to 64-bit interfaces. Without this define, the 32-bit interface</span>
<a name="l00042"></a>00042 <span class="comment">   is the default. Both interfaces are always present, but the</span>
<a name="l00043"></a>00043 <span class="comment">   define sets the default. The actual mapping can be found near the</span>
<a name="l00044"></a>00044 <span class="comment">   end of this header. */</span>
<a name="l00045"></a>00045 <span class="comment">/* #define GPFS_64BIT_INODES 1 */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#if defined(WIN32) &amp;&amp; (defined(GPFSDLL) || defined(GWIN))</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054   <span class="comment">/* The following errno values either are missing from Windows errno.h or</span>
<a name="l00055"></a>00055 <span class="comment">     have a conflicting value. Other errno values (e.g. EPERM) are okay. */</span>
<a name="l00056"></a>00056 <span class="preprocessor">  #define GPFS_EALREADY     37      </span><span class="comment">/* Operation already in progress        */</span>
<a name="l00057"></a>00057 <span class="preprocessor">  #define GPFS_EOPNOTSUPP   45      </span><span class="comment">/* Operation not supported              */</span>
<a name="l00058"></a>00058 <span class="preprocessor">  #define GPFS_EDQUOT       69      </span><span class="comment">/* Disk quota exceeded                  */</span>
<a name="l00059"></a>00059 <span class="preprocessor">  #define GPFS_ESTALE       9       </span><span class="comment">/* No filesystem (mapped to EBADF)      */</span>
<a name="l00060"></a>00060 <span class="preprocessor">  #define GPFS_EFORMAT      19      </span><span class="comment">/* Unformatted media (mapped to ENODEV) */</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">/* specify the library calling convention */</span>
<a name="l00063"></a>00063 <span class="preprocessor">  #define GPFS_API __stdcall</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00065"></a>00065   <span class="comment">/* On Windows, this is a HANDLE as returned by CreateFile() */</span>
<a name="l00066"></a>00066   <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="gpfs_8h.html#abdf38b6e0527472c54afa7d35cb5708b">gpfs_file_t</a>;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="preprocessor">#else </span><span class="comment">/* not WIN32 */</span>
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">00070</a> <span class="preprocessor">  #define GPFS_API</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>  <span class="comment">/* On UNIX (and Windows SUA) systems, this is a file descriptor as</span>
<a name="l00072"></a>00072 <span class="comment">     returned by open() */</span>
<a name="l00073"></a><a class="code" href="gpfs_8h.html#abdf38b6e0527472c54afa7d35cb5708b">00073</a>   <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#abdf38b6e0527472c54afa7d35cb5708b">gpfs_file_t</a>;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 
<a name="l00078"></a><a class="code" href="gpfs_8h.html#a88188674b8571bd416e84be815626d90">00078</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a88188674b8571bd416e84be815626d90">gpfs_uid_t</a>;
<a name="l00079"></a><a class="code" href="gpfs_8h.html#a97fb9cbd94bd28cfc770cd2f6459d2e0">00079</a> <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#a97fb9cbd94bd28cfc770cd2f6459d2e0">gpfs_off64_t</a>;
<a name="l00080"></a><a class="code" href="gpfs_8h.html#a53bdfe4481975b2e3d7f90bf3c4c15c9">00080</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#a53bdfe4481975b2e3d7f90bf3c4c15c9">gpfs_uid64_t</a>;
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="structgpfs__timestruc.html">00082</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__timestruc.html">gpfs_timestruc</a>
<a name="l00083"></a>00083 {
<a name="l00084"></a><a class="code" href="structgpfs__timestruc.html#a8f03272259fa4ce8260dd87394d3701f">00084</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__timestruc.html#a8f03272259fa4ce8260dd87394d3701f">tv_sec</a>;
<a name="l00085"></a><a class="code" href="structgpfs__timestruc.html#a5b2206f3b25d35c0fed3557a54e143eb">00085</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__timestruc.html#a5b2206f3b25d35c0fed3557a54e143eb">tv_nsec</a>;
<a name="l00086"></a>00086 } <a class="code" href="gpfs_8h.html#a1526f0455678fca9c7cb7601bacb9db1">gpfs_timestruc_t</a>;
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="structgpfs__timestruc64.html">00088</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64</a>
<a name="l00089"></a>00089 {
<a name="l00090"></a><a class="code" href="structgpfs__timestruc64.html#af198f530a0a49859b28ef62e26044a67">00090</a>   <span class="keywordtype">long</span> <span class="keywordtype">long</span>    <a class="code" href="structgpfs__timestruc64.html#af198f530a0a49859b28ef62e26044a67">tv_sec</a>;
<a name="l00091"></a><a class="code" href="structgpfs__timestruc64.html#a320e284a4a85d983dd21376eef519ed2">00091</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__timestruc64.html#a320e284a4a85d983dd21376eef519ed2">tv_nsec</a>;
<a name="l00092"></a>00092 } <a class="code" href="gpfs_8h.html#a3886bd98ffea7601e7ba8c6a465552d6">gpfs_timestruc64_t</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="gpfs_8h.html#aece1a09bb93b0aed70d06032e99ece01">00094</a> <span class="preprocessor">#define GPFS_SLITE_SIZE_BIT     0x00000001</span>
<a name="l00095"></a><a class="code" href="gpfs_8h.html#ac0193628a3937fe909ad84ddcc8e33ac">00095</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_BLKSIZE_BIT  0x00000002</span>
<a name="l00096"></a><a class="code" href="gpfs_8h.html#a21a42857eeaa8a255092d1218867d716">00096</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_BLOCKS_BIT   0x00000004</span>
<a name="l00097"></a><a class="code" href="gpfs_8h.html#a1a22f6cd6bbeff84bdaf6175f9d06702">00097</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_ATIME_BIT    0x00000010</span>
<a name="l00098"></a><a class="code" href="gpfs_8h.html#a9f2951f5420503748a9d31e52f703d9a">00098</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_MTIME_BIT    0x00000020</span>
<a name="l00099"></a><a class="code" href="gpfs_8h.html#add20b99faae6ab9fe2e629ad96137192">00099</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_CTIME_BIT    0x00000040</span>
<a name="l00100"></a><a class="code" href="gpfs_8h.html#a56a4d7f30f9a986c9e5da409da9f079a">00100</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_EXACT_BITS   0x00000077</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="comment">/* Returns &quot;1&quot; if the attribute is requested to be accurate.</span>
<a name="l00103"></a>00103 <span class="comment">   (On output, indicates the value returned in statbufP is accurate). */</span>
<a name="l00104"></a><a class="code" href="gpfs_8h.html#ac81071812ddbcf31fe6ac3e2e738fb9e">00104</a> <span class="preprocessor">#define GPFS_SLITE(m)         (0 == (m))</span>
<a name="l00105"></a><a class="code" href="gpfs_8h.html#a6cd1ec3c6f33a4dcc57c2aff1c3903dd">00105</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_SIZET(m)   (0 != ((m) &amp; GPFS_SLITE_SIZE_BIT))</span>
<a name="l00106"></a><a class="code" href="gpfs_8h.html#a9662a58609371f4b589ec36d8244e688">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_BLKSIZE(m) (0 != ((m) &amp; GPFS_SLITE_BLKSIZE_BIT))</span>
<a name="l00107"></a><a class="code" href="gpfs_8h.html#a1eb7c27a7c080798dc1f6c0a824b7e3f">00107</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_BLOCKS(m)  (0 != ((m) &amp; GPFS_SLITE_BLOCKS_BIT))</span>
<a name="l00108"></a><a class="code" href="gpfs_8h.html#a4da7621ad3aeb7db4fe3ef88b475001a">00108</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_ATIME(m)   (0 != ((m) &amp; GPFS_SLITE_ATIME_BIT))</span>
<a name="l00109"></a><a class="code" href="gpfs_8h.html#af72bf92814fc936faf88bd44ee67f6d5">00109</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_MTIME(m)   (0 != ((m) &amp; GPFS_SLITE_MTIME_BIT))</span>
<a name="l00110"></a><a class="code" href="gpfs_8h.html#a99a4c0c28401955122bd7e43d7e7fcc5">00110</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_CTIME(m)   (0 != ((m) &amp; GPFS_SLITE_CTIME_BIT))</span>
<a name="l00111"></a><a class="code" href="gpfs_8h.html#a9f887096372c35ce77be7fd312394d48">00111</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SLITE_EXACT(m)   (GPFS_SLITE_EXACT_BITS == (m))</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>
<a name="l00113"></a>00113 <span class="comment">/* Sets the litemask bit indicating that the attribute should be accurate */</span>
<a name="l00114"></a><a class="code" href="gpfs_8h.html#a6053a0b958ac2927ed466d39927d1aba">00114</a> <span class="preprocessor">#define GPFS_S_SLITE(m)         (m) = 0</span>
<a name="l00115"></a><a class="code" href="gpfs_8h.html#a12e13f9ebaa8ec4100641e730a5cb985">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_SIZET(m)   (m) |= GPFS_SLITE_SIZE_BIT</span>
<a name="l00116"></a><a class="code" href="gpfs_8h.html#a96c3ea7cbf482dd9ddb80647dafa56b3">00116</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_BLKSIZE(m) (m) |= GPFS_SLITE_BLKSIZE_BIT</span>
<a name="l00117"></a><a class="code" href="gpfs_8h.html#a6d957c998a4613696af7a3618627fa03">00117</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_BLOCKS(m)  (m) |= GPFS_SLITE_BLOCKS_BIT</span>
<a name="l00118"></a><a class="code" href="gpfs_8h.html#a8f4d20c36a304057b53defd9069f546a">00118</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_ATIME(m)   (m) |= GPFS_SLITE_ATIME_BIT</span>
<a name="l00119"></a><a class="code" href="gpfs_8h.html#aaa6712bf1a7f5fd7fdc5b4776dc9ce87">00119</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_MTIME(m)   (m) |= GPFS_SLITE_MTIME_BIT</span>
<a name="l00120"></a><a class="code" href="gpfs_8h.html#aa4ee4619165f5a4c3331a58795692022">00120</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_CTIME(m)   (m) |= GPFS_SLITE_CTIME_BIT</span>
<a name="l00121"></a><a class="code" href="gpfs_8h.html#af2a741847ac201e9682042a5f5481d42">00121</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_S_SLITE_EXACT(m)   (m) |= GPFS_SLITE_EXACT_BITS</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a><a class="code" href="gpfs_8h.html#a5014c858b13d16b943ab545b11a5689a">00123</a> <span class="preprocessor">#define GPFS_STATLITE 0</span>
<a name="l00124"></a><a class="code" href="gpfs_8h.html#a90b3f7064550e1ae7b69df5611888b00">00124</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_NOFOLLOW 1</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00126"></a>00126 <span class="comment">/* Mapping of buffer for gpfs_getacl, gpfs_putacl. */</span>
<a name="l00127"></a><a class="code" href="structgpfs__opaque__acl.html">00127</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__opaque__acl.html">gpfs_opaque_acl</a>
<a name="l00128"></a>00128 {
<a name="l00129"></a><a class="code" href="structgpfs__opaque__acl.html#a72d5f6ff1d48e3fb487d0f2508dec27a">00129</a>   <span class="keywordtype">int</span>            <a class="code" href="structgpfs__opaque__acl.html#a72d5f6ff1d48e3fb487d0f2508dec27a">acl_buffer_len</a>;  <span class="comment">/* INPUT:  Total size of buffer (including this field).</span>
<a name="l00130"></a>00130 <span class="comment">                                     OUTPUT: Actual size of the ACL information.  */</span>
<a name="l00131"></a><a class="code" href="structgpfs__opaque__acl.html#adeeb1e84039d2aa13b095d990aefd995">00131</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structgpfs__opaque__acl.html#adeeb1e84039d2aa13b095d990aefd995">acl_version</a>;     <span class="comment">/* INPUT:  Set to zero.</span>
<a name="l00132"></a>00132 <span class="comment">                                     OUTPUT: Current version of the returned ACL. */</span>
<a name="l00133"></a><a class="code" href="structgpfs__opaque__acl.html#ab1c73aa7525b21f5b5e11c9cafd0b65d">00133</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  <a class="code" href="structgpfs__opaque__acl.html#ab1c73aa7525b21f5b5e11c9cafd0b65d">acl_type</a>;        <span class="comment">/* INPUT:  Type of ACL: access (1) or default (2). */</span>
<a name="l00134"></a><a class="code" href="structgpfs__opaque__acl.html#a4344c5fb23b526b7d52e37318c678e68">00134</a>   <span class="keywordtype">char</span>           <a class="code" href="structgpfs__opaque__acl.html#a4344c5fb23b526b7d52e37318c678e68">acl_var_data</a>[1]; <span class="comment">/* OUTPUT: Remainder of the ACL information. */</span>
<a name="l00135"></a>00135 } <a class="code" href="gpfs_8h.html#a6011d108b4fb69b31d117787f1150ca3">gpfs_opaque_acl_t</a>;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">/* ACL types (acl_type field in gpfs_opaque_acl_t or gpfs_acl_t) */</span>
<a name="l00138"></a><a class="code" href="gpfs_8h.html#a0b51be431f5e19adb8275f4e8ab7061f">00138</a> <span class="preprocessor">#define GPFS_ACL_TYPE_ACCESS  1</span>
<a name="l00139"></a><a class="code" href="gpfs_8h.html#a6d9eb3d63339668b083b211ba17fb094">00139</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_TYPE_DEFAULT 2</span>
<a name="l00140"></a><a class="code" href="gpfs_8h.html#a81abf74f3a269a3919665642194d78b0">00140</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_TYPE_NFS4    3</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a>00142 <span class="comment">/* gpfs_getacl, gpfs_putacl flag indicating structures instead of the</span>
<a name="l00143"></a>00143 <span class="comment">   opaque style data normally used.  */</span>
<a name="l00144"></a><a class="code" href="gpfs_8h.html#af2f14aedf8c6baf5df7c0808343b64a8">00144</a> <span class="preprocessor">#define GPFS_GETACL_STRUCT 0x00000020</span>
<a name="l00145"></a><a class="code" href="gpfs_8h.html#aa735c8ed02ac15e48850a9cbdafe7696">00145</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_PUTACL_STRUCT 0x00000020</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>
<a name="l00147"></a>00147 <span class="comment">/* gpfs_getacl, gpfs_putacl flag indicating smbd is the caller */</span>
<a name="l00148"></a><a class="code" href="gpfs_8h.html#aa129e0421dd47c5fa114bf30fcecb86b">00148</a> <span class="preprocessor">#define GPFS_ACL_SAMBA     0x00000040</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150 <span class="comment">/* Defined values for gpfs_aclVersion_t */</span>
<a name="l00151"></a><a class="code" href="gpfs_8h.html#afbbbfa460cc0d64fc2fe152fd364e36b">00151</a> <span class="preprocessor">#define GPFS_ACL_VERSION_POSIX   1</span>
<a name="l00152"></a><a class="code" href="gpfs_8h.html#a9ba3192b4f35adaa2619a276bdd691c1">00152</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_VERSION_NFS4    4</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>
<a name="l00154"></a>00154 <span class="comment">/* Values for gpfs_aclLevel_t  */</span>
<a name="l00155"></a><a class="code" href="gpfs_8h.html#ae017cede727cd8872affbddf0d47250b">00155</a> <span class="preprocessor">#define GPFS_ACL_LEVEL_BASE    0 </span><span class="comment">/* compatible with all acl_version values */</span>
<a name="l00156"></a><a class="code" href="gpfs_8h.html#aaa9bdb19f5ecc05334962b49732e247b">00156</a> <span class="preprocessor">#define GPFS_ACL_LEVEL_V4FLAGS 1 </span><span class="comment">/* requires GPFS_ACL_VERSION_NFS4 */</span>
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">/* Values for gpfs_aceType_t (ACL_VERSION_POSIX) */</span>
<a name="l00159"></a><a class="code" href="gpfs_8h.html#a85982342c5271a9fdb1e8cfc802b9a47">00159</a> <span class="preprocessor">#define GPFS_ACL_USER_OBJ  1</span>
<a name="l00160"></a><a class="code" href="gpfs_8h.html#af61319841cdc82e40ead50a0bd6fd819">00160</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_GROUP_OBJ 2</span>
<a name="l00161"></a><a class="code" href="gpfs_8h.html#aa0bd9cebe222c1661ff614cf0bc63b1f">00161</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_OTHER     3</span>
<a name="l00162"></a><a class="code" href="gpfs_8h.html#abc006b6fc8e57e090815bb4dc8de97fb">00162</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_MASK      4</span>
<a name="l00163"></a><a class="code" href="gpfs_8h.html#a6269d61f1fa74fac53fba4850d7606a2">00163</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_USER      5</span>
<a name="l00164"></a><a class="code" href="gpfs_8h.html#ade3293a1539ccdf9e1182fa92eaecd56">00164</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ACL_GROUP     6</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>
<a name="l00166"></a>00166 <span class="comment">/* Values for gpfs_acePerm_t (ACL_VERSION_POSIX) */</span>
<a name="l00167"></a><a class="code" href="gpfs_8h.html#a36994ee57cda222f63d9171f2ca9e96d">00167</a> <span class="preprocessor">#define ACL_PERM_EXECUTE 001</span>
<a name="l00168"></a><a class="code" href="gpfs_8h.html#a1ec2fe916ca97da54c00cc3746f4a01e">00168</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL_PERM_WRITE   002</span>
<a name="l00169"></a><a class="code" href="gpfs_8h.html#ad69f819856d293edcded4180aedd489f">00169</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL_PERM_READ    004</span>
<a name="l00170"></a><a class="code" href="gpfs_8h.html#a36c84e6b2e2fa2e6f5dfbb5a01237760">00170</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL_PERM_CONTROL 010</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00172"></a>00172 <span class="comment">/* Values for gpfs_aceType_t (ACL_VERSION_NFS4) */</span>
<a name="l00173"></a><a class="code" href="gpfs_8h.html#ad226f1e0b1eadf1648be2af2cbb74cdd">00173</a> <span class="preprocessor">#define ACE4_TYPE_ALLOW 0</span>
<a name="l00174"></a><a class="code" href="gpfs_8h.html#adb6fb79e3915806f5c3c8d589358fcb6">00174</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_TYPE_DENY  1</span>
<a name="l00175"></a><a class="code" href="gpfs_8h.html#adee234d4b6c0dc5e06480f231f483cf8">00175</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_TYPE_AUDIT 2</span>
<a name="l00176"></a><a class="code" href="gpfs_8h.html#aedce7cef1bddef1d9caa01285d5d931e">00176</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_TYPE_ALARM 3</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>
<a name="l00178"></a>00178 <span class="comment">/* Values for gpfs_aceFlags_t (ACL_VERSION_NFS4) */</span>
<a name="l00179"></a><a class="code" href="gpfs_8h.html#a5ac5b29b5a9e3794f19c0ca05295d5e9">00179</a> <span class="preprocessor">#define ACE4_FLAG_FILE_INHERIT    0x00000001</span>
<a name="l00180"></a><a class="code" href="gpfs_8h.html#a51e8da106fb86331da20cf85065c6a1f">00180</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_DIR_INHERIT     0x00000002</span>
<a name="l00181"></a><a class="code" href="gpfs_8h.html#ad247cfe51993fc6cb8b97494d5d7414f">00181</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_NO_PROPAGATE    0x00000004</span>
<a name="l00182"></a><a class="code" href="gpfs_8h.html#a560eb74a19bae1190004af2e84177524">00182</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_INHERIT_ONLY    0x00000008</span>
<a name="l00183"></a><a class="code" href="gpfs_8h.html#a152bbc5a9c4f1fc40c8ddaf0dc524676">00183</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_SUCCESSFUL      0x00000010</span>
<a name="l00184"></a><a class="code" href="gpfs_8h.html#a29d2ac5f8093863e100297c898e2a71d">00184</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_FAILED          0x00000020</span>
<a name="l00185"></a><a class="code" href="gpfs_8h.html#a199600b7a87882fb631dda2474cdb536">00185</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_GROUP_ID        0x00000040</span>
<a name="l00186"></a><a class="code" href="gpfs_8h.html#a6feaa277f03b832e98eb660ba912cdde">00186</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_FLAG_INHERITED       0x00000080</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>
<a name="l00188"></a>00188 <span class="comment">/* GPFS-defined flags.  Placed in a seperate ACL field to avoid</span>
<a name="l00189"></a>00189 <span class="comment">   ever running into newly defined NFSv4 flags. */</span>
<a name="l00190"></a><a class="code" href="gpfs_8h.html#a118d205384771ab40a4b1e295162372c">00190</a> <span class="preprocessor">#define ACE4_IFLAG_SPECIAL_ID     0x80000000</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span>
<a name="l00192"></a>00192 <span class="comment">/* Values for gpfs_aceMask_t (ACL_VERSION_NFS4) */</span>
<a name="l00193"></a><a class="code" href="gpfs_8h.html#ae833502b8fe7aa81165b14ec2c322d5a">00193</a> <span class="preprocessor">#define ACE4_MASK_READ         0x00000001</span>
<a name="l00194"></a><a class="code" href="gpfs_8h.html#a0ff8efb97a9b07dd1069c2a0909d6f08">00194</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_LIST_DIR     0x00000001</span>
<a name="l00195"></a><a class="code" href="gpfs_8h.html#ac8f875a48f4a0c114b1c50848be10d2b">00195</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_WRITE        0x00000002</span>
<a name="l00196"></a><a class="code" href="gpfs_8h.html#a3ab2003926cd44c403d568e9727d02c3">00196</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_ADD_FILE     0x00000002</span>
<a name="l00197"></a><a class="code" href="gpfs_8h.html#a96896a17a298931456b71d13ad87abc4">00197</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_APPEND       0x00000004</span>
<a name="l00198"></a><a class="code" href="gpfs_8h.html#a992c1aa24087117c8be40902c397e0d3">00198</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_ADD_SUBDIR   0x00000004</span>
<a name="l00199"></a><a class="code" href="gpfs_8h.html#a9bb6ae5b151381524310b3ca0965fc24">00199</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_READ_NAMED   0x00000008</span>
<a name="l00200"></a><a class="code" href="gpfs_8h.html#ad686ba7a047776caba3bfd9883ec9cac">00200</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_WRITE_NAMED  0x00000010</span>
<a name="l00201"></a><a class="code" href="gpfs_8h.html#a12a16302a84d625c0338a453769d4380">00201</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_EXECUTE      0x00000020</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>
<a name="l00203"></a>00203 <span class="comment">/* The rfc doesn&#39;t provide a mask equivalent to &quot;search&quot; (&quot;x&quot; on a</span>
<a name="l00204"></a>00204 <span class="comment"> * directory in posix), but it also doesn&#39;t say that its EXECUTE</span>
<a name="l00205"></a>00205 <span class="comment"> * is to have this dual use (even though it does so for other dual</span>
<a name="l00206"></a>00206 <span class="comment"> * use permissions such as read/list.  Going to make the assumption</span>
<a name="l00207"></a>00207 <span class="comment"> * here that the EXECUTE bit has this dual meaning... otherwise</span>
<a name="l00208"></a>00208 <span class="comment"> * we&#39;re left with no control over search.</span>
<a name="l00209"></a>00209 <span class="comment"> */</span>
<a name="l00210"></a><a class="code" href="gpfs_8h.html#a0062939cb17c4e48bbfa0f53f1b534c9">00210</a> <span class="preprocessor">#define ACE4_MASK_SEARCH       0x00000020</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>
<a name="l00212"></a><a class="code" href="gpfs_8h.html#a18bf90b4a1aeae7f0bf8490fb54237a7">00212</a> <span class="preprocessor">#define ACE4_MASK_DELETE_CHILD 0x00000040</span>
<a name="l00213"></a><a class="code" href="gpfs_8h.html#aef852625c9440abb89508b7292f830c8">00213</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_READ_ATTR    0x00000080</span>
<a name="l00214"></a><a class="code" href="gpfs_8h.html#ad6290f5f8cf0871e65439edef239de00">00214</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_WRITE_ATTR   0x00000100</span>
<a name="l00215"></a><a class="code" href="gpfs_8h.html#a3e18530ddec0bd1e63870aaa90a0bf6e">00215</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_DELETE       0x00010000</span>
<a name="l00216"></a><a class="code" href="gpfs_8h.html#a55805f58281346eb4738f2e76542789d">00216</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_READ_ACL     0x00020000</span>
<a name="l00217"></a><a class="code" href="gpfs_8h.html#acd9ae3f6eeb52694bcd6243fb82314c2">00217</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_WRITE_ACL    0x00040000</span>
<a name="l00218"></a><a class="code" href="gpfs_8h.html#aadeb9e316f7746885a2d8f360b60884e">00218</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_WRITE_OWNER  0x00080000</span>
<a name="l00219"></a><a class="code" href="gpfs_8h.html#ad23311b3a7397ec02c37d3a650bd48c8">00219</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_SYNCHRONIZE  0x00100000</span>
<a name="l00220"></a><a class="code" href="gpfs_8h.html#a39cd379d44b4a2818265b9b5da1c07ce">00220</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_MASK_ALL          0x001f01ff</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>
<a name="l00222"></a>00222 <span class="comment">/* Values for gpfs_uid_t (ACL_VERSION_NFS4) */</span>
<a name="l00223"></a><a class="code" href="gpfs_8h.html#a47c87b966a88b2cfdaf3c1b290d45976">00223</a> <span class="preprocessor">#define ACE4_SPECIAL_OWNER              1</span>
<a name="l00224"></a><a class="code" href="gpfs_8h.html#a667909e7c458123af932e9810ce50a33">00224</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_SPECIAL_GROUP              2</span>
<a name="l00225"></a><a class="code" href="gpfs_8h.html#a0c27dd0d8fe5af67ffaf6b4878e6f322">00225</a> <span class="preprocessor"></span><span class="preprocessor">#define ACE4_SPECIAL_EVERYONE           3</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>
<a name="l00227"></a>00227 <span class="comment">/* per-ACL flags imported from a Windows security descriptor object */</span>
<a name="l00228"></a><a class="code" href="gpfs_8h.html#a91e2bd8b5598e3ad43259226f6c5a07f">00228</a> <span class="preprocessor">#define ACL4_FLAG_OWNER_DEFAULTED               0x00000100</span>
<a name="l00229"></a><a class="code" href="gpfs_8h.html#abbcd58f242aacde9179819612bb1cd85">00229</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_GROUP_DEFAULTED               0x00000200</span>
<a name="l00230"></a><a class="code" href="gpfs_8h.html#a5cbb499c701a010913460eaab79e4161">00230</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_PRESENT                  0x00000400</span>
<a name="l00231"></a><a class="code" href="gpfs_8h.html#a4bf37ad79475640dc0de16d30442bd71">00231</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_DEFAULTED                0x00000800</span>
<a name="l00232"></a><a class="code" href="gpfs_8h.html#afb640498435b1226f9d66c3e8ab463eb">00232</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SACL_PRESENT                  0x00001000</span>
<a name="l00233"></a><a class="code" href="gpfs_8h.html#aebdd2b4d40b7e7986cf407d0f295722a">00233</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SACL_DEFAULTED                0x00002000</span>
<a name="l00234"></a><a class="code" href="gpfs_8h.html#a0151cfb81e009dce61823b2346e2f9e8">00234</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_UNTRUSTED                0x00004000</span>
<a name="l00235"></a><a class="code" href="gpfs_8h.html#a5f8e13ad0957b3041d9eeb46084d3f37">00235</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SERVER_SECURITY               0x00008000</span>
<a name="l00236"></a><a class="code" href="gpfs_8h.html#ac4ec0427efcfa4b14f12832516cd8867">00236</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_AUTO_INHERIT_REQ         0x00010000</span>
<a name="l00237"></a><a class="code" href="gpfs_8h.html#a6365804f39ad5e22bc685aabcf566b4b">00237</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SACL_AUTO_INHERIT_REQ         0x00020000</span>
<a name="l00238"></a><a class="code" href="gpfs_8h.html#a5571ba8e09212126c13961bab2366cb8">00238</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_AUTO_INHERITED           0x00040000</span>
<a name="l00239"></a><a class="code" href="gpfs_8h.html#a478b5afaff3be6200be0fc7ef83f7b56">00239</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SACL_AUTO_INHERITED           0x00080000</span>
<a name="l00240"></a><a class="code" href="gpfs_8h.html#a6e8c8ec84e7977cb31e62e7b41486b14">00240</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_DACL_PROTECTED                0x00100000</span>
<a name="l00241"></a><a class="code" href="gpfs_8h.html#a107ed2dbaa9a1a072232980cfde73198">00241</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_SACL_PROTECTED                0x00200000</span>
<a name="l00242"></a><a class="code" href="gpfs_8h.html#ae24ea61ca8b5242664aed6d5a3893521">00242</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_RM_CONTROL_VALID              0x00400000</span>
<a name="l00243"></a><a class="code" href="gpfs_8h.html#aefadb7f586dfaa7e53995f807a839e4d">00243</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_NULL_DACL                     0x00800000</span>
<a name="l00244"></a><a class="code" href="gpfs_8h.html#a8b78df659e5c2d511cfea80023ef0889">00244</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_NULL_SACL                     0x01000000</span>
<a name="l00245"></a><a class="code" href="gpfs_8h.html#aa059d6cdf405f67020fa3d3a19274f8a">00245</a> <span class="preprocessor"></span><span class="preprocessor">#define ACL4_FLAG_VALID_FLAGS                   0x01ffff00</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">/* Externalized ACL defintions */</span>
<a name="l00249"></a><a class="code" href="gpfs_8h.html#aabf580ffdef56b48d376040469a5f458">00249</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#aabf580ffdef56b48d376040469a5f458">gpfs_aclType_t</a>;
<a name="l00250"></a><a class="code" href="gpfs_8h.html#a8df743cee7245b9065b5b1c7e3bbb73c">00250</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a8df743cee7245b9065b5b1c7e3bbb73c">gpfs_aclLen_t</a>;
<a name="l00251"></a><a class="code" href="gpfs_8h.html#a2ec44f5d5150f00b358eff8ac4bb8255">00251</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a2ec44f5d5150f00b358eff8ac4bb8255">gpfs_aclLevel_t</a>;
<a name="l00252"></a><a class="code" href="gpfs_8h.html#a0629219e5ca41ea631cb086500b3ff7f">00252</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a0629219e5ca41ea631cb086500b3ff7f">gpfs_aclVersion_t</a>;
<a name="l00253"></a><a class="code" href="gpfs_8h.html#ac05c69ae60c91fd3e9c84a4b2bb493ae">00253</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#ac05c69ae60c91fd3e9c84a4b2bb493ae">gpfs_aclCount_t</a>;
<a name="l00254"></a><a class="code" href="gpfs_8h.html#a261151e966454dd47df808996c70c2d6">00254</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a261151e966454dd47df808996c70c2d6">gpfs_aclFlag_t</a>;
<a name="l00255"></a>00255 
<a name="l00256"></a><a class="code" href="gpfs_8h.html#a53cf030cebf2a3d895df39c23184d334">00256</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a53cf030cebf2a3d895df39c23184d334">gpfs_aceType_t</a>;
<a name="l00257"></a><a class="code" href="gpfs_8h.html#a83c21d6caca0b10e097d1149580fbe67">00257</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a83c21d6caca0b10e097d1149580fbe67">gpfs_aceFlags_t</a>;
<a name="l00258"></a><a class="code" href="gpfs_8h.html#abe5bec02578cc4b49b5a647d04ff8ddf">00258</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#abe5bec02578cc4b49b5a647d04ff8ddf">gpfs_acePerm_t</a>;
<a name="l00259"></a><a class="code" href="gpfs_8h.html#a1b00a3eed76fa47b76c073ab5f302287">00259</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a1b00a3eed76fa47b76c073ab5f302287">gpfs_aceMask_t</a>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">/* A POSIX ACL Entry */</span>
<a name="l00262"></a><a class="code" href="structgpfs__ace__v1.html">00262</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__ace__v1.html">gpfs_ace_v1</a>
<a name="l00263"></a>00263 {
<a name="l00264"></a><a class="code" href="structgpfs__ace__v1.html#a759bbb4b75663056b2f5adb9a7151991">00264</a>   gpfs_aceType_t  <a class="code" href="structgpfs__ace__v1.html#a759bbb4b75663056b2f5adb9a7151991">ace_type</a>; <span class="comment">/* POSIX ACE type */</span>
<a name="l00265"></a><a class="code" href="structgpfs__ace__v1.html#a5e8e79e569c6f37754cad7915fdeaced">00265</a>   gpfs_uid_t      <a class="code" href="structgpfs__ace__v1.html#a5e8e79e569c6f37754cad7915fdeaced">ace_who</a>;  <span class="comment">/* uid/gid */</span>
<a name="l00266"></a><a class="code" href="structgpfs__ace__v1.html#aef91f8df7fcef73ac03b142032768570">00266</a>   gpfs_acePerm_t  <a class="code" href="structgpfs__ace__v1.html#aef91f8df7fcef73ac03b142032768570">ace_perm</a>; <span class="comment">/* POSIX permissions */</span>
<a name="l00267"></a>00267 } <a class="code" href="gpfs_8h.html#ab498a497b3c87081d2215549c38ad878">gpfs_ace_v1_t</a>;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="comment">/* A NFSv4 ACL Entry */</span>
<a name="l00270"></a><a class="code" href="structgpfs__ace__v4.html">00270</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__ace__v4.html">gpfs_ace_v4</a>
<a name="l00271"></a>00271 {
<a name="l00272"></a><a class="code" href="structgpfs__ace__v4.html#ae9acc6b0513b2ff49d3432f397a608b5">00272</a>   gpfs_aceType_t  <a class="code" href="structgpfs__ace__v4.html#ae9acc6b0513b2ff49d3432f397a608b5">aceType</a>;   <span class="comment">/* Allow or Deny */</span>
<a name="l00273"></a><a class="code" href="structgpfs__ace__v4.html#ab8893b35ef3ff38267c6e04d12d6e098">00273</a>   gpfs_aceFlags_t <a class="code" href="structgpfs__ace__v4.html#ab8893b35ef3ff38267c6e04d12d6e098">aceFlags</a>;  <span class="comment">/* Inherit specifications, etc. */</span>
<a name="l00274"></a><a class="code" href="structgpfs__ace__v4.html#aa7d1c9362bff1cc18d63e824d6e4eadc">00274</a>   gpfs_aceFlags_t <a class="code" href="structgpfs__ace__v4.html#aa7d1c9362bff1cc18d63e824d6e4eadc">aceIFlags</a>; <span class="comment">/* GPFS Internal flags */</span>
<a name="l00275"></a><a class="code" href="structgpfs__ace__v4.html#a1ecffdfa8a8e83cf22845c61d0ce2844">00275</a>   gpfs_aceMask_t  <a class="code" href="structgpfs__ace__v4.html#a1ecffdfa8a8e83cf22845c61d0ce2844">aceMask</a>;   <span class="comment">/* NFSv4 mask specification */</span>
<a name="l00276"></a><a class="code" href="structgpfs__ace__v4.html#a84e5a4cded03a97d411c30583d740bd0">00276</a>   gpfs_uid_t      <a class="code" href="structgpfs__ace__v4.html#a84e5a4cded03a97d411c30583d740bd0">aceWho</a>;    <span class="comment">/* User/Group identification */</span>
<a name="l00277"></a>00277 } <a class="code" href="gpfs_8h.html#acfe46bfe8d55a8021ee1d2dca5ce2161">gpfs_ace_v4_t</a>;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">/* when GPFS_ACL_VERSION_NFS4, and GPFS_ACL_LEVEL_V4FLAGS */</span>
<a name="l00280"></a><a class="code" href="structv4Level1__ext.html">00280</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structv4Level1__ext.html">v4Level1_ext</a> <span class="comment">/* ACL extension */</span>
<a name="l00281"></a>00281 { 
<a name="l00282"></a><a class="code" href="structv4Level1__ext.html#a67e226605817f11fb775aa61fd8f6fa1">00282</a>   gpfs_aclFlag_t <a class="code" href="structv4Level1__ext.html#a67e226605817f11fb775aa61fd8f6fa1">acl_flags</a>; <span class="comment">/* per-ACL flags */</span>
<a name="l00283"></a><a class="code" href="structv4Level1__ext.html#a41d7554bc41153d971eb5bb949e47780">00283</a>   <a class="code" href="structgpfs__ace__v4.html">gpfs_ace_v4_t</a> <a class="code" href="structv4Level1__ext.html#a41d7554bc41153d971eb5bb949e47780">ace_v4</a>[1];
<a name="l00284"></a>00284 } <a class="code" href="gpfs_8h.html#af9d8193af950200a092ba45c7641cf4b">v4Level1_t</a>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="comment">/* The GPFS ACL */</span>
<a name="l00287"></a><a class="code" href="structgpfs__acl.html">00287</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__acl.html">gpfs_acl</a>
<a name="l00288"></a>00288 {
<a name="l00289"></a><a class="code" href="structgpfs__acl.html#a401edb74a8f23fec24ac9836d38d7915">00289</a>   gpfs_aclLen_t     <a class="code" href="structgpfs__acl.html#a401edb74a8f23fec24ac9836d38d7915">acl_len</a>;     <span class="comment">/* Total length of this ACL in bytes */</span>
<a name="l00290"></a><a class="code" href="structgpfs__acl.html#a7b9f51441aaca92d1f58198c441b3e95">00290</a>   gpfs_aclLevel_t   <a class="code" href="structgpfs__acl.html#a7b9f51441aaca92d1f58198c441b3e95">acl_level</a>;   <span class="comment">/* Reserved (must be zero) */</span>
<a name="l00291"></a><a class="code" href="structgpfs__acl.html#a9b6349ab32d0dda78aa3e2a714626250">00291</a>   gpfs_aclVersion_t <a class="code" href="structgpfs__acl.html#a9b6349ab32d0dda78aa3e2a714626250">acl_version</a>; <span class="comment">/* POSIX or NFS4 ACL */</span>
<a name="l00292"></a><a class="code" href="structgpfs__acl.html#aef252fa03514abed4fe19bcd05864571">00292</a>   gpfs_aclType_t    <a class="code" href="structgpfs__acl.html#aef252fa03514abed4fe19bcd05864571">acl_type</a>;    <span class="comment">/* Access, Default, or NFS4 */</span>
<a name="l00293"></a><a class="code" href="structgpfs__acl.html#af22706c6c3496e8a0d2cecbb34fabf66">00293</a>   gpfs_aclCount_t   <a class="code" href="structgpfs__acl.html#af22706c6c3496e8a0d2cecbb34fabf66">acl_nace</a>;    <span class="comment">/* Number of Entries that follow */</span>
<a name="l00294"></a>00294   <span class="keyword">union</span>
<a name="l00295"></a>00295   {
<a name="l00296"></a><a class="code" href="structgpfs__acl.html#a374f1d25fbdb656beada006cedd46d2d">00296</a>     <a class="code" href="structgpfs__ace__v1.html">gpfs_ace_v1_t</a>  <a class="code" href="structgpfs__acl.html#a374f1d25fbdb656beada006cedd46d2d">ace_v1</a>[1]; <span class="comment">/* when GPFS_ACL_VERSION_POSIX */</span>
<a name="l00297"></a><a class="code" href="structgpfs__acl.html#ae99c15da285ebc6c99dfb123834d18a5">00297</a>     <a class="code" href="structgpfs__ace__v4.html">gpfs_ace_v4_t</a>  <a class="code" href="structgpfs__acl.html#ae99c15da285ebc6c99dfb123834d18a5">ace_v4</a>[1]; <span class="comment">/* when GPFS_ACL_VERSION_NFS4  */</span>
<a name="l00298"></a><a class="code" href="structgpfs__acl.html#ace84c51149d9c66ee5d7c2e867ce16fd">00298</a>     <a class="code" href="structv4Level1__ext.html">v4Level1_t</a>     <a class="code" href="structgpfs__acl.html#ace84c51149d9c66ee5d7c2e867ce16fd">v4Level1</a>;  <span class="comment">/* when GPFS_ACL_LEVEL_V4FLAGS */</span>
<a name="l00299"></a>00299   };
<a name="l00300"></a>00300 } <a class="code" href="gpfs_8h.html#a615f32c22eaa48fda4529383008711ce">gpfs_acl_t</a>;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="comment">/* NAME:        gpfs_getacl()</span>
<a name="l00304"></a>00304 <span class="comment"> *</span>
<a name="l00305"></a>00305 <span class="comment"> * FUNCTION:    Retrieves the ACL information for a file.</span>
<a name="l00306"></a>00306 <span class="comment"> *</span>
<a name="l00307"></a>00307 <span class="comment"> *              The aclP parameter must point to a buffer mapped by either:</span>
<a name="l00308"></a>00308 <span class="comment"> *                - gpfs_opaque_acl_t (when flags are zero).  In this case,</span>
<a name="l00309"></a>00309 <span class="comment"> *                  the opaque data that is intended to be used by a backup</span>
<a name="l00310"></a>00310 <span class="comment"> *                  program (restoreed by passing this data back on a subsequent</span>
<a name="l00311"></a>00311 <span class="comment"> *                  call to gpfs_putacl).</span>
<a name="l00312"></a>00312 <span class="comment"> *                - gpfs_acl_t (when GPFS_GETACL_STRUCT is specified).  In this</span>
<a name="l00313"></a>00313 <span class="comment"> *                  case, the data can be interpreted by the calling application</span>
<a name="l00314"></a>00314 <span class="comment"> *                  (and may be modified and applied to the file by passing it</span>
<a name="l00315"></a>00315 <span class="comment"> *                  to gpfs_putacl...along with the GPFS_PUTACL_STRUCT flag).</span>
<a name="l00316"></a>00316 <span class="comment"> *</span>
<a name="l00317"></a>00317 <span class="comment"> *              On input, the first four bytes of the buffer must contain its</span>
<a name="l00318"></a>00318 <span class="comment"> *              total size.</span>
<a name="l00319"></a>00319 <span class="comment"> *</span>
<a name="l00320"></a>00320 <span class="comment"> * Returns:     0       Successful</span>
<a name="l00321"></a>00321 <span class="comment"> *              -1      Failure</span>
<a name="l00322"></a>00322 <span class="comment"> *</span>
<a name="l00323"></a>00323 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l00324"></a>00324 <span class="comment"> *              ENOSPC  buffer too small to return the entire ACL.</span>
<a name="l00325"></a>00325 <span class="comment"> *                      Needed size is returned in the first four</span>
<a name="l00326"></a>00326 <span class="comment"> *                      bytes of the buffer pointed to by aclP.</span>
<a name="l00327"></a>00327 <span class="comment"> *              EINVAL  Invalid arguments</span>
<a name="l00328"></a>00328 <span class="comment"> *              ENOTDIR Not on directory</span>
<a name="l00329"></a>00329 <span class="comment"> *              ENOMEM  Out of memory</span>
<a name="l00330"></a>00330 <span class="comment"> */</span>
<a name="l00331"></a>00331 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00332"></a>00332 <a class="code" href="gpfs_8h.html#af275ba1ff1087672939f6d6e548c80c1">gpfs_getacl</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l00333"></a>00333             <span class="keywordtype">int</span> flags,
<a name="l00334"></a>00334             <span class="keywordtype">void</span> *acl);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="comment">/* NAME:        gpfs_putacl()</span>
<a name="l00338"></a>00338 <span class="comment"> *</span>
<a name="l00339"></a>00339 <span class="comment"> * FUNCTION:    Sets the ACL information for a file.</span>
<a name="l00340"></a>00340 <span class="comment"> *              The buffer passed in should contain the ACL data</span>
<a name="l00341"></a>00341 <span class="comment"> *              that was obtained by a previous call to gpfs_getacl.</span>
<a name="l00342"></a>00342 <span class="comment"> *</span>
<a name="l00343"></a>00343 <span class="comment"> * Returns:     0       Successful</span>
<a name="l00344"></a>00344 <span class="comment"> *              -1      Failure</span>
<a name="l00345"></a>00345 <span class="comment"> *</span>
<a name="l00346"></a>00346 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l00347"></a>00347 <span class="comment"> *              EINVAL  Invalid arguments</span>
<a name="l00348"></a>00348 <span class="comment"> *              ENOTDIR Not on directory</span>
<a name="l00349"></a>00349 <span class="comment"> *              ENOMEM  Out of memory</span>
<a name="l00350"></a>00350 <span class="comment"> */</span>
<a name="l00351"></a>00351 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00352"></a>00352 <a class="code" href="gpfs_8h.html#a7b089caaa47480c8e34dd96c2c42660a">gpfs_putacl</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l00353"></a>00353             <span class="keywordtype">int</span> flags,
<a name="l00354"></a>00354             <span class="keywordtype">void</span> *acl);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="comment">/* NAME:        gpfs_prealloc()</span>
<a name="l00358"></a>00358 <span class="comment"> * FUNCTION:    Preallocate disk storage for the file handle that has</span>
<a name="l00359"></a>00359 <span class="comment"> *              already been opened for writing, starting at the specified</span>
<a name="l00360"></a>00360 <span class="comment"> *              starting offset and covering at least the number of bytes</span>
<a name="l00361"></a>00361 <span class="comment"> *              requested. Allocations are rounded to block boundaries</span>
<a name="l00362"></a>00362 <span class="comment"> *              (block size can be found using fstat() in st_blksize.)</span>
<a name="l00363"></a>00363 <span class="comment"> *              Any existing data already in the file will not be modified.</span>
<a name="l00364"></a>00364 <span class="comment"> *              Any read of the preallocated blocks will return zeros.</span>
<a name="l00365"></a>00365 <span class="comment"> *</span>
<a name="l00366"></a>00366 <span class="comment"> * Returns:     0       Successful</span>
<a name="l00367"></a>00367 <span class="comment"> *              -1      Failure</span>
<a name="l00368"></a>00368 <span class="comment"> *</span>
<a name="l00369"></a>00369 <span class="comment"> * Errno:       ENOSYS  No prealloc service available</span>
<a name="l00370"></a>00370 <span class="comment"> *              EBADF   Bad file desc</span>
<a name="l00371"></a>00371 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l00372"></a>00372 <span class="comment"> *              EINVAL  Not a regular file</span>
<a name="l00373"></a>00373 <span class="comment"> *              EINVAL  StartOffset or BytesToPrealloc &lt; 0</span>
<a name="l00374"></a>00374 <span class="comment"> *              EACCES  File not opened for writing</span>
<a name="l00375"></a>00375 <span class="comment"> *              EDQUOT  Quota exceeded</span>
<a name="l00376"></a>00376 <span class="comment"> *              ENOSPC  Not enough space on disk</span>
<a name="l00377"></a>00377 <span class="comment"> */</span>
<a name="l00378"></a>00378 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00379"></a>00379 <a class="code" href="gpfs_8h.html#a89ca79839563f8b1a9eadecc1adb2075">gpfs_prealloc</a>(gpfs_file_t fileDesc,
<a name="l00380"></a>00380               gpfs_off64_t startOffset,
<a name="l00381"></a>00381               gpfs_off64_t bytesToPrealloc);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 
<a name="l00384"></a><a class="code" href="structgpfs__winattr.html">00384</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__winattr.html">gpfs_winattr</a>
<a name="l00385"></a>00385 {
<a name="l00386"></a><a class="code" href="structgpfs__winattr.html#a0a2d68276dbc7f8d3898904b4032dc8a">00386</a>   <a class="code" href="structgpfs__timestruc.html">gpfs_timestruc_t</a> <a class="code" href="structgpfs__winattr.html#a0a2d68276dbc7f8d3898904b4032dc8a">creationTime</a>;
<a name="l00387"></a><a class="code" href="structgpfs__winattr.html#af4dd97dea039853dd0cf02fa1779d2d8">00387</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__winattr.html#af4dd97dea039853dd0cf02fa1779d2d8">winAttrs</a>; <span class="comment">/* values as defined below */</span>
<a name="l00388"></a>00388 } <a class="code" href="gpfs_8h.html#a893c6546008d37cac1cc85067f3d359d">gpfs_winattr_t</a>;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">/* winAttrs values */</span>
<a name="l00391"></a><a class="code" href="gpfs_8h.html#a011903f8defbedfbc548435b6ad63695">00391</a> <span class="preprocessor">#define GPFS_WINATTR_ARCHIVE              0x0001</span>
<a name="l00392"></a><a class="code" href="gpfs_8h.html#ac6c7e5e3910a6202dba7282abbb5c763">00392</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_COMPRESSED           0x0002</span>
<a name="l00393"></a><a class="code" href="gpfs_8h.html#ac429c3554226d38d35312b84f643d6b5">00393</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_DEVICE               0x0004</span>
<a name="l00394"></a><a class="code" href="gpfs_8h.html#a6005164fbf8357c10b031554afd9b7ae">00394</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_DIRECTORY            0x0008</span>
<a name="l00395"></a><a class="code" href="gpfs_8h.html#aaa99e4671746771f4d42a55e8ec8398c">00395</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_ENCRYPTED            0x0010</span>
<a name="l00396"></a><a class="code" href="gpfs_8h.html#a28a0d233d4b57a7ffcab0733d0a07a78">00396</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_HIDDEN               0x0020</span>
<a name="l00397"></a><a class="code" href="gpfs_8h.html#aaf6448dc653bf544d4bb175a9b8e62e2">00397</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_NORMAL               0x0040</span>
<a name="l00398"></a><a class="code" href="gpfs_8h.html#a78c1ecbbf4788d1064e8fb40fe9945fb">00398</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_NOT_CONTENT_INDEXED  0x0080</span>
<a name="l00399"></a><a class="code" href="gpfs_8h.html#a3acf46dd45ed704dc585205ca3d4b8d0">00399</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_OFFLINE              0x0100</span>
<a name="l00400"></a><a class="code" href="gpfs_8h.html#a7dce31dc1fc961c57597d4ad15d8a3d3">00400</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_READONLY             0x0200</span>
<a name="l00401"></a><a class="code" href="gpfs_8h.html#a4fdac282b0aef0cd34306863736be72c">00401</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_REPARSE_POINT        0x0400</span>
<a name="l00402"></a><a class="code" href="gpfs_8h.html#a28f16801281204bd09bb87431bd5e3ff">00402</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_SPARSE_FILE          0x0800</span>
<a name="l00403"></a><a class="code" href="gpfs_8h.html#a446b4e7322ca76636955d494767c60c2">00403</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_SYSTEM               0x1000</span>
<a name="l00404"></a><a class="code" href="gpfs_8h.html#a79c8e60d0f69654dc28f07640be8df04">00404</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_TEMPORARY            0x2000</span>
<a name="l00405"></a><a class="code" href="gpfs_8h.html#a4e8b860260a6f4926b88d0de0f6a319f">00405</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_HAS_STREAMS          0x4000</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="comment">/* NAME:        gpfs_get_winattrs()</span>
<a name="l00409"></a>00409 <span class="comment"> *              gpfs_get_winattrs_path()</span>
<a name="l00410"></a>00410 <span class="comment"> *</span>
<a name="l00411"></a>00411 <span class="comment"> * FUNCTION:    Returns gpfs_winattr_t attributes</span>
<a name="l00412"></a>00412 <span class="comment"> *</span>
<a name="l00413"></a>00413 <span class="comment"> * Returns:      0      Success</span>
<a name="l00414"></a>00414 <span class="comment"> *              -1      Failure</span>
<a name="l00415"></a>00415 <span class="comment"> *</span>
<a name="l00416"></a>00416 <span class="comment"> * Errno:       ENOENT  file not found</span>
<a name="l00417"></a>00417 <span class="comment"> *              EBADF   Bad file handle, not a GPFS file</span>
<a name="l00418"></a>00418 <span class="comment"> *              ENOMEM  Memory allocation failed</span>
<a name="l00419"></a>00419 <span class="comment"> *              EACCESS Permission denied</span>
<a name="l00420"></a>00420 <span class="comment"> *              EFAULT  Bad address provided</span>
<a name="l00421"></a>00421 <span class="comment"> *              EINVAL  Not a regular file</span>
<a name="l00422"></a>00422 <span class="comment"> *              ENOSYS  function not available</span>
<a name="l00423"></a>00423 <span class="comment"> */</span>
<a name="l00424"></a>00424 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00425"></a>00425 <a class="code" href="gpfs_8h.html#aaf238d3a551fe9639579533297af0263">gpfs_get_winattrs</a>(gpfs_file_t fileDesc, <a class="code" href="structgpfs__winattr.html">gpfs_winattr_t</a> *attrP);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00428"></a>00428 <a class="code" href="gpfs_8h.html#aab6fd3c3a12a093a25909d8066ad0c5f">gpfs_get_winattrs_path</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname, <a class="code" href="structgpfs__winattr.html">gpfs_winattr_t</a> *attrP);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="comment">/* NAME:        gpfs_set_winattrs()</span>
<a name="l00432"></a>00432 <span class="comment"> *              gpfs_set_winattrs_path()</span>
<a name="l00433"></a>00433 <span class="comment"> *</span>
<a name="l00434"></a>00434 <span class="comment"> * FUNCTION:    Sets gpfs_winattr_t attributes (as specified by</span>
<a name="l00435"></a>00435 <span class="comment"> *              the flags).</span>
<a name="l00436"></a>00436 <span class="comment"> *</span>
<a name="l00437"></a>00437 <span class="comment"> * Returns:      0      Success</span>
<a name="l00438"></a>00438 <span class="comment"> *              -1      Failure</span>
<a name="l00439"></a>00439 <span class="comment"> *</span>
<a name="l00440"></a>00440 <span class="comment"> * Errno:       ENOENT  file not found</span>
<a name="l00441"></a>00441 <span class="comment"> *              EBADF   Bad file handle, not a GPFS file</span>
<a name="l00442"></a>00442 <span class="comment"> *              ENOMEM  Memory allocation failed</span>
<a name="l00443"></a>00443 <span class="comment"> *              EACCESS Permission denied</span>
<a name="l00444"></a>00444 <span class="comment"> *              EFAULT  Bad address provided</span>
<a name="l00445"></a>00445 <span class="comment"> *              EINVAL  Not a regular file</span>
<a name="l00446"></a>00446 <span class="comment"> *              ENOSYS  function not available</span>
<a name="l00447"></a>00447 <span class="comment"> */</span>
<a name="l00448"></a>00448 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00449"></a>00449 <a class="code" href="gpfs_8h.html#a722cfd0c6f33faa1d4277786bf913086">gpfs_set_winattrs</a>(gpfs_file_t fileDesc, <span class="keywordtype">int</span> flags, <a class="code" href="structgpfs__winattr.html">gpfs_winattr_t</a> *attrP);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00452"></a>00452 <a class="code" href="gpfs_8h.html#a80f05fbaddbcff6bdea369385297355e">gpfs_set_winattrs_path</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname, <span class="keywordtype">int</span> flags, <a class="code" href="structgpfs__winattr.html">gpfs_winattr_t</a> *attrP);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">/* gpfs_set_winattr flag values */</span>
<a name="l00455"></a><a class="code" href="gpfs_8h.html#a6593cd13452dbf686b3b2c116a85cfc5">00455</a> <span class="preprocessor">#define GPFS_WINATTR_SET_CREATION_TIME 0x08</span>
<a name="l00456"></a><a class="code" href="gpfs_8h.html#af0f5536a552137a3a62d3860f3945345">00456</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_WINATTR_SET_ATTRS         0x10</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00458"></a>00458 <span class="comment">/*</span>
<a name="l00459"></a>00459 <span class="comment"> * NAME:        gpfs_set_times(), gpfs_set_times_path()</span>
<a name="l00460"></a>00460 <span class="comment"> *</span>
<a name="l00461"></a>00461 <span class="comment"> * FUNCTION:    Sets sets file access time, modefied time, change time,</span>
<a name="l00462"></a>00462 <span class="comment"> *              and/or creation time (as specified by the flags).</span>
<a name="l00463"></a>00463 <span class="comment"> *</span>
<a name="l00464"></a>00464 <span class="comment"> * Input:       flagsfileDesc : file descriptor of the object to set</span>
<a name="l00465"></a>00465 <span class="comment"> *              pathname      : path to a file or directory</span>
<a name="l00466"></a>00466 <span class="comment"> *              flag          : define time value to set</span>
<a name="l00467"></a>00467 <span class="comment"> *              GPFS_SET_ATIME - set access time</span>
<a name="l00468"></a>00468 <span class="comment"> *              GPFS_SET_MTIME - set mod. time</span>
<a name="l00469"></a>00469 <span class="comment"> *              GPFS_SET_CTIME - set change time</span>
<a name="l00470"></a>00470 <span class="comment"> *              GPFS_SET_CREATION_TIME - set creation time</span>
<a name="l00471"></a>00471 <span class="comment"> *              times         : array to times</span>
<a name="l00472"></a>00472 <span class="comment"> *</span>
<a name="l00473"></a>00473 <span class="comment"> * Returns:      0      Successful</span>
<a name="l00474"></a>00474 <span class="comment"> *              -1      Failure</span>
<a name="l00475"></a>00475 <span class="comment"> *</span>
<a name="l00476"></a>00476 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l00477"></a>00477 <span class="comment"> *              EBADF   Not a GPFS File</span>
<a name="l00478"></a>00478 <span class="comment"> *              EINVAL  invalid argument</span>
<a name="l00479"></a>00479 <span class="comment"> *              EACCES  Permission denied</span>
<a name="l00480"></a>00480 <span class="comment"> *              EROFS   Filesystem is read only</span>
<a name="l00481"></a>00481 <span class="comment"> *              ENOENT  No such file or directory</span>
<a name="l00482"></a>00482 <span class="comment"> */</span>
<a name="l00483"></a><a class="code" href="gpfs_8h.html#ab2244dc1c79d80cfad5e8b28f4c0fe86">00483</a> <span class="keyword">typedef</span> <a class="code" href="structgpfs__timestruc.html">gpfs_timestruc_t</a> <a class="code" href="gpfs_8h.html#ab2244dc1c79d80cfad5e8b28f4c0fe86">gpfs_times_vector_t</a>[4];
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00486"></a>00486 <a class="code" href="gpfs_8h.html#a8192477252167768f199145d96678a4c">gpfs_set_times</a>(gpfs_file_t fileDesc, <span class="keywordtype">int</span> flags, gpfs_times_vector_t times);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00489"></a>00489 <a class="code" href="gpfs_8h.html#aea5e5c6f5a4175461426d7b96e1320b6">gpfs_set_times_path</a>(<span class="keywordtype">char</span> *pathname, <span class="keywordtype">int</span> flags, gpfs_times_vector_t times);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="comment">/* gpfs_set_times flag values */</span>
<a name="l00492"></a><a class="code" href="gpfs_8h.html#a41ad502631c377a84b17cc7ee0e710dd">00492</a> <span class="preprocessor">#define GPFS_SET_ATIME         0x01</span>
<a name="l00493"></a><a class="code" href="gpfs_8h.html#af943e9de1a9f743ffdcd30d8a6870ffd">00493</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SET_MTIME         0x02</span>
<a name="l00494"></a><a class="code" href="gpfs_8h.html#ae9bf08a3245bbdc828a9ed74350cb061">00494</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SET_CTIME         0x04</span>
<a name="l00495"></a><a class="code" href="gpfs_8h.html#a0d165b810e1547e5725fe337796dd0a4">00495</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SET_CREATION_TIME 0x08</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="comment">/* NAME:        gpfs_set_share()</span>
<a name="l00499"></a>00499 <span class="comment"> *</span>
<a name="l00500"></a>00500 <span class="comment"> * FUNCTION:    Acquire shares</span>
<a name="l00501"></a>00501 <span class="comment"> *</span>
<a name="l00502"></a>00502 <span class="comment"> * Input:       fileDesc : file descriptor</span>
<a name="l00503"></a>00503 <span class="comment"> *              allow    : share type being requested</span>
<a name="l00504"></a>00504 <span class="comment"> *                         GPFS_SHARE_NONE, GPFS_SHARE_READ,</span>
<a name="l00505"></a>00505 <span class="comment"> *                         GPFS_SHARE_WRITE, GPFS_SHARE_BOTH</span>
<a name="l00506"></a>00506 <span class="comment"> *              deny     : share type to deny to others</span>
<a name="l00507"></a>00507 <span class="comment"> *                         GPFS_DENY_NONE, GPFS_DENY_READ,</span>
<a name="l00508"></a>00508 <span class="comment"> *                         GPFS_DENY_WRITE, GPFS_DENY_BOTH</span>
<a name="l00509"></a>00509 <span class="comment"> *</span>
<a name="l00510"></a>00510 <span class="comment"> * Returns:      0      Success</span>
<a name="l00511"></a>00511 <span class="comment"> *              -1      Failure</span>
<a name="l00512"></a>00512 <span class="comment"> *</span>
<a name="l00513"></a>00513 <span class="comment"> * Errno:       EBADF   Bad file handle</span>
<a name="l00514"></a>00514 <span class="comment"> *              EINVAL  Bad argument given</span>
<a name="l00515"></a>00515 <span class="comment"> *              EFAULT  Bad address provided</span>
<a name="l00516"></a>00516 <span class="comment"> *              ENOMEM  Memory allocation failed</span>
<a name="l00517"></a>00517 <span class="comment"> *              EACCES  share mode not available</span>
<a name="l00518"></a>00518 <span class="comment"> *              ENOSYS  function not available</span>
<a name="l00519"></a>00519 <span class="comment"> */</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="comment">/* allow/deny specifications */</span>
<a name="l00522"></a><a class="code" href="gpfs_8h.html#adb65a005a10a84769d72857706ec4ec4">00522</a> <span class="preprocessor">#define GPFS_SHARE_NONE   0</span>
<a name="l00523"></a><a class="code" href="gpfs_8h.html#ababcdcca7825bd364fd0c7c0e8d49427">00523</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SHARE_READ   1</span>
<a name="l00524"></a><a class="code" href="gpfs_8h.html#ac7e5476b6c3c6849e2fe421d7d1e694a">00524</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SHARE_WRITE  2</span>
<a name="l00525"></a><a class="code" href="gpfs_8h.html#a1e22d84e7d0487f9b9e95cdfb0f611b9">00525</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SHARE_BOTH   3</span>
<a name="l00526"></a><a class="code" href="gpfs_8h.html#a6076ee7d56fa6da32894996713bcb301">00526</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_SHARE_ALL    3</span>
<a name="l00527"></a><a class="code" href="gpfs_8h.html#a2727cd2ad5ddaed744556adbe61abc1a">00527</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_NONE    0</span>
<a name="l00528"></a><a class="code" href="gpfs_8h.html#a066c8d23afd1d7b8e8982919d8158a56">00528</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_READ    1</span>
<a name="l00529"></a><a class="code" href="gpfs_8h.html#a01c375d3d029af37d96481d16aabbb4b">00529</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_WRITE   2</span>
<a name="l00530"></a><a class="code" href="gpfs_8h.html#a85ad744278f7d0208a006c78a1aa2385">00530</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_BOTH    3</span>
<a name="l00531"></a><a class="code" href="gpfs_8h.html#a4b0c09b3e2e9c0af3981dba52ccce373">00531</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_DELETE  4</span>
<a name="l00532"></a><a class="code" href="gpfs_8h.html#a8c31bc009dd5122f90e50c9bc6ca0d8d">00532</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DENY_ALL     7</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span>
<a name="l00534"></a>00534 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00535"></a>00535 <a class="code" href="gpfs_8h.html#a1342c611cdc090d1bbc6f4a9702ca474">gpfs_set_share</a>(gpfs_file_t fileDesc,
<a name="l00536"></a>00536                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> share,
<a name="l00537"></a>00537                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deny);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="comment">/* NAME:        gpfs_set_lease()</span>
<a name="l00541"></a>00541 <span class="comment"> *</span>
<a name="l00542"></a>00542 <span class="comment"> * FUNCTION:    Acquire leases for Samba</span>
<a name="l00543"></a>00543 <span class="comment"> *</span>
<a name="l00544"></a>00544 <span class="comment"> * Input:       fileDesc  : file descriptor</span>
<a name="l00545"></a>00545 <span class="comment"> *              leaseType : lease type being requested</span>
<a name="l00546"></a>00546 <span class="comment"> *                          GPFS_LEASE_NONE GPFS_LEASE_READ,</span>
<a name="l00547"></a>00547 <span class="comment"> *                          GPFS_LEASE_WRITE</span>
<a name="l00548"></a>00548 <span class="comment"> *</span>
<a name="l00549"></a>00549 <span class="comment"> * Returns:      0      Success</span>
<a name="l00550"></a>00550 <span class="comment"> *              -1      Failure</span>
<a name="l00551"></a>00551 <span class="comment"> *</span>
<a name="l00552"></a>00552 <span class="comment"> * Errno:       EBADF   Bad file handle</span>
<a name="l00553"></a>00553 <span class="comment"> *              EINVAL  Bad argument given</span>
<a name="l00554"></a>00554 <span class="comment"> *              EFAULT  Bad address provided</span>
<a name="l00555"></a>00555 <span class="comment"> *              ENOMEM  Memory allocation failed</span>
<a name="l00556"></a>00556 <span class="comment"> *              EAGAIN  lease not available</span>
<a name="l00557"></a>00557 <span class="comment"> *              EACCES  permission denied</span>
<a name="l00558"></a>00558 <span class="comment"> *              EOPNOTSUPP unsupported leaseType</span>
<a name="l00559"></a>00559 <span class="comment"> *              ESTALE  unmounted filesystem</span>
<a name="l00560"></a>00560 <span class="comment"> *              ENOSYS  function not available</span>
<a name="l00561"></a>00561 <span class="comment"> */</span>
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">/* leaseType specifications */</span>
<a name="l00564"></a><a class="code" href="gpfs_8h.html#af9a12e789cb110965079a4bb7b144cb7">00564</a> <span class="preprocessor">#define GPFS_LEASE_NONE    0</span>
<a name="l00565"></a><a class="code" href="gpfs_8h.html#a236dab11abd926373702c0278274f7fb">00565</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_LEASE_READ    1</span>
<a name="l00566"></a><a class="code" href="gpfs_8h.html#a545c5bd7f217dfd7c078d3f5b7586107">00566</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_LEASE_WRITE   2</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>
<a name="l00568"></a>00568 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00569"></a>00569 <a class="code" href="gpfs_8h.html#a740173dd95c4522e1e9b42fbbbd590c6">gpfs_set_lease</a>(gpfs_file_t fileDesc,
<a name="l00570"></a>00570                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leaseType);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 <span class="comment">/* NAME:        gpfs_get_lease()</span>
<a name="l00574"></a>00574 <span class="comment"> *</span>
<a name="l00575"></a>00575 <span class="comment"> * FUNCTION:    Returns the type of lease currently held</span>
<a name="l00576"></a>00576 <span class="comment"> *</span>
<a name="l00577"></a>00577 <span class="comment"> * Returns:     GPFS_LEASE_READ</span>
<a name="l00578"></a>00578 <span class="comment"> *              GPFS_LEASE_WRITE</span>
<a name="l00579"></a>00579 <span class="comment"> *              GPFS_LEASE_NONE</span>
<a name="l00580"></a>00580 <span class="comment"> *</span>
<a name="l00581"></a>00581 <span class="comment"> * Returns:     0       Success</span>
<a name="l00582"></a>00582 <span class="comment"> *             -1       Failure   </span>
<a name="l00583"></a>00583 <span class="comment"> *</span>
<a name="l00584"></a>00584 <span class="comment"> * Errno:       EINVAL</span>
<a name="l00585"></a>00585 <span class="comment"> */</span>
<a name="l00586"></a>00586 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00587"></a>00587 <a class="code" href="gpfs_8h.html#a2b1ab7de7aeff06b81c35bf30943bbd3">gpfs_get_lease</a>(gpfs_file_t fileDesc);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 
<a name="l00590"></a>00590  <span class="comment">/* NAME:        gpfs_get_realfilename(), gpfs_get_realfilename_path()</span>
<a name="l00591"></a>00591 <span class="comment">  *</span>
<a name="l00592"></a>00592 <span class="comment">  * FUNCTION:    Interface to get real name of a file.</span>
<a name="l00593"></a>00593 <span class="comment">  *</span>
<a name="l00594"></a>00594 <span class="comment">  * INPUT:       File descriptor, pathname, buffer, bufferlength</span>
<a name="l00595"></a>00595 <span class="comment">  * OUTPUT:      Real file name stored in filesystem</span>
<a name="l00596"></a>00596 <span class="comment">  *</span>
<a name="l00597"></a>00597 <span class="comment">  * Returns:     0       Success</span>
<a name="l00598"></a>00598 <span class="comment">  *             -1       Failure   </span>
<a name="l00599"></a>00599 <span class="comment">  *</span>
<a name="l00600"></a>00600 <span class="comment">  * Errno:       EBADF   Bad file handle</span>
<a name="l00601"></a>00601 <span class="comment">  *              EINVAL  Not a regular file</span>
<a name="l00602"></a>00602 <span class="comment">  *              EFAULT  Bad address provided</span>
<a name="l00603"></a>00603 <span class="comment">  *              ENOSPC  buffer too small to return the real file name.</span>
<a name="l00604"></a>00604 <span class="comment">  *                      Needed size is returned in buflen parameter.</span>
<a name="l00605"></a>00605 <span class="comment">  *              ENOENT  File does not exist</span>
<a name="l00606"></a>00606 <span class="comment">  *              ENOMEM  Memory allocation failed</span>
<a name="l00607"></a>00607 <span class="comment">  *              EACCESS Permission denied</span>
<a name="l00608"></a>00608 <span class="comment">  *              ENOSYS  function not available</span>
<a name="l00609"></a>00609 <span class="comment">  */</span>
<a name="l00610"></a>00610 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00611"></a>00611 <a class="code" href="gpfs_8h.html#a3dd0b8aaefe0e25af95344e2c9bed9e4">gpfs_get_realfilename</a>(gpfs_file_t fileDesc,
<a name="l00612"></a>00612                       <span class="keywordtype">char</span> *fileNameP,
<a name="l00613"></a>00613                       <span class="keywordtype">int</span> *buflen);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00616"></a>00616 <a class="code" href="gpfs_8h.html#a8bc46c5c22639f3bcd4b57b0ed796a01">gpfs_get_realfilename_path</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l00617"></a>00617                            <span class="keywordtype">char</span> *fileNameP,
<a name="l00618"></a>00618                            <span class="keywordtype">int</span> *buflen);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620  <span class="comment">/* NAME:        gpfs_ftruncate()</span>
<a name="l00621"></a>00621 <span class="comment">  *</span>
<a name="l00622"></a>00622 <span class="comment">  * FUNCTION:    Interface to truncate a file.</span>
<a name="l00623"></a>00623 <span class="comment">  *</span>
<a name="l00624"></a>00624 <span class="comment">  * INPUT:       File descriptor</span>
<a name="l00625"></a>00625 <span class="comment">  *              length</span>
<a name="l00626"></a>00626 <span class="comment">  * Returns:     0       Successful</span>
<a name="l00627"></a>00627 <span class="comment">  *              -1      Failure</span>
<a name="l00628"></a>00628 <span class="comment">  *</span>
<a name="l00629"></a>00629 <span class="comment">  * Errno:       ENOSYS  function not available</span>
<a name="l00630"></a>00630 <span class="comment">  *              EBADF   Bad file handle</span>
<a name="l00631"></a>00631 <span class="comment">  *              EBADF   Not a GPFS file</span>
<a name="l00632"></a>00632 <span class="comment">  *              EINVAL  Not a regular file</span>
<a name="l00633"></a>00633 <span class="comment">  *              ENOENT  File does not exist</span>
<a name="l00634"></a>00634 <span class="comment">  *              ENOMEM  Memory allocation failed</span>
<a name="l00635"></a>00635 <span class="comment">  *              EINVAL  length &lt; 0</span>
<a name="l00636"></a>00636 <span class="comment">  *              EACCESS  Permission denied</span>
<a name="l00637"></a>00637 <span class="comment">  */</span>
<a name="l00638"></a>00638 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00639"></a>00639 <a class="code" href="gpfs_8h.html#a116b485afdd4c900167834356e8cde03">gpfs_ftruncate</a>(gpfs_file_t fileDesc, gpfs_off64_t length);
<a name="l00640"></a>00640 
<a name="l00641"></a><a class="code" href="gpfs_8h.html#a67bf6198eed36190249b914c6b9b5e18">00641</a> <span class="preprocessor">#define GPFS_WIN_CIFS_REGISTERED   0x02000000</span>
<a name="l00642"></a><a class="code" href="structcifsThreadData__t.html">00642</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structcifsThreadData__t.html">cifsThreadData_t</a>
<a name="l00643"></a>00643 {
<a name="l00644"></a><a class="code" href="structcifsThreadData__t.html#a63895a023fffe07c82fd91d060e04bf0">00644</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#a63895a023fffe07c82fd91d060e04bf0">dataLength</a>; <span class="comment">/* Total buffer length */</span>
<a name="l00645"></a><a class="code" href="structcifsThreadData__t.html#a7aa5c7c186f119446a995bebb31f4288">00645</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#a7aa5c7c186f119446a995bebb31f4288">share</a>;      <span class="comment">/* gpfs_set_share declaration */</span>
<a name="l00646"></a><a class="code" href="structcifsThreadData__t.html#ac67f4f05fc6c988546cf357706fcc631">00646</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#ac67f4f05fc6c988546cf357706fcc631">deny</a>;       <span class="comment">/* gpfs_set_share specification */</span>
<a name="l00647"></a><a class="code" href="structcifsThreadData__t.html#afe8d6eb0f0df6ccc9bec29e5ab53d9ca">00647</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#afe8d6eb0f0df6ccc9bec29e5ab53d9ca">lease</a>;      <span class="comment">/* gpfs_set_lease lease type */</span>
<a name="l00648"></a><a class="code" href="structcifsThreadData__t.html#a2841e03c0009f6e7b760fd339fe05cac">00648</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#a2841e03c0009f6e7b760fd339fe05cac">secInfoFlags</a>; <span class="comment">/* Future use.  Must be zero */</span>
<a name="l00649"></a><a class="code" href="structcifsThreadData__t.html#a65f5e55489b87d510aebe2697f49af40">00649</a>   gpfs_uid_t   <a class="code" href="structcifsThreadData__t.html#a65f5e55489b87d510aebe2697f49af40">sdUID</a>;      <span class="comment">/* Owning user */</span>
<a name="l00650"></a><a class="code" href="structcifsThreadData__t.html#a3d359c1415e6f06ffee09c9189262148">00650</a>   gpfs_uid_t   <a class="code" href="structcifsThreadData__t.html#a3d359c1415e6f06ffee09c9189262148">sdGID</a>;      <span class="comment">/* Owning group */</span>
<a name="l00651"></a><a class="code" href="structcifsThreadData__t.html#aaa0c55a41339ff47ab917ce20dcf04ad">00651</a>   <span class="keywordtype">int</span>          <a class="code" href="structcifsThreadData__t.html#aaa0c55a41339ff47ab917ce20dcf04ad">shareLocked_fd</a>; <span class="comment">/* file descriptor with share locks */</span>
<a name="l00652"></a><a class="code" href="structcifsThreadData__t.html#a541b8c0579ae380e066a9fec52a0be59">00652</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcifsThreadData__t.html#a541b8c0579ae380e066a9fec52a0be59">aclLength</a> ; <span class="comment">/* Length of the following ACL */</span>
<a name="l00653"></a><a class="code" href="structcifsThreadData__t.html#ae4b497b55bf5ff5f7a70b0c5c5c68ea3">00653</a>   <a class="code" href="structgpfs__acl.html">gpfs_acl_t</a>   <a class="code" href="structcifsThreadData__t.html#ae4b497b55bf5ff5f7a70b0c5c5c68ea3">acl</a>;        <span class="comment">/* The initial ACL for create/mkdir */</span>
<a name="l00654"></a>00654 } <a class="code" href="gpfs_8h.html#a1d84c6a9fdceb14c5897f24a52399d26">cifsThreadData_t</a>;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656  <span class="comment">/* NAME:        gpfs_register_cifs_export()</span>
<a name="l00657"></a>00657 <span class="comment">  *</span>
<a name="l00658"></a>00658 <span class="comment">  * FUNCTION:    Register a CIFS export process.</span>
<a name="l00659"></a>00659 <span class="comment">  *</span>
<a name="l00660"></a>00660 <span class="comment">  * INPUT:       implicit use of the process ids</span>
<a name="l00661"></a>00661 <span class="comment">  *              </span>
<a name="l00662"></a>00662 <span class="comment">  * Returns:     0       Successful</span>
<a name="l00663"></a>00663 <span class="comment">  *              ENOSYS  function not available</span>
<a name="l00664"></a>00664 <span class="comment">  *              EACCES  cannot establish credentials</span>
<a name="l00665"></a>00665 <span class="comment">  *              ENOMEM  temporary shortage of memory</span>
<a name="l00666"></a>00666 <span class="comment">  *              EINVAL  prior process/thread registrations exist</span>
<a name="l00667"></a>00667 <span class="comment">  *              EBADF   unable to allocate a file descriptor</span>
<a name="l00668"></a>00668 <span class="comment">  */</span>
<a name="l00669"></a>00669 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00670"></a>00670 <a class="code" href="gpfs_8h.html#a58395d7138fe63ccb108b05941b99fa2">gpfs_register_cifs_export</a>();
<a name="l00671"></a>00671 
<a name="l00672"></a>00672  <span class="comment">/* NAME:        gpfs_unregister_cifs_export()</span>
<a name="l00673"></a>00673 <span class="comment">  *</span>
<a name="l00674"></a>00674 <span class="comment">  * FUNCTION:    remove a registration for a CIFS export </span>
<a name="l00675"></a>00675 <span class="comment">  *</span>
<a name="l00676"></a>00676 <span class="comment">  * INPUT:       implicit use of the process ids</span>
<a name="l00677"></a>00677 <span class="comment">  *              </span>
<a name="l00678"></a>00678 <span class="comment">  * Returns:     0       Successful</span>
<a name="l00679"></a>00679 <span class="comment">  *              ENOSYS  function not available</span>
<a name="l00680"></a>00680 <span class="comment">  *              EACCES  cannot establish credentials</span>
<a name="l00681"></a>00681 <span class="comment">  *              ENOMEM  temporary shortage of memory</span>
<a name="l00682"></a>00682 <span class="comment">  */</span>
<a name="l00683"></a>00683 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00684"></a>00684 <a class="code" href="gpfs_8h.html#a03a128ba4601bb329098bf73d7b65319">gpfs_unregister_cifs_export</a>();
<a name="l00685"></a>00685 
<a name="l00686"></a>00686  <span class="comment">/* NAME:        gpfs_register_cifs_buffer()</span>
<a name="l00687"></a>00687 <span class="comment">  *</span>
<a name="l00688"></a>00688 <span class="comment">  * FUNCTION:    Register a CIFS thread/buffer combination</span>
<a name="l00689"></a>00689 <span class="comment">  *</span>
<a name="l00690"></a>00690 <span class="comment">  * INPUT:       implicit use of the process and thread ids</span>
<a name="l00691"></a>00691 <span class="comment">  *              Address of a cifsThreadData_t structure that will include</span>
<a name="l00692"></a>00692 <span class="comment">  *              a GPFS ACL (GPFS_ACL_VERSION_NFS4/GPFS_ACL_LEVEL_V4FLAGS)              </span>
<a name="l00693"></a>00693 <span class="comment">  *              that can be applied at file/dir creation.              </span>
<a name="l00694"></a>00694 <span class="comment">  *              </span>
<a name="l00695"></a>00695 <span class="comment">  * Returns:     0       Successful</span>
<a name="l00696"></a>00696 <span class="comment">  *              ENOSYS  function not available</span>
<a name="l00697"></a>00697 <span class="comment">  *              EACCES  cannot establish credentials</span>
<a name="l00698"></a>00698 <span class="comment">  *              ENOMEM  unable to allocate required memory</span>
<a name="l00699"></a>00699 <span class="comment">  *              EINVAL  no associated process registrion exists </span>
<a name="l00700"></a>00700 <span class="comment">  *                      bad dataLength in buffer.</span>
<a name="l00701"></a>00701 <span class="comment">  */</span>
<a name="l00702"></a>00702 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00703"></a>00703 <a class="code" href="gpfs_8h.html#ae88cbe07cc1353c95678c9bc0dfd2968">gpfs_register_cifs_buffer</a>(<a class="code" href="structcifsThreadData__t.html">cifsThreadData_t</a> *bufP);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705  <span class="comment">/* NAME:        gpfs_unregister_cifs_buffer()</span>
<a name="l00706"></a>00706 <span class="comment">  *</span>
<a name="l00707"></a>00707 <span class="comment">  * FUNCTION:    remove a CIFS thread/buffer registration</span>
<a name="l00708"></a>00708 <span class="comment">  *</span>
<a name="l00709"></a>00709 <span class="comment">  * INPUT:       implicit use of the process and thread ids</span>
<a name="l00710"></a>00710 <span class="comment">  *              </span>
<a name="l00711"></a>00711 <span class="comment">  * Returns:     0       Successful</span>
<a name="l00712"></a>00712 <span class="comment">  *              ENOSYS  function not available</span>
<a name="l00713"></a>00713 <span class="comment">  *              EACCES  cannot establish credentials</span>
<a name="l00714"></a>00714 <span class="comment">  *              ENOMEM  unable to allocate required memory</span>
<a name="l00715"></a>00715 <span class="comment">  *              EINVAL  no associated process registrion exists</span>
<a name="l00716"></a>00716 <span class="comment">  */</span>
<a name="l00717"></a>00717 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00718"></a>00718 <a class="code" href="gpfs_8h.html#a59010976d658f124bf8e818353155143">gpfs_unregister_cifs_buffer</a>();
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 <span class="comment">/* NAME:        gpfs_lib_init()</span>
<a name="l00721"></a>00721 <span class="comment"> *</span>
<a name="l00722"></a>00722 <span class="comment"> * FUNCTION:    Open GPFS main module device file</span>
<a name="l00723"></a>00723 <span class="comment"> *</span>
<a name="l00724"></a>00724 <span class="comment"> * INPUT:       Flags</span>
<a name="l00725"></a>00725 <span class="comment"> * Returns:     0       Successful</span>
<a name="l00726"></a>00726 <span class="comment"> *              -1      Failure</span>
<a name="l00727"></a>00727 <span class="comment"> *</span>
<a name="l00728"></a>00728 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l00729"></a>00729 <span class="comment"> */</span>
<a name="l00730"></a>00730 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00731"></a>00731 <a class="code" href="gpfs_8h.html#afb7eeaaf62b485bad7f50fb94ccc66ca">gpfs_lib_init</a>(<span class="keywordtype">int</span> flags);
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="comment">/* NAME:        gpfs_lib_term()</span>
<a name="l00734"></a>00734 <span class="comment"> *</span>
<a name="l00735"></a>00735 <span class="comment"> * FUNCTION:    Close GPFS main module device file</span>
<a name="l00736"></a>00736 <span class="comment"> *</span>
<a name="l00737"></a>00737 <span class="comment"> * INPUT:       Flags</span>
<a name="l00738"></a>00738 <span class="comment"> * Returns:     0       Successful</span>
<a name="l00739"></a>00739 <span class="comment"> *              -1      Failure</span>
<a name="l00740"></a>00740 <span class="comment"> *</span>
<a name="l00741"></a>00741 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l00742"></a>00742 <span class="comment"> */</span>
<a name="l00743"></a>00743 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l00744"></a>00744 <a class="code" href="gpfs_8h.html#a82b8e1468095efa4601bcd71680d1f97">gpfs_lib_term</a>(<span class="keywordtype">int</span> flags);
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="comment">/* Define maximum length of the name for a GPFS named object, such</span>
<a name="l00747"></a>00747 <span class="comment">   as a snapshot, storage pool or fileset. The name is a null-terminated</span>
<a name="l00748"></a>00748 <span class="comment">   character string, which is not include in the max length */</span>
<a name="l00749"></a><a class="code" href="gpfs_8h.html#a70cb7b8bd4d81c7975a75f6ff83e361e">00749</a> <span class="preprocessor">#define GPFS_MAXNAMLEN       255</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>
<a name="l00751"></a>00751 <span class="comment">/* Define maximum length of the path to a GPFS named object</span>
<a name="l00752"></a>00752 <span class="comment">   such as a snapshot or fileset. If the absolute path name exceeds</span>
<a name="l00753"></a>00753 <span class="comment">   this limit, then use a relative path name. The path is a null-terminated</span>
<a name="l00754"></a>00754 <span class="comment">   character string, which is not included in the max length */</span>
<a name="l00755"></a><a class="code" href="gpfs_8h.html#aad646d8404c5b5cbe4a509183e460e23">00755</a> <span class="preprocessor">#define GPFS_MAXPATHLEN     1023</span>
<a name="l00756"></a>00756 <span class="preprocessor"></span>
<a name="l00757"></a>00757 <span class="comment">/* ASCII code for &quot;GPFS&quot; in the struct statfs f_type field */</span>
<a name="l00758"></a><a class="code" href="gpfs_8h.html#a11cc33f602c52ef20c09945ce5c4be49">00758</a> <span class="preprocessor">#define GPFS_SUPER_MAGIC     0x47504653</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span>
<a name="l00760"></a>00760 <span class="comment">/* GPFS inode attributes</span>
<a name="l00761"></a>00761 <span class="comment">   gpfs_uid_t - defined above</span>
<a name="l00762"></a>00762 <span class="comment">   gpfs_uid64_t - defined above</span>
<a name="l00763"></a>00763 <span class="comment">   gpfs_off64_t - defined above */</span>
<a name="l00764"></a><a class="code" href="gpfs_8h.html#a42a013e880afbd5fb41e1ac65ef08775">00764</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a42a013e880afbd5fb41e1ac65ef08775">gpfs_mode_t</a>;
<a name="l00765"></a><a class="code" href="gpfs_8h.html#a318e4b573fd107ed944ee33c965f2dbb">00765</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a318e4b573fd107ed944ee33c965f2dbb">gpfs_gid_t</a>;
<a name="l00766"></a><a class="code" href="gpfs_8h.html#a16d5a476c942c6ad2d54d6ab2cc4b7fa">00766</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#a16d5a476c942c6ad2d54d6ab2cc4b7fa">gpfs_gid64_t</a>;
<a name="l00767"></a><a class="code" href="gpfs_8h.html#a22e9c998653e5b7bccf41f1834116c3f">00767</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a22e9c998653e5b7bccf41f1834116c3f">gpfs_ino_t</a>;
<a name="l00768"></a><a class="code" href="gpfs_8h.html#afed1bbbae777822a65f43893b6159d16">00768</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#afed1bbbae777822a65f43893b6159d16">gpfs_ino64_t</a>;
<a name="l00769"></a><a class="code" href="gpfs_8h.html#aacfdf046882d3d58abd29691bbc7d4ac">00769</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#aacfdf046882d3d58abd29691bbc7d4ac">gpfs_gen_t</a>;
<a name="l00770"></a><a class="code" href="gpfs_8h.html#a0b01b7b9f30779a8b745efc8fd5cf57d">00770</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#a0b01b7b9f30779a8b745efc8fd5cf57d">gpfs_gen64_t</a>;
<a name="l00771"></a><a class="code" href="gpfs_8h.html#acd28b89924b6c1242a1a6d9e4ff5d3f1">00771</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#acd28b89924b6c1242a1a6d9e4ff5d3f1">gpfs_dev_t</a>;
<a name="l00772"></a><a class="code" href="gpfs_8h.html#ac3f01be0b34e95f5eebbe647ca0c1f55">00772</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#ac3f01be0b34e95f5eebbe647ca0c1f55">gpfs_mask_t</a>;
<a name="l00773"></a><a class="code" href="gpfs_8h.html#a623047e21ec84a76b6cbafff8f54c1b6">00773</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a623047e21ec84a76b6cbafff8f54c1b6">gpfs_pool_t</a>;
<a name="l00774"></a><a class="code" href="gpfs_8h.html#ab4287d3aff68354fd0326df23779b687">00774</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#ab4287d3aff68354fd0326df23779b687">gpfs_snapid_t</a>;
<a name="l00775"></a><a class="code" href="gpfs_8h.html#a0482bee3e25d9f7aa5a8036cbafc714b">00775</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#a0482bee3e25d9f7aa5a8036cbafc714b">gpfs_snapid64_t</a>;
<a name="l00776"></a><a class="code" href="gpfs_8h.html#aa54d800950319dd109aac7a5487df627">00776</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#aa54d800950319dd109aac7a5487df627">gpfs_fsid64_t</a>[2];
<a name="l00777"></a><a class="code" href="gpfs_8h.html#a550e0b533048f8d8184f6d93a3554f29">00777</a> <span class="keyword">typedef</span> <span class="keywordtype">short</span> <a class="code" href="gpfs_8h.html#a550e0b533048f8d8184f6d93a3554f29">gpfs_nlink_t</a>;
<a name="l00778"></a><a class="code" href="gpfs_8h.html#add3deac0c98e1472954bbe78e4981d7f">00778</a> <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="gpfs_8h.html#add3deac0c98e1472954bbe78e4981d7f">gpfs_nlink64_t</a>;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 <span class="preprocessor">#if defined(WIN32) || defined(_MS_SUA_)</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span>  <span class="keyword">typedef</span> <span class="keyword">struct </span>gpfs_stat64
<a name="l00783"></a>00783   {
<a name="l00784"></a>00784     gpfs_dev_t         st_dev;        <span class="comment">/* id of device containing file */</span>
<a name="l00785"></a>00785     gpfs_ino64_t       st_ino;        <span class="comment">/* file inode number */</span>
<a name="l00786"></a>00786     gpfs_mode_t        st_mode;       <span class="comment">/* access mode */</span>
<a name="l00787"></a>00787     gpfs_nlink64_t     st_nlink;      <span class="comment">/* number of links */</span>
<a name="l00788"></a>00788     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       st_flags;      <span class="comment">/* flag word */</span>
<a name="l00789"></a>00789     gpfs_uid64_t       st_uid;        <span class="comment">/* owner uid */</span>
<a name="l00790"></a>00790     gpfs_gid64_t       st_gid;        <span class="comment">/* owner gid */</span>
<a name="l00791"></a>00791     gpfs_dev_t         st_rdev;       <span class="comment">/* device id (if special file) */</span>
<a name="l00792"></a>00792     gpfs_off64_t       st_size;       <span class="comment">/* file size in bytes */</span>
<a name="l00793"></a>00793     <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> st_atime;      <span class="comment">/* time of last access */</span>
<a name="l00794"></a>00794     <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> st_mtime;      <span class="comment">/* time of last data modification */</span>
<a name="l00795"></a>00795     <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> st_ctime;      <span class="comment">/* time of last status change */</span>
<a name="l00796"></a>00796     <span class="keywordtype">int</span>                st_blksize;    <span class="comment">/* preferred block size for io */</span>
<a name="l00797"></a>00797     gpfs_off64_t       st_blocks;     <span class="comment">/* 512 byte blocks of disk held by file */</span>
<a name="l00798"></a>00798     <span class="keywordtype">long</span> <span class="keywordtype">long</span>          st_fsid;       <span class="comment">/* file system id */</span>
<a name="l00799"></a>00799     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       st_type;       <span class="comment">/* file type */</span>
<a name="l00800"></a>00800     gpfs_gen64_t       st_gen;        <span class="comment">/* inode generation number */</span>
<a name="l00801"></a>00801     <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> st_createtime; <span class="comment">/* time of creation */</span>
<a name="l00802"></a>00802     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       st_attrs;      <span class="comment">/* Window&#39;s flags */</span>
<a name="l00803"></a>00803   } <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a>;
<a name="l00804"></a>00804 <span class="preprocessor">#else</span>
<a name="l00805"></a><a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">00805</a> <span class="preprocessor"></span>  <span class="keyword">typedef</span> <span class="keyword">struct </span>stat64 <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a>;
<a name="l00806"></a>00806 <span class="preprocessor">#endif</span>
<a name="l00807"></a>00807 <span class="preprocessor"></span>
<a name="l00808"></a>00808 <span class="preprocessor">#if defined(WIN32) || defined(_MS_SUA_)</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span>  <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="gpfs_8h.html#a4746da0302b40ef89b13d50f19fafb53">gpfs_statfs64</a>
<a name="l00810"></a>00810   {
<a name="l00811"></a>00811     gpfs_off64_t       f_blocks;      <span class="comment">/* total data blocks in file system */</span>
<a name="l00812"></a>00812     gpfs_off64_t       f_bfree;       <span class="comment">/* free block in fs */</span>
<a name="l00813"></a>00813     gpfs_off64_t       f_bavail;      <span class="comment">/* free blocks avail to non-superuser */</span>
<a name="l00814"></a>00814     <span class="keywordtype">int</span>                f_bsize;       <span class="comment">/* optimal file system block size */</span>
<a name="l00815"></a>00815     gpfs_ino64_t       f_files;       <span class="comment">/* total file nodes in file system */</span>
<a name="l00816"></a>00816     gpfs_ino64_t       f_ffree;       <span class="comment">/* free file nodes in fs */</span>
<a name="l00817"></a>00817     gpfs_fsid64_t      f_fsid;        <span class="comment">/* file system id */</span>
<a name="l00818"></a>00818     <span class="keywordtype">int</span>                f_fsize;       <span class="comment">/* fundamental file system block size */</span>
<a name="l00819"></a>00819     <span class="keywordtype">int</span>                f_sector_size; <span class="comment">/* logical disk sector size */</span>
<a name="l00820"></a>00820     <span class="keywordtype">char</span>               f_fname[32];   <span class="comment">/* file system name (usually mount pt.) */</span>
<a name="l00821"></a>00821     <span class="keywordtype">char</span>               f_fpack[32];   <span class="comment">/* file system pack name */</span>
<a name="l00822"></a>00822     <span class="keywordtype">int</span>                f_name_max;    <span class="comment">/* maximum component name length for posix */</span>
<a name="l00823"></a>00823   } <a class="code" href="gpfs_8h.html#a585945966f328f4b19fd3142f9fc48b9">gpfs_statfs64_t</a>;
<a name="l00824"></a>00824 <span class="preprocessor">#else</span>
<a name="l00825"></a><a class="code" href="gpfs_8h.html#a585945966f328f4b19fd3142f9fc48b9">00825</a> <span class="preprocessor"></span>  <span class="keyword">typedef</span> <span class="keyword">struct </span>statfs64 <a class="code" href="gpfs_8h.html#a585945966f328f4b19fd3142f9fc48b9">gpfs_statfs64_t</a>;
<a name="l00826"></a>00826 <span class="preprocessor">#endif</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span>
<a name="l00828"></a>00828 <span class="comment">/* Declarations for backwards compatibility. */</span>
<a name="l00829"></a><a class="code" href="gpfs_8h.html#aef4f240579fd63678f96a7a68e2d9bd1">00829</a> <span class="keyword">typedef</span> <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a> <a class="code" href="gpfs_8h.html#aef4f240579fd63678f96a7a68e2d9bd1">stat64_t</a>;
<a name="l00830"></a><a class="code" href="gpfs_8h.html#a51d30f26f1da6853a849d68fbc3234fc">00830</a> <span class="keyword">typedef</span> <a class="code" href="gpfs_8h.html#a585945966f328f4b19fd3142f9fc48b9">gpfs_statfs64_t</a> <a class="code" href="gpfs_8h.html#a51d30f26f1da6853a849d68fbc3234fc">statfs64_t</a>;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">/* Define a version number for the directory entry data to allow</span>
<a name="l00834"></a>00834 <span class="comment">   future changes in this structure. Careful callers should also use</span>
<a name="l00835"></a>00835 <span class="comment">   the d_reclen field for the size of the structure rather than sizeof,</span>
<a name="l00836"></a>00836 <span class="comment">   to allow some degree of forward compatibility */</span>
<a name="l00837"></a><a class="code" href="gpfs_8h.html#ae8f5392acf6e3fb67bda82e5a8cad708">00837</a> <span class="preprocessor">#define GPFS_D_VERSION 1</span>
<a name="l00838"></a>00838 <span class="preprocessor"></span>
<a name="l00839"></a><a class="code" href="structgpfs__direntx.html">00839</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__direntx.html">gpfs_direntx</a>
<a name="l00840"></a>00840 {
<a name="l00841"></a><a class="code" href="structgpfs__direntx.html#a511ae37dd133b73b1d3f022eebaac439">00841</a>   <span class="keywordtype">int</span>            <a class="code" href="structgpfs__direntx.html#a511ae37dd133b73b1d3f022eebaac439">d_version</a>;     <span class="comment">/* this struct&#39;s version */</span>
<a name="l00842"></a><a class="code" href="structgpfs__direntx.html#a900f1c2ec8dee65991f4621f4238787d">00842</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structgpfs__direntx.html#a900f1c2ec8dee65991f4621f4238787d">d_reclen</a>;      <span class="comment">/* actual size of this struct including</span>
<a name="l00843"></a>00843 <span class="comment">                                   null terminated variable length d_name */</span>
<a name="l00844"></a><a class="code" href="structgpfs__direntx.html#adde53ad5720c72d5ec3b507d5e9fb584">00844</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structgpfs__direntx.html#adde53ad5720c72d5ec3b507d5e9fb584">d_type</a>;        <span class="comment">/* Types are defined below */</span>
<a name="l00845"></a><a class="code" href="structgpfs__direntx.html#a14c0aa0697bf58f65c7b52d725e8b41a">00845</a>   gpfs_ino_t     <a class="code" href="structgpfs__direntx.html#a14c0aa0697bf58f65c7b52d725e8b41a">d_ino</a>;         <span class="comment">/* File inode number */</span>
<a name="l00846"></a><a class="code" href="structgpfs__direntx.html#a6ebecf03384851d6466055bb8c489651">00846</a>   gpfs_gen_t     <a class="code" href="structgpfs__direntx.html#a6ebecf03384851d6466055bb8c489651">d_gen</a>;         <span class="comment">/* Generation number for the inode */</span>
<a name="l00847"></a><a class="code" href="structgpfs__direntx.html#a3476a01fe86753035974a880b0ad5ae3">00847</a>   <span class="keywordtype">char</span>           <a class="code" href="structgpfs__direntx.html#a3476a01fe86753035974a880b0ad5ae3">d_name</a>[256];   <span class="comment">/* null terminated variable length name */</span>
<a name="l00848"></a>00848 } <a class="code" href="gpfs_8h.html#ab4aeacfddad07eb776f7aceb4ed056a3">gpfs_direntx_t</a>;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 
<a name="l00851"></a><a class="code" href="gpfs_8h.html#a6cb32c27221320839c8990b2a4dc90b4">00851</a> <span class="preprocessor">#define GPFS_D64_VERSION 2</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span>
<a name="l00853"></a><a class="code" href="structgpfs__direntx64.html">00853</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__direntx64.html">gpfs_direntx64</a>
<a name="l00854"></a>00854 {
<a name="l00855"></a><a class="code" href="structgpfs__direntx64.html#a932c39c40adbf0d1c04e80c66c0c2d91">00855</a>   <span class="keywordtype">int</span>            <a class="code" href="structgpfs__direntx64.html#a932c39c40adbf0d1c04e80c66c0c2d91">d_version</a>;     <span class="comment">/* this struct&#39;s version */</span>
<a name="l00856"></a><a class="code" href="structgpfs__direntx64.html#a2137d25c1940690f08f210dfdcb6a992">00856</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structgpfs__direntx64.html#a2137d25c1940690f08f210dfdcb6a992">d_reclen</a>;      <span class="comment">/* actual size of this struct including</span>
<a name="l00857"></a>00857 <span class="comment">                                   null terminated variable length d_name */</span>
<a name="l00858"></a><a class="code" href="structgpfs__direntx64.html#a560592c5e2d452bdaa9b036249e2aecb">00858</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structgpfs__direntx64.html#a560592c5e2d452bdaa9b036249e2aecb">d_type</a>;        <span class="comment">/* Types are defined below */</span>
<a name="l00859"></a><a class="code" href="structgpfs__direntx64.html#acc73c1c5cde31f4a12c17af5456fa0bd">00859</a>   gpfs_ino64_t   <a class="code" href="structgpfs__direntx64.html#acc73c1c5cde31f4a12c17af5456fa0bd">d_ino</a>;         <span class="comment">/* File inode number */</span>
<a name="l00860"></a><a class="code" href="structgpfs__direntx64.html#ad9eaa3212d82f1c692590f6679f74a9f">00860</a>   gpfs_gen64_t   <a class="code" href="structgpfs__direntx64.html#ad9eaa3212d82f1c692590f6679f74a9f">d_gen</a>;         <span class="comment">/* Generation number for the inode */</span>
<a name="l00861"></a><a class="code" href="structgpfs__direntx64.html#af03bff1dc9c18581c11caddb1b08386d">00861</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   <a class="code" href="structgpfs__direntx64.html#af03bff1dc9c18581c11caddb1b08386d">d_flags</a>;       <span class="comment">/* Flags are defined below */</span>
<a name="l00862"></a><a class="code" href="structgpfs__direntx64.html#ae9f5a197fbfc81ee26d244c6593a1c11">00862</a>   <span class="keywordtype">char</span>           <a class="code" href="structgpfs__direntx64.html#ae9f5a197fbfc81ee26d244c6593a1c11">d_name</a>[1028];  <span class="comment">/* null terminated variable length name */</span>
<a name="l00863"></a>00863                                 <span class="comment">/* (1020+null+7 byte pad to double word) */</span>
<a name="l00864"></a>00864                                 <span class="comment">/* to handle up to 255 UTF-8 chars */</span>
<a name="l00865"></a>00865 } <a class="code" href="gpfs_8h.html#a7fae8df670d0d0e1789999efb2f16a05">gpfs_direntx64_t</a>;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="comment">/* File types for d_type field in gpfs_direntx_t */</span>
<a name="l00868"></a><a class="code" href="gpfs_8h.html#a7ca72ef82fc932f8d3df954ce21f8eb4">00868</a> <span class="preprocessor">#define GPFS_DE_OTHER    0</span>
<a name="l00869"></a><a class="code" href="gpfs_8h.html#a90ccdf94f9724af14853df3ae766fffd">00869</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DE_DIR      4</span>
<a name="l00870"></a><a class="code" href="gpfs_8h.html#a6d42b681aa9072c60aef2fb9a8980186">00870</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DE_REG      8</span>
<a name="l00871"></a><a class="code" href="gpfs_8h.html#a2e86b56f50a025c62972a3e19594b0bf">00871</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DE_LNK     10</span>
<a name="l00872"></a><a class="code" href="gpfs_8h.html#a8dc8ba07658f37f308aee0b4e96c2fd8">00872</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_DE_DEL     16</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span>
<a name="l00874"></a>00874 <span class="comment">/* Define flags for gpfs_direntx64_t */</span>
<a name="l00875"></a><a class="code" href="gpfs_8h.html#ace22e78ac17f825f3feeeb4a15d54581">00875</a> <span class="preprocessor">#define GPFS_DEFLAG_NONE      0x0000 </span><span class="comment">/* Default value, no flags set */</span>
<a name="l00876"></a><a class="code" href="gpfs_8h.html#aba2afc78938db0f5b3f05d93f689f08f">00876</a> <span class="preprocessor">#define GPFS_DEFLAG_JUNCTION  0x0001 </span><span class="comment">/* DirEnt is a fileset junction */</span>
<a name="l00877"></a><a class="code" href="gpfs_8h.html#a7770ce49d67420136dedaacefe212a9e">00877</a> <span class="preprocessor">#define GPFS_DEFLAG_IJUNCTION 0x0002 </span><span class="comment">/* DirEnt is a inode space junction */</span>
<a name="l00878"></a><a class="code" href="gpfs_8h.html#a1c3536ed288326c46f524d190bee8606">00878</a> <span class="preprocessor">#define GPFS_DEFLAG_ORPHAN    0x0004 </span><span class="comment">/* DirEnt is an orphan (pcache) */</span>
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="comment">/* Define a version number for the iattr data to allow future changes</span>
<a name="l00882"></a>00882 <span class="comment">   in this structure. Careful callers should also use the ia_reclen field</span>
<a name="l00883"></a>00883 <span class="comment">   for the size of the structure rather than sizeof, to allow some degree</span>
<a name="l00884"></a>00884 <span class="comment">   of forward compatibility */</span>
<a name="l00885"></a><a class="code" href="gpfs_8h.html#a1f34f556477eb5d12cff5d5121179381">00885</a> <span class="preprocessor">#define GPFS_IA_VERSION 1</span>
<a name="l00886"></a><a class="code" href="gpfs_8h.html#ab04a00f4787a109107278e229cf79f02">00886</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_IA64_VERSION 2</span>
<a name="l00887"></a><a class="code" href="gpfs_8h.html#ad7592eba181cec6749642acce342ae0a">00887</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_IA64_RESERVED 4</span>
<a name="l00888"></a><a class="code" href="gpfs_8h.html#abe67f0403f5b689b380c50050ad25cce">00888</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_IA64_UNUSED 10</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span>
<a name="l00890"></a><a class="code" href="structgpfs__iattr.html">00890</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__iattr.html">gpfs_iattr</a>
<a name="l00891"></a>00891 {
<a name="l00892"></a><a class="code" href="structgpfs__iattr.html#aafbce99480050e2d317bf50139968a35">00892</a>   <span class="keywordtype">int</span>              <a class="code" href="structgpfs__iattr.html#aafbce99480050e2d317bf50139968a35">ia_version</a>;    <span class="comment">/* this struct version */</span>
<a name="l00893"></a><a class="code" href="structgpfs__iattr.html#a1c65176685b70bd04b6ecd0d46353dde">00893</a>   <span class="keywordtype">int</span>              <a class="code" href="structgpfs__iattr.html#a1c65176685b70bd04b6ecd0d46353dde">ia_reclen</a>;     <span class="comment">/* sizeof this structure */</span>
<a name="l00894"></a><a class="code" href="structgpfs__iattr.html#a28f2927b6d7e92dc692d96978a59281d">00894</a>   <span class="keywordtype">int</span>              <a class="code" href="structgpfs__iattr.html#a28f2927b6d7e92dc692d96978a59281d">ia_checksum</a>;   <span class="comment">/* validity check on iattr struct */</span>
<a name="l00895"></a><a class="code" href="structgpfs__iattr.html#a084dc67e4665dab82331978db33a2b9d">00895</a>   gpfs_mode_t      <a class="code" href="structgpfs__iattr.html#a084dc67e4665dab82331978db33a2b9d">ia_mode</a>;       <span class="comment">/* access mode */</span>
<a name="l00896"></a><a class="code" href="structgpfs__iattr.html#a407bea05c6f1d0c039df1f697387f1f9">00896</a>   gpfs_uid_t       <a class="code" href="structgpfs__iattr.html#a407bea05c6f1d0c039df1f697387f1f9">ia_uid</a>;        <span class="comment">/* owner uid */</span>
<a name="l00897"></a><a class="code" href="structgpfs__iattr.html#a2323edb1d1ccd7a3c0e60a59bec2c57e">00897</a>   gpfs_gid_t       <a class="code" href="structgpfs__iattr.html#a2323edb1d1ccd7a3c0e60a59bec2c57e">ia_gid</a>;        <span class="comment">/* owner gid */</span>
<a name="l00898"></a><a class="code" href="structgpfs__iattr.html#a1ab373db5d4b6ac50c0cadbf514fd659">00898</a>   gpfs_ino_t       <a class="code" href="structgpfs__iattr.html#a1ab373db5d4b6ac50c0cadbf514fd659">ia_inode</a>;      <span class="comment">/* file inode number */</span>
<a name="l00899"></a><a class="code" href="structgpfs__iattr.html#ad5d67d366935687a8bfa4f9a471871c1">00899</a>   gpfs_gen_t       <a class="code" href="structgpfs__iattr.html#ad5d67d366935687a8bfa4f9a471871c1">ia_gen</a>;        <span class="comment">/* inode generation number */</span>
<a name="l00900"></a><a class="code" href="structgpfs__iattr.html#ade116dbc427b2255d26b1a279c96046c">00900</a>   gpfs_nlink_t     <a class="code" href="structgpfs__iattr.html#ade116dbc427b2255d26b1a279c96046c">ia_nlink</a>;      <span class="comment">/* number of links */</span>
<a name="l00901"></a><a class="code" href="structgpfs__iattr.html#a2beb0bf9d863e653d8fb586ed429ee22">00901</a>   <span class="keywordtype">short</span>            <a class="code" href="structgpfs__iattr.html#a2beb0bf9d863e653d8fb586ed429ee22">ia_flags</a>;      <span class="comment">/* Flags (defined below) */</span>
<a name="l00902"></a><a class="code" href="structgpfs__iattr.html#a8161c3b05505ea9d22794792aa2add15">00902</a>   <span class="keywordtype">int</span>              <a class="code" href="structgpfs__iattr.html#a8161c3b05505ea9d22794792aa2add15">ia_blocksize</a>;  <span class="comment">/* preferred block size for io */</span>
<a name="l00903"></a><a class="code" href="structgpfs__iattr.html#a88d27efc8283d7a3e6a369af0c62329e">00903</a>   gpfs_mask_t      <a class="code" href="structgpfs__iattr.html#a88d27efc8283d7a3e6a369af0c62329e">ia_mask</a>;       <span class="comment">/* Initial attribute mask (not used) */</span>
<a name="l00904"></a><a class="code" href="structgpfs__iattr.html#abd176ad5c78eba91d09a0c17b436b373">00904</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#abd176ad5c78eba91d09a0c17b436b373">ia_pad1</a>;       <span class="comment">/* reserved space */</span>
<a name="l00905"></a><a class="code" href="structgpfs__iattr.html#ada44d821ea3168fec17e40baa421e9c3">00905</a>   gpfs_off64_t     <a class="code" href="structgpfs__iattr.html#ada44d821ea3168fec17e40baa421e9c3">ia_size</a>;       <span class="comment">/* file size in bytes */</span>
<a name="l00906"></a><a class="code" href="structgpfs__iattr.html#a6042eb350417308f9310ecdd5aba4aff">00906</a>   gpfs_off64_t     <a class="code" href="structgpfs__iattr.html#a6042eb350417308f9310ecdd5aba4aff">ia_blocks</a>;     <span class="comment">/* 512 byte blocks of disk held by file */</span>
<a name="l00907"></a><a class="code" href="structgpfs__iattr.html#a185f5b789c3c8426467be29d62cfae73">00907</a>   <a class="code" href="structgpfs__timestruc.html">gpfs_timestruc_t</a> <a class="code" href="structgpfs__iattr.html#a185f5b789c3c8426467be29d62cfae73">ia_atime</a>;      <span class="comment">/* time of last access */</span>
<a name="l00908"></a><a class="code" href="structgpfs__iattr.html#a8fbef91c95fd54176f8166f4636eebd2">00908</a>   <a class="code" href="structgpfs__timestruc.html">gpfs_timestruc_t</a> <a class="code" href="structgpfs__iattr.html#a8fbef91c95fd54176f8166f4636eebd2">ia_mtime</a>;      <span class="comment">/* time of last data modification */</span>
<a name="l00909"></a><a class="code" href="structgpfs__iattr.html#a1870fa0b36c5264fbd481fe6ccd889f1">00909</a>   <a class="code" href="structgpfs__timestruc.html">gpfs_timestruc_t</a> <a class="code" href="structgpfs__iattr.html#a1870fa0b36c5264fbd481fe6ccd889f1">ia_ctime</a>;      <span class="comment">/* time of last status change */</span>
<a name="l00910"></a><a class="code" href="structgpfs__iattr.html#a8bd6f4b33390b34f4f9787cf9ddb1ec1">00910</a>   gpfs_dev_t       <a class="code" href="structgpfs__iattr.html#a8bd6f4b33390b34f4f9787cf9ddb1ec1">ia_rdev</a>;       <span class="comment">/* id of device */</span>
<a name="l00911"></a><a class="code" href="structgpfs__iattr.html#a5b9b6c19a68bffe7f1facba6753edd65">00911</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#a5b9b6c19a68bffe7f1facba6753edd65">ia_xperm</a>;      <span class="comment">/* extended attributes (defined below) */</span>
<a name="l00912"></a><a class="code" href="structgpfs__iattr.html#a0877856433f9034def77692e8aef5059">00912</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#a0877856433f9034def77692e8aef5059">ia_modsnapid</a>;  <span class="comment">/* snapshot id of last modification */</span>
<a name="l00913"></a><a class="code" href="structgpfs__iattr.html#a5d00e44c47567cd35fcadcee92446da1">00913</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#a5d00e44c47567cd35fcadcee92446da1">ia_filesetid</a>;  <span class="comment">/* fileset ID */</span>
<a name="l00914"></a><a class="code" href="structgpfs__iattr.html#a9cc6cbb7b75a7a4d5acb67cefc64ff2d">00914</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#a9cc6cbb7b75a7a4d5acb67cefc64ff2d">ia_datapoolid</a>; <span class="comment">/* storage pool ID for data */</span>
<a name="l00915"></a><a class="code" href="structgpfs__iattr.html#a62897a97147ff81bc2d31adbc4944831">00915</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     <a class="code" href="structgpfs__iattr.html#a62897a97147ff81bc2d31adbc4944831">ia_pad2</a>;       <span class="comment">/* reserved space */</span>
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 } <a class="code" href="gpfs_8h.html#a72fd7beee2018bf853dea9972722c5a0">gpfs_iattr_t</a>;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 
<a name="l00920"></a><a class="code" href="structgpfs__iattr64.html">00920</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__iattr64.html">gpfs_iattr64</a>
<a name="l00921"></a>00921 {
<a name="l00922"></a><a class="code" href="structgpfs__iattr64.html#abf279000e98090f425bd031bce2e7879">00922</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#abf279000e98090f425bd031bce2e7879">ia_version</a>;    <span class="comment">/* this struct version */</span>
<a name="l00923"></a><a class="code" href="structgpfs__iattr64.html#ab9af70ac5c5becc50127c01b18dd5eff">00923</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#ab9af70ac5c5becc50127c01b18dd5eff">ia_reclen</a>;     <span class="comment">/* sizeof this structure */</span>
<a name="l00924"></a><a class="code" href="structgpfs__iattr64.html#aa069cbe4510ffde3e77cc433665f227f">00924</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#aa069cbe4510ffde3e77cc433665f227f">ia_checksum</a>;   <span class="comment">/* validity check on iattr struct */</span>
<a name="l00925"></a><a class="code" href="structgpfs__iattr64.html#a20f84aa00b445c48802511713b3053ef">00925</a>   gpfs_mode_t        <a class="code" href="structgpfs__iattr64.html#a20f84aa00b445c48802511713b3053ef">ia_mode</a>;       <span class="comment">/* access mode */</span>
<a name="l00926"></a><a class="code" href="structgpfs__iattr64.html#a6a690700b619c487c19f985ff9fb9be6">00926</a>   gpfs_uid64_t       <a class="code" href="structgpfs__iattr64.html#a6a690700b619c487c19f985ff9fb9be6">ia_uid</a>;        <span class="comment">/* owner uid */</span>
<a name="l00927"></a><a class="code" href="structgpfs__iattr64.html#aeee028a2db0566cd64c932d1f2243b9c">00927</a>   gpfs_gid64_t       <a class="code" href="structgpfs__iattr64.html#aeee028a2db0566cd64c932d1f2243b9c">ia_gid</a>;        <span class="comment">/* owner gid */</span>
<a name="l00928"></a><a class="code" href="structgpfs__iattr64.html#a44c4561e8747b11c49166f72b3b36ee2">00928</a>   gpfs_ino64_t       <a class="code" href="structgpfs__iattr64.html#a44c4561e8747b11c49166f72b3b36ee2">ia_inode</a>;      <span class="comment">/* file inode number */</span>
<a name="l00929"></a><a class="code" href="structgpfs__iattr64.html#ae06878eb7f484e08d9d60257b2805bd1">00929</a>   gpfs_gen64_t       <a class="code" href="structgpfs__iattr64.html#ae06878eb7f484e08d9d60257b2805bd1">ia_gen</a>;        <span class="comment">/* inode generation number */</span>
<a name="l00930"></a><a class="code" href="structgpfs__iattr64.html#a2baefa0203ad14c333e26d6652caa57a">00930</a>   gpfs_nlink64_t     <a class="code" href="structgpfs__iattr64.html#a2baefa0203ad14c333e26d6652caa57a">ia_nlink</a>;      <span class="comment">/* number of links */</span>
<a name="l00931"></a><a class="code" href="structgpfs__iattr64.html#a49f3cdac2bde65e9ddf2dc548f8db034">00931</a>   gpfs_off64_t       <a class="code" href="structgpfs__iattr64.html#a49f3cdac2bde65e9ddf2dc548f8db034">ia_size</a>;       <span class="comment">/* file size in bytes */</span>
<a name="l00932"></a><a class="code" href="structgpfs__iattr64.html#a0101d4b759d9f49cd408d539081623c4">00932</a>   gpfs_off64_t       <a class="code" href="structgpfs__iattr64.html#a0101d4b759d9f49cd408d539081623c4">ia_blocks</a>;     <span class="comment">/* 512 byte blocks of disk held by file */</span>
<a name="l00933"></a><a class="code" href="structgpfs__iattr64.html#af5ece0fcec7259b13e9f099e9609b7dd">00933</a>   <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> <a class="code" href="structgpfs__iattr64.html#af5ece0fcec7259b13e9f099e9609b7dd">ia_atime</a>;      <span class="comment">/* time of last access */</span>
<a name="l00934"></a><a class="code" href="structgpfs__iattr64.html#a6de50492661ff83a2551f7f2ee71a15e">00934</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a6de50492661ff83a2551f7f2ee71a15e">ia_winflags</a>;   <span class="comment">/* window&#39;s flags (defined below) */</span>
<a name="l00935"></a><a class="code" href="structgpfs__iattr64.html#ac8ca19e0933b906a8d88d5ee8aab8e81">00935</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#ac8ca19e0933b906a8d88d5ee8aab8e81">ia_pad1</a>;       <span class="comment">/* reserved space */</span>
<a name="l00936"></a><a class="code" href="structgpfs__iattr64.html#af5b517ad20b70d807749e03f7e9fc477">00936</a>   <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> <a class="code" href="structgpfs__iattr64.html#af5b517ad20b70d807749e03f7e9fc477">ia_mtime</a>;      <span class="comment">/* time of last data modification */</span>
<a name="l00937"></a><a class="code" href="structgpfs__iattr64.html#a26b7ecd7fb5bc108ae1705923e546588">00937</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a26b7ecd7fb5bc108ae1705923e546588">ia_flags</a>;      <span class="comment">/* flags (defined below) */</span>
<a name="l00938"></a><a class="code" href="structgpfs__iattr64.html#a43db721ff1d64644b2e00811e1520c0e">00938</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#a43db721ff1d64644b2e00811e1520c0e">ia_pad2</a>;       <span class="comment">/* reserved space */</span>
<a name="l00939"></a><a class="code" href="structgpfs__iattr64.html#a3994707ed133502c78aac658464f7e27">00939</a>   <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> <a class="code" href="structgpfs__iattr64.html#a3994707ed133502c78aac658464f7e27">ia_ctime</a>;      <span class="comment">/* time of last status change */</span>
<a name="l00940"></a><a class="code" href="structgpfs__iattr64.html#a9fa0e3744f58b353affe4469a0526207">00940</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#a9fa0e3744f58b353affe4469a0526207">ia_blocksize</a>;  <span class="comment">/* preferred block size for io */</span>
<a name="l00941"></a><a class="code" href="structgpfs__iattr64.html#afb8f91ae349859b83e3fe69f3d60fc56">00941</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#afb8f91ae349859b83e3fe69f3d60fc56">ia_pad3</a>;       <span class="comment">/* reserved space */</span>
<a name="l00942"></a><a class="code" href="structgpfs__iattr64.html#a9f908f5f084ae2e566e0fcf1c046cc99">00942</a>   <a class="code" href="structgpfs__timestruc64.html">gpfs_timestruc64_t</a> <a class="code" href="structgpfs__iattr64.html#a9f908f5f084ae2e566e0fcf1c046cc99">ia_createtime</a>; <span class="comment">/* creation time */</span>
<a name="l00943"></a><a class="code" href="structgpfs__iattr64.html#a909aaf8cdd4e6d28480d99e0b14372bc">00943</a>   gpfs_mask_t        <a class="code" href="structgpfs__iattr64.html#a909aaf8cdd4e6d28480d99e0b14372bc">ia_mask</a>;       <span class="comment">/* initial attribute mask (not used) */</span>
<a name="l00944"></a><a class="code" href="structgpfs__iattr64.html#a6178a654a03cca21b57c56301ff76983">00944</a>   <span class="keywordtype">int</span>                <a class="code" href="structgpfs__iattr64.html#a6178a654a03cca21b57c56301ff76983">ia_pad4</a>;       <span class="comment">/* reserved space */</span>
<a name="l00945"></a><a class="code" href="structgpfs__iattr64.html#a5c73ecfb5a18956bd11fbe617783ced6">00945</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a5c73ecfb5a18956bd11fbe617783ced6">ia_reserved</a>[<a class="code" href="gpfs_8h.html#ad7592eba181cec6749642acce342ae0a">GPFS_IA64_RESERVED</a>]; <span class="comment">/* reserved space */</span>
<a name="l00946"></a><a class="code" href="structgpfs__iattr64.html#a10b62413948feb28c13c17cab61e22e5">00946</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a10b62413948feb28c13c17cab61e22e5">ia_xperm</a>;      <span class="comment">/* extended attributes (defined below) */</span>
<a name="l00947"></a><a class="code" href="structgpfs__iattr64.html#ae814448a5020e5f48d44ba3bf5b689ee">00947</a>   gpfs_dev_t         <a class="code" href="structgpfs__iattr64.html#ae814448a5020e5f48d44ba3bf5b689ee">ia_dev</a>;        <span class="comment">/* id of device containing file */</span>
<a name="l00948"></a><a class="code" href="structgpfs__iattr64.html#afd7e6e2ccd04b0d6df197f045fb67ac6">00948</a>   gpfs_dev_t         <a class="code" href="structgpfs__iattr64.html#afd7e6e2ccd04b0d6df197f045fb67ac6">ia_rdev</a>;       <span class="comment">/* device id (if special file) */</span>
<a name="l00949"></a><a class="code" href="structgpfs__iattr64.html#a10f97fd02673d6d98d4a48b20f9ec7c8">00949</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a10f97fd02673d6d98d4a48b20f9ec7c8">ia_pcacheflags</a>; <span class="comment">/* pcache inode bits */</span>
<a name="l00950"></a><a class="code" href="structgpfs__iattr64.html#a375357ce51a1c8a80b792d6a7d8ac183">00950</a>   gpfs_snapid64_t    <a class="code" href="structgpfs__iattr64.html#a375357ce51a1c8a80b792d6a7d8ac183">ia_modsnapid</a>;  <span class="comment">/* snapshot id of last modification */</span>
<a name="l00951"></a><a class="code" href="structgpfs__iattr64.html#a23906d068eaef4138c2356ba22426973">00951</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a23906d068eaef4138c2356ba22426973">ia_filesetid</a>;  <span class="comment">/* fileset ID */</span>
<a name="l00952"></a><a class="code" href="structgpfs__iattr64.html#a9dff6a09b706248272d0376167dff557">00952</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#a9dff6a09b706248272d0376167dff557">ia_datapoolid</a>; <span class="comment">/* storage pool ID for data */</span>
<a name="l00953"></a><a class="code" href="structgpfs__iattr64.html#a07cfc11c68525c57510f744ecc361712">00953</a>   gpfs_ino64_t       <a class="code" href="structgpfs__iattr64.html#a07cfc11c68525c57510f744ecc361712">ia_inode_space_mask</a>; <span class="comment">/* inode space mask of this file system */</span>
<a name="l00954"></a>00954                                           <span class="comment">/* This value is saved in the iattr structure</span>
<a name="l00955"></a>00955 <span class="comment">                                             during backup and used during restore */</span>
<a name="l00956"></a><a class="code" href="structgpfs__iattr64.html#ae6e89cd84c5d9a87d5d70b768e113b69">00956</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       <a class="code" href="structgpfs__iattr64.html#ae6e89cd84c5d9a87d5d70b768e113b69">ia_unused</a>[<a class="code" href="gpfs_8h.html#abe67f0403f5b689b380c50050ad25cce">GPFS_IA64_UNUSED</a>];  <span class="comment">/* reserved space */</span>
<a name="l00957"></a>00957 } <a class="code" href="gpfs_8h.html#a254e393b7b8b47992b97bd8962549144">gpfs_iattr64_t</a>;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="comment">/* Define flags for inode attributes */</span>
<a name="l00960"></a><a class="code" href="gpfs_8h.html#a7c3e8ce95f50e0c29fa7b316919a4d84">00960</a> <span class="preprocessor">#define GPFS_IAFLAG_SNAPDIR         0x0001 </span><span class="comment">/* (obsolete) */</span>
<a name="l00961"></a><a class="code" href="gpfs_8h.html#a79695ec8fffea35eacca9fec9e941e87">00961</a> <span class="preprocessor">#define GPFS_IAFLAG_USRQUOTA        0x0002 </span><span class="comment">/* inode is a user quota file */</span>
<a name="l00962"></a><a class="code" href="gpfs_8h.html#abaed807d2604a1dc1a860448d23604ee">00962</a> <span class="preprocessor">#define GPFS_IAFLAG_GRPQUOTA        0x0004 </span><span class="comment">/* inode is a group quota file */</span>
<a name="l00963"></a><a class="code" href="gpfs_8h.html#af6377ab5aa7138600e8f806a338245d4">00963</a> <span class="preprocessor">#define GPFS_IAFLAG_ERROR           0x0008 </span><span class="comment">/* error reading inode */</span>
<a name="l00964"></a>00964 <span class="comment">/* Define flags for inode replication attributes */</span>
<a name="l00965"></a><a class="code" href="gpfs_8h.html#a343fc3fc911dec469a8e275ba8cb297d">00965</a> <span class="preprocessor">#define GPFS_IAFLAG_FILESET_ROOT    0x0010 </span><span class="comment">/* root dir of a fileset */</span>
<a name="l00966"></a><a class="code" href="gpfs_8h.html#afced8252142a85720b636e5c42c6cc6b">00966</a> <span class="preprocessor">#define GPFS_IAFLAG_NO_SNAP_RESTORE 0x0020 </span><span class="comment">/* don&#39;t restore from snapshots */</span>
<a name="l00967"></a><a class="code" href="gpfs_8h.html#a4dd67a83dc42b63659df42626a232ea4">00967</a> <span class="preprocessor">#define GPFS_IAFLAG_FILESETQUOTA    0x0040 </span><span class="comment">/* inode is a fileset quota file */</span>
<a name="l00968"></a><a class="code" href="gpfs_8h.html#a3e6db54f4cd441c920d3ce42789fa3d9">00968</a> <span class="preprocessor">#define GPFS_IAFLAG_COMANAGED       0x0080 </span><span class="comment">/* file data is co-managed */</span>
<a name="l00969"></a><a class="code" href="gpfs_8h.html#a68c1c41b2ad4f25daccb7f7ba3c10ec3">00969</a> <span class="preprocessor">#define GPFS_IAFLAG_ILLPLACED       0x0100 </span><span class="comment">/* may not be properly placed */</span>
<a name="l00970"></a><a class="code" href="gpfs_8h.html#afe112d198c586fb893511cfdf1cfc7dc">00970</a> <span class="preprocessor">#define GPFS_IAFLAG_REPLMETA        0x0200 </span><span class="comment">/* metadata replication set */</span>
<a name="l00971"></a><a class="code" href="gpfs_8h.html#a4bbc565fba765bbf10f115005f484a8e">00971</a> <span class="preprocessor">#define GPFS_IAFLAG_REPLDATA        0x0400 </span><span class="comment">/* data replication set */</span>
<a name="l00972"></a><a class="code" href="gpfs_8h.html#ad7c777da36ce2d980c0328da7787e00f">00972</a> <span class="preprocessor">#define GPFS_IAFLAG_EXPOSED         0x0800 </span><span class="comment">/* may have data on suspended disks */</span>
<a name="l00973"></a><a class="code" href="gpfs_8h.html#a83f325b75ecf50be380167255350945e">00973</a> <span class="preprocessor">#define GPFS_IAFLAG_ILLREPLICATED   0x1000 </span><span class="comment">/* may not be properly replicated */</span>
<a name="l00974"></a><a class="code" href="gpfs_8h.html#a7dade15ee036d39e3afbeb98169b7b24">00974</a> <span class="preprocessor">#define GPFS_IAFLAG_UNBALANCED      0x2000 </span><span class="comment">/* may not be properly balanced */</span>
<a name="l00975"></a><a class="code" href="gpfs_8h.html#a998cf4bbb167e48344b8e9c6d7ab4e82">00975</a> <span class="preprocessor">#define GPFS_IAFLAG_DATAUPDATEMISS  0x4000 </span><span class="comment">/* has stale data blocks on</span>
<a name="l00976"></a>00976 <span class="comment">                                              unavailable disk */</span>
<a name="l00977"></a><a class="code" href="gpfs_8h.html#a10e3173f07bb40b7fe05187e8b06765c">00977</a> <span class="preprocessor">#define GPFS_IAFLAG_METAUPDATEMISS  0x8000 </span><span class="comment">/* has stale metadata on</span>
<a name="l00978"></a>00978 <span class="comment">                                              unavailable disk */</span>
<a name="l00979"></a>00979 
<a name="l00980"></a><a class="code" href="gpfs_8h.html#aa4f5661f96c328753b6052678ff3ee60">00980</a> <span class="preprocessor">#define GPFS_IAFLAG_IMMUTABLE       0x00010000 </span><span class="comment">/* Immutability */</span>
<a name="l00981"></a><a class="code" href="gpfs_8h.html#a87050e699203ed40641a766007e26b06">00981</a> <span class="preprocessor">#define GPFS_IAFLAG_INDEFRETENT     0x00020000 </span><span class="comment">/* Indefinite retention */</span>
<a name="l00982"></a><a class="code" href="gpfs_8h.html#a44351b304eff01f316f08e00ccd0f0e4">00982</a> <span class="preprocessor">#define GPFS_IAFLAG_SECUREDELETE    0x00040000 </span><span class="comment">/* Secure deletion */</span>
<a name="l00983"></a>00983 
<a name="l00984"></a><a class="code" href="gpfs_8h.html#a321350c9d41aee9981926dee949e1a80">00984</a> <span class="preprocessor">#define GPFS_IAFLAG_TRUNCMANAGED    0x00080000 </span><span class="comment">/* dmapi truncate event enabled */</span>
<a name="l00985"></a><a class="code" href="gpfs_8h.html#a946a3c1508db1247a16556a341da975b">00985</a> <span class="preprocessor">#define GPFS_IAFLAG_READMANAGED     0x00100000 </span><span class="comment">/* dmapi read event enabled */</span>
<a name="l00986"></a><a class="code" href="gpfs_8h.html#a6356f96a29273b2a5ffb7e0e9016f80e">00986</a> <span class="preprocessor">#define GPFS_IAFLAG_WRITEMANAGED    0x00200000 </span><span class="comment">/* dmapi write event enabled */</span>
<a name="l00987"></a>00987 
<a name="l00988"></a><a class="code" href="gpfs_8h.html#a9280dd22d4f4e33b1fa9cc5b4031cef2">00988</a> <span class="preprocessor">#define GPFS_IAFLAG_APPENDONLY      0x00400000 </span><span class="comment">/* AppendOnly only */</span>
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="comment">/* Define flags for window&#39;s attributes */</span>
<a name="l00991"></a><a class="code" href="gpfs_8h.html#aec45651b5a1faf7c7db6d8b112b37432">00991</a> <span class="preprocessor">#define GPFS_IWINFLAG_ARCHIVE       0x0001 </span><span class="comment">/* Archive */</span>
<a name="l00992"></a><a class="code" href="gpfs_8h.html#a474bf1fc10ab3d8ca23f58310393d375">00992</a> <span class="preprocessor">#define GPFS_IWINFLAG_HIDDEN        0x0002 </span><span class="comment">/* Hidden */</span>
<a name="l00993"></a><a class="code" href="gpfs_8h.html#a5948b9141a3cf76c8537985fa5f5a4e7">00993</a> <span class="preprocessor">#define GPFS_IWINFLAG_NOTINDEXED    0x0004 </span><span class="comment">/* Not content indexed */</span>
<a name="l00994"></a><a class="code" href="gpfs_8h.html#a9525ed08668a9368d1113e816cb5254d">00994</a> <span class="preprocessor">#define GPFS_IWINFLAG_OFFLINE       0x0008 </span><span class="comment">/* Off-line */</span>
<a name="l00995"></a><a class="code" href="gpfs_8h.html#af161bd5ca24377a5e636d6aad6c323fc">00995</a> <span class="preprocessor">#define GPFS_IWINFLAG_READONLY      0x0010 </span><span class="comment">/* Read-only */</span>
<a name="l00996"></a><a class="code" href="gpfs_8h.html#aa8ba5f6d6ec9be016ed0ca4c1402a9dc">00996</a> <span class="preprocessor">#define GPFS_IWINFLAG_REPARSE       0x0020 </span><span class="comment">/* Reparse point */</span>
<a name="l00997"></a><a class="code" href="gpfs_8h.html#a73c74b8bceb3f64f2d870ec928c4623f">00997</a> <span class="preprocessor">#define GPFS_IWINFLAG_SYSTEM        0x0040 </span><span class="comment">/* System */</span>
<a name="l00998"></a><a class="code" href="gpfs_8h.html#aa10b691b55d524e04ffec0d63bace2d5">00998</a> <span class="preprocessor">#define GPFS_IWINFLAG_TEMPORARY     0x0080 </span><span class="comment">/* Temporary */</span>
<a name="l00999"></a><a class="code" href="gpfs_8h.html#aa81e3b265e25e84f34913acf43a94000">00999</a> <span class="preprocessor">#define GPFS_IWINFLAG_COMPRESSED    0x0100 </span><span class="comment">/* Compressed */</span>
<a name="l01000"></a><a class="code" href="gpfs_8h.html#a7b538d2a6bbae03e330006740b85bd9c">01000</a> <span class="preprocessor">#define GPFS_IWINFLAG_ENCRYPTED     0x0200 </span><span class="comment">/* Encrypted */</span>
<a name="l01001"></a><a class="code" href="gpfs_8h.html#a68f0b306f6d4f0af713d7b62537bf064">01001</a> <span class="preprocessor">#define GPFS_IWINFLAG_SPARSE        0x0400 </span><span class="comment">/* Sparse file */</span>
<a name="l01002"></a><a class="code" href="gpfs_8h.html#a784f21675b84d4116529ec7a2938bf29">01002</a> <span class="preprocessor">#define GPFS_IWINFLAG_HASSTREAMS    0x0800 </span><span class="comment">/* Has streams */</span>
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="comment">/* Define flags for extended attributes */</span>
<a name="l01005"></a><a class="code" href="gpfs_8h.html#a3b54653b091a731c1d41879b26773c11">01005</a> <span class="preprocessor">#define GPFS_IAXPERM_ACL            0x0001 </span><span class="comment">/* file has acls */</span>
<a name="l01006"></a><a class="code" href="gpfs_8h.html#a11286517987382265d7055c98a3dacf7">01006</a> <span class="preprocessor">#define GPFS_IAXPERM_XATTR          0x0002 </span><span class="comment">/* file has extended attributes */</span>
<a name="l01007"></a><a class="code" href="gpfs_8h.html#a1d2b44083e3f47b3c513ddb1f5faad65">01007</a> <span class="preprocessor">#define GPFS_IAXPERM_DMATTR         0x0004 </span><span class="comment">/* file has dm attributes */</span>
<a name="l01008"></a><a class="code" href="gpfs_8h.html#aff11e5b3ca376817846c106f57140708">01008</a> <span class="preprocessor">#define GPFS_IAXPERM_DOSATTR        0x0008 </span><span class="comment">/* file has non-default dos attrs */</span>
<a name="l01009"></a><a class="code" href="gpfs_8h.html#ae4461e040205431c004d1b2585497df6">01009</a> <span class="preprocessor">#define GPFS_IAXPERM_RPATTR         0x0010 </span><span class="comment">/* file has restore policy attrs */</span>
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">/* Define flags for pcache bits defined in the inode */</span>
<a name="l01012"></a><a class="code" href="gpfs_8h.html#a011fd085e949096c55b1cbacb6b238ba">01012</a> <span class="preprocessor">#define GPFS_ICAFLAG_CACHED   0x0001  // &quot;cached complete&quot;</span>
<a name="l01013"></a><a class="code" href="gpfs_8h.html#a83a36460698fd2b5de282556668bc05f">01013</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_CREATE   0x0002  // &quot;created&quot;</span>
<a name="l01014"></a><a class="code" href="gpfs_8h.html#a43b4c51edc2be4cc47126595effe0118">01014</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_DIRTY    0x0004  // &quot;data dirty&quot;</span>
<a name="l01015"></a><a class="code" href="gpfs_8h.html#addafb6dabb0f7ac5a1e95e1f59122d0e">01015</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_LINK     0x0008  // &quot;hard linked&quot;</span>
<a name="l01016"></a><a class="code" href="gpfs_8h.html#acf591c4dcbab284fb41e7044774b181e">01016</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_SETATTR  0x0010  // &quot;attr changed&quot;</span>
<a name="l01017"></a><a class="code" href="gpfs_8h.html#a08cae919df52c92efdfd9cd4f3b8db57">01017</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_LOCAL    0x0020  // &quot;local&quot;</span>
<a name="l01018"></a><a class="code" href="gpfs_8h.html#ac995c3bbc7ef980dc1e53ca57d42b139">01018</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_APPEND   0x0040  // &quot;append&quot;</span>
<a name="l01019"></a><a class="code" href="gpfs_8h.html#afa239d3c434e82b020a3c9af23196b4e">01019</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_ICAFLAG_STATE    0x0080  // &quot;has remote state&quot;</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span>
<a name="l01021"></a>01021 <span class="comment">/* Define pointers to interface types */</span>
<a name="l01022"></a><a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">01022</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>gpfs_fssnap_handle <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a>;
<a name="l01023"></a><a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">01023</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>gpfs_iscan <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a>;
<a name="l01024"></a><a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">01024</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>gpfs_ifile <a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a>;
<a name="l01025"></a><a class="code" href="gpfs_8h.html#a022a359f2dec88568f61efde07c13ca5">01025</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>gpfs_restore <a class="code" href="gpfs_8h.html#a022a359f2dec88568f61efde07c13ca5">gpfs_restore_t</a>;
<a name="l01026"></a>01026 
<a name="l01027"></a><a class="code" href="structgpfs__fssnap__id.html">01027</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id</a>
<a name="l01028"></a>01028 {
<a name="l01029"></a><a class="code" href="structgpfs__fssnap__id.html#a68a1376102d4b40f74214f47f1be6b90">01029</a>   <span class="keywordtype">char</span> <a class="code" href="structgpfs__fssnap__id.html#a68a1376102d4b40f74214f47f1be6b90">opaque</a>[48];
<a name="l01030"></a>01030 } <a class="code" href="gpfs_8h.html#a3ebe85e65a7d35b3ab2cfded0a4f93fc">gpfs_fssnap_id_t</a>;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="comment">/* Define extended return codes for gpfs backup &amp; restore</span>
<a name="l01034"></a>01034 <span class="comment">   calls without an explicit return code will return the value in errno */</span>
<a name="l01035"></a><a class="code" href="gpfs_8h.html#acf0e2c16e1efa76b1dde745c4c904530">01035</a> <span class="preprocessor">#define GPFS_ERRNO_BASE  190</span>
<a name="l01036"></a><a class="code" href="gpfs_8h.html#a705af3f0d72d0807f8f772d76419fd07">01036</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_E_INVAL_FSSNAPID       (GPFS_ERRNO_BASE+0) </span><span class="comment">/* invalid fssnap id */</span>
<a name="l01037"></a><a class="code" href="gpfs_8h.html#a5fd16026f043978fdc8fd876e16d6d5e">01037</a> <span class="preprocessor">#define GPFS_E_INVAL_ISCAN          (GPFS_ERRNO_BASE+1) </span><span class="comment">/* invalid iscan pointer */</span>
<a name="l01038"></a><a class="code" href="gpfs_8h.html#a4f5d97061adf9d72d1fa6637a2adec5f">01038</a> <span class="preprocessor">#define GPFS_E_INVAL_IFILE          (GPFS_ERRNO_BASE+2) </span><span class="comment">/* invalid ifile pointer */</span>
<a name="l01039"></a><a class="code" href="gpfs_8h.html#a629eb5b5d52f4a9e1463d5a0536e0567">01039</a> <span class="preprocessor">#define GPFS_E_INVAL_IATTR          (GPFS_ERRNO_BASE+3) </span><span class="comment">/* invalid iattr structure */</span>
<a name="l01040"></a><a class="code" href="gpfs_8h.html#ad9a55c21e5d32a565673a5c071915e0d">01040</a> <span class="preprocessor">#define GPFS_E_INVAL_RESTORE        (GPFS_ERRNO_BASE+4) </span><span class="comment">/* invalid restore pointer */</span>
<a name="l01041"></a><a class="code" href="gpfs_8h.html#a0f58aeae7fb77206a8a9026480cdd646">01041</a> <span class="preprocessor">#define GPFS_E_INVAL_FSSNAPHANDLE   (GPFS_ERRNO_BASE+5) </span><span class="comment">/* invalid fssnap handle */</span>
<a name="l01042"></a><a class="code" href="gpfs_8h.html#afd7f7b3731b4c689d6b9faaa6c9fad25">01042</a> <span class="preprocessor">#define GPFS_E_INVAL_SNAPNAME       (GPFS_ERRNO_BASE+6) </span><span class="comment">/* invalid snapshot name */</span>
<a name="l01043"></a><a class="code" href="gpfs_8h.html#acbf4887785502e6eb86a6633503ace94">01043</a> <span class="preprocessor">#define GPFS_E_FS_NOT_RESTORABLE    (GPFS_ERRNO_BASE+7) </span><span class="comment">/* FS is not clean */</span>
<a name="l01044"></a><a class="code" href="gpfs_8h.html#aa3576c10d9d7b00e9b5b66f4dfcc0877">01044</a> <span class="preprocessor">#define GPFS_E_RESTORE_NOT_ENABLED  (GPFS_ERRNO_BASE+8) </span><span class="comment">/* Restore was not enabled */</span>
<a name="l01045"></a><a class="code" href="gpfs_8h.html#a364dd8ab7e6477b425f896cbcd8906d7">01045</a> <span class="preprocessor">#define GPFS_E_RESTORE_STARTED      (GPFS_ERRNO_BASE+9) </span><span class="comment">/* Restore is running */</span>
<a name="l01046"></a><a class="code" href="gpfs_8h.html#ae51e74c9f61ca528cfc14c807aba1909">01046</a> <span class="preprocessor">#define GPFS_E_INVAL_XATTR          (GPFS_ERRNO_BASE+10) </span><span class="comment">/* invalid extended</span>
<a name="l01047"></a>01047 <span class="comment">                                                            attribute pointer */</span>
<a name="l01048"></a>01048 
<a name="l01049"></a>01049 <span class="comment">/* Define flags parameter for get/put file attributes.</span>
<a name="l01050"></a>01050 <span class="comment">   Used by gpfs_fgetattr, gpfs_fputattr, gpfs_fputattrwithpath</span>
<a name="l01051"></a>01051 <span class="comment">   and gpfs_igetattrsx, gpfs_iputattrsx</span>
<a name="l01052"></a>01052 <span class="comment">*/</span>
<a name="l01053"></a><a class="code" href="gpfs_8h.html#a1745ba99165fb46ab780a1905f050144">01053</a> <span class="preprocessor">#define GPFS_ATTRFLAG_DEFAULT        0x0000  </span><span class="comment">/* default behavior */</span>
<a name="l01054"></a><a class="code" href="gpfs_8h.html#afeab9aafeec2aa98fe2171b5c8630761">01054</a> <span class="preprocessor">#define GPFS_ATTRFLAG_NO_PLACEMENT   0x0001  </span><span class="comment">/* exclude file placement attributes */</span>
<a name="l01055"></a><a class="code" href="gpfs_8h.html#a58f61b8a7038104445d095cbdb3939a3">01055</a> <span class="preprocessor">#define GPFS_ATTRFLAG_IGNORE_POOL    0x0002  </span><span class="comment">/* saved poolid is not valid */</span>
<a name="l01056"></a><a class="code" href="gpfs_8h.html#ae93b990ac99ec6bf22397c3b0a9741e6">01056</a> <span class="preprocessor">#define GPFS_ATTRFLAG_USE_POLICY     0x0004  </span><span class="comment">/* use restore policy rules to</span>
<a name="l01057"></a>01057 <span class="comment">                                                determine poolid */</span>
<a name="l01058"></a><a class="code" href="gpfs_8h.html#ac02c85982dbb84c0cd106018748c1448">01058</a> <span class="preprocessor">#define GPFS_ATTRFLAG_INCL_DMAPI     0x0008  </span><span class="comment">/* Include dmapi attributes */</span>
<a name="l01059"></a><a class="code" href="gpfs_8h.html#a63578551ae0758aa206b7190a132520a">01059</a> <span class="preprocessor">#define GPFS_ATTRFLAG_FINALIZE_ATTRS 0x0010  </span><span class="comment">/* Finalize immutability attributes */</span>
<a name="l01060"></a><a class="code" href="gpfs_8h.html#acb98dc8e3b68f8406290064b4e7cedf1">01060</a> <span class="preprocessor">#define GPFS_ATTRFLAG_SKIP_IMMUTABLE 0x0020  </span><span class="comment">/* Skip immutable attributes */</span>
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 <span class="comment">/* Define structure used by gpfs_statfspool */</span>
<a name="l01063"></a><a class="code" href="structgpfs__statfspool__s.html">01063</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__statfspool__s.html">gpfs_statfspool_s</a>
<a name="l01064"></a>01064 {
<a name="l01065"></a><a class="code" href="structgpfs__statfspool__s.html#a6b1746b6c8024163933db1f3611c3c2f">01065</a>   gpfs_off64_t <a class="code" href="structgpfs__statfspool__s.html#a6b1746b6c8024163933db1f3611c3c2f">f_blocks</a>;     <span class="comment">/* total data blocks in pool */</span>
<a name="l01066"></a><a class="code" href="structgpfs__statfspool__s.html#a642fa35c9914dfe599bfd626593a494b">01066</a>   gpfs_off64_t <a class="code" href="structgpfs__statfspool__s.html#a642fa35c9914dfe599bfd626593a494b">f_bfree</a>;      <span class="comment">/* free blocks in pool */</span>
<a name="l01067"></a><a class="code" href="structgpfs__statfspool__s.html#ae758222884140801a940ad9eeec7ae34">01067</a>   gpfs_off64_t <a class="code" href="structgpfs__statfspool__s.html#ae758222884140801a940ad9eeec7ae34">f_bavail</a>;     <span class="comment">/* free blocks avail to non-superuser */</span>
<a name="l01068"></a><a class="code" href="structgpfs__statfspool__s.html#ad7f966cbd8f10d722ddbca30c7038277">01068</a>   gpfs_off64_t <a class="code" href="structgpfs__statfspool__s.html#ad7f966cbd8f10d722ddbca30c7038277">f_mblocks</a>;    <span class="comment">/* total metadata blocks in pool */</span>
<a name="l01069"></a><a class="code" href="structgpfs__statfspool__s.html#a7577764e01e2b5c7ef94d4edeabbefc4">01069</a>   gpfs_off64_t <a class="code" href="structgpfs__statfspool__s.html#a7577764e01e2b5c7ef94d4edeabbefc4">f_mfree</a>;      <span class="comment">/* free blocks avail for system metadata */</span>
<a name="l01070"></a><a class="code" href="structgpfs__statfspool__s.html#a8b48eca69a39bbe8d4bc269cff585698">01070</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__statfspool__s.html#a8b48eca69a39bbe8d4bc269cff585698">f_bsize</a>;      <span class="comment">/* optimal storage pool block size */</span>
<a name="l01071"></a><a class="code" href="structgpfs__statfspool__s.html#a88a003857d108224e4cf39863fc5cd13">01071</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__statfspool__s.html#a88a003857d108224e4cf39863fc5cd13">f_files</a>;      <span class="comment">/* total file nodes assigned to pool */</span>
<a name="l01072"></a><a class="code" href="structgpfs__statfspool__s.html#a40b08e12bcce5dfda29563f6f72fb030">01072</a>   gpfs_pool_t  <a class="code" href="structgpfs__statfspool__s.html#a40b08e12bcce5dfda29563f6f72fb030">f_poolid</a>;     <span class="comment">/* storage pool id */</span>
<a name="l01073"></a><a class="code" href="structgpfs__statfspool__s.html#aa67c26bcd0f3c88c7b60a95e34d2ab0f">01073</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__statfspool__s.html#aa67c26bcd0f3c88c7b60a95e34d2ab0f">f_fsize</a>;      <span class="comment">/* fundamental file system block size */</span>
<a name="l01074"></a><a class="code" href="structgpfs__statfspool__s.html#a937bff980af2ac2804ea8f99877520ac">01074</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__statfspool__s.html#a937bff980af2ac2804ea8f99877520ac">f_usage</a>;      <span class="comment">/* data and/or metadata stored in pool */</span>
<a name="l01075"></a><a class="code" href="structgpfs__statfspool__s.html#a03efdf5b81250fd919493466a45b64d9">01075</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__statfspool__s.html#a03efdf5b81250fd919493466a45b64d9">f_reserved</a>[7];<span class="comment">/* Current unused and set to  zero */</span>
<a name="l01076"></a>01076 } <a class="code" href="gpfs_8h.html#aaa73d35ad52471fe0f3eb2cc72f40b3e">gpfs_statfspool_t</a>;
<a name="l01077"></a>01077 
<a name="l01078"></a><a class="code" href="gpfs_8h.html#a3b1c870db958c2e87cbdbc43562b4a6e">01078</a> <span class="preprocessor">#define STATFSPOOL_USAGE_DATA      0x0001 </span><span class="comment">/* Pool stores user data */</span>
<a name="l01079"></a><a class="code" href="gpfs_8h.html#a29fd8b338b1469efe16348accbac1f97">01079</a> <span class="preprocessor">#define STATFSPOOL_USAGE_METADATA  0x0002 </span><span class="comment">/* Pool stores system metadata */</span>
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 <span class="comment">/* NAME:        gpfs_fstat(), gpfs_stat()</span>
<a name="l01083"></a>01083 <span class="comment"> *</span>
<a name="l01084"></a>01084 <span class="comment"> * FUNCTION:    Get exact stat information for a file descriptor (or filename).</span>
<a name="l01085"></a>01085 <span class="comment"> *              Forces all other nodes to flush dirty data and metadata to disk.</span>
<a name="l01086"></a>01086 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01087"></a>01087 <span class="comment"> *              -1      Failure</span>
<a name="l01088"></a>01088 <span class="comment"> *</span>
<a name="l01089"></a>01089 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l01090"></a>01090 <span class="comment"> *              EBADF   Bad file desc</span>
<a name="l01091"></a>01091 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01092"></a>01092 <span class="comment"> *              ESTALE  cached fs information was invalid</span>
<a name="l01093"></a>01093 <span class="comment"> */</span>
<a name="l01094"></a>01094 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01095"></a>01095 <a class="code" href="gpfs_8h.html#a467a400718559fd672d6e91a8a1d61c4">gpfs_fstat</a>(gpfs_file_t fileDesc,
<a name="l01096"></a>01096            <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a> *buffer);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01099"></a>01099 <a class="code" href="gpfs_8h.html#acbf11abb17966e1ae54561a0b6f12a3a">gpfs_stat</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname, <span class="comment">/* File pathname */</span>
<a name="l01100"></a>01100           <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a> *buffer);
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 <span class="comment">/* NAME:        gpfs_statfs64()</span>
<a name="l01103"></a>01103 <span class="comment"> *</span>
<a name="l01104"></a>01104 <span class="comment"> * FUNCTION:    Get information about the file system.</span>
<a name="l01105"></a>01105 <span class="comment"> *</span>
<a name="l01106"></a>01106 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01107"></a>01107 <span class="comment"> *              -1      Failure</span>
<a name="l01108"></a>01108 <span class="comment"> *</span>
<a name="l01109"></a>01109 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l01110"></a>01110 <span class="comment"> *              EBADF   Bad file desc</span>
<a name="l01111"></a>01111 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01112"></a>01112 <span class="comment"> *              ESTALE  cached fs information was invalid</span>
<a name="l01113"></a>01113 <span class="comment"> */</span>
<a name="l01114"></a>01114 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01115"></a>01115 <a class="code" href="gpfs_8h.html#a4746da0302b40ef89b13d50f19fafb53">gpfs_statfs64</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname, <span class="comment">/* File pathname */</span>
<a name="l01116"></a>01116               <a class="code" href="gpfs_8h.html#a585945966f328f4b19fd3142f9fc48b9">gpfs_statfs64_t</a> *buffer);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118 <span class="comment">/* NAME:        gpfs_statlite()</span>
<a name="l01119"></a>01119 <span class="comment"> *              gpfs_lstatlite() - do not follow a symlink at the end of the path</span>
<a name="l01120"></a>01120 <span class="comment"> *</span>
<a name="l01121"></a>01121 <span class="comment"> * FUNCTION:    Returns stat() information with specified accuracy</span>
<a name="l01122"></a>01122 <span class="comment"> *</span>
<a name="l01123"></a>01123 <span class="comment"> * Input:       pathname    : path to a file or directory</span>
<a name="l01124"></a>01124 <span class="comment"> *</span>
<a name="l01125"></a>01125 <span class="comment"> * In/Out:      st_litemaskP: bitmask specification of required accuracy</span>
<a name="l01126"></a>01126 <span class="comment"> *              statbufP    : buffer for returned stat information</span>
<a name="l01127"></a>01127 <span class="comment"> *</span>
<a name="l01128"></a>01128 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01129"></a>01129 <span class="comment"> *              -1      Failure</span>
<a name="l01130"></a>01130 <span class="comment"> *</span>
<a name="l01131"></a>01131 <span class="comment"> * Errno:       Specific error indication</span>
<a name="l01132"></a>01132 <span class="comment"> *              EINVAL</span>
<a name="l01133"></a>01133 <span class="comment"> *</span>
<a name="l01134"></a>01134 <span class="comment"> */</span>
<a name="l01135"></a>01135 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01136"></a>01136 <a class="code" href="gpfs_8h.html#af611bebaaf926aa795290c3821255160">gpfs_statlite</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l01137"></a>01137               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *st_litemaskP,
<a name="l01138"></a>01138               <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a> *statbufP);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01141"></a>01141 <a class="code" href="gpfs_8h.html#a84d70745a94aa50ef3129872b3e673b5">gpfs_lstatlite</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l01142"></a>01142                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *st_litemaskP,
<a name="l01143"></a>01143                <a class="code" href="gpfs_8h.html#a1ec34aeda6ce35f86cb41a72199299b5">gpfs_stat64_t</a> *statbufP);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="comment">/* NAME:        gpfs_fgetattrs()</span>
<a name="l01147"></a>01147 <span class="comment"> *</span>
<a name="l01148"></a>01148 <span class="comment"> * FUNCTION:    Retrieves all extended file attributes in opaque format.</span>
<a name="l01149"></a>01149 <span class="comment"> *              This function together with gpfs_fputattrs is intended for</span>
<a name="l01150"></a>01150 <span class="comment"> *              use by a backup program to save (gpfs_fgetattrs) and</span>
<a name="l01151"></a>01151 <span class="comment"> *              restore (gpfs_fputattrs) all extended file attributes</span>
<a name="l01152"></a>01152 <span class="comment"> *              (ACLs, user attributes, ...) in one call.</span>
<a name="l01153"></a>01153 <span class="comment"> *</span>
<a name="l01154"></a>01154 <span class="comment"> *              NOTE: This call does not return extended attributes used for</span>
<a name="l01155"></a>01155 <span class="comment"> *                    the Data Storage Management (XDSM) API (aka DMAPI).</span>
<a name="l01156"></a>01156 <span class="comment"> *</span>
<a name="l01157"></a>01157 <span class="comment"> * Input:       flags   Define behavior of get attributes</span>
<a name="l01158"></a>01158 <span class="comment"> *                GPFS_ATTRFLAG_NO_PLACEMENT - file attributes for placement</span>
<a name="l01159"></a>01159 <span class="comment"> *                      are not saved, neither is the current storage pool.</span>
<a name="l01160"></a>01160 <span class="comment"> *                GPFS_ATTRFLAG_IGNORE_POOL - file attributes for placement</span>
<a name="l01161"></a>01161 <span class="comment"> *                      are saved, but the current storage pool is not.</span>
<a name="l01162"></a>01162 <span class="comment"> *</span>
<a name="l01163"></a>01163 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01164"></a>01164 <span class="comment"> *              -1      Failure</span>
<a name="l01165"></a>01165 <span class="comment"> *</span>
<a name="l01166"></a>01166 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l01167"></a>01167 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01168"></a>01168 <span class="comment"> *              EINVAL  invalid flags provided</span>
<a name="l01169"></a>01169 <span class="comment"> *              ENOSPC  buffer too small to return all attributes</span>
<a name="l01170"></a>01170 <span class="comment"> *                      *attrSizeP will be set to the size necessary</span>
<a name="l01171"></a>01171 <span class="comment"> */</span>
<a name="l01172"></a>01172 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01173"></a>01173 <a class="code" href="gpfs_8h.html#a80c89e62ebbb11861be1927af6b264e9">gpfs_fgetattrs</a>(gpfs_file_t fileDesc,
<a name="l01174"></a>01174                <span class="keywordtype">int</span> flags,
<a name="l01175"></a>01175                <span class="keywordtype">void</span> *bufferP,
<a name="l01176"></a>01176                <span class="keywordtype">int</span> bufferSize,
<a name="l01177"></a>01177                <span class="keywordtype">int</span> *attrSizeP);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="comment">/* NAME:        gpfs_fputattrs()</span>
<a name="l01181"></a>01181 <span class="comment"> *</span>
<a name="l01182"></a>01182 <span class="comment"> * FUNCTION:    Sets all extended file attributes of a file</span>
<a name="l01183"></a>01183 <span class="comment"> *              and sets the file&#39;s storage pool and data replication</span>
<a name="l01184"></a>01184 <span class="comment"> *              to the values saved in the extended attributes.</span>
<a name="l01185"></a>01185 <span class="comment"> *</span>
<a name="l01186"></a>01186 <span class="comment"> *              If the saved storage pool is not valid or if the IGNORE_POOL</span>
<a name="l01187"></a>01187 <span class="comment"> *              flag is set, then it will select the storage pool by matching</span>
<a name="l01188"></a>01188 <span class="comment"> *              a PLACEMENT rule using the saved file attributes.</span>
<a name="l01189"></a>01189 <span class="comment"> *              If it fails to match a placement rule or if there are</span>
<a name="l01190"></a>01190 <span class="comment"> *              no placement rules installed it will assign the file</span>
<a name="l01191"></a>01191 <span class="comment"> *              to the &quot;system&quot; storage pool.</span>
<a name="l01192"></a>01192 <span class="comment"> *</span>
<a name="l01193"></a>01193 <span class="comment"> *              The buffer passed in should contain extended attribute data</span>
<a name="l01194"></a>01194 <span class="comment"> *              that was obtained by a previous call to gpfs_fgetattrs.</span>
<a name="l01195"></a>01195 <span class="comment"> *</span>
<a name="l01196"></a>01196 <span class="comment"> * Input:       flags   Define behavior of put attributes</span>
<a name="l01197"></a>01197 <span class="comment"> *                GPFS_ATTRFLAG_NO_PLACEMENT - file attributes are restored</span>
<a name="l01198"></a>01198 <span class="comment"> *                      but the storage pool and data replication are unchanged</span>
<a name="l01199"></a>01199 <span class="comment"> *                GPFS_ATTRFLAG_IGNORE_POOL - file attributes are restored</span>
<a name="l01200"></a>01200 <span class="comment"> *                      but the storage pool and data replication are selected</span>
<a name="l01201"></a>01201 <span class="comment"> *                      by matching the saved attributes to a placement rule</span>
<a name="l01202"></a>01202 <span class="comment"> *                      instead of restoring the saved storage pool.</span>
<a name="l01203"></a>01203 <span class="comment"> *</span>
<a name="l01204"></a>01204 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01205"></a>01205 <span class="comment"> *              -1      Failure</span>
<a name="l01206"></a>01206 <span class="comment"> *</span>
<a name="l01207"></a>01207 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l01208"></a>01208 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01209"></a>01209 <span class="comment"> *              EINVAL  the buffer does not contain valid attribute data</span>
<a name="l01210"></a>01210 <span class="comment"> *              EINVAL  invalid flags provided</span>
<a name="l01211"></a>01211 <span class="comment"> */</span>
<a name="l01212"></a>01212 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01213"></a>01213 <a class="code" href="gpfs_8h.html#a2ca43fb2b663b7ea7cf9a9a9f5e0e006">gpfs_fputattrs</a>(gpfs_file_t fileDesc,
<a name="l01214"></a>01214                <span class="keywordtype">int</span> flags,
<a name="l01215"></a>01215                <span class="keywordtype">void</span> *bufferP);
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment">/* NAME:        gpfs_fputattrswithpathname()</span>
<a name="l01219"></a>01219 <span class="comment"> *</span>
<a name="l01220"></a>01220 <span class="comment"> * FUNCTION:    Sets all extended file attributes of a file and invokes</span>
<a name="l01221"></a>01221 <span class="comment"> *              the policy engine to match a RESTORE rule using the file&#39;s</span>
<a name="l01222"></a>01222 <span class="comment"> *              attributes saved in the extended attributes to set the</span>
<a name="l01223"></a>01223 <span class="comment"> *              file&#39;s storage pool and data replication. The caller should</span>
<a name="l01224"></a>01224 <span class="comment"> *              include the full path to the file, including the file name,</span>
<a name="l01225"></a>01225 <span class="comment"> *              to allow rule selection based on file name or path.</span>
<a name="l01226"></a>01226 <span class="comment"> *</span>
<a name="l01227"></a>01227 <span class="comment"> *              If the file fails to match a RESTORE rule, or if there are</span>
<a name="l01228"></a>01228 <span class="comment"> *              no RESTORE rules installed, then the storage pool and data</span>
<a name="l01229"></a>01229 <span class="comment"> *              replication are selected as when calling gpfs_fputattrs().</span>
<a name="l01230"></a>01230 <span class="comment"> *</span>
<a name="l01231"></a>01231 <span class="comment"> *              The buffer passed in should contain extended attribute data</span>
<a name="l01232"></a>01232 <span class="comment"> *              that was obtained by a previous call to gpfs_fgetattrs.</span>
<a name="l01233"></a>01233 <span class="comment"> *</span>
<a name="l01234"></a>01234 <span class="comment"> *              pathName is a UTF-8 encoded string. On Windows, applications</span>
<a name="l01235"></a>01235 <span class="comment"> *              can convert UTF-16 (&quot;Unicode&quot;) to UTF-8 using the platforms</span>
<a name="l01236"></a>01236 <span class="comment"> *              WideCharToMultiByte function.</span>
<a name="l01237"></a>01237 <span class="comment"> *</span>
<a name="l01238"></a>01238 <span class="comment"> *</span>
<a name="l01239"></a>01239 <span class="comment"> * Input:       flags   Define behavior of put attributes</span>
<a name="l01240"></a>01240 <span class="comment"> *                GPFS_ATTRFLAG_NO_PLACEMENT - file attributes are restored</span>
<a name="l01241"></a>01241 <span class="comment"> *                      but the storage pool and data replication are unchanged</span>
<a name="l01242"></a>01242 <span class="comment"> *                GPFS_ATTRFLAG_IGNORE_POOL - file attributes are restored</span>
<a name="l01243"></a>01243 <span class="comment"> *                      but if the file fails to match a RESTORE rule, it</span>
<a name="l01244"></a>01244 <span class="comment"> *                      ignore the saved storage pool and select a pool</span>
<a name="l01245"></a>01245 <span class="comment"> *                      by matching the saved attributes to a PLACEMENT rule.</span>
<a name="l01246"></a>01246 <span class="comment"> *                GPFS_ATTRFLAG_SKIP_IMMUTABLE - Skip immutable/appendOnly flags</span>
<a name="l01247"></a>01247 <span class="comment"> *                      before restoring file data. Then use GPFS_ATTRFLAG_FINALIZE_ATTRS</span>
<a name="l01248"></a>01248 <span class="comment"> *                      to restore immutable/appendOnly flags after data is restored.</span>
<a name="l01249"></a>01249 <span class="comment"> *                GPFS_ATTRFLAG_FINALIZE_ATTRS - file attributes that are restored</span>
<a name="l01250"></a>01250 <span class="comment"> *                      after data is retored. If file is immutable/appendOnly</span>
<a name="l01251"></a>01251 <span class="comment"> *                      call without this flag before restoring data</span>
<a name="l01252"></a>01252 <span class="comment"> *                      then call with this flag after restoring data</span>
<a name="l01253"></a>01253 <span class="comment"> *</span>
<a name="l01254"></a>01254 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01255"></a>01255 <span class="comment"> *              -1      Failure</span>
<a name="l01256"></a>01256 <span class="comment"> *</span>
<a name="l01257"></a>01257 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l01258"></a>01258 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01259"></a>01259 <span class="comment"> *              EINVAL  the buffer does not contain valid attribute data</span>
<a name="l01260"></a>01260 <span class="comment"> *              ENOENT  invalid pathname</span>
<a name="l01261"></a>01261 <span class="comment"> *              EINVAL  invalid flags provided</span>
<a name="l01262"></a>01262 <span class="comment"> */</span>
<a name="l01263"></a>01263 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01264"></a>01264 <a class="code" href="gpfs_8h.html#ae15ce939e037b6dd45b1671304ef5aef">gpfs_fputattrswithpathname</a>(gpfs_file_t fileDesc,
<a name="l01265"></a>01265                            <span class="keywordtype">int</span> flags,
<a name="l01266"></a>01266                            <span class="keywordtype">void</span> *bufferP,
<a name="l01267"></a>01267                            <span class="keyword">const</span> <span class="keywordtype">char</span> *pathName);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269 
<a name="l01270"></a>01270 <span class="comment">/* NAME:        gpfs_get_fssnaphandle_by_path()</span>
<a name="l01271"></a>01271 <span class="comment"> *</span>
<a name="l01272"></a>01272 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify a filesystem</span>
<a name="l01273"></a>01273 <span class="comment"> *              and snapshot by the path to the file system and snapshot</span>
<a name="l01274"></a>01274 <span class="comment"> *</span>
<a name="l01275"></a>01275 <span class="comment"> * Input:       pathName: path to a file or directory in a gpfs file system</span>
<a name="l01276"></a>01276 <span class="comment"> *                        or to one of its snapshots</span>
<a name="l01277"></a>01277 <span class="comment"> *</span>
<a name="l01278"></a>01278 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01279"></a>01279 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01280"></a>01280 <span class="comment"> *</span>
<a name="l01281"></a>01281 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01282"></a>01282 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01283"></a>01283 <span class="comment"> *              ENOENT invalid pathname</span>
<a name="l01284"></a>01284 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01285"></a>01285 <span class="comment"> */</span>
<a name="l01286"></a>01286 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01287"></a>01287 <a class="code" href="gpfs_8h.html#aa2715ccc64b204448e138d53c6a10880">gpfs_get_fssnaphandle_by_path</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathName);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 
<a name="l01290"></a>01290 <span class="comment">/* NAME:        gpfs_get_fssnaphandle_by_name()</span>
<a name="l01291"></a>01291 <span class="comment"> *</span>
<a name="l01292"></a>01292 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify a filesystem</span>
<a name="l01293"></a>01293 <span class="comment"> *              and snapshot by the file system name and snapshot name.</span>
<a name="l01294"></a>01294 <span class="comment"> *</span>
<a name="l01295"></a>01295 <span class="comment"> * Input:       fsName: unique name for gpfs file system (may be specified</span>
<a name="l01296"></a>01296 <span class="comment"> *                      as fsName or /dev/fsName)</span>
<a name="l01297"></a>01297 <span class="comment"> *              snapName: name for snapshot within that file system</span>
<a name="l01298"></a>01298 <span class="comment"> *                        or NULL to access the active file system rather</span>
<a name="l01299"></a>01299 <span class="comment"> *                        than a snapshot within the file system.</span>
<a name="l01300"></a>01300 <span class="comment"> *</span>
<a name="l01301"></a>01301 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01302"></a>01302 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01303"></a>01303 <span class="comment"> *</span>
<a name="l01304"></a>01304 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01305"></a>01305 <span class="comment"> *              ENOENT invalid file system name</span>
<a name="l01306"></a>01306 <span class="comment"> *              GPFS_E_INVAL_SNAPNAME invalid snapshot name</span>
<a name="l01307"></a>01307 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01308"></a>01308 <span class="comment"> */</span>
<a name="l01309"></a>01309 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01310"></a>01310 <a class="code" href="gpfs_8h.html#a245bb3497ab2fc942898eaa6964775bf">gpfs_get_fssnaphandle_by_name</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fsName,
<a name="l01311"></a>01311                               <span class="keyword">const</span> <span class="keywordtype">char</span> *snapName);
<a name="l01312"></a>01312 
<a name="l01313"></a>01313 
<a name="l01314"></a>01314 <span class="comment">/* NAME:        gpfs_get_fssnaphandle_by_fssnapid()</span>
<a name="l01315"></a>01315 <span class="comment"> *</span>
<a name="l01316"></a>01316 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify a filesystem</span>
<a name="l01317"></a>01317 <span class="comment"> *              and snapshot by a fssnapId created from a previous handle.</span>
<a name="l01318"></a>01318 <span class="comment"> *</span>
<a name="l01319"></a>01319 <span class="comment"> * Input:       fssnapId: unique id for a file system and snapshot</span>
<a name="l01320"></a>01320 <span class="comment"> *</span>
<a name="l01321"></a>01321 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01322"></a>01322 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01323"></a>01323 <span class="comment"> *</span>
<a name="l01324"></a>01324 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01325"></a>01325 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID invalid snapshot id</span>
<a name="l01326"></a>01326 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01327"></a>01327 <span class="comment"> */</span>
<a name="l01328"></a>01328 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01329"></a>01329 <a class="code" href="gpfs_8h.html#a54efa2c2ab54421a9986d31685b9714b">gpfs_get_fssnaphandle_by_fssnapid</a>(<span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fssnapId);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="comment">/* NAME:        gpfs_get_fset_snaphandle_by_path()</span>
<a name="l01332"></a>01332 <span class="comment"> *</span>
<a name="l01333"></a>01333 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify an inode space within a</span>
<a name="l01334"></a>01334 <span class="comment"> *              filesyetsm and snapshot by the path to the file system and snapshot.</span>
<a name="l01335"></a>01335 <span class="comment"> *</span>
<a name="l01336"></a>01336 <span class="comment"> * Input:       pathName: path to a file or directory in a gpfs file system</span>
<a name="l01337"></a>01337 <span class="comment"> *                        or to one of its snapshots</span>
<a name="l01338"></a>01338 <span class="comment"> *</span>
<a name="l01339"></a>01339 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01340"></a>01340 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01341"></a>01341 <span class="comment"> *</span>
<a name="l01342"></a>01342 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01343"></a>01343 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l01344"></a>01344 <span class="comment"> *              ENOENT invalid pathname</span>
<a name="l01345"></a>01345 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01346"></a>01346 <span class="comment"> */</span>
<a name="l01347"></a>01347 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01348"></a>01348 <a class="code" href="gpfs_8h.html#a6d09941891f9f652e9bbff82baa9e42d">gpfs_get_fset_snaphandle_by_path</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathName);
<a name="l01349"></a>01349 
<a name="l01350"></a>01350 <span class="comment">/* NAME:        gpfs_get_fset_snaphandle_by_name()</span>
<a name="l01351"></a>01351 <span class="comment"> *</span>
<a name="l01352"></a>01352 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify an inode space within a</span>
<a name="l01353"></a>01353 <span class="comment"> *              filesystem and snapshot by the independent fileset name, file system</span>
<a name="l01354"></a>01354 <span class="comment"> *              name and snapshot name.</span>
<a name="l01355"></a>01355 <span class="comment"> *</span>
<a name="l01356"></a>01356 <span class="comment"> * Input:       fsName: unique name for gpfs file system (may be specified</span>
<a name="l01357"></a>01357 <span class="comment"> *                      as fsName or /dev/fsName)</span>
<a name="l01358"></a>01358 <span class="comment"> *              fsetName name of the independent fileset that owns the inode space</span>
<a name="l01359"></a>01359 <span class="comment"> *              snapName: name for snapshot within that file system</span>
<a name="l01360"></a>01360 <span class="comment"> *                        or NULL to access the active file system rather</span>
<a name="l01361"></a>01361 <span class="comment"> *                        than a snapshot within the file system.</span>
<a name="l01362"></a>01362 <span class="comment"> *</span>
<a name="l01363"></a>01363 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01364"></a>01364 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01365"></a>01365 <span class="comment"> *</span>
<a name="l01366"></a>01366 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01367"></a>01367 <span class="comment"> *              ENOENT invalid file system name</span>
<a name="l01368"></a>01368 <span class="comment"> *              GPFS_E_INVAL_FSETNAME invalid fset nsmae</span>
<a name="l01369"></a>01369 <span class="comment"> *              GPFS_E_INVAL_SNAPNAME invalid snapshot name</span>
<a name="l01370"></a>01370 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01371"></a>01371 <span class="comment"> */</span>
<a name="l01372"></a>01372 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01373"></a>01373 <a class="code" href="gpfs_8h.html#a5263096ad9a85e76d92194bd11e718c0">gpfs_get_fset_snaphandle_by_name</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fsName,
<a name="l01374"></a>01374                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *fsetName,
<a name="l01375"></a>01375                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *snapName);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377 <span class="comment">/* NAME:        gpfs_get_fset_snaphandle_by_fset_snapid()</span>
<a name="l01378"></a>01378 <span class="comment"> *</span>
<a name="l01379"></a>01379 <span class="comment"> * FUNCTION:    Get a volatile handle to uniquely identify a filesystem</span>
<a name="l01380"></a>01380 <span class="comment"> *              and snapshot by a fssnapId created from a previous handle.</span>
<a name="l01381"></a>01381 <span class="comment"> *</span>
<a name="l01382"></a>01382 <span class="comment"> * Input:       fssnapId: unique id for a file system and snapshot</span>
<a name="l01383"></a>01383 <span class="comment"> *</span>
<a name="l01384"></a>01384 <span class="comment"> * Returns:     pointer to gpfs_fssnap_handle_t (Successful)</span>
<a name="l01385"></a>01385 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01386"></a>01386 <span class="comment"> *</span>
<a name="l01387"></a>01387 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01388"></a>01388 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID invalid snapshot id</span>
<a name="l01389"></a>01389 <span class="comment"> *              see system calls open(), fstatfs(), and malloc() ERRORS</span>
<a name="l01390"></a>01390 <span class="comment"> */</span>
<a name="l01391"></a>01391 <a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01392"></a>01392 <a class="code" href="gpfs_8h.html#aa5a5c8365e492dfb07a052dcd6b95772">gpfs_get_fset_snaphandle_by_fset_snapid</a>(<span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fsetsnapId);
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="comment">/* NAME:        gpfs_get_pathname_from_fssnaphandle()</span>
<a name="l01395"></a>01395 <span class="comment"> *</span>
<a name="l01396"></a>01396 <span class="comment"> * FUNCTION:    Get the mountpoint and path to a file system</span>
<a name="l01397"></a>01397 <span class="comment"> *              and snapshot identified by a fssnapHandle</span>
<a name="l01398"></a>01398 <span class="comment"> *</span>
<a name="l01399"></a>01399 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01400"></a>01400 <span class="comment"> *</span>
<a name="l01401"></a>01401 <span class="comment"> * Returns:     ptr to path name to the file system  (Successful)</span>
<a name="l01402"></a>01402 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01403"></a>01403 <span class="comment"> *</span>
<a name="l01404"></a>01404 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01405"></a>01405 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnapHandle</span>
<a name="l01406"></a>01406 <span class="comment"> */</span>
<a name="l01407"></a>01407 <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01408"></a>01408 <a class="code" href="gpfs_8h.html#ab38c0e64ccb1ab8f20d04b9bdab43045">gpfs_get_pathname_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="comment">/* NAME:        gpfs_get_fsname_from_fssnaphandle()</span>
<a name="l01412"></a>01412 <span class="comment"> *</span>
<a name="l01413"></a>01413 <span class="comment"> * FUNCTION:    Get the unique name for the file system</span>
<a name="l01414"></a>01414 <span class="comment"> *              identified by a fssnapHandle</span>
<a name="l01415"></a>01415 <span class="comment"> *</span>
<a name="l01416"></a>01416 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01417"></a>01417 <span class="comment"> *</span>
<a name="l01418"></a>01418 <span class="comment"> * Returns:     ptr to name of the file system  (Successful)</span>
<a name="l01419"></a>01419 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01420"></a>01420 <span class="comment"> *</span>
<a name="l01421"></a>01421 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01422"></a>01422 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnapHandle</span>
<a name="l01423"></a>01423 <span class="comment"> */</span>
<a name="l01424"></a>01424 <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01425"></a>01425 <a class="code" href="gpfs_8h.html#a79616e1014ded9ecc66cdfadb6dbf279">gpfs_get_fsname_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="comment">/* NAME:        gpfs_get_snapname_from_fssnaphandle()</span>
<a name="l01429"></a>01429 <span class="comment"> *</span>
<a name="l01430"></a>01430 <span class="comment"> * FUNCTION:    Get the name for the snapshot</span>
<a name="l01431"></a>01431 <span class="comment"> *              uniquely identified by a fssnapHandle</span>
<a name="l01432"></a>01432 <span class="comment"> *</span>
<a name="l01433"></a>01433 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01434"></a>01434 <span class="comment"> *</span>
<a name="l01435"></a>01435 <span class="comment"> * Returns:     ptr to name assigned to the snapshot (Successful)</span>
<a name="l01436"></a>01436 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01437"></a>01437 <span class="comment"> *</span>
<a name="l01438"></a>01438 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01439"></a>01439 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnaphandle</span>
<a name="l01440"></a>01440 <span class="comment"> *              GPFS_E_INVAL_SNAPNAME snapshot has been deleted</span>
<a name="l01441"></a>01441 <span class="comment"> *</span>
<a name="l01442"></a>01442 <span class="comment"> * Notes:       If the snapshot has been deleted from the file system</span>
<a name="l01443"></a>01443 <span class="comment"> *              the snapId may still be valid, but the call will fail</span>
<a name="l01444"></a>01444 <span class="comment"> *              with errno set to GPFS_E_INVAL_SNAPNAME.</span>
<a name="l01445"></a>01445 <span class="comment"> */</span>
<a name="l01446"></a>01446 <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01447"></a>01447 <a class="code" href="gpfs_8h.html#a96afcfcca3fef16604ef5bdfd4ebd182">gpfs_get_snapname_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="comment">/* NAME:        gpfs_get_snapid_from_fssnaphandle()</span>
<a name="l01451"></a>01451 <span class="comment"> *</span>
<a name="l01452"></a>01452 <span class="comment"> * FUNCTION:    Get the numeric id for the snapshot identified</span>
<a name="l01453"></a>01453 <span class="comment"> *              by a fssnapHandle. The snapshots define an ordered</span>
<a name="l01454"></a>01454 <span class="comment"> *              sequence of changes to each file. The file&#39;s iattr</span>
<a name="l01455"></a>01455 <span class="comment"> *              structure defines the snapshot id in which the file</span>
<a name="l01456"></a>01456 <span class="comment"> *              was last modified (ia_modsnapid). This numeric value</span>
<a name="l01457"></a>01457 <span class="comment"> *              can be compared to the numeric snapid from a fssnaphandle</span>
<a name="l01458"></a>01458 <span class="comment"> *              to determine if the file changed before or after the</span>
<a name="l01459"></a>01459 <span class="comment"> *              snapshot identified by the fssnaphandle.</span>
<a name="l01460"></a>01460 <span class="comment"> *</span>
<a name="l01461"></a>01461 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01462"></a>01462 <span class="comment"> *</span>
<a name="l01463"></a>01463 <span class="comment"> * Returns:     Numeric id for the snapshot referred to by the fssnaphandle</span>
<a name="l01464"></a>01464 <span class="comment"> *              0 if the fssnaphandle does not refer to a snapshot</span>
<a name="l01465"></a>01465 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01466"></a>01466 <span class="comment"> *</span>
<a name="l01467"></a>01467 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01468"></a>01468 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnaphandle</span>
<a name="l01469"></a>01469 <span class="comment"> *</span>
<a name="l01470"></a>01470 <span class="comment"> * Notes:       The snapshot need not be on-line to determine the</span>
<a name="l01471"></a>01471 <span class="comment"> *              snapshot&#39;s numeric id.</span>
<a name="l01472"></a>01472 <span class="comment"> */</span>
<a name="l01473"></a>01473 gpfs_snapid_t <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01474"></a>01474 <a class="code" href="gpfs_8h.html#add79269badf3dd875f8f2a9ddfd1b4d6">gpfs_get_snapid_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 gpfs_snapid64_t <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01477"></a>01477 <a class="code" href="gpfs_8h.html#ac51184bf2b45bd50fcd1616d34682bcc">gpfs_get_snapid_from_fssnaphandle64</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="comment">/* NAME:        gpfs_get_fssnapid_from_fssnaphandle()</span>
<a name="l01481"></a>01481 <span class="comment"> *</span>
<a name="l01482"></a>01482 <span class="comment"> * FUNCTION:    Get a unique, non-volatile file system and snapshot id</span>
<a name="l01483"></a>01483 <span class="comment"> *              for the file system and snapshot identified by a</span>
<a name="l01484"></a>01484 <span class="comment"> *              volatile fssnap handle.</span>
<a name="l01485"></a>01485 <span class="comment"> *</span>
<a name="l01486"></a>01486 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01487"></a>01487 <span class="comment"> *              fssnapId: returned fssnapId uniquely identifying the</span>
<a name="l01488"></a>01488 <span class="comment"> *                        file system and snapshot being scanned</span>
<a name="l01489"></a>01489 <span class="comment"> *</span>
<a name="l01490"></a>01490 <span class="comment"> * Returns:     0 and fssnapId is set with id (Successful)</span>
<a name="l01491"></a>01491 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01492"></a>01492 <span class="comment"> *</span>
<a name="l01493"></a>01493 <span class="comment"> * Errno:       GPFS_E_INVAL_FSSNAPHANDLE invalid fssnaphandle</span>
<a name="l01494"></a>01494 <span class="comment"> *              EINVAL null ptr given for returned fssnapId</span>
<a name="l01495"></a>01495 <span class="comment"> *              EFAULT size mismatch for fssnapId</span>
<a name="l01496"></a>01496 <span class="comment"> */</span>
<a name="l01497"></a>01497 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01498"></a>01498 <a class="code" href="gpfs_8h.html#ac50d66de2fb053a4600bee23625d7ad8">gpfs_get_fssnapid_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01499"></a>01499                                     <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fssnapId);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="comment">/* NAME:        gpfs_get_restore_fssnapid_from_fssnaphandle()</span>
<a name="l01503"></a>01503 <span class="comment"> *</span>
<a name="l01504"></a>01504 <span class="comment"> * FUNCTION:    Get the unique, non-volatile file system and snapshot id</span>
<a name="l01505"></a>01505 <span class="comment"> *              used for the last complete restore of a mirrored file</span>
<a name="l01506"></a>01506 <span class="comment"> *              system. The file system must been a previous restore</span>
<a name="l01507"></a>01507 <span class="comment"> *              target and ready for additional incremental restore.</span>
<a name="l01508"></a>01508 <span class="comment"> *</span>
<a name="l01509"></a>01509 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01510"></a>01510 <span class="comment"> *              fssnapId: returned fssnapId uniquely identifying the</span>
<a name="l01511"></a>01511 <span class="comment"> *                        last complete restored file system.</span>
<a name="l01512"></a>01512 <span class="comment"> *</span>
<a name="l01513"></a>01513 <span class="comment"> * Returns:     0 and fssnapId is set with id (Successful)</span>
<a name="l01514"></a>01514 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01515"></a>01515 <span class="comment"> *</span>
<a name="l01516"></a>01516 <span class="comment"> * Errno:       GPFS_E_INVAL_FSSNAPHANDLE invalid fssnaphandle</span>
<a name="l01517"></a>01517 <span class="comment"> *              EINVAL null ptr given for returned fssnapId</span>
<a name="l01518"></a>01518 <span class="comment"> *              EFAULT size mismatch for fssnapId</span>
<a name="l01519"></a>01519 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01520"></a>01520 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l01521"></a>01521 <span class="comment"> *              GPFS_E_FS_NOT_RESTORABLE fs is not clean for restore</span>
<a name="l01522"></a>01522 <span class="comment"> */</span>
<a name="l01523"></a>01523 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01524"></a>01524 <a class="code" href="gpfs_8h.html#a149120a0298ea5648b0e93d386b92dd8">gpfs_get_restore_fssnapid_from_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01525"></a>01525                                             <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fssnapId);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 <span class="comment">/* NAME:        gpfs_free_fssnaphandle()</span>
<a name="l01528"></a>01528 <span class="comment"> *</span>
<a name="l01529"></a>01529 <span class="comment"> * FUNCTION:    Free a fssnapHandle</span>
<a name="l01530"></a>01530 <span class="comment"> *</span>
<a name="l01531"></a>01531 <span class="comment"> * Input:       fssnapHandle: ptr to file system &amp; snapshot handle</span>
<a name="l01532"></a>01532 <span class="comment"> *</span>
<a name="l01533"></a>01533 <span class="comment"> * Returns:     void</span>
<a name="l01534"></a>01534 <span class="comment"> *</span>
<a name="l01535"></a>01535 <span class="comment"> * Errno:       None</span>
<a name="l01536"></a>01536 <span class="comment"> */</span>
<a name="l01537"></a>01537 <span class="keywordtype">void</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01538"></a>01538 <a class="code" href="gpfs_8h.html#a10ed67b1e0afc0e367e54edc4bf17a8a">gpfs_free_fssnaphandle</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="comment">/* NAME:        gpfs_get_snapdirname()</span>
<a name="l01541"></a>01541 <span class="comment"> *</span>
<a name="l01542"></a>01542 <span class="comment"> * FUNCTION:    Get the name of the directory containing snapshots.</span>
<a name="l01543"></a>01543 <span class="comment"> *</span>
<a name="l01544"></a>01544 <span class="comment"> * Input:       fssnapHandle: handle for the file system</span>
<a name="l01545"></a>01545 <span class="comment"> *              snapdirName: buffer into which the name of the snapshot</span>
<a name="l01546"></a>01546 <span class="comment"> *                directory will be copied</span>
<a name="l01547"></a>01547 <span class="comment"> *              bufLen: the size of the provided buffer</span>
<a name="l01548"></a>01548 <span class="comment"> *</span>
<a name="l01549"></a>01549 <span class="comment"> * Returns:     0 (Successful)</span>
<a name="l01550"></a>01550 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01551"></a>01551 <span class="comment"> *</span>
<a name="l01552"></a>01552 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01553"></a>01553 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01554"></a>01554 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01555"></a>01555 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l01556"></a>01556 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE fssnapHandle is invalid</span>
<a name="l01557"></a>01557 <span class="comment"> *              E2BIG buffer too small to return the snapshot directory name</span>
<a name="l01558"></a>01558 <span class="comment"> */</span>
<a name="l01559"></a>01559 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01560"></a>01560 <a class="code" href="gpfs_8h.html#ac2f48e5242761745e2eaa29c80168c3d">gpfs_get_snapdirname</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01561"></a>01561                      <span class="keywordtype">char</span> *snapdirName,
<a name="l01562"></a>01562                      <span class="keywordtype">int</span> bufLen);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 
<a name="l01565"></a>01565 <span class="comment">/* NAME:        gpfs_open_inodescan()</span>
<a name="l01566"></a>01566 <span class="comment"> *</span>
<a name="l01567"></a>01567 <span class="comment"> * FUNCTION:    Open inode file for inode scan.</span>
<a name="l01568"></a>01568 <span class="comment"> *</span>
<a name="l01569"></a>01569 <span class="comment"> * Input:       fssnapHandle: handle for file system and snapshot</span>
<a name="l01570"></a>01570 <span class="comment"> *                            to be scanned</span>
<a name="l01571"></a>01571 <span class="comment"> *              prev_fssnapId: if NULL, all inodes of existing file will</span>
<a name="l01572"></a>01572 <span class="comment"> *                be returned; if non-null, only returns inodes of files</span>
<a name="l01573"></a>01573 <span class="comment"> *                that have changed since the specified previous snapshot</span>
<a name="l01574"></a>01574 <span class="comment"> *              maxIno: if non-null, returns the maximum inode number</span>
<a name="l01575"></a>01575 <span class="comment"> *                available in the inode file being scanned.</span>
<a name="l01576"></a>01576 <span class="comment"> *</span>
<a name="l01577"></a>01577 <span class="comment"> * Returns:     pointer to gpfs_iscan_t (Successful)</span>
<a name="l01578"></a>01578 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01579"></a>01579 <span class="comment"> *</span>
<a name="l01580"></a>01580 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01581"></a>01581 <span class="comment"> *              EINVAL bad parameters</span>
<a name="l01582"></a>01582 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01583"></a>01583 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01584"></a>01584 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l01585"></a>01585 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE fssnapHandle is invalid</span>
<a name="l01586"></a>01586 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID prev_fssnapId is invalid</span>
<a name="l01587"></a>01587 <span class="comment"> *              EDOM prev_fssnapId is from a different fs</span>
<a name="l01588"></a>01588 <span class="comment"> *              ERANGE prev_fssnapId is same as or more recent than snapId</span>
<a name="l01589"></a>01589 <span class="comment"> *                     being scanned</span>
<a name="l01590"></a>01590 <span class="comment"> *              see system calls dup() and malloc() ERRORS</span>
<a name="l01591"></a>01591 <span class="comment"> */</span>
<a name="l01592"></a>01592 <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01593"></a>01593 <a class="code" href="gpfs_8h.html#a1587b9de78a8c05ff68c7e908e88a844">gpfs_open_inodescan</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01594"></a>01594                     <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *prev_fssnapId,
<a name="l01595"></a>01595                     gpfs_ino_t *maxIno);
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01598"></a>01598 <a class="code" href="gpfs_8h.html#a1dfa12042b906651af8b255c0cb3bb14">gpfs_open_inodescan64</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01599"></a>01599                       <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *prev_fssnapId,
<a name="l01600"></a>01600                       gpfs_ino64_t *maxIno);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 <span class="comment">/* NAME:        gpfs_open_inodescan_with_xattrs()</span>
<a name="l01604"></a>01604 <span class="comment"> *</span>
<a name="l01605"></a>01605 <span class="comment"> * FUNCTION:    Open inode file and extended attributes for an inode scan</span>
<a name="l01606"></a>01606 <span class="comment"> *</span>
<a name="l01607"></a>01607 <span class="comment"> * Input:       fssnapHandle: handle for file system and snapshot</span>
<a name="l01608"></a>01608 <span class="comment"> *                            to be scanned</span>
<a name="l01609"></a>01609 <span class="comment"> *              prev_fssnapId: if NULL, all inodes of existing file will</span>
<a name="l01610"></a>01610 <span class="comment"> *                be returned; if non-null, only returns inodes of files</span>
<a name="l01611"></a>01611 <span class="comment"> *                that have changed since the specified previous snapshot</span>
<a name="l01612"></a>01612 <span class="comment"> *              nxAttrs: count of extended attributes to be returned.</span>
<a name="l01613"></a>01613 <span class="comment"> *                if nxAttrs is set to 0, call returns no extended</span>
<a name="l01614"></a>01614 <span class="comment"> *                attributes, like gpfs_open_inodescan.</span>
<a name="l01615"></a>01615 <span class="comment"> *                if nxAttrs is set to -1, call returns all extended attributes</span>
<a name="l01616"></a>01616 <span class="comment"> *              xAttrList: pointer to array of pointers to names of extended</span>
<a name="l01617"></a>01617 <span class="comment"> *                attribute to be returned. nxAttrList may be null if nxAttrs</span>
<a name="l01618"></a>01618 <span class="comment"> *                is set to 0 or -1.</span>
<a name="l01619"></a>01619 <span class="comment"> *              maxIno: if non-null, returns the maximum inode number</span>
<a name="l01620"></a>01620 <span class="comment"> *                available in the inode file being scanned.</span>
<a name="l01621"></a>01621 <span class="comment"> *</span>
<a name="l01622"></a>01622 <span class="comment"> * Returns:     pointer to gpfs_iscan_t (Successful)</span>
<a name="l01623"></a>01623 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01624"></a>01624 <span class="comment"> *</span>
<a name="l01625"></a>01625 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01626"></a>01626 <span class="comment"> *              EINVAL bad parameters</span>
<a name="l01627"></a>01627 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01628"></a>01628 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01629"></a>01629 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l01630"></a>01630 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE fssnapHandle is invalid</span>
<a name="l01631"></a>01631 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID prev_fssnapId is invalid</span>
<a name="l01632"></a>01632 <span class="comment"> *              EDOM prev_fssnapId is from a different fs</span>
<a name="l01633"></a>01633 <span class="comment"> *              ERANGE prev_fssnapId is same as or more recent than snapId</span>
<a name="l01634"></a>01634 <span class="comment"> *                     being scanned</span>
<a name="l01635"></a>01635 <span class="comment"> *              see system calls dup() and malloc() ERRORS</span>
<a name="l01636"></a>01636 <span class="comment"> */</span>
<a name="l01637"></a>01637 <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01638"></a>01638 <a class="code" href="gpfs_8h.html#a5945a9c47268451f876fc154614def96">gpfs_open_inodescan_with_xattrs</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01639"></a>01639                                 <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *prev_fssnapId,
<a name="l01640"></a>01640                                 <span class="keywordtype">int</span> nxAttrs,
<a name="l01641"></a>01641                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *xattrsList[],
<a name="l01642"></a>01642                                 gpfs_ino_t *maxIno);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01645"></a>01645 <a class="code" href="gpfs_8h.html#a39aed6528328a1f266befc666c91b9d0">gpfs_open_inodescan_with_xattrs64</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01646"></a>01646                                   <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *prev_fssnapId,
<a name="l01647"></a>01647                                   <span class="keywordtype">int</span> nxAttrs,
<a name="l01648"></a>01648                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *xattrList[],
<a name="l01649"></a>01649                                   gpfs_ino64_t *maxIno);
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 <span class="comment">/* NAME:        gpfs_next_inode()</span>
<a name="l01653"></a>01653 <span class="comment"> *</span>
<a name="l01654"></a>01654 <span class="comment"> * FUNCTION:    Get next inode from inode scan. Scan terminates before</span>
<a name="l01655"></a>01655 <span class="comment"> *              the last inode specified or the last inode in the</span>
<a name="l01656"></a>01656 <span class="comment"> *              inode file being scanned.</span>
<a name="l01657"></a>01657 <span class="comment"> *</span>
<a name="l01658"></a>01658 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01659"></a>01659 <span class="comment"> *              termIno: scan terminates before this inode number</span>
<a name="l01660"></a>01660 <span class="comment"> *                caller may specify maxIno from gpfs_open_inodescan()</span>
<a name="l01661"></a>01661 <span class="comment"> *                or 0 to scan the entire inode file.</span>
<a name="l01662"></a>01662 <span class="comment"> *              iattr: pointer to returned pointer to file&#39;s iattr.</span>
<a name="l01663"></a>01663 <span class="comment"> *</span>
<a name="l01664"></a>01664 <span class="comment"> * Returns:     0 and *iattr set to point to gpfs_iattr_t (Successful)</span>
<a name="l01665"></a>01665 <span class="comment"> *              0 and *iattr set to NULL for no more inodes before termIno</span>
<a name="l01666"></a>01666 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01667"></a>01667 <span class="comment"> *</span>
<a name="l01668"></a>01668 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01669"></a>01669 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01670"></a>01670 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01671"></a>01671 <span class="comment"> *              ENOMEM buffer too small</span>
<a name="l01672"></a>01672 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad parameters</span>
<a name="l01673"></a>01673 <span class="comment"> *</span>
<a name="l01674"></a>01674 <span class="comment"> * Notes:       The data returned by gpfs_next_inode() is overwritten by</span>
<a name="l01675"></a>01675 <span class="comment"> *              subsequent calls to gpfs_next_inode() or gpfs_seek_inode().</span>
<a name="l01676"></a>01676 <span class="comment"> *</span>
<a name="l01677"></a>01677 <span class="comment"> *              The termIno parameter provides a means to partition an</span>
<a name="l01678"></a>01678 <span class="comment"> *              inode scan such that it may be executed on more than one node.</span>
<a name="l01679"></a>01679 <span class="comment"> */</span>
<a name="l01680"></a>01680 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01681"></a>01681 <a class="code" href="gpfs_8h.html#a9ef80d995ce11e94a6f9f0e1f1ce62d2">gpfs_next_inode</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01682"></a>01682                 gpfs_ino_t termIno,
<a name="l01683"></a>01683                 <span class="keyword">const</span> <a class="code" href="structgpfs__iattr.html">gpfs_iattr_t</a> **iattr);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01686"></a>01686 <a class="code" href="gpfs_8h.html#a8171e769ef725481219f42d01a69cdc3">gpfs_next_inode64</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01687"></a>01687                   gpfs_ino64_t termIno,
<a name="l01688"></a>01688                   <span class="keyword">const</span> <a class="code" href="structgpfs__iattr64.html">gpfs_iattr64_t</a> **iattr);
<a name="l01689"></a>01689 
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="comment">/* NAME:        gpfs_next_inode_with_xattrs()</span>
<a name="l01692"></a>01692 <span class="comment"> *</span>
<a name="l01693"></a>01693 <span class="comment"> * FUNCTION:    Get next inode and its extended attributes from the inode scan.</span>
<a name="l01694"></a>01694 <span class="comment"> *              The set of extended attributes returned were defined when</span>
<a name="l01695"></a>01695 <span class="comment"> *              the inode scan was opened. The scan terminates before the last</span>
<a name="l01696"></a>01696 <span class="comment"> *              inode specified or the last inode in the inode file being</span>
<a name="l01697"></a>01697 <span class="comment"> *              scanned.</span>
<a name="l01698"></a>01698 <span class="comment"> *</span>
<a name="l01699"></a>01699 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01700"></a>01700 <span class="comment"> *              termIno: scan terminates before this inode number</span>
<a name="l01701"></a>01701 <span class="comment"> *                caller may specify maxIno from gpfs_open_inodescan()</span>
<a name="l01702"></a>01702 <span class="comment"> *                or 0 to scan the entire inode file.</span>
<a name="l01703"></a>01703 <span class="comment"> *              iattr: pointer to returned pointer to file&#39;s iattr.</span>
<a name="l01704"></a>01704 <span class="comment"> *              xattrBuf: pointer to returned pointer to xattr buffer</span>
<a name="l01705"></a>01705 <span class="comment"> *              xattrBufLen: returned length of xattr buffer</span>
<a name="l01706"></a>01706 <span class="comment"> *</span>
<a name="l01707"></a>01707 <span class="comment"> *</span>
<a name="l01708"></a>01708 <span class="comment"> * Returns:     0 and *iattr set to point to gpfs_iattr_t (Successful)</span>
<a name="l01709"></a>01709 <span class="comment"> *              0 and *iattr set to NULL for no more inodes before termIno</span>
<a name="l01710"></a>01710 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01711"></a>01711 <span class="comment"> *</span>
<a name="l01712"></a>01712 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01713"></a>01713 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01714"></a>01714 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01715"></a>01715 <span class="comment"> *              EFAULT buffer data was overwritten</span>
<a name="l01716"></a>01716 <span class="comment"> *              ENOMEM buffer too small</span>
<a name="l01717"></a>01717 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad parameters</span>
<a name="l01718"></a>01718 <span class="comment"> *              GPFS_E_INVAL_XATTR bad parameters</span>
<a name="l01719"></a>01719 <span class="comment"> *</span>
<a name="l01720"></a>01720 <span class="comment"> * Notes:       The data returned by gpfs_next_inode() is overwritten by</span>
<a name="l01721"></a>01721 <span class="comment"> *              subsequent calls to gpfs_next_inode(), gpfs_seek_inode()</span>
<a name="l01722"></a>01722 <span class="comment"> *              or gpfs_stat_inode().</span>
<a name="l01723"></a>01723 <span class="comment"> *</span>
<a name="l01724"></a>01724 <span class="comment"> *              The termIno parameter provides a means to partition an</span>
<a name="l01725"></a>01725 <span class="comment"> *              inode scan such that it may be executed on more than one node.</span>
<a name="l01726"></a>01726 <span class="comment"> *</span>
<a name="l01727"></a>01727 <span class="comment"> *              The returned values for xattrBuf and xattrBufLen must be</span>
<a name="l01728"></a>01728 <span class="comment"> *              provided to gpfs_next_xattr() to obtain the extended attribute</span>
<a name="l01729"></a>01729 <span class="comment"> *              names and values. The buffer used for the extended attributes</span>
<a name="l01730"></a>01730 <span class="comment"> *              is overwritten by subsequent calls to gpfs_next_inode(),</span>
<a name="l01731"></a>01731 <span class="comment"> *              gpfs_seek_inode() or gpfs_stat_inode();</span>
<a name="l01732"></a>01732 <span class="comment"> *</span>
<a name="l01733"></a>01733 <span class="comment"> *              The returned pointers to the extended attribute name and value</span>
<a name="l01734"></a>01734 <span class="comment"> *              will be aligned to a double-word boundary.</span>
<a name="l01735"></a>01735 <span class="comment"> */</span>
<a name="l01736"></a>01736 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01737"></a>01737 <a class="code" href="gpfs_8h.html#af2d35e18b29fedf22caae4918d3a1214">gpfs_next_inode_with_xattrs</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01738"></a>01738                             gpfs_ino_t termIno,
<a name="l01739"></a>01739                             <span class="keyword">const</span> <a class="code" href="structgpfs__iattr.html">gpfs_iattr_t</a> **iattr,
<a name="l01740"></a>01740                             <span class="keyword">const</span> <span class="keywordtype">char</span> **xattrBuf,
<a name="l01741"></a>01741                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *xattrBufLen);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01744"></a>01744 <a class="code" href="gpfs_8h.html#aa8c3d2345be9b0a60d8ff99de4138312">gpfs_next_inode_with_xattrs64</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01745"></a>01745                               gpfs_ino64_t termIno,
<a name="l01746"></a>01746                               <span class="keyword">const</span> <a class="code" href="structgpfs__iattr64.html">gpfs_iattr64_t</a> **iattr,
<a name="l01747"></a>01747                               <span class="keyword">const</span> <span class="keywordtype">char</span> **xattrBuf,
<a name="l01748"></a>01748                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *xattrBufLen);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 <span class="comment">/* NAME:        gpfs_next_xattr()</span>
<a name="l01752"></a>01752 <span class="comment"> *</span>
<a name="l01753"></a>01753 <span class="comment"> * FUNCTION:    Iterate over the extended attributes buffer returned</span>
<a name="l01754"></a>01754 <span class="comment"> *              by get_next_inode_with_xattrs to return the individual</span>
<a name="l01755"></a>01755 <span class="comment"> *              attributes and their values. Note that the attribute names</span>
<a name="l01756"></a>01756 <span class="comment"> *              are null-terminated strings, whereas the atttribute value</span>
<a name="l01757"></a>01757 <span class="comment"> *              contains binary data.</span>
<a name="l01758"></a>01758 <span class="comment"> *</span>
<a name="l01759"></a>01759 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01760"></a>01760 <span class="comment"> *              xattrBufLen: ptr to attribute buffer length</span>
<a name="l01761"></a>01761 <span class="comment"> *              xattrBuf: ptr to the ptr to the attribute buffer</span>
<a name="l01762"></a>01762 <span class="comment"> *</span>
<a name="l01763"></a>01763 <span class="comment"> * Returns:     0 and *name set to point attribue name (Successful)</span>
<a name="l01764"></a>01764 <span class="comment"> *                also sets: *valueLen to length of attribute value</span>
<a name="l01765"></a>01765 <span class="comment"> *                           *value to point to attribute value</span>
<a name="l01766"></a>01766 <span class="comment"> *                           *xattrBufLen to remaining length of buffer</span>
<a name="l01767"></a>01767 <span class="comment"> *                           **xattrBuf to index next attribute in buffer</span>
<a name="l01768"></a>01768 <span class="comment"> *              0 and *name set to NULL for no more attributes in buffer</span>
<a name="l01769"></a>01769 <span class="comment"> *                also sets: *valueLen to 0</span>
<a name="l01770"></a>01770 <span class="comment"> *                           *value to NULL</span>
<a name="l01771"></a>01771 <span class="comment"> *                           *xattrBufLen to 0</span>
<a name="l01772"></a>01772 <span class="comment"> *                           **xattrBuf to NULL</span>
<a name="l01773"></a>01773 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01774"></a>01774 <span class="comment"> *</span>
<a name="l01775"></a>01775 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01776"></a>01776 <span class="comment"> *              GPFS_E_INVAL_ISCAN invalid iscan parameter</span>
<a name="l01777"></a>01777 <span class="comment"> *              GPFS_E_INVAL_XATTR invalid xattr parameters</span>
<a name="l01778"></a>01778 <span class="comment"> *</span>
<a name="l01779"></a>01779 <span class="comment"> * Notes:       The caller is not allowed to modify the returned attribute</span>
<a name="l01780"></a>01780 <span class="comment"> *              names or values.  The data returned by gpfs_next_attribute()</span>
<a name="l01781"></a>01781 <span class="comment"> *              may be overwritten by subsequent calls to gpfs_next_attribute()</span>
<a name="l01782"></a>01782 <span class="comment"> *              or other gpfs library calls.</span>
<a name="l01783"></a>01783 <span class="comment"> */</span>
<a name="l01784"></a>01784 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01785"></a>01785 <a class="code" href="gpfs_8h.html#a61b51c8dd4d0081ef7b46047a0bd9dbb">gpfs_next_xattr</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01786"></a>01786                 <span class="keyword">const</span> <span class="keywordtype">char</span> **xattrBuf,
<a name="l01787"></a>01787                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *xattrBufLen,
<a name="l01788"></a>01788                 <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="mount_8h.html#a2946c588fc7fa2fa5b43ac54b7872725">name</a>,
<a name="l01789"></a>01789                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *valueLen,
<a name="l01790"></a>01790                 <span class="keyword">const</span> <span class="keywordtype">char</span> **value);
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 
<a name="l01793"></a>01793 
<a name="l01794"></a>01794 <span class="comment">/* NAME:        gpfs_seek_inode()</span>
<a name="l01795"></a>01795 <span class="comment"> *</span>
<a name="l01796"></a>01796 <span class="comment"> * FUNCTION:    Seek to a given inode number.</span>
<a name="l01797"></a>01797 <span class="comment"> *</span>
<a name="l01798"></a>01798 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01799"></a>01799 <span class="comment"> *              ino: next inode number to be scanned</span>
<a name="l01800"></a>01800 <span class="comment"> *</span>
<a name="l01801"></a>01801 <span class="comment"> * Returns:     0       Successful</span>
<a name="l01802"></a>01802 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l01803"></a>01803 <span class="comment"> *</span>
<a name="l01804"></a>01804 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01805"></a>01805 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad parameters</span>
<a name="l01806"></a>01806 <span class="comment"> */</span>
<a name="l01807"></a>01807 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01808"></a>01808 <a class="code" href="gpfs_8h.html#afab9fdec5b068a1ff9c184ecdd57dff1">gpfs_seek_inode</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01809"></a>01809                 gpfs_ino_t ino);
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01812"></a>01812 <a class="code" href="gpfs_8h.html#aeaa7149f4c881d8e397cfd972f644bdb">gpfs_seek_inode64</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01813"></a>01813                   gpfs_ino64_t ino);
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="comment">/* NAME:        gpfs_stat_inode()</span>
<a name="l01817"></a>01817 <span class="comment"> * NAME:        gpfs_stat_inode_with_xattrs()</span>
<a name="l01818"></a>01818 <span class="comment"> *</span>
<a name="l01819"></a>01819 <span class="comment"> * FUNCTION:    Seek to the specified inode and get that inode and</span>
<a name="l01820"></a>01820 <span class="comment"> *              its extended attributes from the inode scan. This is</span>
<a name="l01821"></a>01821 <span class="comment"> *              simply a combination of gpfs_seek_inode and get_next_inode</span>
<a name="l01822"></a>01822 <span class="comment"> *              but will only return the specified inode.</span>
<a name="l01823"></a>01823 <span class="comment"> *</span>
<a name="l01824"></a>01824 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01825"></a>01825 <span class="comment"> *              ino: inode number to be returned</span>
<a name="l01826"></a>01826 <span class="comment"> *              termIno: prefetch inodes up to this inode</span>
<a name="l01827"></a>01827 <span class="comment"> *                caller may specify maxIno from gpfs_open_inodescan()</span>
<a name="l01828"></a>01828 <span class="comment"> *                or 0 to allow prefetching over the entire inode file.</span>
<a name="l01829"></a>01829 <span class="comment"> *              iattr: pointer to returned pointer to file&#39;s iattr.</span>
<a name="l01830"></a>01830 <span class="comment"> *              xattrBuf: pointer to returned pointer to xattr buffer</span>
<a name="l01831"></a>01831 <span class="comment"> *              xattrBufLen: returned length of xattr buffer</span>
<a name="l01832"></a>01832 <span class="comment"> *</span>
<a name="l01833"></a>01833 <span class="comment"> * Returns:     0 and *iattr set to point to gpfs_iattr_t (Successful)</span>
<a name="l01834"></a>01834 <span class="comment"> *              0 and *iattr set to NULL for no more inodes before termIno</span>
<a name="l01835"></a>01835 <span class="comment"> *                or if requested inode does not exist.</span>
<a name="l01836"></a>01836 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01837"></a>01837 <span class="comment"> *</span>
<a name="l01838"></a>01838 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01839"></a>01839 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01840"></a>01840 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01841"></a>01841 <span class="comment"> *              ENOMEM buffer too small</span>
<a name="l01842"></a>01842 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad parameters</span>
<a name="l01843"></a>01843 <span class="comment"> *</span>
<a name="l01844"></a>01844 <span class="comment"> * Notes:       The data returned by gpfs_next_inode() is overwritten by</span>
<a name="l01845"></a>01845 <span class="comment"> *              subsequent calls to gpfs_next_inode(), gpfs_seek_inode()</span>
<a name="l01846"></a>01846 <span class="comment"> *              or gpfs_stat_inode().</span>
<a name="l01847"></a>01847 <span class="comment"> *</span>
<a name="l01848"></a>01848 <span class="comment"> *              The termIno parameter provides a means to partition an</span>
<a name="l01849"></a>01849 <span class="comment"> *              inode scan such that it may be executed on more than one node.</span>
<a name="l01850"></a>01850 <span class="comment"> *              It is only used by this call to control prefetching.</span>
<a name="l01851"></a>01851 <span class="comment"> *</span>
<a name="l01852"></a>01852 <span class="comment"> *              The returned values for xattrBuf and xattrBufLen must be</span>
<a name="l01853"></a>01853 <span class="comment"> *              provided to gpfs_next_xattr() to obtain the extended attribute</span>
<a name="l01854"></a>01854 <span class="comment"> *              names and values. The buffer used for the extended attributes</span>
<a name="l01855"></a>01855 <span class="comment"> *              is overwritten by subsequent calls to gpfs_next_inode(),</span>
<a name="l01856"></a>01856 <span class="comment"> *              gpfs_seek_inode() or gpfs_stat_inode();</span>
<a name="l01857"></a>01857 <span class="comment"> */</span>
<a name="l01858"></a>01858 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01859"></a>01859 <a class="code" href="gpfs_8h.html#af233c3aee09bc01c2f77b5f4411b211c">gpfs_stat_inode</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01860"></a>01860                 gpfs_ino_t ino,
<a name="l01861"></a>01861                 gpfs_ino_t termIno,
<a name="l01862"></a>01862                 <span class="keyword">const</span> <a class="code" href="structgpfs__iattr.html">gpfs_iattr_t</a> **iattr);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01865"></a>01865 <a class="code" href="gpfs_8h.html#a1cead6b172854234e6ffff1876a3c536">gpfs_stat_inode64</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01866"></a>01866                   gpfs_ino64_t ino,
<a name="l01867"></a>01867                   gpfs_ino64_t termIno,
<a name="l01868"></a>01868                   <span class="keyword">const</span> <a class="code" href="structgpfs__iattr64.html">gpfs_iattr64_t</a> **iattr);
<a name="l01869"></a>01869 
<a name="l01870"></a>01870 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01871"></a>01871 <a class="code" href="gpfs_8h.html#aca1e781536ca0fb72813a0bb1c69008a">gpfs_stat_inode_with_xattrs</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01872"></a>01872                             gpfs_ino_t ino,
<a name="l01873"></a>01873                             gpfs_ino_t termIno,
<a name="l01874"></a>01874                             <span class="keyword">const</span> <a class="code" href="structgpfs__iattr.html">gpfs_iattr_t</a> **iattr,
<a name="l01875"></a>01875                             <span class="keyword">const</span> <span class="keywordtype">char</span> **xattrBuf,
<a name="l01876"></a>01876                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *xattrBufLen);
<a name="l01877"></a>01877 
<a name="l01878"></a>01878 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01879"></a>01879 <a class="code" href="gpfs_8h.html#a03670c86de9c0d1339355e3310da00c2">gpfs_stat_inode_with_xattrs64</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l01880"></a>01880                               gpfs_ino64_t ino,
<a name="l01881"></a>01881                               gpfs_ino64_t termIno,
<a name="l01882"></a>01882                               <span class="keyword">const</span> <a class="code" href="structgpfs__iattr64.html">gpfs_iattr64_t</a> **iattr,
<a name="l01883"></a>01883                               <span class="keyword">const</span> <span class="keywordtype">char</span> **xattrBuf,
<a name="l01884"></a>01884                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *xattrBufLen);
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 <span class="comment">/* NAME:        gpfs_close_inodescan()</span>
<a name="l01888"></a>01888 <span class="comment"> *</span>
<a name="l01889"></a>01889 <span class="comment"> * FUNCTION:    Close inode file.</span>
<a name="l01890"></a>01890 <span class="comment"> *</span>
<a name="l01891"></a>01891 <span class="comment"> * Input:       iscan: ptr to inode scan descriptor</span>
<a name="l01892"></a>01892 <span class="comment"> *</span>
<a name="l01893"></a>01893 <span class="comment"> * Returns:     void</span>
<a name="l01894"></a>01894 <span class="comment"> *</span>
<a name="l01895"></a>01895 <span class="comment"> * Errno:       None</span>
<a name="l01896"></a>01896 <span class="comment"> */</span>
<a name="l01897"></a>01897 <span class="keywordtype">void</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01898"></a>01898 <a class="code" href="gpfs_8h.html#a7ed442f2d31323a6097475d12279ec0f">gpfs_close_inodescan</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan);
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 <span class="comment">/* NAME:        gpfs_cmp_fssnapid()</span>
<a name="l01902"></a>01902 <span class="comment"> *</span>
<a name="l01903"></a>01903 <span class="comment"> * FUNCTION:    Compare two fssnapIds for the same file system to</span>
<a name="l01904"></a>01904 <span class="comment"> *              determine the order in which the two snapshots were taken.</span>
<a name="l01905"></a>01905 <span class="comment"> *              The &#39;result&#39; variable will be set as follows:</span>
<a name="l01906"></a>01906 <span class="comment"> *                *result &lt; 0:  snapshot 1 was taken before snapshot 2</span>
<a name="l01907"></a>01907 <span class="comment"> *                *result == 0: snapshot 1 and 2 are the same</span>
<a name="l01908"></a>01908 <span class="comment"> *                *result &gt; 0:  snapshot 1 was taken after snapshot 2</span>
<a name="l01909"></a>01909 <span class="comment"> *</span>
<a name="l01910"></a>01910 <span class="comment"> * Input:      fssnapId1: ptr to fssnapId 1</span>
<a name="l01911"></a>01911 <span class="comment"> *             fssnapId2: ptr to fssnapId id 2</span>
<a name="l01912"></a>01912 <span class="comment"> *             result: ptr to returned results</span>
<a name="l01913"></a>01913 <span class="comment"> *</span>
<a name="l01914"></a>01914 <span class="comment"> * Returns:     0 and *result is set as described above (Successful)</span>
<a name="l01915"></a>01915 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01916"></a>01916 <span class="comment"> *</span>
<a name="l01917"></a>01917 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01918"></a>01918 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID fssnapid1 or fssnapid2 is not a</span>
<a name="l01919"></a>01919 <span class="comment"> *                valid snapshot id</span>
<a name="l01920"></a>01920 <span class="comment"> *              EDOM the two snapshots cannot be compared because</span>
<a name="l01921"></a>01921 <span class="comment"> *                they were taken from two different file systems.</span>
<a name="l01922"></a>01922 <span class="comment"> */</span>
<a name="l01923"></a>01923 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01924"></a>01924 <a class="code" href="gpfs_8h.html#a5db9796484e39c390d574cb3960a00d4">gpfs_cmp_fssnapid</a>(<span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fssnapId1,
<a name="l01925"></a>01925                   <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *fssnapId2,
<a name="l01926"></a>01926                   <span class="keywordtype">int</span> *result);
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 
<a name="l01929"></a>01929 <span class="comment">/* NAME:        gpfs_iopen()</span>
<a name="l01930"></a>01930 <span class="comment"> *</span>
<a name="l01931"></a>01931 <span class="comment"> * FUNCTION:    Open a file or directory by inode number.</span>
<a name="l01932"></a>01932 <span class="comment"> *</span>
<a name="l01933"></a>01933 <span class="comment"> * Input: fssnapHandle: handle for file system and snapshot</span>
<a name="l01934"></a>01934 <span class="comment"> *                      being scanned</span>
<a name="l01935"></a>01935 <span class="comment"> *        ino: inode number</span>
<a name="l01936"></a>01936 <span class="comment"> *        open_flags: O_RDONLY for gpfs_iread()</span>
<a name="l01937"></a>01937 <span class="comment"> *                    O_WRONLY for gpfs_iwrite()</span>
<a name="l01938"></a>01938 <span class="comment"> *                    O_CREAT create the file if it doesn&#39;t exist</span>
<a name="l01939"></a>01939 <span class="comment"> *                    O_TRUNC if the inode already exists delete it</span>
<a name="l01940"></a>01940 <span class="comment"> *           caller may use GPFS_O_BACKUP to read files for backup</span>
<a name="l01941"></a>01941 <span class="comment"> *                      and GPFS_O_RESTORE to write files for restore</span>
<a name="l01942"></a>01942 <span class="comment"> *        statxbuf: used only with O_CREAT/GPFS_O_BACKUP</span>
<a name="l01943"></a>01943 <span class="comment"> *                  all other cases set to NULL</span>
<a name="l01944"></a>01944 <span class="comment"> *        symLink: used only with O_CREAT/GPFS_O_BACKUP for a symbolic link</span>
<a name="l01945"></a>01945 <span class="comment"> *                 all other cases set to NULL</span>
<a name="l01946"></a>01946 <span class="comment"> *</span>
<a name="l01947"></a>01947 <span class="comment"> * Returns:     pointer to gpfs_ifile_t (Successful)</span>
<a name="l01948"></a>01948 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l01949"></a>01949 <span class="comment"> *</span>
<a name="l01950"></a>01950 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l01951"></a>01951 <span class="comment"> *              EINVAL missing or bad parameter</span>
<a name="l01952"></a>01952 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l01953"></a>01953 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l01954"></a>01954 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l01955"></a>01955 <span class="comment"> *              EFORMAT invalid fs version number</span>
<a name="l01956"></a>01956 <span class="comment"> *              EIO error reading original inode</span>
<a name="l01957"></a>01957 <span class="comment"> *              ERANGE error ino is out of range, should use gpfs_iopen64</span>
<a name="l01958"></a>01958 <span class="comment"> *              GPFS_E_INVAL_IATTR iattr structure was corrupted</span>
<a name="l01959"></a>01959 <span class="comment"> *              see dup() and malloc() ERRORS</span>
<a name="l01960"></a>01960 <span class="comment"> */</span>
<a name="l01961"></a>01961 <a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01962"></a>01962 <a class="code" href="gpfs_8h.html#a8bbb451943a4b6edf854ce7e0958bd47">gpfs_iopen</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01963"></a>01963            gpfs_ino_t ino,
<a name="l01964"></a>01964            <span class="keywordtype">int</span> open_flags,
<a name="l01965"></a>01965            <span class="keyword">const</span> <a class="code" href="structgpfs__iattr.html">gpfs_iattr_t</a> *statxbuf,
<a name="l01966"></a>01966            <span class="keyword">const</span> <span class="keywordtype">char</span> *symLink);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l01969"></a>01969 <a class="code" href="gpfs_8h.html#ac9f4584cd02211320307d156eda69111">gpfs_iopen64</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l01970"></a>01970              gpfs_ino64_t ino,
<a name="l01971"></a>01971              <span class="keywordtype">int</span> open_flags,
<a name="l01972"></a>01972              <span class="keyword">const</span> <a class="code" href="structgpfs__iattr64.html">gpfs_iattr64_t</a> *statxbuf,
<a name="l01973"></a>01973              <span class="keyword">const</span> <span class="keywordtype">char</span> *symLink);
<a name="l01974"></a>01974 
<a name="l01975"></a>01975 
<a name="l01976"></a>01976 <span class="comment">/* Define gpfs_iopen flags as used by the backup &amp; restore by inode.</span>
<a name="l01977"></a>01977 <span class="comment">   The backup code will only read the source files.</span>
<a name="l01978"></a>01978 <span class="comment">   The restore code writes the target files &amp; creates them if they</span>
<a name="l01979"></a>01979 <span class="comment">   don&#39;t already exist. The file length is set by the inode attributes.</span>
<a name="l01980"></a>01980 <span class="comment">   Consequently, to restore a user file it is unnecessary to include</span>
<a name="l01981"></a>01981 <span class="comment">   the O_TRUNC flag. */</span>
<a name="l01982"></a><a class="code" href="gpfs_8h.html#aa665a52d3232ce05f23ab5ef5fa11bd6">01982</a> <span class="preprocessor">#define GPFS_O_BACKUP  (O_RDONLY)</span>
<a name="l01983"></a><a class="code" href="gpfs_8h.html#aa274d6e3718f2408639133f4e70c6d4a">01983</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_O_RESTORE (O_WRONLY | O_CREAT)</span>
<a name="l01984"></a>01984 <span class="preprocessor"></span>
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="comment">/* NAME:        gpfs_iread()</span>
<a name="l01987"></a>01987 <span class="comment"> *</span>
<a name="l01988"></a>01988 <span class="comment"> * FUNCTION:    Read file opened by gpfs_iopen.</span>
<a name="l01989"></a>01989 <span class="comment"> *</span>
<a name="l01990"></a>01990 <span class="comment"> * Input:       ifile:      pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l01991"></a>01991 <span class="comment"> *              buffer:     buffer for data to be read</span>
<a name="l01992"></a>01992 <span class="comment"> *              bufferSize: size of buffer (ie amount of data to be read)</span>
<a name="l01993"></a>01993 <span class="comment"> * In/Out       offset:     offset of where within the file to read</span>
<a name="l01994"></a>01994 <span class="comment"> *                          if successful, offset will be updated to the</span>
<a name="l01995"></a>01995 <span class="comment"> *                          next byte after the last one that was read</span>
<a name="l01996"></a>01996 <span class="comment"> *</span>
<a name="l01997"></a>01997 <span class="comment"> * Returns:     number of bytes read (Successful)</span>
<a name="l01998"></a>01998 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l01999"></a>01999 <span class="comment"> *</span>
<a name="l02000"></a>02000 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02001"></a>02001 <span class="comment"> *              EISDIR file is a directory</span>
<a name="l02002"></a>02002 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02003"></a>02003 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02004"></a>02004 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameters</span>
<a name="l02005"></a>02005 <span class="comment"> *              see system call read() ERRORS</span>
<a name="l02006"></a>02006 <span class="comment"> */</span>
<a name="l02007"></a>02007 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02008"></a>02008 <a class="code" href="gpfs_8h.html#a11a870b3b44fc58d4d5634df0d2233f4">gpfs_iread</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02009"></a>02009            <span class="keywordtype">void</span> *buffer,
<a name="l02010"></a>02010            <span class="keywordtype">int</span> bufferSize,
<a name="l02011"></a>02011            gpfs_off64_t *offset);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 
<a name="l02014"></a>02014 <span class="comment">/* NAME:        gpfs_iwrite()</span>
<a name="l02015"></a>02015 <span class="comment"> *</span>
<a name="l02016"></a>02016 <span class="comment"> * FUNCTION:    Write file opened by gpfs_iopen.</span>
<a name="l02017"></a>02017 <span class="comment"> *</span>
<a name="l02018"></a>02018 <span class="comment"> * Input:       ifile:    pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02019"></a>02019 <span class="comment"> *              buffer:   the data to be written</span>
<a name="l02020"></a>02020 <span class="comment"> *              writeLen: how much to write</span>
<a name="l02021"></a>02021 <span class="comment"> * In/Out       offset:   offset of where within the file to write</span>
<a name="l02022"></a>02022 <span class="comment"> *                        if successful, offset will be updated to the</span>
<a name="l02023"></a>02023 <span class="comment"> *                        next byte after the last one that was written</span>
<a name="l02024"></a>02024 <span class="comment"> *</span>
<a name="l02025"></a>02025 <span class="comment"> * Returns:     number of bytes written (Successful)</span>
<a name="l02026"></a>02026 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02027"></a>02027 <span class="comment"> *</span>
<a name="l02028"></a>02028 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02029"></a>02029 <span class="comment"> *              EISDIR file is a directory</span>
<a name="l02030"></a>02030 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02031"></a>02031 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02032"></a>02032 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameters</span>
<a name="l02033"></a>02033 <span class="comment"> *              see system call write() ERRORS</span>
<a name="l02034"></a>02034 <span class="comment"> */</span>
<a name="l02035"></a>02035 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02036"></a>02036 <a class="code" href="gpfs_8h.html#a7299ccec9ac2ca0ba72b79cf3214f536">gpfs_iwrite</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02037"></a>02037             <span class="keywordtype">void</span> *buffer,
<a name="l02038"></a>02038             <span class="keywordtype">int</span> writeLen,
<a name="l02039"></a>02039             gpfs_off64_t *offset);
<a name="l02040"></a>02040 
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 <span class="comment">/* NAME:        gpfs_ireaddir()</span>
<a name="l02043"></a>02043 <span class="comment"> *</span>
<a name="l02044"></a>02044 <span class="comment"> * FUNCTION:    Get next directory entry.</span>
<a name="l02045"></a>02045 <span class="comment"> *</span>
<a name="l02046"></a>02046 <span class="comment"> * Input:       idir:   pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02047"></a>02047 <span class="comment"> *              dirent: pointer to returned pointer to directory entry</span>
<a name="l02048"></a>02048 <span class="comment"> *</span>
<a name="l02049"></a>02049 <span class="comment"> * Returns:     0 and pointer to gpfs_direntx set (Successful)</span>
<a name="l02050"></a>02050 <span class="comment"> *              0 and pointer to gpfs_direntx set to NULL (End of directory)</span>
<a name="l02051"></a>02051 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02052"></a>02052 <span class="comment"> *</span>
<a name="l02053"></a>02053 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02054"></a>02054 <span class="comment"> *              ENOTDIR file is not a directory</span>
<a name="l02055"></a>02055 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02056"></a>02056 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02057"></a>02057 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameter</span>
<a name="l02058"></a>02058 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02059"></a>02059 <span class="comment"> *</span>
<a name="l02060"></a>02060 <span class="comment"> * Notes:       The data returned by gpfs_ireaddir() is overwritten by</span>
<a name="l02061"></a>02061 <span class="comment"> *              subsequent calls to gpfs_ireaddir().</span>
<a name="l02062"></a>02062 <span class="comment"> */</span>
<a name="l02063"></a>02063 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02064"></a>02064 <a class="code" href="gpfs_8h.html#a28f300ae15965da5b3dac85390643658">gpfs_ireaddir</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02065"></a>02065               <span class="keyword">const</span> <a class="code" href="structgpfs__direntx.html">gpfs_direntx_t</a> **dirent);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02068"></a>02068 <a class="code" href="gpfs_8h.html#aa2911ed58f44722a17082a1b66ab64ff">gpfs_ireaddir64</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02069"></a>02069                 <span class="keyword">const</span> <a class="code" href="structgpfs__direntx64.html">gpfs_direntx64_t</a> **dirent);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02073"></a>02073 <a class="code" href="gpfs_8h.html#a8bf26c3497c36129e0e1917ec3417880">gpfs_ireaddirx</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02074"></a>02074                <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,      <span class="comment">/* in only  */</span>
<a name="l02075"></a>02075                <span class="keyword">const</span> <a class="code" href="structgpfs__direntx.html">gpfs_direntx_t</a> **dirent);
<a name="l02076"></a>02076 
<a name="l02077"></a>02077 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02078"></a>02078 <a class="code" href="gpfs_8h.html#a1f34c9b0c064ad3af9894ff02d555c78">gpfs_ireaddirx64</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02079"></a>02079                  <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,      <span class="comment">/* in only  */</span>
<a name="l02080"></a>02080                  <span class="keyword">const</span> <a class="code" href="structgpfs__direntx64.html">gpfs_direntx64_t</a> **dirent);
<a name="l02081"></a>02081 
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 <span class="comment">/* NAME:        gpfs_iwritedir()</span>
<a name="l02084"></a>02084 <span class="comment"> *</span>
<a name="l02085"></a>02085 <span class="comment"> * FUNCTION:    Create a directory entry in a directory opened by gpfs_iopen.</span>
<a name="l02086"></a>02086 <span class="comment"> *</span>
<a name="l02087"></a>02087 <span class="comment"> * Input:       idir:   pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02088"></a>02088 <span class="comment"> *              dirent: directory entry to be written</span>
<a name="l02089"></a>02089 <span class="comment"> *</span>
<a name="l02090"></a>02090 <span class="comment"> * Returns:     0 (Successful)</span>
<a name="l02091"></a>02091 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02092"></a>02092 <span class="comment"> *</span>
<a name="l02093"></a>02093 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02094"></a>02094 <span class="comment"> *              GPFS_E_INVAL_IFILE bad file pointer</span>
<a name="l02095"></a>02095 <span class="comment"> *              ENOTDIR file is not a directory</span>
<a name="l02096"></a>02096 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02097"></a>02097 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02098"></a>02098 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02099"></a>02099 <span class="comment"> *              EFORMAT invalid dirent version number</span>
<a name="l02100"></a>02100 <span class="comment"> *              see system call write() ERRORS</span>
<a name="l02101"></a>02101 <span class="comment"> */</span>
<a name="l02102"></a>02102 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02103"></a>02103 <a class="code" href="gpfs_8h.html#a62ed9de11f357dbd01e5bb946750dd56">gpfs_iwritedir</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02104"></a>02104                <span class="keyword">const</span> <a class="code" href="structgpfs__direntx.html">gpfs_direntx_t</a> *dirent);
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02107"></a>02107 <a class="code" href="gpfs_8h.html#a18e74c83c1cd8bc683d4fd1e8b55eb58">gpfs_iwritedir64</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *idir,
<a name="l02108"></a>02108                  <span class="keyword">const</span> <a class="code" href="structgpfs__direntx64.html">gpfs_direntx64_t</a> *dirent);
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 <span class="comment">/* NAME:        gpfs_igetattrs()</span>
<a name="l02112"></a>02112 <span class="comment"> *</span>
<a name="l02113"></a>02113 <span class="comment"> * FUNCTION:    Retrieves all extended file attributes in opaque format.</span>
<a name="l02114"></a>02114 <span class="comment"> *              This function together with gpfs_iputattrs is intended for</span>
<a name="l02115"></a>02115 <span class="comment"> *              use by a backup program to save (gpfs_igetattrs) and</span>
<a name="l02116"></a>02116 <span class="comment"> *              restore (gpfs_iputattrs) all extended file attributes</span>
<a name="l02117"></a>02117 <span class="comment"> *              (ACLs, user attributes, ...) in one call.</span>
<a name="l02118"></a>02118 <span class="comment"> *</span>
<a name="l02119"></a>02119 <span class="comment"> *              NOTE: This call does not return extended attributes used for</span>
<a name="l02120"></a>02120 <span class="comment"> *                    the Data Storage Management (XDSM) API (aka DMAPI).</span>
<a name="l02121"></a>02121 <span class="comment"> *</span>
<a name="l02122"></a>02122 <span class="comment"> * Input:       ifile:      pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02123"></a>02123 <span class="comment"> *              buffer:     pointer to buffer for returned attributes</span>
<a name="l02124"></a>02124 <span class="comment"> *              bufferSize: size of buffer</span>
<a name="l02125"></a>02125 <span class="comment"> *              attrSize:   ptr to returned size of attributes</span>
<a name="l02126"></a>02126 <span class="comment"> *</span>
<a name="l02127"></a>02127 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02128"></a>02128 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02129"></a>02129 <span class="comment"> *</span>
<a name="l02130"></a>02130 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02131"></a>02131 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02132"></a>02132 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02133"></a>02133 <span class="comment"> *              ENOSPC  buffer too small to return all attributes</span>
<a name="l02134"></a>02134 <span class="comment"> *                      *attrSizeP will be set to the size necessary</span>
<a name="l02135"></a>02135 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameters</span>
<a name="l02136"></a>02136 <span class="comment"> */</span>
<a name="l02137"></a>02137 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02138"></a>02138 <a class="code" href="gpfs_8h.html#aeae89b6f9619b1c612da5d1324475165">gpfs_igetattrs</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02139"></a>02139                <span class="keywordtype">void</span> *buffer,
<a name="l02140"></a>02140                <span class="keywordtype">int</span> bufferSize,
<a name="l02141"></a>02141                <span class="keywordtype">int</span> *attrSize);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143 <span class="comment">/* NAME:        gpfs_igetattrsx()</span>
<a name="l02144"></a>02144 <span class="comment"> *</span>
<a name="l02145"></a>02145 <span class="comment"> * FUNCTION:    Retrieves all extended file attributes in opaque format.</span>
<a name="l02146"></a>02146 <span class="comment"> *              This function together with gpfs_iputattrsx is intended for</span>
<a name="l02147"></a>02147 <span class="comment"> *              use by a backup program to save (gpfs_igetattrsx) and</span>
<a name="l02148"></a>02148 <span class="comment"> *              restore (gpfs_iputattrsx) all extended file attributes</span>
<a name="l02149"></a>02149 <span class="comment"> *              (ACLs, user attributes, ...) in one call.</span>
<a name="l02150"></a>02150 <span class="comment"> *</span>
<a name="l02151"></a>02151 <span class="comment"> *              NOTE: This call can optionally return extended attributes</span>
<a name="l02152"></a>02152 <span class="comment"> *                    used for the Data Storage Management (XDSM) API</span>
<a name="l02153"></a>02153 <span class="comment"> *                    (aka DMAPI).</span>
<a name="l02154"></a>02154 <span class="comment"> *</span>
<a name="l02155"></a>02155 <span class="comment"> * Input:       ifile:      pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02156"></a>02156 <span class="comment"> *              flags   Define behavior of get attributes</span>
<a name="l02157"></a>02157 <span class="comment"> *                GPFS_ATTRFLAG_NO_PLACEMENT - file attributes for placement</span>
<a name="l02158"></a>02158 <span class="comment"> *                      are not saved, neither is the current storage pool.</span>
<a name="l02159"></a>02159 <span class="comment"> *                GPFS_ATTRFLAG_IGNORE_POOL - file attributes for placement</span>
<a name="l02160"></a>02160 <span class="comment"> *                      are saved, but the current storage pool is not.</span>
<a name="l02161"></a>02161 <span class="comment"> *                GPFS_ATTRFLAG_INCL_DMAPI - file attributes for dmapi are</span>
<a name="l02162"></a>02162 <span class="comment"> *                      included in the returned buffer</span>
<a name="l02163"></a>02163 <span class="comment"> *</span>
<a name="l02164"></a>02164 <span class="comment"> *              buffer:     pointer to buffer for returned attributes</span>
<a name="l02165"></a>02165 <span class="comment"> *              bufferSize: size of buffer</span>
<a name="l02166"></a>02166 <span class="comment"> *              attrSize:   ptr to returned size of attributes</span>
<a name="l02167"></a>02167 <span class="comment"> *</span>
<a name="l02168"></a>02168 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02169"></a>02169 <span class="comment"> *              -1      Failure</span>
<a name="l02170"></a>02170 <span class="comment"> *</span>
<a name="l02171"></a>02171 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02172"></a>02172 <span class="comment"> *              EINVAL  Not a GPFS file</span>
<a name="l02173"></a>02173 <span class="comment"> *              EINVAL  invalid flags provided</span>
<a name="l02174"></a>02174 <span class="comment"> *              ENOSPC  buffer too small to return all attributes</span>
<a name="l02175"></a>02175 <span class="comment"> *                      *attrSizeP will be set to the size necessary</span>
<a name="l02176"></a>02176 <span class="comment"> */</span>
<a name="l02177"></a>02177 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02178"></a>02178 <a class="code" href="gpfs_8h.html#ae95d04ae3acdefbcec5768095b678f06">gpfs_igetattrsx</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02179"></a>02179                 <span class="keywordtype">int</span> flags,
<a name="l02180"></a>02180                 <span class="keywordtype">void</span> *buffer,
<a name="l02181"></a>02181                 <span class="keywordtype">int</span> bufferSize,
<a name="l02182"></a>02182                 <span class="keywordtype">int</span> *attrSize);
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 
<a name="l02185"></a>02185 <span class="comment">/* NAME:        gpfs_iputattrs()</span>
<a name="l02186"></a>02186 <span class="comment"> *</span>
<a name="l02187"></a>02187 <span class="comment"> * FUNCTION:    Sets all extended file attributes of a file.</span>
<a name="l02188"></a>02188 <span class="comment"> *              The buffer passed in should contain extended attribute data</span>
<a name="l02189"></a>02189 <span class="comment"> *              that was obtained by a previous call to gpfs_igetattrs.</span>
<a name="l02190"></a>02190 <span class="comment"> *</span>
<a name="l02191"></a>02191 <span class="comment"> *              NOTE: This call will not restore extended attributes</span>
<a name="l02192"></a>02192 <span class="comment"> *                    used for the Data Storage Management (XDSM) API</span>
<a name="l02193"></a>02193 <span class="comment"> *                    (aka DMAPI). They will be silently ignored.</span>
<a name="l02194"></a>02194 <span class="comment"> *</span>
<a name="l02195"></a>02195 <span class="comment"> * Input:       ifile:  pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02196"></a>02196 <span class="comment"> *              buffer: pointer to buffer for returned attributes</span>
<a name="l02197"></a>02197 <span class="comment"> *</span>
<a name="l02198"></a>02198 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02199"></a>02199 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02200"></a>02200 <span class="comment"> *</span>
<a name="l02201"></a>02201 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02202"></a>02202 <span class="comment"> *              EINVAL  the buffer does not contain valid attribute data</span>
<a name="l02203"></a>02203 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02204"></a>02204 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02205"></a>02205 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameters</span>
<a name="l02206"></a>02206 <span class="comment"> */</span>
<a name="l02207"></a>02207 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02208"></a>02208 <a class="code" href="gpfs_8h.html#aee136f64e287625bb798447628fb4704">gpfs_iputattrs</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02209"></a>02209                <span class="keywordtype">void</span> *buffer);
<a name="l02210"></a>02210 
<a name="l02211"></a>02211 
<a name="l02212"></a>02212 <span class="comment">/* NAME:        gpfs_iputattrsx()</span>
<a name="l02213"></a>02213 <span class="comment"> *</span>
<a name="l02214"></a>02214 <span class="comment"> * FUNCTION:    Sets all extended file attributes of a file.</span>
<a name="l02215"></a>02215 <span class="comment"> *</span>
<a name="l02216"></a>02216 <span class="comment"> *              This routine can optionally invoke the policy engine</span>
<a name="l02217"></a>02217 <span class="comment"> *              to match a RESTORE rule using the file&#39;s attributes saved</span>
<a name="l02218"></a>02218 <span class="comment"> *              in the extended attributes to set the file&#39;s storage pool and</span>
<a name="l02219"></a>02219 <span class="comment"> *              data replication as when calling gpfs_fputattrswithpathname.</span>
<a name="l02220"></a>02220 <span class="comment"> *              When used with the policy the caller should include the</span>
<a name="l02221"></a>02221 <span class="comment"> *              full path to the file, including the file name, to allow</span>
<a name="l02222"></a>02222 <span class="comment"> *              rule selection based on file name or path.</span>
<a name="l02223"></a>02223 <span class="comment"> *</span>
<a name="l02224"></a>02224 <span class="comment"> *              By default, the routine will not use RESTORE policy rules</span>
<a name="l02225"></a>02225 <span class="comment"> *              for data placement. The pathName parameter will be ignored</span>
<a name="l02226"></a>02226 <span class="comment"> *              and may be set to NULL.</span>
<a name="l02227"></a>02227 <span class="comment"> *</span>
<a name="l02228"></a>02228 <span class="comment"> *              If the call does not use RESTORE policy rules, or if the</span>
<a name="l02229"></a>02229 <span class="comment"> *              file fails to match a RESTORE rule, or if there are no</span>
<a name="l02230"></a>02230 <span class="comment"> *              RESTORE rules installed, then the storage pool and data</span>
<a name="l02231"></a>02231 <span class="comment"> *              replication are selected as when calling gpfs_fputattrs().</span>
<a name="l02232"></a>02232 <span class="comment"> *</span>
<a name="l02233"></a>02233 <span class="comment"> *              The buffer passed in should contain extended attribute data</span>
<a name="l02234"></a>02234 <span class="comment"> *              that was obtained by a previous call to gpfs_fgetattrs.</span>
<a name="l02235"></a>02235 <span class="comment"> *</span>
<a name="l02236"></a>02236 <span class="comment"> *              pathName is a UTF-8 encoded string. On Windows, applications</span>
<a name="l02237"></a>02237 <span class="comment"> *              can convert UTF-16 (&quot;Unicode&quot;) to UTF-8 using the platforms</span>
<a name="l02238"></a>02238 <span class="comment"> *              WideCharToMultiByte function.</span>
<a name="l02239"></a>02239 <span class="comment"> *</span>
<a name="l02240"></a>02240 <span class="comment"> *              NOTE: This call will restore extended attributes</span>
<a name="l02241"></a>02241 <span class="comment"> *                    used for the Data Storage Management (XDSM) API</span>
<a name="l02242"></a>02242 <span class="comment"> *                    (aka DMAPI) if they are present in the buffer.</span>
<a name="l02243"></a>02243 <span class="comment"> *</span>
<a name="l02244"></a>02244 <span class="comment"> * Input:       ifile:  pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02245"></a>02245 <span class="comment"> *              flags   Define behavior of put attributes</span>
<a name="l02246"></a>02246 <span class="comment"> *                GPFS_ATTRFLAG_NO_PLACEMENT - file attributes are restored</span>
<a name="l02247"></a>02247 <span class="comment"> *                      but the storage pool and data replication are unchanged</span>
<a name="l02248"></a>02248 <span class="comment"> *                GPFS_ATTRFLAG_IGNORE_POOL - file attributes are restored</span>
<a name="l02249"></a>02249 <span class="comment"> *                      but the storage pool and data replication are selected</span>
<a name="l02250"></a>02250 <span class="comment"> *                      by matching the saved attributes to a placement rule</span>
<a name="l02251"></a>02251 <span class="comment"> *                      instead of restoring the saved storage pool.</span>
<a name="l02252"></a>02252 <span class="comment"> *                GPFS_ATTRFLAG_USE_POLICY - file attributes are restored</span>
<a name="l02253"></a>02253 <span class="comment"> *                      but the storage pool and data replication are selected</span>
<a name="l02254"></a>02254 <span class="comment"> *                      by matching the saved attributes to a RESTORE rule</span>
<a name="l02255"></a>02255 <span class="comment"> *                      instead of restoring the saved storage pool.</span>
<a name="l02256"></a>02256 <span class="comment"> *                GPFS_ATTRFLAG_FINALIZE_ATTRS - file attributes that are restored</span>
<a name="l02257"></a>02257 <span class="comment"> *                      after data is retored. If file is immutable/appendOnly</span>
<a name="l02258"></a>02258 <span class="comment"> *                      call without this flag before restoring data</span>
<a name="l02259"></a>02259 <span class="comment"> *                      then call with this flag after restoring data</span>
<a name="l02260"></a>02260 <span class="comment"> *</span>
<a name="l02261"></a>02261 <span class="comment"> *              buffer: pointer to buffer for returned attributes</span>
<a name="l02262"></a>02262 <span class="comment"> *              pathName: pointer to file path and file name for file</span>
<a name="l02263"></a>02263 <span class="comment"> *                        May be set to NULL.</span>
<a name="l02264"></a>02264 <span class="comment"> *</span>
<a name="l02265"></a>02265 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02266"></a>02266 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02267"></a>02267 <span class="comment"> *</span>
<a name="l02268"></a>02268 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02269"></a>02269 <span class="comment"> *              EINVAL  the buffer does not contain valid attribute data</span>
<a name="l02270"></a>02270 <span class="comment"> *              EINVAL  invalid flags provided</span>
<a name="l02271"></a>02271 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02272"></a>02272 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02273"></a>02273 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameters</span>
<a name="l02274"></a>02274 <span class="comment"> */</span>
<a name="l02275"></a>02275 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02276"></a>02276 <a class="code" href="gpfs_8h.html#ae8d133d5aca0a35404e4babffa39af45">gpfs_iputattrsx</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,
<a name="l02277"></a>02277                 <span class="keywordtype">int</span> flags,
<a name="l02278"></a>02278                 <span class="keywordtype">void</span> *buffer,
<a name="l02279"></a>02279                 <span class="keyword">const</span> <span class="keywordtype">char</span> *pathName);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281 
<a name="l02282"></a>02282 <span class="comment">/* NAME:        gpfs_igetfilesetname()</span>
<a name="l02283"></a>02283 <span class="comment"> *</span>
<a name="l02284"></a>02284 <span class="comment"> * FUNCTION:    Retrieves the name of the fileset which contains this file.</span>
<a name="l02285"></a>02285 <span class="comment"> *              The fileset name is a null-terminated string, with a</span>
<a name="l02286"></a>02286 <span class="comment"> *              a maximum length of GPFS_MAXNAMLEN.</span>
<a name="l02287"></a>02287 <span class="comment"> *</span>
<a name="l02288"></a>02288 <span class="comment"> * Input:       iscan:      ptr to gpfs_iscan_t from gpfs_open_inodescan()</span>
<a name="l02289"></a>02289 <span class="comment"> *              filesetId:  ia_filesetId returned in an iattr from the iscan</span>
<a name="l02290"></a>02290 <span class="comment"> *              buffer:     pointer to buffer for returned fileset name</span>
<a name="l02291"></a>02291 <span class="comment"> *              bufferSize: size of buffer</span>
<a name="l02292"></a>02292 <span class="comment"> *</span>
<a name="l02293"></a>02293 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02294"></a>02294 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02295"></a>02295 <span class="comment"> *</span>
<a name="l02296"></a>02296 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02297"></a>02297 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02298"></a>02298 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02299"></a>02299 <span class="comment"> *              ENOSPC  buffer too small to return fileset name</span>
<a name="l02300"></a>02300 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad iscan parameter</span>
<a name="l02301"></a>02301 <span class="comment"> */</span>
<a name="l02302"></a>02302 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02303"></a>02303 <a class="code" href="gpfs_8h.html#af2b980327d53ee309f5f600553e67fa5">gpfs_igetfilesetname</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l02304"></a>02304                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> filesetId,
<a name="l02305"></a>02305                      <span class="keywordtype">void</span> *buffer,
<a name="l02306"></a>02306                      <span class="keywordtype">int</span> bufferSize);
<a name="l02307"></a>02307 
<a name="l02308"></a>02308 
<a name="l02309"></a>02309 <span class="comment">/* NAME:        gpfs_igetstoragepool()</span>
<a name="l02310"></a>02310 <span class="comment"> *</span>
<a name="l02311"></a>02311 <span class="comment"> * FUNCTION:    Retrieves the name of the storage pool assigned for</span>
<a name="l02312"></a>02312 <span class="comment"> *              this file&#39;s data. The storage pool name is a null-terminated</span>
<a name="l02313"></a>02313 <span class="comment"> *              string, with a maximum length of GPFS_MAXNAMLEN.</span>
<a name="l02314"></a>02314 <span class="comment"> *</span>
<a name="l02315"></a>02315 <span class="comment"> * Input:       iscan:      ptr to gpfs_iscan_t from gpfs_open_inodescan()</span>
<a name="l02316"></a>02316 <span class="comment"> *              dataPoolId: ia_dataPoolId returned in an iattr from the iscan</span>
<a name="l02317"></a>02317 <span class="comment"> *              buffer:     pointer to buffer for returned attributes</span>
<a name="l02318"></a>02318 <span class="comment"> *              bufferSize: size of buffer</span>
<a name="l02319"></a>02319 <span class="comment"> *</span>
<a name="l02320"></a>02320 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02321"></a>02321 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02322"></a>02322 <span class="comment"> *</span>
<a name="l02323"></a>02323 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02324"></a>02324 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02325"></a>02325 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02326"></a>02326 <span class="comment"> *              ENOSPC  buffer too small to return all storage pool name</span>
<a name="l02327"></a>02327 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad iscan parameters</span>
<a name="l02328"></a>02328 <span class="comment"> */</span>
<a name="l02329"></a>02329 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02330"></a>02330 <a class="code" href="gpfs_8h.html#ab329ffb97933c7296dc4e6c2aef4ed85">gpfs_igetstoragepool</a>(<a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,
<a name="l02331"></a>02331                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataPoolId,
<a name="l02332"></a>02332                      <span class="keywordtype">void</span> *buffer,
<a name="l02333"></a>02333                      <span class="keywordtype">int</span> bufferSize);
<a name="l02334"></a>02334 
<a name="l02335"></a>02335 
<a name="l02336"></a>02336 <span class="comment">/* NAME:        gpfs_iclose()</span>
<a name="l02337"></a>02337 <span class="comment"> *</span>
<a name="l02338"></a>02338 <span class="comment"> * FUNCTION:    Close file opened by inode and update dates.</span>
<a name="l02339"></a>02339 <span class="comment"> *</span>
<a name="l02340"></a>02340 <span class="comment"> * Input:       ifile:   pointer to gpfs_ifile_t from gpfs_iopen</span>
<a name="l02341"></a>02341 <span class="comment"> *</span>
<a name="l02342"></a>02342 <span class="comment"> * Returns:     void</span>
<a name="l02343"></a>02343 <span class="comment"> *</span>
<a name="l02344"></a>02344 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02345"></a>02345 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02346"></a>02346 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02347"></a>02347 <span class="comment"> */</span>
<a name="l02348"></a>02348 <span class="keywordtype">void</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02349"></a>02349 <a class="code" href="gpfs_8h.html#a5dcf7aa42c4e78adaa8cfce61907915e">gpfs_iclose</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile);
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 
<a name="l02352"></a>02352 <span class="comment">/* NAME:        gpfs_ireadlink()</span>
<a name="l02353"></a>02353 <span class="comment"> *</span>
<a name="l02354"></a>02354 <span class="comment"> * FUNCTION:    Read symbolic link by inode number.</span>
<a name="l02355"></a>02355 <span class="comment"> *</span>
<a name="l02356"></a>02356 <span class="comment"> * Input:       fssnapHandle: handle for file system &amp; snapshot being scanned</span>
<a name="l02357"></a>02357 <span class="comment"> *              ino:        inode number of link file to read</span>
<a name="l02358"></a>02358 <span class="comment"> *              buffer:     pointer to buffer for returned link data</span>
<a name="l02359"></a>02359 <span class="comment"> *              bufferSize: size of the buffer</span>
<a name="l02360"></a>02360 <span class="comment"> *</span>
<a name="l02361"></a>02361 <span class="comment"> * Returns:     number of bytes read (Successful)</span>
<a name="l02362"></a>02362 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02363"></a>02363 <span class="comment"> *</span>
<a name="l02364"></a>02364 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02365"></a>02365 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02366"></a>02366 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02367"></a>02367 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnap handle</span>
<a name="l02368"></a>02368 <span class="comment"> *              see system call readlink() ERRORS</span>
<a name="l02369"></a>02369 <span class="comment"> */</span>
<a name="l02370"></a>02370 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02371"></a>02371 <a class="code" href="gpfs_8h.html#a98c3d392dac1866cf64a67b81401569d">gpfs_ireadlink</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l02372"></a>02372                gpfs_ino_t ino,
<a name="l02373"></a>02373                <span class="keywordtype">char</span> *buffer,
<a name="l02374"></a>02374                <span class="keywordtype">int</span> bufferSize);
<a name="l02375"></a>02375 
<a name="l02376"></a>02376 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02377"></a>02377 <a class="code" href="gpfs_8h.html#a12ded3bdef487f7affe671a0a3858bf9">gpfs_ireadlink64</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l02378"></a>02378                gpfs_ino64_t ino,
<a name="l02379"></a>02379                <span class="keywordtype">char</span> *buffer,
<a name="l02380"></a>02380                <span class="keywordtype">int</span> bufferSize);
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 <span class="comment">/* NAME:        gpfs_sync_fs()</span>
<a name="l02384"></a>02384 <span class="comment"> *</span>
<a name="l02385"></a>02385 <span class="comment"> * FUNCTION:    sync file system.</span>
<a name="l02386"></a>02386 <span class="comment"> *</span>
<a name="l02387"></a>02387 <span class="comment"> * Input:       fssnapHandle: handle for file system being restored</span>
<a name="l02388"></a>02388 <span class="comment"> *</span>
<a name="l02389"></a>02389 <span class="comment"> * Returns:      0 all data flushed to disk (Successful)</span>
<a name="l02390"></a>02390 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02391"></a>02391 <span class="comment"> *</span>
<a name="l02392"></a>02392 <span class="comment"> * Errno:       ENOSYS  function not available</span>
<a name="l02393"></a>02393 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02394"></a>02394 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02395"></a>02395 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02396"></a>02396 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnapHandle</span>
<a name="l02397"></a>02397 <span class="comment"> */</span>
<a name="l02398"></a>02398 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02399"></a>02399 <a class="code" href="gpfs_8h.html#a237abb17c36ff0375d58958126feb840">gpfs_sync_fs</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle);
<a name="l02400"></a>02400 
<a name="l02401"></a>02401 
<a name="l02402"></a>02402 <span class="comment">/* NAME:        gpfs_enable_restore()</span>
<a name="l02403"></a>02403 <span class="comment"> *</span>
<a name="l02404"></a>02404 <span class="comment"> * FUNCTION:    Mark file system as enabled for restore on/off</span>
<a name="l02405"></a>02405 <span class="comment"> *</span>
<a name="l02406"></a>02406 <span class="comment"> * Input:       fssnapHandle: handle for file system to be enabled</span>
<a name="l02407"></a>02407 <span class="comment"> *                            or disabled for restore</span>
<a name="l02408"></a>02408 <span class="comment"> *              on_off:   flag set to 1 to enable restore</span>
<a name="l02409"></a>02409 <span class="comment"> *                                    0 to disable restore</span>
<a name="l02410"></a>02410 <span class="comment"> *</span>
<a name="l02411"></a>02411 <span class="comment"> * Returns:      0 (Successful)</span>
<a name="l02412"></a>02412 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02413"></a>02413 <span class="comment"> *</span>
<a name="l02414"></a>02414 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02415"></a>02415 <span class="comment"> *              EINVAL bad parameters</span>
<a name="l02416"></a>02416 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnapHandle</span>
<a name="l02417"></a>02417 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02418"></a>02418 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02419"></a>02419 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02420"></a>02420 <span class="comment"> *              E_FS_NOT_RESTORABLE fs is not clean</span>
<a name="l02421"></a>02421 <span class="comment"> *              EALREADY fs already marked as requested</span>
<a name="l02422"></a>02422 <span class="comment"> *              E_RESTORE_STARTED restore in progress</span>
<a name="l02423"></a>02423 <span class="comment"> *</span>
<a name="l02424"></a>02424 <span class="comment"> * Notes: EALREADY indicates enable/disable restore was already called</span>
<a name="l02425"></a>02425 <span class="comment"> * for this fs. The caller must decide if EALREADY represents an</span>
<a name="l02426"></a>02426 <span class="comment"> * error condition.</span>
<a name="l02427"></a>02427 <span class="comment"> */</span>
<a name="l02428"></a>02428 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02429"></a>02429 <a class="code" href="gpfs_8h.html#a3f94f6cc46147bc866c696967bbc36ce">gpfs_enable_restore</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l02430"></a>02430                     <span class="keywordtype">int</span> on_off);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432 
<a name="l02433"></a>02433 <span class="comment">/* NAME:        gpfs_start_restore()</span>
<a name="l02434"></a>02434 <span class="comment"> *</span>
<a name="l02435"></a>02435 <span class="comment"> * FUNCTION:    Start a restore session.</span>
<a name="l02436"></a>02436 <span class="comment"> *</span>
<a name="l02437"></a>02437 <span class="comment"> * Input:       fssnapHandle: handle for file system to be restored</span>
<a name="l02438"></a>02438 <span class="comment"> *              restore_flags: Flag to indicate the restore should be started</span>
<a name="l02439"></a>02439 <span class="comment"> *                             even if a prior restore has not completed.</span>
<a name="l02440"></a>02440 <span class="comment"> *              old_fssnapId: fssnapId of last restored snapshot</span>
<a name="l02441"></a>02441 <span class="comment"> *              new_fssnapId: fssnapId of snapshot being restored</span>
<a name="l02442"></a>02442 <span class="comment"> *</span>
<a name="l02443"></a>02443 <span class="comment"> * Returns:     pointer to gpfs_restore_t (Successful)</span>
<a name="l02444"></a>02444 <span class="comment"> *              NULL and errno is set (Failure)</span>
<a name="l02445"></a>02445 <span class="comment"> *</span>
<a name="l02446"></a>02446 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02447"></a>02447 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02448"></a>02448 <span class="comment"> *              EINVAL missing parameter</span>
<a name="l02449"></a>02449 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02450"></a>02450 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02451"></a>02451 <span class="comment"> *              EDOM restore fs does not match existing fs</span>
<a name="l02452"></a>02452 <span class="comment"> *              ERANGE restore is missing updates</span>
<a name="l02453"></a>02453 <span class="comment"> *              EFORMAT invalid fs version number</span>
<a name="l02454"></a>02454 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnaphandle</span>
<a name="l02455"></a>02455 <span class="comment"> *              GPFS_E_INVAL_FSSNAPID bad fssnapId parameter</span>
<a name="l02456"></a>02456 <span class="comment"> *              E_FS_NOT_RESTORABLE fs is not clean for restore</span>
<a name="l02457"></a>02457 <span class="comment"> *              E_RESTORE_NOT_ENABLED fs is not enabled for restore</span>
<a name="l02458"></a>02458 <span class="comment"> *              EALREADY Restore already in progress</span>
<a name="l02459"></a>02459 <span class="comment"> *</span>
<a name="l02460"></a>02460 <span class="comment"> * Note: EALREADY indicates start restore was already called for</span>
<a name="l02461"></a>02461 <span class="comment"> * this fs. This could be due to a prior restore process that failed</span>
<a name="l02462"></a>02462 <span class="comment"> * or it could be due to a concurrent restore process still running.</span>
<a name="l02463"></a>02463 <span class="comment"> * The caller must decide if EALREADY represents an error condition.</span>
<a name="l02464"></a>02464 <span class="comment"> */</span>
<a name="l02465"></a>02465 <a class="code" href="gpfs_8h.html#a022a359f2dec88568f61efde07c13ca5">gpfs_restore_t</a> * <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02466"></a>02466 <a class="code" href="gpfs_8h.html#a7b9d0620dcb563a8ebbe504de263e14d">gpfs_start_restore</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a> *fssnapHandle,
<a name="l02467"></a>02467                    <span class="keywordtype">int</span> restore_flags,
<a name="l02468"></a>02468                    <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *old_fssnapId,
<a name="l02469"></a>02469                    <span class="keyword">const</span> <a class="code" href="structgpfs__fssnap__id.html">gpfs_fssnap_id_t</a> *new_fssnapId);
<a name="l02470"></a>02470 
<a name="l02471"></a><a class="code" href="gpfs_8h.html#a2705d18f1f07a3af08d41ae7e97493b7">02471</a> <span class="preprocessor">#define GPFS_RESTORE_NORMAL 0   </span><span class="comment">/* Restore not started if prior restore</span>
<a name="l02472"></a>02472 <span class="comment">                                   has not completed. */</span>
<a name="l02473"></a><a class="code" href="gpfs_8h.html#a1e751306203cb9ee464942a7cfa3cf02">02473</a> <span class="preprocessor">#define GPFS_RESTORE_FORCED 1   </span><span class="comment">/* Restore starts even if prior restore</span>
<a name="l02474"></a>02474 <span class="comment">                                   has not completed. */</span>
<a name="l02475"></a>02475 
<a name="l02476"></a>02476 
<a name="l02477"></a>02477 <span class="comment">/* NAME:        gpfs_end_restore()</span>
<a name="l02478"></a>02478 <span class="comment"> *</span>
<a name="l02479"></a>02479 <span class="comment"> * FUNCTION:    End a restore session.</span>
<a name="l02480"></a>02480 <span class="comment"> *</span>
<a name="l02481"></a>02481 <span class="comment"> * Input:       restoreId: ptr to gpfs_restore_t</span>
<a name="l02482"></a>02482 <span class="comment"> *</span>
<a name="l02483"></a>02483 <span class="comment"> * Returns:     0 (Successful)</span>
<a name="l02484"></a>02484 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02485"></a>02485 <span class="comment"> *</span>
<a name="l02486"></a>02486 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02487"></a>02487 <span class="comment"> *              EINVAL bad parameters</span>
<a name="l02488"></a>02488 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02489"></a>02489 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02490"></a>02490 <span class="comment"> *              GPFS_E_INVAL_RESTORE bad restoreId parameter</span>
<a name="l02491"></a>02491 <span class="comment"> *              GPFS_E_FS_NOT_RESTORABLE fs is not clean for restore</span>
<a name="l02492"></a>02492 <span class="comment"> *              GPFS_E_RESTORE_NOT_ENABLED fs is not enabled for restore</span>
<a name="l02493"></a>02493 <span class="comment"> *              EALREADY Restore already ended</span>
<a name="l02494"></a>02494 <span class="comment"> *</span>
<a name="l02495"></a>02495 <span class="comment"> * Note: EALREADY indicates end restore was already called for</span>
<a name="l02496"></a>02496 <span class="comment"> * this fs. This could be due to a concurrent restore process that</span>
<a name="l02497"></a>02497 <span class="comment"> * already completed. The caller must decide if EALREADY represents</span>
<a name="l02498"></a>02498 <span class="comment"> * an error condition.</span>
<a name="l02499"></a>02499 <span class="comment"> */</span>
<a name="l02500"></a>02500 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02501"></a>02501 <a class="code" href="gpfs_8h.html#af4f80209e7c5ed8549bdae34417bd81f">gpfs_end_restore</a>(<a class="code" href="gpfs_8h.html#a022a359f2dec88568f61efde07c13ca5">gpfs_restore_t</a> *restoreId);
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 
<a name="l02504"></a>02504 <span class="comment">/* NAME:        gpfs_ireadx()</span>
<a name="l02505"></a>02505 <span class="comment"> *</span>
<a name="l02506"></a>02506 <span class="comment"> * FUNCTION:    Block level incremental read on a file opened by gpfs_iopen</span>
<a name="l02507"></a>02507 <span class="comment"> *              with a given incremental scan opened via gpfs_open_inodescan.</span>
<a name="l02508"></a>02508 <span class="comment"> *</span>
<a name="l02509"></a>02509 <span class="comment"> * Input:       ifile:      ptr to gpfs_ifile_t returned from gpfs_iopen()</span>
<a name="l02510"></a>02510 <span class="comment"> *              iscan:      ptr to gpfs_iscan_t from gpfs_open_inodescan()</span>
<a name="l02511"></a>02511 <span class="comment"> *              buffer:     ptr to buffer for returned data</span>
<a name="l02512"></a>02512 <span class="comment"> *              bufferSize: size of buffer for returned data</span>
<a name="l02513"></a>02513 <span class="comment"> *              offset:     ptr to offset value</span>
<a name="l02514"></a>02514 <span class="comment"> *              termOffset: read terminates before reading this offset</span>
<a name="l02515"></a>02515 <span class="comment"> *                          caller may specify ia_size for the file&#39;s</span>
<a name="l02516"></a>02516 <span class="comment"> *                          gpfs_iattr_t or 0 to scan the entire file.</span>
<a name="l02517"></a>02517 <span class="comment"> *              hole:       ptr to returned flag to indicate a hole in the file</span>
<a name="l02518"></a>02518 <span class="comment"> *</span>
<a name="l02519"></a>02519 <span class="comment"> * Returns:     number of bytes read and returned in buffer</span>
<a name="l02520"></a>02520 <span class="comment"> *              or size of hole encountered in the file. (Success)</span>
<a name="l02521"></a>02521 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02522"></a>02522 <span class="comment"> *</span>
<a name="l02523"></a>02523 <span class="comment"> *              On input, *offset contains the offset in the file</span>
<a name="l02524"></a>02524 <span class="comment"> *              at which to begin reading to find a difference same file</span>
<a name="l02525"></a>02525 <span class="comment"> *              in a previous snapshot specified when the inodescan was opened.</span>
<a name="l02526"></a>02526 <span class="comment"> *              On return, *offset contains the offset of the first</span>
<a name="l02527"></a>02527 <span class="comment"> *              difference.</span>
<a name="l02528"></a>02528 <span class="comment"> *</span>
<a name="l02529"></a>02529 <span class="comment"> *              On return, *hole indicates if the change in the file</span>
<a name="l02530"></a>02530 <span class="comment"> *              was data (*hole == 0) and the data is returned in the</span>
<a name="l02531"></a>02531 <span class="comment"> *              buffer provided. The function&#39;s value is the amount of data</span>
<a name="l02532"></a>02532 <span class="comment"> *              returned. If the change is a hole in the file,</span>
<a name="l02533"></a>02533 <span class="comment"> *              *hole != 0 and the size of the changed hole is returned</span>
<a name="l02534"></a>02534 <span class="comment"> *              as the function value.</span>
<a name="l02535"></a>02535 <span class="comment"> *</span>
<a name="l02536"></a>02536 <span class="comment"> *              A call with a NULL buffer pointer will query the next increment</span>
<a name="l02537"></a>02537 <span class="comment"> *              to be read from the current offset. The *offset, *hole and</span>
<a name="l02538"></a>02538 <span class="comment"> *              returned length will be set for the next increment to be read,</span>
<a name="l02539"></a>02539 <span class="comment"> *              but no data will be returned. The bufferSize parameter is</span>
<a name="l02540"></a>02540 <span class="comment"> *              ignored, but the termOffset parameter will limit the</span>
<a name="l02541"></a>02541 <span class="comment"> *              increment returned.</span>
<a name="l02542"></a>02542 <span class="comment"> *</span>
<a name="l02543"></a>02543 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02544"></a>02544 <span class="comment"> *              EINVAL missing or bad parameter</span>
<a name="l02545"></a>02545 <span class="comment"> *              EISDIR file is a directory</span>
<a name="l02546"></a>02546 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02547"></a>02547 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02548"></a>02548 <span class="comment"> *              ENOMEM unable to allocate memory for request</span>
<a name="l02549"></a>02549 <span class="comment"> *              EDOM fs snapId does match local fs</span>
<a name="l02550"></a>02550 <span class="comment"> *              ERANGE previous snapId is more recent than scanned snapId</span>
<a name="l02551"></a>02551 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameter</span>
<a name="l02552"></a>02552 <span class="comment"> *              GPFS_E_INVAL_ISCAN bad iscan parameter</span>
<a name="l02553"></a>02553 <span class="comment"> *              see system call read() ERRORS</span>
<a name="l02554"></a>02554 <span class="comment"> *</span>
<a name="l02555"></a>02555 <span class="comment"> * Notes:       The termOffset parameter provides a means to partition a</span>
<a name="l02556"></a>02556 <span class="comment"> *              file&#39;s data such that it may be read on more than one node.</span>
<a name="l02557"></a>02557 <span class="comment"> */</span>
<a name="l02558"></a>02558 gpfs_off64_t <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02559"></a>02559 <a class="code" href="gpfs_8h.html#a8297da4295d66a626f607f2707f86ab2">gpfs_ireadx</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,      <span class="comment">/* in only  */</span>
<a name="l02560"></a>02560             <a class="code" href="gpfs_8h.html#a78d5b157af0df6cf775027db1d38c893">gpfs_iscan_t</a> *iscan,      <span class="comment">/* in only  */</span>
<a name="l02561"></a>02561             <span class="keywordtype">void</span> *buffer,             <span class="comment">/* in only  */</span>
<a name="l02562"></a>02562             <span class="keywordtype">int</span> bufferSize,           <span class="comment">/* in only  */</span>
<a name="l02563"></a>02563             gpfs_off64_t *offset,     <span class="comment">/* in/out   */</span>
<a name="l02564"></a>02564             gpfs_off64_t termOffset,  <span class="comment">/* in only */</span>
<a name="l02565"></a>02565             <span class="keywordtype">int</span> *hole);               <span class="comment">/* out only */</span>
<a name="l02566"></a>02566 
<a name="l02567"></a>02567 
<a name="l02568"></a>02568 <span class="comment">/* NAME:        gpfs_iwritex()</span>
<a name="l02569"></a>02569 <span class="comment"> *</span>
<a name="l02570"></a>02570 <span class="comment"> * FUNCTION:    Write file opened by gpfs_iopen.</span>
<a name="l02571"></a>02571 <span class="comment"> *              If parameter hole == 0, then write data</span>
<a name="l02572"></a>02572 <span class="comment"> *              addressed by buffer to the given offset for the</span>
<a name="l02573"></a>02573 <span class="comment"> *              given length. If hole != 0, then write</span>
<a name="l02574"></a>02574 <span class="comment"> *              a hole at the given offset for the given length.</span>
<a name="l02575"></a>02575 <span class="comment"> *</span>
<a name="l02576"></a>02576 <span class="comment"> * Input:       ifile :   ptr to gpfs_ifile_t returned from gpfs_iopen()</span>
<a name="l02577"></a>02577 <span class="comment"> *              buffer:   ptr to data buffer</span>
<a name="l02578"></a>02578 <span class="comment"> *              writeLen: length of data to write</span>
<a name="l02579"></a>02579 <span class="comment"> *              offset:   offset in file to write data</span>
<a name="l02580"></a>02580 <span class="comment"> *              hole:     flag =1 to write a &quot;hole&quot;</span>
<a name="l02581"></a>02581 <span class="comment"> *                             =0 to write data</span>
<a name="l02582"></a>02582 <span class="comment"> *</span>
<a name="l02583"></a>02583 <span class="comment"> * Returns:     number of bytes/size of hole written (Success)</span>
<a name="l02584"></a>02584 <span class="comment"> *              -1 and errno is set (Failure)</span>
<a name="l02585"></a>02585 <span class="comment"> *</span>
<a name="l02586"></a>02586 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02587"></a>02587 <span class="comment"> *              EINVAL missing or bad parameter</span>
<a name="l02588"></a>02588 <span class="comment"> *              EISDIR file is a directory</span>
<a name="l02589"></a>02589 <span class="comment"> *              EPERM caller must have superuser privilege</span>
<a name="l02590"></a>02590 <span class="comment"> *              ESTALE cached fs information was invalid</span>
<a name="l02591"></a>02591 <span class="comment"> *              GPFS_E_INVAL_IFILE bad ifile parameter</span>
<a name="l02592"></a>02592 <span class="comment"> *              see system call write() ERRORS</span>
<a name="l02593"></a>02593 <span class="comment"> */</span>
<a name="l02594"></a>02594 gpfs_off64_t <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02595"></a>02595 <a class="code" href="gpfs_8h.html#a2e0523b909d5d6b70dbf60384df28832">gpfs_iwritex</a>(<a class="code" href="gpfs_8h.html#a4e49f0ae810d26a70ea01101a47249c5">gpfs_ifile_t</a> *ifile,    <span class="comment">/* in only */</span>
<a name="l02596"></a>02596              <span class="keywordtype">void</span> *buffer,           <span class="comment">/* in only */</span>
<a name="l02597"></a>02597              gpfs_off64_t writeLen,  <span class="comment">/* in only */</span>
<a name="l02598"></a>02598              gpfs_off64_t offset,    <span class="comment">/* in only */</span>
<a name="l02599"></a>02599              <span class="keywordtype">int</span> hole);              <span class="comment">/* in only */</span>
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 
<a name="l02602"></a>02602 <span class="comment">/* NAME:        gpfs_statfspool()</span>
<a name="l02603"></a>02603 <span class="comment"> *</span>
<a name="l02604"></a>02604 <span class="comment"> * FUNCTION:    Obtain status information about the storage pools</span>
<a name="l02605"></a>02605 <span class="comment"> *</span>
<a name="l02606"></a>02606 <span class="comment"> * Input:       pathname   : path to any file in the file system</span>
<a name="l02607"></a>02607 <span class="comment"> *              poolId     : id of first pool to return</span>
<a name="l02608"></a>02608 <span class="comment"> *                           on return set to next poolId or -1</span>
<a name="l02609"></a>02609 <span class="comment"> *                           to indicate there are no more pools.</span>
<a name="l02610"></a>02610 <span class="comment"> *              options    : option flags (currently not used)</span>
<a name="l02611"></a>02611 <span class="comment"> *              nPools     : number of stat structs requested or 0</span>
<a name="l02612"></a>02612 <span class="comment"> *                           on return number of stat structs in buffer</span>
<a name="l02613"></a>02613 <span class="comment"> *                           or if nPools was 0 its value is the max number</span>
<a name="l02614"></a>02614 <span class="comment"> *                           of storage pools currently defined</span>
<a name="l02615"></a>02615 <span class="comment"> *              buffer     :  ptr to return stat structures</span>
<a name="l02616"></a>02616 <span class="comment"> *              bufferSize : sizeof stat buffer</span>
<a name="l02617"></a>02617 <span class="comment"> *</span>
<a name="l02618"></a>02618 <span class="comment"> *              The user is expected to issue two or more calls. On the first</span>
<a name="l02619"></a>02619 <span class="comment"> *              call the user should pass nPools set to 0 and gpfs will</span>
<a name="l02620"></a>02620 <span class="comment"> *              return in nPools the total number of storage pools currently</span>
<a name="l02621"></a>02621 <span class="comment"> *              defined for the file system indicated by the pathname</span>
<a name="l02622"></a>02622 <span class="comment"> *              and it returns in poolId the id of the first storage pool.</span>
<a name="l02623"></a>02623 <span class="comment"> *              The buffer parameter may be set to NULL for this call.</span>
<a name="l02624"></a>02624 <span class="comment"> *</span>
<a name="l02625"></a>02625 <span class="comment"> *              The user may then allocate a buffer large enough to contain</span>
<a name="l02626"></a>02626 <span class="comment"> *              a gpfs_statfspool_t structure for each of the pools and issue</span>
<a name="l02627"></a>02627 <span class="comment"> *              a second call to obtain stat information about each pool.</span>
<a name="l02628"></a>02628 <span class="comment"> *              Parameter nPools should be set the number of pools requested.</span>
<a name="l02629"></a>02629 <span class="comment"> *              On return, nPools will be set to the number of stat structs</span>
<a name="l02630"></a>02630 <span class="comment"> *              contained in the buffer, and poolId will be set to the id</span>
<a name="l02631"></a>02631 <span class="comment"> *              of the next storage pool or -1 to indicate there are no</span>
<a name="l02632"></a>02632 <span class="comment"> *              additional storage pools defined.</span>
<a name="l02633"></a>02633 <span class="comment"> *</span>
<a name="l02634"></a>02634 <span class="comment"> *              Alternatively, if the user has a valid poolId from a previous</span>
<a name="l02635"></a>02635 <span class="comment"> *              call, the user may provide that poolId and a buffer large</span>
<a name="l02636"></a>02636 <span class="comment"> *              enough for a single gpfs_statfspool_t structure, and the call</span>
<a name="l02637"></a>02637 <span class="comment"> *              will return the status for a single storage pool.</span>
<a name="l02638"></a>02638 <span class="comment"> *</span>
<a name="l02639"></a>02639 <span class="comment"> *</span>
<a name="l02640"></a>02640 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02641"></a>02641 <span class="comment"> *              -1      Failure</span>
<a name="l02642"></a>02642 <span class="comment"> *</span>
<a name="l02643"></a>02643 <span class="comment"> * Errno:       Specific error indication</span>
<a name="l02644"></a>02644 <span class="comment"> *              EINVAL</span>
<a name="l02645"></a>02645 <span class="comment"> */</span>
<a name="l02646"></a>02646 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02647"></a>02647 <a class="code" href="gpfs_8h.html#aa98ab85744f1a4afd898e5c89dbe515e">gpfs_statfspool</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname, <span class="comment">/* in only: path to file system*/</span>
<a name="l02648"></a>02648                 gpfs_pool_t *poolId,  <span class="comment">/* in out: id of first pool to return</span>
<a name="l02649"></a>02649 <span class="comment">                                         on return set to next poolId</span>
<a name="l02650"></a>02650 <span class="comment">                                         or -1 when there are no more pools */</span>
<a name="l02651"></a>02651                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fuse__binding_8c.html#a3e62f5b7fb8976126fc23e6f39b5f6b5">options</a>, <span class="comment">/* in only: option flags */</span>
<a name="l02652"></a>02652                 <span class="keywordtype">int</span> *nPools,          <span class="comment">/* in out: number of pool stats requested</span>
<a name="l02653"></a>02653 <span class="comment">                                         on return number of stat structs</span>
<a name="l02654"></a>02654 <span class="comment">                                         returned in buffer or if nPools was</span>
<a name="l02655"></a>02655 <span class="comment">                                         set to 0, the return value is the</span>
<a name="l02656"></a>02656 <span class="comment">                                         number of pools currently defined */</span>
<a name="l02657"></a>02657                 <span class="keywordtype">void</span> *buffer,         <span class="comment">/* ptr to return stat structures */</span>
<a name="l02658"></a>02658                 <span class="keywordtype">int</span> bufferSize);      <span class="comment">/* sizeof stat buffer or 0 */</span>
<a name="l02659"></a>02659 
<a name="l02660"></a>02660 
<a name="l02661"></a>02661 <span class="comment">/* NAME:        gpfs_getpoolname()</span>
<a name="l02662"></a>02662 <span class="comment"> *</span>
<a name="l02663"></a>02663 <span class="comment"> * FUNCTION:    Retrieves the name of the storage pool assigned for</span>
<a name="l02664"></a>02664 <span class="comment"> *              this file&#39;s data. The storage pool name is a null-terminated</span>
<a name="l02665"></a>02665 <span class="comment"> *              string, with a maximum length of GPFS_MAXNAMLEN.</span>
<a name="l02666"></a>02666 <span class="comment"> *</span>
<a name="l02667"></a>02667 <span class="comment"> * Input:       pathname:   path to any file in the file system</span>
<a name="l02668"></a>02668 <span class="comment"> *              poolId:     f_poolid returned in gpfs_statfspool_t</span>
<a name="l02669"></a>02669 <span class="comment"> *              buffer:     pointer to buffer for returned name</span>
<a name="l02670"></a>02670 <span class="comment"> *              bufferSize: size of buffer</span>
<a name="l02671"></a>02671 <span class="comment"> *</span>
<a name="l02672"></a>02672 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02673"></a>02673 <span class="comment"> *              -1      Failure and errno is set</span>
<a name="l02674"></a>02674 <span class="comment"> *</span>
<a name="l02675"></a>02675 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02676"></a>02676 <span class="comment"> *              ESTALE file system was unmounted</span>
<a name="l02677"></a>02677 <span class="comment"> *              E_FORMAT_INCOMPAT file system does not support pools</span>
<a name="l02678"></a>02678 <span class="comment"> *              E2BIG  buffer too small to return storage pool name</span>
<a name="l02679"></a>02679 <span class="comment"> */</span>
<a name="l02680"></a>02680 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02681"></a>02681 <a class="code" href="gpfs_8h.html#a37435a186e771bcb6470cff8ce0570ab">gpfs_getpoolname</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l02682"></a>02682                  gpfs_pool_t poolId,
<a name="l02683"></a>02683                  <span class="keywordtype">void</span> *buffer,
<a name="l02684"></a>02684                  <span class="keywordtype">int</span> bufferSize);
<a name="l02685"></a>02685 
<a name="l02686"></a>02686 
<a name="l02687"></a>02687 <span class="comment">/* /usr/src/linux/include/linux/fs.h includes /usr/src/linux/include/linux/quota.h</span>
<a name="l02688"></a>02688 <span class="comment">   which has conflicting definitions. */</span>
<a name="l02689"></a>02689 <span class="preprocessor">#ifdef _LINUX_QUOTA_</span>
<a name="l02690"></a>02690 <span class="preprocessor"></span><span class="preprocessor">  #undef Q_SYNC</span>
<a name="l02691"></a>02691 <span class="preprocessor"></span><span class="preprocessor">  #undef Q_GETQUOTA</span>
<a name="l02692"></a>02692 <span class="preprocessor"></span><span class="preprocessor">  #undef Q_SETQUOTA</span>
<a name="l02693"></a>02693 <span class="preprocessor"></span><span class="preprocessor">  #undef Q_QUOTAON</span>
<a name="l02694"></a>02694 <span class="preprocessor"></span><span class="preprocessor">  #undef Q_QUOTAOFF</span>
<a name="l02695"></a>02695 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02696"></a>02696 <span class="preprocessor"></span>
<a name="l02697"></a>02697 
<a name="l02698"></a>02698 <span class="comment">/* GPFS QUOTACTL */</span>
<a name="l02699"></a>02699 
<a name="l02700"></a>02700 <span class="comment">/*</span>
<a name="l02701"></a>02701 <span class="comment"> * Command definitions for the &#39;gpfs_quotactl&#39; system call.</span>
<a name="l02702"></a>02702 <span class="comment"> * The commands are broken into a main command defined below</span>
<a name="l02703"></a>02703 <span class="comment"> * and a subcommand that is used to convey the type of</span>
<a name="l02704"></a>02704 <span class="comment"> * quota that is being manipulated (see above).</span>
<a name="l02705"></a>02705 <span class="comment"> */</span>
<a name="l02706"></a>02706 
<a name="l02707"></a><a class="code" href="gpfs_8h.html#a9f8cfc1f44c48ed79699e84ab121509e">02707</a> <span class="preprocessor">#define SUBCMDMASK      0x00ff</span>
<a name="l02708"></a><a class="code" href="gpfs_8h.html#a318a11f40b13b28db8a653562fd4de26">02708</a> <span class="preprocessor"></span><span class="preprocessor">#define SUBCMDSHIFT     8</span>
<a name="l02709"></a><a class="code" href="gpfs_8h.html#ac2b8a65f5e67611fdd9679137dc1eeda">02709</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_QCMD(cmd, type) (((cmd) &lt;&lt; SUBCMDSHIFT) | ((type) &amp; SUBCMDMASK))</span>
<a name="l02710"></a>02710 <span class="preprocessor"></span>
<a name="l02711"></a><a class="code" href="gpfs_8h.html#ab4abef932e949ed7e1fa541d0247afd3">02711</a> <span class="preprocessor">#define Q_QUOTAON       0x0100  </span><span class="comment">/* enable quotas */</span>
<a name="l02712"></a><a class="code" href="gpfs_8h.html#ae8beae314fe8eeba719c9bec0cd2dcde">02712</a> <span class="preprocessor">#define Q_QUOTAOFF      0x0200  </span><span class="comment">/* disable quotas */</span>
<a name="l02713"></a><a class="code" href="gpfs_8h.html#a16c74c59fd0bb764b5616c536b668a30">02713</a> <span class="preprocessor">#define Q_GETQUOTA      0x0300  </span><span class="comment">/* get limits and usage */</span>
<a name="l02714"></a>02714 <span class="preprocessor">#ifndef _LINUX_SOURCE_COMPAT</span>
<a name="l02715"></a>02715 <span class="preprocessor"></span>  <span class="comment">/* Standard AIX definitions of quota commands */</span>
<a name="l02716"></a><a class="code" href="gpfs_8h.html#a5bf478599df52ae18618de0823ead68b">02716</a> <span class="preprocessor">  #define Q_SETQUOTA    0x0400  </span><span class="comment">/* set limits */</span>
<a name="l02717"></a><a class="code" href="gpfs_8h.html#a4d90d0427a8705dc5a3db603d83093f2">02717</a> <span class="preprocessor">  #define Q_SETQLIM     Q_SETQUOTA</span>
<a name="l02718"></a>02718 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l02719"></a>02719 <span class="preprocessor"></span>  <span class="comment">/* Alternate definitions, for Linux Affinity */</span>
<a name="l02720"></a>02720 <span class="preprocessor">  #define Q_SETQLIM     0x0400  </span><span class="comment">/* set limits */</span>
<a name="l02721"></a>02721 <span class="preprocessor">  #define Q_SETQUOTA    0x0700  </span><span class="comment">/* set limits and usage */</span>
<a name="l02722"></a>02722 <span class="preprocessor">#endif</span>
<a name="l02723"></a><a class="code" href="gpfs_8h.html#a08c2d4261991d92731626b144f9e2b42">02723</a> <span class="preprocessor"></span><span class="preprocessor">#define Q_SETUSE        0x0500  </span><span class="comment">/* set usage */</span>
<a name="l02724"></a><a class="code" href="gpfs_8h.html#a868d9e11248570cd3555aadca051191e">02724</a> <span class="preprocessor">#define Q_SYNC          0x0600  </span><span class="comment">/* sync disk copy of a filesystems quotas */</span>
<a name="l02725"></a><a class="code" href="gpfs_8h.html#a70110f3b126f375e7281b03dd68eeb88">02725</a> <span class="preprocessor">#define Q_SETGRACETIME  0x0700  </span><span class="comment">/* set grace time */</span>
<a name="l02726"></a><a class="code" href="gpfs_8h.html#a9eea6def70d928c0962dc79ead8c8333">02726</a> <span class="preprocessor">#define Q_SETGRACETIME_ENHANCE  0x0800  </span><span class="comment">/* set grace time and update all</span>
<a name="l02727"></a>02727 <span class="comment">                                         * quota entries */</span>
<a name="l02728"></a>02728 
<a name="l02729"></a>02729 <span class="comment">/* gpfs quota types */</span>
<a name="l02730"></a><a class="code" href="gpfs_8h.html#a17eec015141af97f69578e9021c46120">02730</a> <span class="preprocessor">#define GPFS_USRQUOTA     0</span>
<a name="l02731"></a><a class="code" href="gpfs_8h.html#a2712051ef3e574f4eeb2b50db3bb5916">02731</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_GRPQUOTA     1</span>
<a name="l02732"></a><a class="code" href="gpfs_8h.html#a23c67b4a9b442b87b9419a12b3ce7c04">02732</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_FILESETQUOTA 2</span>
<a name="l02733"></a>02733 <span class="preprocessor"></span>
<a name="l02734"></a>02734 <span class="comment">/* define GPFS generated errno */</span>
<a name="l02735"></a><a class="code" href="gpfs_8h.html#af563442fc57054cd45c16abffa7d4db8">02735</a> <span class="preprocessor">#define GPFS_E_NO_QUOTA_INST  237 </span><span class="comment">/* file system does not support quotas */</span>
<a name="l02736"></a>02736 
<a name="l02737"></a><a class="code" href="structgpfs__quotaInfo.html">02737</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgpfs__quotaInfo.html">gpfs_quotaInfo</a>
<a name="l02738"></a>02738 {
<a name="l02739"></a><a class="code" href="structgpfs__quotaInfo.html#a93e79671259b77ad22ed71b7ca1fdd18">02739</a>   gpfs_off64_t <a class="code" href="structgpfs__quotaInfo.html#a93e79671259b77ad22ed71b7ca1fdd18">blockUsage</a>;      <span class="comment">/* current block count in 1 KB units*/</span>
<a name="l02740"></a><a class="code" href="structgpfs__quotaInfo.html#a01afbb1c3e4ba7dd650e3989335b28a2">02740</a>   gpfs_off64_t <a class="code" href="structgpfs__quotaInfo.html#a01afbb1c3e4ba7dd650e3989335b28a2">blockHardLimit</a>;  <span class="comment">/* absolute limit on disk blks alloc */</span>
<a name="l02741"></a><a class="code" href="structgpfs__quotaInfo.html#a80d2b7a3f9cf8c01b37c0632f1e67412">02741</a>   gpfs_off64_t <a class="code" href="structgpfs__quotaInfo.html#a80d2b7a3f9cf8c01b37c0632f1e67412">blockSoftLimit</a>;  <span class="comment">/* preferred limit on disk blks */</span>
<a name="l02742"></a><a class="code" href="structgpfs__quotaInfo.html#ab2cddca37698c5fe45c4921d7ca8501f">02742</a>   gpfs_off64_t <a class="code" href="structgpfs__quotaInfo.html#ab2cddca37698c5fe45c4921d7ca8501f">blockInDoubt</a>;    <span class="comment">/* distributed shares + &quot;lost&quot; usage for blks */</span>
<a name="l02743"></a><a class="code" href="structgpfs__quotaInfo.html#aa9aa99b37257c8585d90b1d31dd2b19f">02743</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__quotaInfo.html#aa9aa99b37257c8585d90b1d31dd2b19f">inodeUsage</a>;      <span class="comment">/* current # allocated inodes */</span>
<a name="l02744"></a><a class="code" href="structgpfs__quotaInfo.html#a5c8624e0151e6a3d58241deb2825120e">02744</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__quotaInfo.html#a5c8624e0151e6a3d58241deb2825120e">inodeHardLimit</a>;  <span class="comment">/* absolute limit on allocated inodes */</span>
<a name="l02745"></a><a class="code" href="structgpfs__quotaInfo.html#aa24de0edda65f842a5c258cf4f761495">02745</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__quotaInfo.html#aa24de0edda65f842a5c258cf4f761495">inodeSoftLimit</a>;  <span class="comment">/* preferred inode limit */</span>
<a name="l02746"></a><a class="code" href="structgpfs__quotaInfo.html#ade8a97fdfb6a67511aeb64c077d53216">02746</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__quotaInfo.html#ade8a97fdfb6a67511aeb64c077d53216">inodeInDoubt</a>;    <span class="comment">/* distributed shares + &quot;lost&quot; usage for inodes */</span>
<a name="l02747"></a><a class="code" href="structgpfs__quotaInfo.html#a552ca6402e68e6899a4debcb3d20720b">02747</a>   gpfs_uid_t   <a class="code" href="structgpfs__quotaInfo.html#a552ca6402e68e6899a4debcb3d20720b">quoId</a>;           <span class="comment">/* uid, gid or fileset id */</span>
<a name="l02748"></a><a class="code" href="structgpfs__quotaInfo.html#a3668484f339fe471e72aab96c21ceb0e">02748</a>   <span class="keywordtype">int</span>          <a class="code" href="structgpfs__quotaInfo.html#a3668484f339fe471e72aab96c21ceb0e">entryType</a>;       <span class="comment">/* entry type, not used */</span>
<a name="l02749"></a><a class="code" href="structgpfs__quotaInfo.html#a913fba82784b254f6c66df01d268e897">02749</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__quotaInfo.html#a913fba82784b254f6c66df01d268e897">blockGraceTime</a>;  <span class="comment">/* time limit for excessive disk use */</span>
<a name="l02750"></a><a class="code" href="structgpfs__quotaInfo.html#a3249be8fb56d741c01a70e42eb41a128">02750</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structgpfs__quotaInfo.html#a3249be8fb56d741c01a70e42eb41a128">inodeGraceTime</a>;  <span class="comment">/* time limit for excessive inode use */</span>
<a name="l02751"></a>02751 } <a class="code" href="gpfs_8h.html#a41974da665fee5eec7a16d5b6b125b1d">gpfs_quotaInfo_t</a>;
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 
<a name="l02754"></a>02754 <span class="comment">/* NAME:        gpfs_quotactl()</span>
<a name="l02755"></a>02755 <span class="comment"> *</span>
<a name="l02756"></a>02756 <span class="comment"> * FUNCTION:    Manipulate disk quotas</span>
<a name="l02757"></a>02757 <span class="comment"> * INPUT:       pathname: specifies the pathname of any file within the</span>
<a name="l02758"></a>02758 <span class="comment"> *                        mounted file system to which the command is to</span>
<a name="l02759"></a>02759 <span class="comment"> *                        be applied</span>
<a name="l02760"></a>02760 <span class="comment"> *              cmd: specifies a quota control command to be applied</span>
<a name="l02761"></a>02761 <span class="comment"> *                   to UID/GID/FILESETID id. The cmd parameter can be</span>
<a name="l02762"></a>02762 <span class="comment"> *                   constructed using GPFS_QCMD(cmd, type) macro defined</span>
<a name="l02763"></a>02763 <span class="comment"> *                   in gpfs.h</span>
<a name="l02764"></a>02764 <span class="comment"> *              id:  UID or GID or FILESETID that command applied to.</span>
<a name="l02765"></a>02765 <span class="comment"> *              bufferP: points to the address of an optional, command</span>
<a name="l02766"></a>02766 <span class="comment"> *                       specific, data structure that is copied in or out of</span>
<a name="l02767"></a>02767 <span class="comment"> *                       the system.</span>
<a name="l02768"></a>02768 <span class="comment"> *</span>
<a name="l02769"></a>02769 <span class="comment"> * OUTPUT:      bufferP, if applicable.</span>
<a name="l02770"></a>02770 <span class="comment"> *</span>
<a name="l02771"></a>02771 <span class="comment"> * Returns:     0 success</span>
<a name="l02772"></a>02772 <span class="comment"> *              -1 failure</span>
<a name="l02773"></a>02773 <span class="comment"> *</span>
<a name="l02774"></a>02774 <span class="comment"> * Errno:       EACCESS</span>
<a name="l02775"></a>02775 <span class="comment"> *              EFAULT        An invalid bufferP parameter is supplied;</span>
<a name="l02776"></a>02776 <span class="comment"> *                            the associated structure could not be copied</span>
<a name="l02777"></a>02777 <span class="comment"> *                            in or out of the kernel</span>
<a name="l02778"></a>02778 <span class="comment"> *              EINVAL</span>
<a name="l02779"></a>02779 <span class="comment"> *              ENOENT        No such file or directory</span>
<a name="l02780"></a>02780 <span class="comment"> *              EPERM         The quota control command is privileged and</span>
<a name="l02781"></a>02781 <span class="comment"> *                            the caller did not have root user authority</span>
<a name="l02782"></a>02782 <span class="comment"> *              EOPNOTSUPP</span>
<a name="l02783"></a>02783 <span class="comment"> *              GPFS_E_NO_QUOTA_INST The file system does not support quotas</span>
<a name="l02784"></a>02784 <span class="comment"> */</span>
<a name="l02785"></a>02785 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02786"></a>02786 <a class="code" href="gpfs_8h.html#a2a436dc4494daa86b21cdb8309a0385c">gpfs_quotactl</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l02787"></a>02787               <span class="keywordtype">int</span> cmd,
<a name="l02788"></a>02788               <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l02789"></a>02789               <span class="keywordtype">void</span> *bufferP);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791 
<a name="l02792"></a>02792 <span class="comment">/* NAME:        gpfs_getfilesetid()</span>
<a name="l02793"></a>02793 <span class="comment"> *</span>
<a name="l02794"></a>02794 <span class="comment"> * FUNCTION:    Translate FilesetName to FilesetID</span>
<a name="l02795"></a>02795 <span class="comment"> *</span>
<a name="l02796"></a>02796 <span class="comment"> * INPUT:       pathname: specifies the pathname of any file within the</span>
<a name="l02797"></a>02797 <span class="comment"> *                        mounted file system to which the command is to</span>
<a name="l02798"></a>02798 <span class="comment"> *                        be applied</span>
<a name="l02799"></a>02799 <span class="comment"> *              name: name of the fileset</span>
<a name="l02800"></a>02800 <span class="comment"> *</span>
<a name="l02801"></a>02801 <span class="comment"> * OUTPUT:      idP:  points to the address of an integer that receives the ID</span>
<a name="l02802"></a>02802 <span class="comment"> *</span>
<a name="l02803"></a>02803 <span class="comment"> * Returns:     0 success</span>
<a name="l02804"></a>02804 <span class="comment"> *              -1 failure</span>
<a name="l02805"></a>02805 <span class="comment"> *</span>
<a name="l02806"></a>02806 <span class="comment"> * Errno:       EACCESS</span>
<a name="l02807"></a>02807 <span class="comment"> *              EFAULT        An invalid pointer is supplied; the associated</span>
<a name="l02808"></a>02808 <span class="comment"> *                            data could not be copied in or out of the kernel</span>
<a name="l02809"></a>02809 <span class="comment"> *              EINVAL</span>
<a name="l02810"></a>02810 <span class="comment"> *              ENOENT        No such file, directory or fileset</span>
<a name="l02811"></a>02811 <span class="comment"> */</span>
<a name="l02812"></a>02812 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02813"></a>02813 <a class="code" href="gpfs_8h.html#ac79f1c8f70b79946da0b85172c416358">gpfs_getfilesetid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pathname,
<a name="l02814"></a>02814                   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="mount_8h.html#a2946c588fc7fa2fa5b43ac54b7872725">name</a>,
<a name="l02815"></a>02815                   <span class="keywordtype">int</span> *idP);
<a name="l02816"></a>02816 
<a name="l02817"></a>02817 
<a name="l02818"></a>02818 <span class="comment">/* NAME:        gpfs_clone_snap()</span>
<a name="l02819"></a>02819 <span class="comment"> *</span>
<a name="l02820"></a>02820 <span class="comment"> * FUNCTION:    Create an immutable clone parent from a source file</span>
<a name="l02821"></a>02821 <span class="comment"> *</span>
<a name="l02822"></a>02822 <span class="comment"> * Input:       sourcePathP:  path to source file, which will be cloned</span>
<a name="l02823"></a>02823 <span class="comment"> *              destPathP:    path to destination file, to be created</span>
<a name="l02824"></a>02824 <span class="comment"> *</span>
<a name="l02825"></a>02825 <span class="comment"> *              If destPathP is NULL, then the source file will be changed</span>
<a name="l02826"></a>02826 <span class="comment"> *              in place into an immutable clone parent.</span>
<a name="l02827"></a>02827 <span class="comment"> *</span>
<a name="l02828"></a>02828 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02829"></a>02829 <span class="comment"> *              -1      Failure</span>
<a name="l02830"></a>02830 <span class="comment"> *</span>
<a name="l02831"></a>02831 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l02832"></a>02832 <span class="comment"> *              ENOENT  File does not exist</span>
<a name="l02833"></a>02833 <span class="comment"> *              EACCESS Write access to target or source search permission denied</span>
<a name="l02834"></a>02834 <span class="comment"> *              EINVAL  Not a regular file or not a GPFS filesystem</span>
<a name="l02835"></a>02835 <span class="comment"> *              EFAULT  Input argument points outside accessible address space</span>
<a name="l02836"></a>02836 <span class="comment"> *              ENAMETOOLONG  Source or destination path name too long</span>
<a name="l02837"></a>02837 <span class="comment"> *              ENOSPC  Not enough space on disk</span>
<a name="l02838"></a>02838 <span class="comment"> *              EISDIR  Destination is a directory</span>
<a name="l02839"></a>02839 <span class="comment"> *              EXDEV   Source and destination aren&#39;t in the same filesystem</span>
<a name="l02840"></a>02840 <span class="comment"> */</span>
<a name="l02841"></a>02841 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02842"></a>02842 <a class="code" href="gpfs_8h.html#abf12c7a88d4fc82430e39c2a09c1a0ea">gpfs_clone_snap</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *sourcePathP, <span class="keyword">const</span> <span class="keywordtype">char</span> *destPathP);
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 <span class="comment">/* NAME:        gpfs_clone_copy()</span>
<a name="l02845"></a>02845 <span class="comment"> *</span>
<a name="l02846"></a>02846 <span class="comment"> * FUNCTION:    Create a clone copy of an immutable clone parent file</span>
<a name="l02847"></a>02847 <span class="comment"> *</span>
<a name="l02848"></a>02848 <span class="comment"> * Input:       sourcePathP:  path to immutable source file, to be cloned</span>
<a name="l02849"></a>02849 <span class="comment"> *              destPathP:    path to destination file, to be created</span>
<a name="l02850"></a>02850 <span class="comment"> *</span>
<a name="l02851"></a>02851 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02852"></a>02852 <span class="comment"> *              -1      Failure</span>
<a name="l02853"></a>02853 <span class="comment"> *</span>
<a name="l02854"></a>02854 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l02855"></a>02855 <span class="comment"> *              ENOENT  File does not exist</span>
<a name="l02856"></a>02856 <span class="comment"> *              EACCESS Write access to target or source search permission denied</span>
<a name="l02857"></a>02857 <span class="comment"> *              EINVAL  Not a regular file or not a GPFS filesystem</span>
<a name="l02858"></a>02858 <span class="comment"> *              EFAULT  Input argument points outside accessible address space</span>
<a name="l02859"></a>02859 <span class="comment"> *              ENAMETOOLONG  Source or destination path name too long</span>
<a name="l02860"></a>02860 <span class="comment"> *              ENOSPC  Not enough space on disk</span>
<a name="l02861"></a>02861 <span class="comment"> *              EISDIR  Destination is a directory</span>
<a name="l02862"></a>02862 <span class="comment"> *              EXDEV   Source and destination aren&#39;t in the same filesystem</span>
<a name="l02863"></a>02863 <span class="comment"> */</span>
<a name="l02864"></a>02864 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02865"></a>02865 <a class="code" href="gpfs_8h.html#a7bb105cae92d2b64cdf718bd67698d2c">gpfs_clone_copy</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *sourcePathP, <span class="keyword">const</span> <span class="keywordtype">char</span> *destPathP);
<a name="l02866"></a>02866 
<a name="l02867"></a>02867 
<a name="l02868"></a>02868 <span class="comment">/* NAME:        gpfs_declone()</span>
<a name="l02869"></a>02869 <span class="comment"> *</span>
<a name="l02870"></a>02870 <span class="comment"> * FUNCTION:    Copy blocks from clone parent(s) to child so that the</span>
<a name="l02871"></a>02871 <span class="comment"> *              parent blocks are no longer referenced by the child.</span>
<a name="l02872"></a>02872 <span class="comment"> *</span>
<a name="l02873"></a>02873 <span class="comment"> * Input:       fileDesc:  File descriptor for file to be de-cloned</span>
<a name="l02874"></a>02874 <span class="comment"> *              ancLimit:  Ancestor limit (immediate parent only, or all)</span>
<a name="l02875"></a>02875 <span class="comment"> *              nBlocks:   Maximum number of GPFS blocks to copy</span>
<a name="l02876"></a>02876 <span class="comment"> * In/Out:      offsetP:   Pointer to starting offset within file (will be</span>
<a name="l02877"></a>02877 <span class="comment"> *                         updated to offset of next block to process or</span>
<a name="l02878"></a>02878 <span class="comment"> *                         -1 if no more blocks)</span>
<a name="l02879"></a>02879 <span class="comment"> *</span>
<a name="l02880"></a>02880 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02881"></a>02881 <span class="comment"> *              -1      Failure</span>
<a name="l02882"></a>02882 <span class="comment"> *</span>
<a name="l02883"></a>02883 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l02884"></a>02884 <span class="comment"> *              EINVAL  Invalid argument to function</span>
<a name="l02885"></a>02885 <span class="comment"> *              EBADF   Bad file descriptor or not a GPFS file</span>
<a name="l02886"></a>02886 <span class="comment"> *              EPERM   Not a regular file</span>
<a name="l02887"></a>02887 <span class="comment"> *              EACCESS Write access to target file not permitted</span>
<a name="l02888"></a>02888 <span class="comment"> *              EFAULT  Input argument points outside accessible address space</span>
<a name="l02889"></a>02889 <span class="comment"> *              ENOSPC  Not enough space on disk</span>
<a name="l02890"></a>02890 <span class="comment"> */</span>
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 <span class="comment">/* Values for ancLimit */</span>
<a name="l02893"></a><a class="code" href="gpfs_8h.html#aa2a554864e0ccbba983993df5385260d">02893</a> <span class="preprocessor">#define GPFS_CLONE_ALL         0</span>
<a name="l02894"></a><a class="code" href="gpfs_8h.html#a1eb9c5d2f84538d0ed27d4d03d0dcfa7">02894</a> <span class="preprocessor"></span><span class="preprocessor">#define GPFS_CLONE_PARENT_ONLY 1</span>
<a name="l02895"></a>02895 <span class="preprocessor"></span>
<a name="l02896"></a>02896 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02897"></a>02897 <a class="code" href="gpfs_8h.html#aca2bd7d5a1e6f0930ebb18a5345a8ec6">gpfs_declone</a>(gpfs_file_t fileDesc, <span class="keywordtype">int</span> ancLimit, gpfs_off64_t nBlocks,
<a name="l02898"></a>02898              gpfs_off64_t *offsetP);
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 <span class="comment">/* NAME:        gpfs_clone_split()</span>
<a name="l02901"></a>02901 <span class="comment"> *</span>
<a name="l02902"></a>02902 <span class="comment"> * FUNCTION:    Split a clone child file from its parent.  Must call</span>
<a name="l02903"></a>02903 <span class="comment"> *              gpfs_declone first, to remove all references.</span>
<a name="l02904"></a>02904 <span class="comment"> *</span>
<a name="l02905"></a>02905 <span class="comment"> * Input:       fileDesc:  File descriptor for file to be split</span>
<a name="l02906"></a>02906 <span class="comment"> *              ancLimit:  Ancestor limit (immediate parent only, or all)</span>
<a name="l02907"></a>02907 <span class="comment"> *</span>
<a name="l02908"></a>02908 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02909"></a>02909 <span class="comment"> *              -1      Failure</span>
<a name="l02910"></a>02910 <span class="comment"> *</span>
<a name="l02911"></a>02911 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l02912"></a>02912 <span class="comment"> *              EINVAL  Invalid argument to function</span>
<a name="l02913"></a>02913 <span class="comment"> *              EBADF   Bad file descriptor or not a GPFS file</span>
<a name="l02914"></a>02914 <span class="comment"> *              EPERM   Not a regular file or not a clone child</span>
<a name="l02915"></a>02915 <span class="comment"> *              EACCESS Write access to target file not permitted</span>
<a name="l02916"></a>02916 <span class="comment"> */</span>
<a name="l02917"></a>02917 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02918"></a>02918 <a class="code" href="gpfs_8h.html#a778870f3410a9ba95c03b237fa198049">gpfs_clone_split</a>(gpfs_file_t fileDesc, <span class="keywordtype">int</span> ancLimit);
<a name="l02919"></a>02919 
<a name="l02920"></a>02920 <span class="comment">/* NAME:        gpfs_clone_unsnap()</span>
<a name="l02921"></a>02921 <span class="comment"> *</span>
<a name="l02922"></a>02922 <span class="comment"> * FUNCTION:    Change a clone parent with no children back into a</span>
<a name="l02923"></a>02923 <span class="comment"> *              normal file.</span>
<a name="l02924"></a>02924 <span class="comment"> *</span>
<a name="l02925"></a>02925 <span class="comment"> * Input:       fileDesc:  File descriptor for file to be un-snapped</span>
<a name="l02926"></a>02926 <span class="comment"> *</span>
<a name="l02927"></a>02927 <span class="comment"> * Returns:     0       Successful</span>
<a name="l02928"></a>02928 <span class="comment"> *              -1      Failure</span>
<a name="l02929"></a>02929 <span class="comment"> *</span>
<a name="l02930"></a>02930 <span class="comment"> * Errno:       ENOSYS  Function not available</span>
<a name="l02931"></a>02931 <span class="comment"> *              EINVAL  Invalid argument to function</span>
<a name="l02932"></a>02932 <span class="comment"> *              EBADF   Bad file descriptor or not a GPFS file</span>
<a name="l02933"></a>02933 <span class="comment"> *              EPERM   Not a regular file or not a clone parent</span>
<a name="l02934"></a>02934 <span class="comment"> *              EACCESS Write access to target file not permitted</span>
<a name="l02935"></a>02935 <span class="comment"> */</span>
<a name="l02936"></a>02936 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02937"></a>02937 <a class="code" href="gpfs_8h.html#a2b9ee62b5c812c8c6a7f13faddff1543">gpfs_clone_unsnap</a>(gpfs_file_t fileDesc);
<a name="l02938"></a>02938 
<a name="l02939"></a>02939 <span class="comment">/* NAME:       gpfs_get_fset_masks()</span>
<a name="l02940"></a>02940 <span class="comment"> *</span>
<a name="l02941"></a>02941 <span class="comment"> * FUNCTION:   return bit masks governing &quot;external&quot; inode and inode-space numbering</span>
<a name="l02942"></a>02942 <span class="comment"> *</span>
<a name="l02943"></a>02943 <span class="comment"> * Input:      fset_snaphandle: ptr to an fset snaphandle</span>
<a name="l02944"></a>02944 <span class="comment"> * Output:     the bit masks and inodes per block factor.</span>
<a name="l02945"></a>02945 <span class="comment"> *</span>
<a name="l02946"></a>02946 <span class="comment"> * Returns:    0       Success</span>
<a name="l02947"></a>02947 <span class="comment"> *            -1       Failure</span>
<a name="l02948"></a>02948 <span class="comment"> *</span>
<a name="l02949"></a>02949 <span class="comment"> * Errno:       ENOSYS function not available</span>
<a name="l02950"></a>02950 <span class="comment"> *              GPFS_E_INVAL_FSSNAPHANDLE invalid fssnapHandle</span>
<a name="l02951"></a>02951 <span class="comment"> */</span>
<a name="l02952"></a>02952 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l02953"></a>02953 <a class="code" href="gpfs_8h.html#a31002ad894f09fb5b85dfa1b1717de1b">gpfs_get_fset_masks</a>(<a class="code" href="gpfs_8h.html#a040757fa5024032c0e6b42c58ff1ae0d">gpfs_fssnap_handle_t</a>* fset_snapHandle,
<a name="l02954"></a>02954                     gpfs_ino64_t* inodeSpaceMask,
<a name="l02955"></a>02955                     gpfs_ino64_t* inodeBlockMask,
<a name="l02956"></a>02956                     <span class="keywordtype">int</span>* inodesPerInodeBlock);
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 
<a name="l02959"></a>02959 <span class="comment">/*</span>
<a name="l02960"></a>02960 <span class="comment">   API functions for Light Weight Event</span>
<a name="l02961"></a>02961 <span class="comment">*/</span>
<a name="l02962"></a>02962 <span class="preprocessor">#include &lt;<a class="code" href="gpfs__lweTypes_8h.html">gpfs_lweTypes.h</a>&gt;</span>
<a name="l02963"></a>02963 
<a name="l02964"></a>02964 <span class="comment">/* NAME:       gpfs_lweCreateSession()</span>
<a name="l02965"></a>02965 <span class="comment"> *</span>
<a name="l02966"></a>02966 <span class="comment"> * FUNCTION:   create a light weight event session</span>
<a name="l02967"></a>02967 <span class="comment"> *</span>
<a name="l02968"></a>02968 <span class="comment"> * Input:      oldsid: existing session id, </span>
<a name="l02969"></a>02969 <span class="comment">                       INVALID_SID for create a new session,</span>
<a name="l02970"></a>02970 <span class="comment">                       valid sid for resume an existing session</span>
<a name="l02971"></a>02971 <span class="comment">               sessinfop: session string, unique for each session</span>
<a name="l02972"></a>02972 <span class="comment"> *             </span>
<a name="l02973"></a>02973 <span class="comment"> * Output:     newsidp: session id for new session</span>
<a name="l02974"></a>02974 <span class="comment"> *</span>
<a name="l02975"></a>02975 <span class="comment"> * Returns:    0       Success</span>
<a name="l02976"></a>02976 <span class="comment"> *            -1       Failure</span>
<a name="l02977"></a>02977 <span class="comment"> *</span>
<a name="l02978"></a>02978 <span class="comment"> * Errno:       EINVAL oldsid and sessinfop mismatch</span>
<a name="l02979"></a>02979 <span class="comment"> *              EEXIST session with the same name already exists, can not create.</span>
<a name="l02980"></a>02980 <span class="comment"> */</span>
<a name="l02981"></a>02981 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a> 
<a name="l02982"></a>02982 <a class="code" href="gpfs_8h.html#ade885e61ecd9868acca33395feaadf3e">gpfs_lweCreateSession</a>(<a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>   oldsid,        <span class="comment">/* IN */</span>
<a name="l02983"></a>02983                       <span class="keywordtype">char</span>          *sessinfop,     <span class="comment">/* IN */</span>
<a name="l02984"></a>02984                       <a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>  *newsidp        <span class="comment">/* OUT */</span>
<a name="l02985"></a>02985                       );
<a name="l02986"></a>02986 
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="comment">/* NAME:       gpfs_lweDestroySession()</span>
<a name="l02989"></a>02989 <span class="comment"> *</span>
<a name="l02990"></a>02990 <span class="comment"> * FUNCTION:   destroy a light weight event session</span>
<a name="l02991"></a>02991 <span class="comment"> *</span>
<a name="l02992"></a>02992 <span class="comment"> * Input:      sid: id of the session to be destroyed</span>
<a name="l02993"></a>02993 <span class="comment"> *</span>
<a name="l02994"></a>02994 <span class="comment"> * Returns:    0       Success</span>
<a name="l02995"></a>02995 <span class="comment"> *             EINVAL sid invalid</span>
<a name="l02996"></a>02996 <span class="comment"> *             EBUSY  session is busy </span>
<a name="l02997"></a>02997 <span class="comment"> */</span>
<a name="l02998"></a>02998 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a> 
<a name="l02999"></a>02999 <a class="code" href="gpfs_8h.html#a0cce2703d2d9e82b9df0b2d0a8e77a3c">gpfs_lweDestroySession</a>(<a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a> sid);         <span class="comment">/* IN */</span>
<a name="l03000"></a>03000 
<a name="l03001"></a>03001 <span class="comment">/* NAME:       gpfs_lweGetAllSessions()</span>
<a name="l03002"></a>03002 <span class="comment"> *</span>
<a name="l03003"></a>03003 <span class="comment"> * FUNCTION:   fetch all lwe sessions</span>
<a name="l03004"></a>03004 <span class="comment"> *</span>
<a name="l03005"></a>03005 <span class="comment"> * Input:      nelem:   max number of elements</span>
<a name="l03006"></a>03006 <span class="comment">               sidbufp: array of session id</span>
<a name="l03007"></a>03007 <span class="comment">               nelemp:  number of session returned in sidbufp</span>
<a name="l03008"></a>03008 <span class="comment"> *</span>
<a name="l03009"></a>03009 <span class="comment"> * Returns:    0       Success</span>
<a name="l03010"></a>03010 <span class="comment"> *             EINVAL pass in args invalid</span>
<a name="l03011"></a>03011 <span class="comment"> *             E2BIG  information is too large</span>
<a name="l03012"></a>03012 <span class="comment"> */</span>
<a name="l03013"></a>03013 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a> 
<a name="l03014"></a>03014 <a class="code" href="gpfs_8h.html#a4d1ff3c7c70185b3294b511429929635">gpfs_lweGetAllSessions</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   nelem,      <span class="comment">/* IN */</span>
<a name="l03015"></a>03015                        <a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>  *sidbufp,    <span class="comment">/* OUT */</span>
<a name="l03016"></a>03016                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  *nelemp);    <span class="comment">/* OUT */</span>
<a name="l03017"></a>03017 
<a name="l03018"></a>03018 <span class="comment">/* NAME:       gpfs_lweQuerySession()</span>
<a name="l03019"></a>03019 <span class="comment"> *</span>
<a name="l03020"></a>03020 <span class="comment"> * FUNCTION:   query session string by id </span>
<a name="l03021"></a>03021 <span class="comment"> *</span>
<a name="l03022"></a>03022 <span class="comment"> * Input:      sid:    id of session to be queryed</span>
<a name="l03023"></a>03023 <span class="comment">               buflen: length of buffer</span>
<a name="l03024"></a>03024 <span class="comment">               bufp:   buffer to store sessions string</span>
<a name="l03025"></a>03025 <span class="comment">               rlenp:  returned length of bufp</span>
<a name="l03026"></a>03026 <span class="comment"> *</span>
<a name="l03027"></a>03027 <span class="comment"> * Returns:    0       Success</span>
<a name="l03028"></a>03028 <span class="comment"> *             EINVAL  pass in args invalid</span>
<a name="l03029"></a>03029 <span class="comment"> *             E2BIG   information is too large</span>
<a name="l03030"></a>03030 <span class="comment"> */</span>
<a name="l03031"></a>03031 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a> 
<a name="l03032"></a>03032 <a class="code" href="gpfs_8h.html#af6d7dbd254b163cbd79366c72acd3b23">gpfs_lweQuerySession</a>(<a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>   sid,     <span class="comment">/* IN */</span>
<a name="l03033"></a>03033                      <span class="keywordtype">size_t</span>         buflen,  <span class="comment">/* IN */</span>
<a name="l03034"></a>03034                      <span class="keywordtype">void</span>          *bufp,    <span class="comment">/* OUT */</span>
<a name="l03035"></a>03035                      <span class="keywordtype">size_t</span>        *rlenP);  <span class="comment">/* OUT */</span>
<a name="l03036"></a>03036 
<a name="l03037"></a>03037 <span class="comment">/* NAME:       gpfs_lweGetEvents()</span>
<a name="l03038"></a>03038 <span class="comment"> *</span>
<a name="l03039"></a>03039 <span class="comment"> * FUNCTION:   get events from a light weight session</span>
<a name="l03040"></a>03040 <span class="comment"> *</span>
<a name="l03041"></a>03041 <span class="comment"> * Input:      sid:     id of the session</span>
<a name="l03042"></a>03042 <span class="comment"> *             maxmsgs: max number of event to fetch, </span>
<a name="l03043"></a>03043 <span class="comment"> *                      0 to fetch all possible</span>
<a name="l03044"></a>03044 <span class="comment"> *             flags:   LWE_EV_WAIT: waiting for new events if event</span>
<a name="l03045"></a>03045 <span class="comment"> *                      queue is empty</span>
<a name="l03046"></a>03046 <span class="comment"> *             buflen:  length of the buffer</span>
<a name="l03047"></a>03047 <span class="comment"> *             bufp:    buffer to hold events</span>
<a name="l03048"></a>03048 <span class="comment"> *             rlenp:   returned length of bufp</span>
<a name="l03049"></a>03049 <span class="comment"> *</span>
<a name="l03050"></a>03050 <span class="comment"> * Returns:    0        Success</span>
<a name="l03051"></a>03051 <span class="comment"> *             E2BIG    information is too large</span>
<a name="l03052"></a>03052 <span class="comment"> *             EINVAL   pass in args invalid</span>
<a name="l03053"></a>03053 <span class="comment"> */</span>
<a name="l03054"></a>03054 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l03055"></a>03055 <a class="code" href="gpfs_8h.html#a30b2fa7ea78622fd20478488ea66b0ac">gpfs_lweGetEvents</a>(<a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>  sid,     <span class="comment">/* IN  */</span>
<a name="l03056"></a>03056                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  maxmsgs, <span class="comment">/* IN  */</span>
<a name="l03057"></a>03057                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  flags,   <span class="comment">/* IN  */</span>
<a name="l03058"></a>03058                   <span class="keywordtype">size_t</span>        buflen,  <span class="comment">/* IN  */</span>
<a name="l03059"></a>03059                   <span class="keywordtype">void</span>         *bufp,    <span class="comment">/* OUT */</span>
<a name="l03060"></a>03060                   <span class="keywordtype">size_t</span>       *rlenp);  <span class="comment">/* OUT */</span>
<a name="l03061"></a>03061 
<a name="l03062"></a>03062 <span class="comment">/* NAME:      gpfs_lweRespondEvent()</span>
<a name="l03063"></a>03063 <span class="comment"> *</span>
<a name="l03064"></a>03064 <span class="comment"> * FUNCTION:  response to a light weight event</span>
<a name="l03065"></a>03065 <span class="comment"> *</span>
<a name="l03066"></a>03066 <span class="comment"> * Input:     sid:      id of the session</span>
<a name="l03067"></a>03067 <span class="comment"> *            token:    token of the event</span>
<a name="l03068"></a>03068 <span class="comment"> *            response: response to the event</span>
<a name="l03069"></a>03069 <span class="comment"> *            reterror: return error to event callers</span>
<a name="l03070"></a>03070 <span class="comment"> *</span>
<a name="l03071"></a>03071 <span class="comment"> * Returns:   0         Success</span>
<a name="l03072"></a>03072 <span class="comment"> *            EINVAL    pass in args invalid</span>
<a name="l03073"></a>03073 <span class="comment"> *</span>
<a name="l03074"></a>03074 <span class="comment"> */</span>
<a name="l03075"></a>03075 <span class="keywordtype">int</span> <a class="code" href="gpfs_8h.html#a49355aa9d81891b853317bab921d8f30">GPFS_API</a>
<a name="l03076"></a>03076 <a class="code" href="gpfs_8h.html#a4f66f26147eab8f35bcb4425c04bd2fd">gpfs_lweRespondEvent</a>(<a class="code" href="gpfs__lweTypes_8h.html#a76cdf81b92b06bfafa5f30ef64932b9d">lwe_sessid_t</a>   sid,       <span class="comment">/* IN */</span>
<a name="l03077"></a>03077                      <a class="code" href="gpfs__lweTypes_8h.html#a5ae99e55bffcc0462335c5c1ba77d879">lwe_token_t</a>    token,     <span class="comment">/* IN */</span>
<a name="l03078"></a>03078                      <a class="code" href="gpfs__lweTypes_8h.html#a49f9c60c6d49c0b4ed58c8964c33062f">lwe_resp_t</a>     response,  <span class="comment">/* IN */</span>
<a name="l03079"></a>03079                      <span class="keywordtype">int</span>            reterror); <span class="comment">/* IN */</span>
<a name="l03080"></a>03080 
<a name="l03081"></a>03081 
<a name="l03082"></a>03082 <span class="comment">/* </span>
<a name="l03083"></a>03083 <span class="comment"> * When GPFS_64BIT_INODES is defined, use the 64-bit interface definitions as</span>
<a name="l03084"></a>03084 <span class="comment"> * the default.</span>
<a name="l03085"></a>03085 <span class="comment"> */</span>
<a name="l03086"></a>03086 
<a name="l03087"></a>03087 <span class="preprocessor">#ifdef GPFS_64BIT_INODES</span>
<a name="l03088"></a>03088 <span class="preprocessor"></span><span class="preprocessor">  #undef  GPFS_D_VERSION</span>
<a name="l03089"></a>03089 <span class="preprocessor"></span><span class="preprocessor">  #define GPFS_D_VERSION GPFS_D64_VERSION</span>
<a name="l03090"></a>03090 <span class="preprocessor"></span><span class="preprocessor">  #undef  GPFS_IA_VERSION</span>
<a name="l03091"></a>03091 <span class="preprocessor"></span><span class="preprocessor">  #define GPFS_IA_VERSION GPFS_IA64_VERSION</span>
<a name="l03092"></a>03092 <span class="preprocessor"></span>
<a name="l03093"></a>03093 <span class="preprocessor">  #define gpfs_ino_t gpfs_ino64_t</span>
<a name="l03094"></a>03094 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_gen_t gpfs_gen64_t</span>
<a name="l03095"></a>03095 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_uid_t gpfs_uid64_t</span>
<a name="l03096"></a>03096 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_gid_t gpfs_gid64_t</span>
<a name="l03097"></a>03097 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_snapid_t gpfs_snapid64_t</span>
<a name="l03098"></a>03098 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_nlink_t gpfs_nlink64_t</span>
<a name="l03099"></a>03099 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_timestruc_t gpfs_timestruc64_t</span>
<a name="l03100"></a>03100 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_direntx_t gpfs_direntx64_t</span>
<a name="l03101"></a>03101 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_direntx gpfs_direntx64</span>
<a name="l03102"></a>03102 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_iattr_t gpfs_iattr64_t</span>
<a name="l03103"></a>03103 <span class="preprocessor"></span>
<a name="l03104"></a>03104 <span class="preprocessor">  #define gpfs_get_snapid_from_fssnaphandle gpfs_get_snapid_from_fssnaphandle64</span>
<a name="l03105"></a>03105 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_open_inodescan gpfs_open_inodescan64</span>
<a name="l03106"></a>03106 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_open_inodescan_with_xattrs gpfs_open_inodescan_with_xattrs64</span>
<a name="l03107"></a>03107 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_next_inode gpfs_next_inode64</span>
<a name="l03108"></a>03108 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_next_inode_with_xattrs gpfs_next_inode_with_xattrs64</span>
<a name="l03109"></a>03109 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_seek_inode gpfs_seek_inode64</span>
<a name="l03110"></a>03110 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_stat_inode gpfs_stat_inode64</span>
<a name="l03111"></a>03111 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_stat_inode_with_xattrs gpfs_stat_inode_with_xattrs64</span>
<a name="l03112"></a>03112 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_iopen gpfs_iopen64</span>
<a name="l03113"></a>03113 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_ireaddir gpfs_ireaddir64</span>
<a name="l03114"></a>03114 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_ireaddirx gpfs_ireaddirx64</span>
<a name="l03115"></a>03115 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_iwritedir gpfs_iwritedir64</span>
<a name="l03116"></a>03116 <span class="preprocessor"></span><span class="preprocessor">  #define gpfs_ireadlink gpfs_ireadlink64</span>
<a name="l03117"></a>03117 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03118"></a>03118 <span class="preprocessor"></span>
<a name="l03119"></a>03119 
<a name="l03120"></a>03120 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l03121"></a>03121 <span class="preprocessor"></span>}
<a name="l03122"></a>03122 <span class="preprocessor">#endif</span>
<a name="l03123"></a>03123 <span class="preprocessor"></span>
<a name="l03124"></a>03124 <span class="preprocessor">#endif </span><span class="comment">/* H_GPFS */</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 21 2012 for nfs-ganesha by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
