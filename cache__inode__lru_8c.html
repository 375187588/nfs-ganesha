<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>nfs-ganesha: cache_inode_lru.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">nfs-ganesha&#160;<span id="projectnumber">1.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>cache_inode_lru.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>Constant-time cache inode cache management implementation.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;abstract_atomic.h&quot;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/param.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;pthread.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &lt;sys/time.h&gt;</code><br/>
<code>#include &lt;sys/resource.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;nlm_list.h&quot;</code><br/>
<code>#include &quot;fsal.h&quot;</code><br/>
<code>#include &quot;nfs_core.h&quot;</code><br/>
<code>#include &quot;log.h&quot;</code><br/>
<code>#include &quot;cache_inode.h&quot;</code><br/>
<code>#include &quot;cache_inode_lru.h&quot;</code><br/>
</div>
<p><a href="cache__inode__lru_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlru__q__base.html">lru_q_base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlru__q__.html">lru_q_</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a64c1947a41a81f84f1fcd4c28eda9dd9">CACHE_PAD</a>(_n)&#160;&#160;&#160;char __pad ## _n [CACHE_LINE_SIZE]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a8eb9dc2cc69a793ba6301b7e18aefbe3">ALIGNED_ALLOC</a>(_s)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a3867104f4ebef1bafec0d6f67a62b00b">cache_inode_lru_pkginit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a2da5e5fd9af43a7f17a5646baa47a82d">cache_inode_lru_pkgshutdown</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a9456c1d8a1afed3b16680d1457d5085d">cache_inode_lru_get</a> (<a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> *status, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-use or allocate an entry.  <a href="#a9456c1d8a1afed3b16680d1457d5085d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1">cache_inode_inc_pin_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let the state layer pin an entry.  <a href="#a96bb243e361cf38c5ae8ac4c50c108f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#aa1259fe625e57dd73a21c1105aaf8be3">cache_inode_unpinnable</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make it impossible to pin an entry.  <a href="#aa1259fe625e57dd73a21c1105aaf8be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03">cache_inode_dec_pin_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let the state layer rlease a pin.  <a href="#a9b53565faa2bf3bb8a20467385b35e03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a2c29ae784216cbb96ec55c6460f44bbb">cache_inode_lru_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference.  <a href="#a2c29ae784216cbb96ec55c6460f44bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#af2406fc0968f41f94a70a2940beffddf">cache_inode_lru_kill</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the sentinel refcount safely.  <a href="#af2406fc0968f41f94a70a2940beffddf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a84096eac6e9589aed54c83040a4b0b2a">cache_inode_lru_unref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquish a reference.  <a href="#a84096eac6e9589aed54c83040a4b0b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#aa5483629caef00dab52c51a1269037d2">lru_wake_thread</a> (<a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the LRU thread to free FDs.  <a href="#aa5483629caef00dab52c51a1269037d2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlru__state.html">lru_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#a1e6338e569a2a798614f74e92539b8d9">lru_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8c.html#afa15c96d409e40624b34e0d85b5df32c">open_fd_count</a> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Constant-time cache inode cache management implementation. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Matt Benjamin </dd></dl>
<h2><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h2>
<p>This module implements a constant-time cache management strategy based on LRU. Some ideas are taken from 2Q [Johnson and Shasha 1994] and MQ [Zhou, Chen, Li 2004]. In this system, cache management does interact with cache entry lifecycle, but the lru queue is not a garbage collector. Most imporantly, cache management operations execute in constant time, as expected with LRU (and MQ).</p>
<p>Cache entries in use by a currently-active protocol request (or other operation) have a positive refcount, and threfore should not be present at the cold end of an lru queue if the cache is well-sized.</p>
<p>Cache entries with lock and open state are not eligible for collection under ordinary circumstances, so are kept on a separate lru_pinned list to retain constant time.</p>
<p>The locking discipline for this module is complex, because an entry LRU can either be found through the cache entry in which it is embedded (through a hash table or weakref lookup) or one can be found on the queue. Thus, we have some sections for which locking the entry then the queue is natural, and others for which locking the queue then the entry is natural. Because it is the most common case in request processing, we have made the lock the queue case the defined lock order.</p>
<p>This introduces some complication, particularly in the case of cache_inode_lru_get and the repaer thread, which access entries through their queue. Therefore, we introduce the following rules for accessing LRU entries:</p>
<ul>
<li>The LRU refcount may be increased by a thread holding either the entry lock or the lock for the queue holding the entry.</li>
<li>The entry flags may be set or inspected only by a thread holding the lock on that entry.</li>
<li>An entry may only be removed from or inserted into a queue by a thread holding a lock on both the entry and the queue.</li>
<li>A thread may only decrement the reference count while holding the entry lock.</li>
<li>A thread that wishes to decrement the reference count must check that the reference count is greater than LRU_SENTINEL_REFCOUNT and, if not, acquire the queue lock before decrementing it. When the reference count falls to 0, the controlling thread will have already acquired the queue lock. It must then set the LRU_ENTRY_CONDEMNED bit on the entry's flags, and remove it from the queue. It must then drop both the entry and queue lock, call pthread_yield, and reacquire the entry lock before continuing with disposal.</li>
<li>A thread wishing to operate on an entry picked from a given queue fragment must lock that queue fragment, find the entry, and increase its reference count by one. It must then store a pointer to the entry and release the queue lock before acquiring the entry lock. If the LRU_ENTRY_CONDEMNED bit is set, it must relinquish its lock on the entry and attempt no further access to it. Otherwise, it must examine the flags and lane stored in the entry to determine the current queue fragment containing it, rather than assuming that the original location is still valid. </li>
</ul>

<p>Definition in file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a8eb9dc2cc69a793ba6301b7e18aefbe3"></a><!-- doxytag: member="cache_inode_lru.c::ALIGNED_ALLOC" ref="a8eb9dc2cc69a793ba6301b7e18aefbe3" args="(_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGNED_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_s</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<span class="keywordtype">void</span> *)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)malloc((_s)+<a class="code" href="cache__inode__lru_8c.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>*2) + \
                <a class="code" href="cache__inode__lru_8c.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a> - 1) &amp; ~(<a class="code" href="cache__inode__lru_8c.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>-1)))
</pre></div>
<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00141">141</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="af89f60b07247176687889ade776c8e10"></a><!-- doxytag: member="cache_inode_lru.c::CACHE_LINE_SIZE" ref="af89f60b07247176687889ade776c8e10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_LINE_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00139">139</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a64c1947a41a81f84f1fcd4c28eda9dd9"></a><!-- doxytag: member="cache_inode_lru.c::CACHE_PAD" ref="a64c1947a41a81f84f1fcd4c28eda9dd9" args="(_n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_PAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_n</td><td>)</td>
          <td>&#160;&#160;&#160;char __pad ## _n [CACHE_LINE_SIZE]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00140">140</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9b53565faa2bf3bb8a20467385b35e03"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_dec_pin_ref" ref="a9b53565faa2bf3bb8a20467385b35e03" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_dec_pin_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to let the state layer rlease a pin. </p>
<p>This function moves the given entry out of the pinned queue fragment for its lane. If the entry is not pinned, it is a no-op.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the entry was moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01211">1211</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a96bb243e361cf38c5ae8ac4c50c108f1"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_inc_pin_ref" ref="a96bb243e361cf38c5ae8ac4c50c108f1" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_inc_pin_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to let the state layer pin an entry. </p>
<p>This function moves the given entry to the pinned queue fragment for its lane. If the entry is already pinned, it is a no-op.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the entry was moved. </td></tr>
    <tr><td class="paramname">CACHE_INODE_DEAD_ENTRY</td><td>if the entry is in the process of disposal </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01155">1155</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9456c1d8a1afed3b16680d1457d5085d"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_get" ref="a9456c1d8a1afed3b16680d1457d5085d" args="(cache_inode_status_t *status, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcache__entry__t.html">cache_entry_t</a>* cache_inode_lru_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-use or allocate an entry. </p>
<p>This function repurposes a resident entry in the LRU system if the system is above low-water mark, and allocates a new one otherwise. On success, this function always returns an entry with two references (one for the sentinel, one to allow the caller's use.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Returned status </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags governing call</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CACHE_INODE_SUCCESS or error. </dd></dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01056">1056</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="af2406fc0968f41f94a70a2940beffddf"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_kill" ref="af2406fc0968f41f94a70a2940beffddf" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the sentinel refcount safely. </p>
<p>This function decrements the refcount by one unless the LRU_FLAG_KILLED bit is set in the flags word. This is intended to allow a function that needs to remove an extra refcount (the sentinel) to be called multiple times without causing an underflow.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to decrement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01307">1307</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3867104f4ebef1bafec0d6f67a62b00b"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_pkginit" ref="a3867104f4ebef1bafec0d6f67a62b00b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_pkginit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize subsystem </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00876">876</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2da5e5fd9af43a7f17a5646baa47a82d"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_pkgshutdown" ref="a2da5e5fd9af43a7f17a5646baa47a82d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_pkgshutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown subsystem </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01032">1032</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2c29ae784216cbb96ec55c6460f44bbb"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_ref" ref="a2c29ae784216cbb96ec55c6460f44bbb" args="(cache_entry_t *entry, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_lru_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference. </p>
<p>This function acquires a reference on the given cache entry, if the entry is still live. Terrible things will happen if you call this function and don't check its return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry on which to get a reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags indicating the type of reference sought</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the reference was acquired </td></tr>
    <tr><td class="paramname">CACHE_INODE_DEAD_ENTRY</td><td>if the object is being disposed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01247">1247</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a84096eac6e9589aed54c83040a4b0b2a"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_lru_unref" ref="a84096eac6e9589aed54c83040a4b0b2a" args="(cache_entry_t *entry, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relinquish a reference. </p>
<p>This function relinquishes a reference on the given cache entry. It follows the disposal/recycling lock discipline given at the beginning of the file.</p>
<p>The supplied entry is always either unlocked or destroyed by the time this function returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry on which to release a reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Currently significant are and LRU_FLAG_LOCKED (indicating that the caller holds the LRU mutex lock for this entry.) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01337">1337</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa1259fe625e57dd73a21c1105aaf8be3"></a><!-- doxytag: member="cache_inode_lru.c::cache_inode_unpinnable" ref="aa1259fe625e57dd73a21c1105aaf8be3" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_unpinnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make it impossible to pin an entry. </p>
<p>This function makes it impossible to pin an entry, but does not unpin it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01191">1191</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa5483629caef00dab52c51a1269037d2"></a><!-- doxytag: member="cache_inode_lru.c::lru_wake_thread" ref="aa5483629caef00dab52c51a1269037d2" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lru_wake_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wake the LRU thread to free FDs. </p>
<p>This function wakes the LRU reaper thread to free FDs and should be called when we are over the high water mark.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags to affect the wake (currently none) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01397">1397</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a1e6338e569a2a798614f74e92539b8d9"></a><!-- doxytag: member="cache_inode_lru.c::lru_state" ref="a1e6338e569a2a798614f74e92539b8d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlru__state.html">lru_state</a> <a class="el" href="structlru__state.html">lru_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00124">124</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="afa15c96d409e40624b34e0d85b5df32c"></a><!-- doxytag: member="cache_inode_lru.c::open_fd_count" ref="afa15c96d409e40624b34e0d85b5df32c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="cache__inode__lru_8h.html#afa15c96d409e40624b34e0d85b5df32c">open_fd_count</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a global counter of files opened by cache_inode. This is preliminary expected to go away. Problems with this method are that it overcounts file descriptors for FSALs that don't use them for open files, and, under the Lieb Rearchitecture, FSALs will be responsible for caching their own file descriptors, with interfaces for Cache_Inode to interrogate them as to usage or instruct them to close them. </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00178">178</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 21 2012 for nfs-ganesha by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
