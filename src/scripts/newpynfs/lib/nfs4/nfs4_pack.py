# Generated by rpcgen.py from nfs4.x on Fri Jan 25 14:59:49 2008
import nfs4_const as const
import nfs4_type as types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class NFS4Packer(xdrlib.Packer):
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_string = xdrlib.Packer.pack_string
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_int = xdrlib.Packer.pack_int
    pack_double = xdrlib.Packer.pack_double
    pack_float = xdrlib.Packer.pack_float
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_uint = xdrlib.Packer.pack_uint
    pack_bool = xdrlib.Packer.pack_bool
    pack_int32_t = pack_int

    pack_uint32_t = pack_uint

    pack_int64_t = pack_hyper

    pack_uint64_t = pack_uhyper

    def pack_nfs_ftype4(self, data):
        if data not in [const.NF4REG, const.NF4DIR, const.NF4BLK, const.NF4CHR, const.NF4LNK, const.NF4SOCK, const.NF4FIFO, const.NF4ATTRDIR, const.NF4NAMEDATTR]:
            raise XDRError, 'value=%s not in enum nfs_ftype4' % data
        self.pack_int(data)

    def pack_nfsstat4(self, data):
        if data not in [const.NFS4_OK, const.NFS4ERR_PERM, const.NFS4ERR_NOENT, const.NFS4ERR_IO, const.NFS4ERR_NXIO, const.NFS4ERR_ACCESS, const.NFS4ERR_EXIST, const.NFS4ERR_XDEV, const.NFS4ERR_NOTDIR, const.NFS4ERR_ISDIR, const.NFS4ERR_INVAL, const.NFS4ERR_FBIG, const.NFS4ERR_NOSPC, const.NFS4ERR_ROFS, const.NFS4ERR_MLINK, const.NFS4ERR_NAMETOOLONG, const.NFS4ERR_NOTEMPTY, const.NFS4ERR_DQUOT, const.NFS4ERR_STALE, const.NFS4ERR_BADHANDLE, const.NFS4ERR_BAD_COOKIE, const.NFS4ERR_NOTSUPP, const.NFS4ERR_TOOSMALL, const.NFS4ERR_SERVERFAULT, const.NFS4ERR_BADTYPE, const.NFS4ERR_DELAY, const.NFS4ERR_SAME, const.NFS4ERR_DENIED, const.NFS4ERR_EXPIRED, const.NFS4ERR_LOCKED, const.NFS4ERR_GRACE, const.NFS4ERR_FHEXPIRED, const.NFS4ERR_SHARE_DENIED, const.NFS4ERR_WRONGSEC, const.NFS4ERR_CLID_INUSE, const.NFS4ERR_RESOURCE, const.NFS4ERR_MOVED, const.NFS4ERR_NOFILEHANDLE, const.NFS4ERR_MINOR_VERS_MISMATCH, const.NFS4ERR_STALE_CLIENTID, const.NFS4ERR_STALE_STATEID, const.NFS4ERR_OLD_STATEID, const.NFS4ERR_BAD_STATEID, const.NFS4ERR_BAD_SEQID, const.NFS4ERR_NOT_SAME, const.NFS4ERR_LOCK_RANGE, const.NFS4ERR_SYMLINK, const.NFS4ERR_RESTOREFH, const.NFS4ERR_LEASE_MOVED, const.NFS4ERR_ATTRNOTSUPP, const.NFS4ERR_NO_GRACE, const.NFS4ERR_RECLAIM_BAD, const.NFS4ERR_RECLAIM_CONFLICT, const.NFS4ERR_BADXDR, const.NFS4ERR_LOCKS_HELD, const.NFS4ERR_OPENMODE, const.NFS4ERR_BADOWNER, const.NFS4ERR_BADCHAR, const.NFS4ERR_BADNAME, const.NFS4ERR_BAD_RANGE, const.NFS4ERR_LOCK_NOTSUPP, const.NFS4ERR_OP_ILLEGAL, const.NFS4ERR_DEADLOCK, const.NFS4ERR_FILE_OPEN, const.NFS4ERR_ADMIN_REVOKED, const.NFS4ERR_CB_PATH_DOWN]:
            raise XDRError, 'value=%s not in enum nfsstat4' % data
        self.pack_int(data)

    def pack_bitmap4(self, data):
        self.pack_array(data, self.pack_uint32_t)

    pack_offset4 = pack_uint64_t

    pack_count4 = pack_uint32_t

    pack_length4 = pack_uint64_t

    pack_clientid4 = pack_uint64_t

    pack_seqid4 = pack_uint32_t

    def pack_utf8string(self, data):
        self.pack_opaque(data)

    pack_utf8str_cis = pack_utf8string

    pack_utf8str_cs = pack_utf8string

    pack_utf8str_mixed = pack_utf8string

    pack_component4 = pack_utf8str_cs

    def pack_pathname4(self, data):
        self.pack_array(data, self.pack_component4)

    pack_nfs_lockid4 = pack_uint64_t

    pack_nfs_cookie4 = pack_uint64_t

    pack_linktext4 = pack_utf8str_cs

    def pack_sec_oid4(self, data):
        self.pack_opaque(data)

    pack_qop4 = pack_uint32_t

    pack_mode4 = pack_uint32_t

    pack_changeid4 = pack_uint64_t

    def pack_verifier4(self, data):
        self.pack_fopaque(const.NFS4_VERIFIER_SIZE, data)

    def pack_nfstime4(self, data):
        if data.seconds is None:
            raise TypeError, 'data.seconds == None'
        self.pack_int64_t(data.seconds)
        if data.nseconds is None:
            raise TypeError, 'data.nseconds == None'
        self.pack_uint32_t(data.nseconds)

    def pack_time_how4(self, data):
        if data not in [const.SET_TO_SERVER_TIME4, const.SET_TO_CLIENT_TIME4]:
            raise XDRError, 'value=%s not in enum time_how4' % data
        self.pack_int(data)

    def pack_settime4(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_time_how4(data.set_it)
        if data.set_it == const.SET_TO_CLIENT_TIME4:
            if data.time is None:
                raise TypeError, 'data.time == None'
            self.pack_nfstime4(data.time)
        else:
            pass

    def pack_nfs_fh4(self, data):
        if len(data) > const.NFS4_FHSIZE:
            raise XDRError, 'array length too long for data'
        self.pack_opaque(data)

    def pack_fsid4(self, data):
        if data.major is None:
            raise TypeError, 'data.major == None'
        self.pack_uint64_t(data.major)
        if data.minor is None:
            raise TypeError, 'data.minor == None'
        self.pack_uint64_t(data.minor)

    def pack_fs_location4(self, data):
        if data.server is None:
            raise TypeError, 'data.server == None'
        self.pack_array(data.server, self.pack_utf8str_cis)
        if data.rootpath is None:
            raise TypeError, 'data.rootpath == None'
        self.pack_pathname4(data.rootpath)

    def pack_fs_locations4(self, data):
        if data.fs_root is None:
            raise TypeError, 'data.fs_root == None'
        self.pack_pathname4(data.fs_root)
        if data.locations is None:
            raise TypeError, 'data.locations == None'
        self.pack_array(data.locations, self.pack_fs_location4)

    pack_acetype4 = pack_uint32_t

    pack_aceflag4 = pack_uint32_t

    pack_acemask4 = pack_uint32_t

    def pack_nfsace4(self, data):
        if data.type is None:
            raise TypeError, 'data.type == None'
        self.pack_acetype4(data.type)
        if data.flag is None:
            raise TypeError, 'data.flag == None'
        self.pack_aceflag4(data.flag)
        if data.access_mask is None:
            raise TypeError, 'data.access_mask == None'
        self.pack_acemask4(data.access_mask)
        if data.who is None:
            raise TypeError, 'data.who == None'
        self.pack_utf8str_mixed(data.who)

    def pack_specdata4(self, data):
        if data.specdata1 is None:
            raise TypeError, 'data.specdata1 == None'
        self.pack_uint32_t(data.specdata1)
        if data.specdata2 is None:
            raise TypeError, 'data.specdata2 == None'
        self.pack_uint32_t(data.specdata2)

    pack_fattr4_supported_attrs = pack_bitmap4

    pack_fattr4_type = pack_nfs_ftype4

    pack_fattr4_fh_expire_type = pack_uint32_t

    pack_fattr4_change = pack_changeid4

    pack_fattr4_size = pack_uint64_t

    pack_fattr4_link_support = pack_bool

    pack_fattr4_symlink_support = pack_bool

    pack_fattr4_named_attr = pack_bool

    pack_fattr4_fsid = pack_fsid4

    pack_fattr4_unique_handles = pack_bool

    pack_fattr4_lease_time = pack_uint32_t

    pack_fattr4_rdattr_error = pack_nfsstat4

    def pack_fattr4_acl(self, data):
        self.pack_array(data, self.pack_nfsace4)

    pack_fattr4_aclsupport = pack_uint32_t

    pack_fattr4_archive = pack_bool

    pack_fattr4_cansettime = pack_bool

    pack_fattr4_case_insensitive = pack_bool

    pack_fattr4_case_preserving = pack_bool

    pack_fattr4_chown_restricted = pack_bool

    pack_fattr4_fileid = pack_uint64_t

    pack_fattr4_files_avail = pack_uint64_t

    pack_fattr4_filehandle = pack_nfs_fh4

    pack_fattr4_files_free = pack_uint64_t

    pack_fattr4_files_total = pack_uint64_t

    pack_fattr4_fs_locations = pack_fs_locations4

    pack_fattr4_hidden = pack_bool

    pack_fattr4_homogeneous = pack_bool

    pack_fattr4_maxfilesize = pack_uint64_t

    pack_fattr4_maxlink = pack_uint32_t

    pack_fattr4_maxname = pack_uint32_t

    pack_fattr4_maxread = pack_uint64_t

    pack_fattr4_maxwrite = pack_uint64_t

    pack_fattr4_mimetype = pack_utf8str_cs

    pack_fattr4_mode = pack_mode4

    pack_fattr4_mounted_on_fileid = pack_uint64_t

    pack_fattr4_no_trunc = pack_bool

    pack_fattr4_numlinks = pack_uint32_t

    pack_fattr4_owner = pack_utf8str_mixed

    pack_fattr4_owner_group = pack_utf8str_mixed

    pack_fattr4_quota_avail_hard = pack_uint64_t

    pack_fattr4_quota_avail_soft = pack_uint64_t

    pack_fattr4_quota_used = pack_uint64_t

    pack_fattr4_rawdev = pack_specdata4

    pack_fattr4_space_avail = pack_uint64_t

    pack_fattr4_space_free = pack_uint64_t

    pack_fattr4_space_total = pack_uint64_t

    pack_fattr4_space_used = pack_uint64_t

    pack_fattr4_system = pack_bool

    pack_fattr4_time_access = pack_nfstime4

    pack_fattr4_time_access_set = pack_settime4

    pack_fattr4_time_backup = pack_nfstime4

    pack_fattr4_time_create = pack_nfstime4

    pack_fattr4_time_delta = pack_nfstime4

    pack_fattr4_time_metadata = pack_nfstime4

    pack_fattr4_time_modify = pack_nfstime4

    pack_fattr4_time_modify_set = pack_settime4

    def pack_attrlist4(self, data):
        self.pack_opaque(data)

    def pack_fattr4(self, data):
        if data.attrmask is None:
            raise TypeError, 'data.attrmask == None'
        self.pack_bitmap4(data.attrmask)
        if data.attr_vals is None:
            raise TypeError, 'data.attr_vals == None'
        self.pack_attrlist4(data.attr_vals)

    def pack_change_info4(self, data):
        if data.atomic is None:
            raise TypeError, 'data.atomic == None'
        self.pack_bool(data.atomic)
        if data.before is None:
            raise TypeError, 'data.before == None'
        self.pack_changeid4(data.before)
        if data.after is None:
            raise TypeError, 'data.after == None'
        self.pack_changeid4(data.after)

    def pack_clientaddr4(self, data):
        if data.r_netid is None:
            raise TypeError, 'data.r_netid == None'
        self.pack_string(data.r_netid)
        if data.r_addr is None:
            raise TypeError, 'data.r_addr == None'
        self.pack_string(data.r_addr)

    def pack_cb_client4(self, data):
        if data.cb_program is None:
            raise TypeError, 'data.cb_program == None'
        self.pack_uint32_t(data.cb_program)
        if data.cb_location is None:
            raise TypeError, 'data.cb_location == None'
        self.pack_clientaddr4(data.cb_location)

    def pack_stateid4(self, data):
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_uint32_t(data.seqid)
        if data.other is None:
            raise TypeError, 'data.other == None'
        self.pack_fopaque(12, data.other)

    def pack_nfs_client_id4(self, data):
        if data.verifier is None:
            raise TypeError, 'data.verifier == None'
        self.pack_verifier4(data.verifier)
        if data.id is None:
            raise TypeError, 'data.id == None'
        if len(data.id) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.id'
        self.pack_opaque(data.id)

    def pack_open_owner4(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)
        if data.owner is None:
            raise TypeError, 'data.owner == None'
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.owner'
        self.pack_opaque(data.owner)

    def pack_lock_owner4(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)
        if data.owner is None:
            raise TypeError, 'data.owner == None'
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.owner'
        self.pack_opaque(data.owner)

    def pack_nfs_lock_type4(self, data):
        if data not in [const.READ_LT, const.WRITE_LT, const.READW_LT, const.WRITEW_LT]:
            raise XDRError, 'value=%s not in enum nfs_lock_type4' % data
        self.pack_int(data)

    def pack_ACCESS4args(self, data):
        if data.access is None:
            raise TypeError, 'data.access == None'
        self.pack_uint32_t(data.access)

    def pack_ACCESS4resok(self, data):
        if data.supported is None:
            raise TypeError, 'data.supported == None'
        self.pack_uint32_t(data.supported)
        if data.access is None:
            raise TypeError, 'data.access == None'
        self.pack_uint32_t(data.access)

    def pack_ACCESS4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_ACCESS4resok(data.resok4)
        else:
            pass

    def pack_CLOSE4args(self, data):
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_seqid4(data.seqid)
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)

    def pack_CLOSE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.open_stateid is None:
                raise TypeError, 'data.open_stateid == None'
            self.pack_stateid4(data.open_stateid)
        else:
            pass

    def pack_COMMIT4args(self, data):
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count4(data.count)

    def pack_COMMIT4resok(self, data):
        if data.writeverf is None:
            raise TypeError, 'data.writeverf == None'
        self.pack_verifier4(data.writeverf)

    def pack_COMMIT4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_COMMIT4resok(data.resok4)
        else:
            pass

    def pack_createtype4(self, data):
        if data.type is None:
            raise TypeError, 'data.type == None'
        self.pack_nfs_ftype4(data.type)
        if data.type == const.NF4LNK:
            if data.linkdata is None:
                raise TypeError, 'data.linkdata == None'
            self.pack_linktext4(data.linkdata)
        elif data.type == const.NF4BLK or data.type == const.NF4CHR:
            if data.devdata is None:
                raise TypeError, 'data.devdata == None'
            self.pack_specdata4(data.devdata)
        elif data.type == const.NF4SOCK or data.type == const.NF4FIFO or data.type == const.NF4DIR:
            pass
        else:
            pass

    def pack_CREATE4args(self, data):
        if data.objtype is None:
            raise TypeError, 'data.objtype == None'
        self.pack_createtype4(data.objtype)
        if data.objname is None:
            raise TypeError, 'data.objname == None'
        self.pack_component4(data.objname)
        if data.createattrs is None:
            raise TypeError, 'data.createattrs == None'
        self.pack_fattr4(data.createattrs)

    def pack_CREATE4resok(self, data):
        if data.cinfo is None:
            raise TypeError, 'data.cinfo == None'
        self.pack_change_info4(data.cinfo)
        if data.attrset is None:
            raise TypeError, 'data.attrset == None'
        self.pack_bitmap4(data.attrset)

    def pack_CREATE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_CREATE4resok(data.resok4)
        else:
            pass

    def pack_DELEGPURGE4args(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)

    def pack_DELEGPURGE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_DELEGRETURN4args(self, data):
        if data.deleg_stateid is None:
            raise TypeError, 'data.deleg_stateid == None'
        self.pack_stateid4(data.deleg_stateid)

    def pack_DELEGRETURN4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_GETATTR4args(self, data):
        if data.attr_request is None:
            raise TypeError, 'data.attr_request == None'
        self.pack_bitmap4(data.attr_request)

    def pack_GETATTR4resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr4(data.obj_attributes)

    def pack_GETATTR4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_GETATTR4resok(data.resok4)
        else:
            pass

    def pack_GETFH4resok(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh4(data.object)

    def pack_GETFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_GETFH4resok(data.resok4)
        else:
            pass

    def pack_LINK4args(self, data):
        if data.newname is None:
            raise TypeError, 'data.newname == None'
        self.pack_component4(data.newname)

    def pack_LINK4resok(self, data):
        if data.cinfo is None:
            raise TypeError, 'data.cinfo == None'
        self.pack_change_info4(data.cinfo)

    def pack_LINK4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_LINK4resok(data.resok4)
        else:
            pass

    def pack_open_to_lock_owner4(self, data):
        if data.open_seqid is None:
            raise TypeError, 'data.open_seqid == None'
        self.pack_seqid4(data.open_seqid)
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)
        if data.lock_seqid is None:
            raise TypeError, 'data.lock_seqid == None'
        self.pack_seqid4(data.lock_seqid)
        if data.lock_owner is None:
            raise TypeError, 'data.lock_owner == None'
        self.pack_lock_owner4(data.lock_owner)

    def pack_exist_lock_owner4(self, data):
        if data.lock_stateid is None:
            raise TypeError, 'data.lock_stateid == None'
        self.pack_stateid4(data.lock_stateid)
        if data.lock_seqid is None:
            raise TypeError, 'data.lock_seqid == None'
        self.pack_seqid4(data.lock_seqid)

    def pack_locker4(self, data):
        if data.new_lock_owner is None:
            raise TypeError, 'data.new_lock_owner == None'
        self.pack_bool(data.new_lock_owner)
        if data.new_lock_owner == const.TRUE:
            if data.open_owner is None:
                raise TypeError, 'data.open_owner == None'
            self.pack_open_to_lock_owner4(data.open_owner)
        elif data.new_lock_owner == const.FALSE:
            if data.lock_owner is None:
                raise TypeError, 'data.lock_owner == None'
            self.pack_exist_lock_owner4(data.lock_owner)
        else:
            raise XDRError, 'bad switch=%s' % data.new_lock_owner

    def pack_LOCK4args(self, data):
        if data.locktype is None:
            raise TypeError, 'data.locktype == None'
        self.pack_nfs_lock_type4(data.locktype)
        if data.reclaim is None:
            raise TypeError, 'data.reclaim == None'
        self.pack_bool(data.reclaim)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError, 'data.length == None'
        self.pack_length4(data.length)
        if data.locker is None:
            raise TypeError, 'data.locker == None'
        self.pack_locker4(data.locker)

    def pack_LOCK4denied(self, data):
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError, 'data.length == None'
        self.pack_length4(data.length)
        if data.locktype is None:
            raise TypeError, 'data.locktype == None'
        self.pack_nfs_lock_type4(data.locktype)
        if data.owner is None:
            raise TypeError, 'data.owner == None'
        self.pack_lock_owner4(data.owner)

    def pack_LOCK4resok(self, data):
        if data.lock_stateid is None:
            raise TypeError, 'data.lock_stateid == None'
        self.pack_stateid4(data.lock_stateid)

    def pack_LOCK4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_LOCK4resok(data.resok4)
        elif data.status == const.NFS4ERR_DENIED:
            if data.denied is None:
                raise TypeError, 'data.denied == None'
            self.pack_LOCK4denied(data.denied)
        else:
            pass

    def pack_LOCKT4args(self, data):
        if data.locktype is None:
            raise TypeError, 'data.locktype == None'
        self.pack_nfs_lock_type4(data.locktype)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError, 'data.length == None'
        self.pack_length4(data.length)
        if data.owner is None:
            raise TypeError, 'data.owner == None'
        self.pack_lock_owner4(data.owner)

    def pack_LOCKT4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4ERR_DENIED:
            if data.denied is None:
                raise TypeError, 'data.denied == None'
            self.pack_LOCK4denied(data.denied)
        elif data.status == const.NFS4_OK:
            pass
        else:
            pass

    def pack_LOCKU4args(self, data):
        if data.locktype is None:
            raise TypeError, 'data.locktype == None'
        self.pack_nfs_lock_type4(data.locktype)
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_seqid4(data.seqid)
        if data.lock_stateid is None:
            raise TypeError, 'data.lock_stateid == None'
        self.pack_stateid4(data.lock_stateid)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError, 'data.length == None'
        self.pack_length4(data.length)

    def pack_LOCKU4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.lock_stateid is None:
                raise TypeError, 'data.lock_stateid == None'
            self.pack_stateid4(data.lock_stateid)
        else:
            pass

    def pack_LOOKUP4args(self, data):
        if data.objname is None:
            raise TypeError, 'data.objname == None'
        self.pack_component4(data.objname)

    def pack_LOOKUP4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_LOOKUPP4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_NVERIFY4args(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr4(data.obj_attributes)

    def pack_NVERIFY4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_createmode4(self, data):
        if data not in [const.UNCHECKED4, const.GUARDED4, const.EXCLUSIVE4]:
            raise XDRError, 'value=%s not in enum createmode4' % data
        self.pack_int(data)

    def pack_createhow4(self, data):
        if data.mode is None:
            raise TypeError, 'data.mode == None'
        self.pack_createmode4(data.mode)
        if data.mode == const.UNCHECKED4 or data.mode == const.GUARDED4:
            if data.createattrs is None:
                raise TypeError, 'data.createattrs == None'
            self.pack_fattr4(data.createattrs)
        elif data.mode == const.EXCLUSIVE4:
            if data.createverf is None:
                raise TypeError, 'data.createverf == None'
            self.pack_verifier4(data.createverf)
        else:
            raise XDRError, 'bad switch=%s' % data.mode

    def pack_opentype4(self, data):
        if data not in [const.OPEN4_NOCREATE, const.OPEN4_CREATE]:
            raise XDRError, 'value=%s not in enum opentype4' % data
        self.pack_int(data)

    def pack_openflag4(self, data):
        if data.opentype is None:
            raise TypeError, 'data.opentype == None'
        self.pack_opentype4(data.opentype)
        if data.opentype == const.OPEN4_CREATE:
            if data.how is None:
                raise TypeError, 'data.how == None'
            self.pack_createhow4(data.how)
        else:
            pass

    def pack_limit_by4(self, data):
        if data not in [const.NFS_LIMIT_SIZE, const.NFS_LIMIT_BLOCKS]:
            raise XDRError, 'value=%s not in enum limit_by4' % data
        self.pack_int(data)

    def pack_nfs_modified_limit4(self, data):
        if data.num_blocks is None:
            raise TypeError, 'data.num_blocks == None'
        self.pack_uint32_t(data.num_blocks)
        if data.bytes_per_block is None:
            raise TypeError, 'data.bytes_per_block == None'
        self.pack_uint32_t(data.bytes_per_block)

    def pack_nfs_space_limit4(self, data):
        if data.limitby is None:
            raise TypeError, 'data.limitby == None'
        self.pack_limit_by4(data.limitby)
        if data.limitby == const.NFS_LIMIT_SIZE:
            if data.filesize is None:
                raise TypeError, 'data.filesize == None'
            self.pack_uint64_t(data.filesize)
        elif data.limitby == const.NFS_LIMIT_BLOCKS:
            if data.mod_blocks is None:
                raise TypeError, 'data.mod_blocks == None'
            self.pack_nfs_modified_limit4(data.mod_blocks)
        else:
            raise XDRError, 'bad switch=%s' % data.limitby

    def pack_open_delegation_type4(self, data):
        if data not in [const.OPEN_DELEGATE_NONE, const.OPEN_DELEGATE_READ, const.OPEN_DELEGATE_WRITE]:
            raise XDRError, 'value=%s not in enum open_delegation_type4' % data
        self.pack_int(data)

    def pack_open_claim_type4(self, data):
        if data not in [const.CLAIM_NULL, const.CLAIM_PREVIOUS, const.CLAIM_DELEGATE_CUR, const.CLAIM_DELEGATE_PREV]:
            raise XDRError, 'value=%s not in enum open_claim_type4' % data
        self.pack_int(data)

    def pack_open_claim_delegate_cur4(self, data):
        if data.delegate_stateid is None:
            raise TypeError, 'data.delegate_stateid == None'
        self.pack_stateid4(data.delegate_stateid)
        if data.file is None:
            raise TypeError, 'data.file == None'
        self.pack_component4(data.file)

    def pack_open_claim4(self, data):
        if data.claim is None:
            raise TypeError, 'data.claim == None'
        self.pack_open_claim_type4(data.claim)
        if data.claim == const.CLAIM_NULL:
            if data.file is None:
                raise TypeError, 'data.file == None'
            self.pack_component4(data.file)
        elif data.claim == const.CLAIM_PREVIOUS:
            if data.delegate_type is None:
                raise TypeError, 'data.delegate_type == None'
            self.pack_open_delegation_type4(data.delegate_type)
        elif data.claim == const.CLAIM_DELEGATE_CUR:
            if data.delegate_cur_info is None:
                raise TypeError, 'data.delegate_cur_info == None'
            self.pack_open_claim_delegate_cur4(data.delegate_cur_info)
        elif data.claim == const.CLAIM_DELEGATE_PREV:
            if data.file_delegate_prev is None:
                raise TypeError, 'data.file_delegate_prev == None'
            self.pack_component4(data.file_delegate_prev)
        else:
            raise XDRError, 'bad switch=%s' % data.claim

    def pack_OPEN4args(self, data):
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_seqid4(data.seqid)
        if data.share_access is None:
            raise TypeError, 'data.share_access == None'
        self.pack_uint32_t(data.share_access)
        if data.share_deny is None:
            raise TypeError, 'data.share_deny == None'
        self.pack_uint32_t(data.share_deny)
        if data.owner is None:
            raise TypeError, 'data.owner == None'
        self.pack_open_owner4(data.owner)
        if data.openhow is None:
            raise TypeError, 'data.openhow == None'
        self.pack_openflag4(data.openhow)
        if data.claim is None:
            raise TypeError, 'data.claim == None'
        self.pack_open_claim4(data.claim)

    def pack_open_read_delegation4(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.recall is None:
            raise TypeError, 'data.recall == None'
        self.pack_bool(data.recall)
        if data.permissions is None:
            raise TypeError, 'data.permissions == None'
        self.pack_nfsace4(data.permissions)

    def pack_open_write_delegation4(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.recall is None:
            raise TypeError, 'data.recall == None'
        self.pack_bool(data.recall)
        if data.space_limit is None:
            raise TypeError, 'data.space_limit == None'
        self.pack_nfs_space_limit4(data.space_limit)
        if data.permissions is None:
            raise TypeError, 'data.permissions == None'
        self.pack_nfsace4(data.permissions)

    def pack_open_delegation4(self, data):
        if data.delegation_type is None:
            raise TypeError, 'data.delegation_type == None'
        self.pack_open_delegation_type4(data.delegation_type)
        if data.delegation_type == const.OPEN_DELEGATE_NONE:
            pass
        elif data.delegation_type == const.OPEN_DELEGATE_READ:
            if data.read is None:
                raise TypeError, 'data.read == None'
            self.pack_open_read_delegation4(data.read)
        elif data.delegation_type == const.OPEN_DELEGATE_WRITE:
            if data.write is None:
                raise TypeError, 'data.write == None'
            self.pack_open_write_delegation4(data.write)
        else:
            raise XDRError, 'bad switch=%s' % data.delegation_type

    def pack_OPEN4resok(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.cinfo is None:
            raise TypeError, 'data.cinfo == None'
        self.pack_change_info4(data.cinfo)
        if data.rflags is None:
            raise TypeError, 'data.rflags == None'
        self.pack_uint32_t(data.rflags)
        if data.attrset is None:
            raise TypeError, 'data.attrset == None'
        self.pack_bitmap4(data.attrset)
        if data.delegation is None:
            raise TypeError, 'data.delegation == None'
        self.pack_open_delegation4(data.delegation)

    def pack_OPEN4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_OPEN4resok(data.resok4)
        else:
            pass

    def pack_OPENATTR4args(self, data):
        if data.createdir is None:
            raise TypeError, 'data.createdir == None'
        self.pack_bool(data.createdir)

    def pack_OPENATTR4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_OPEN_CONFIRM4args(self, data):
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_seqid4(data.seqid)

    def pack_OPEN_CONFIRM4resok(self, data):
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)

    def pack_OPEN_CONFIRM4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_OPEN_CONFIRM4resok(data.resok4)
        else:
            pass

    def pack_OPEN_DOWNGRADE4args(self, data):
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)
        if data.seqid is None:
            raise TypeError, 'data.seqid == None'
        self.pack_seqid4(data.seqid)
        if data.share_access is None:
            raise TypeError, 'data.share_access == None'
        self.pack_uint32_t(data.share_access)
        if data.share_deny is None:
            raise TypeError, 'data.share_deny == None'
        self.pack_uint32_t(data.share_deny)

    def pack_OPEN_DOWNGRADE4resok(self, data):
        if data.open_stateid is None:
            raise TypeError, 'data.open_stateid == None'
        self.pack_stateid4(data.open_stateid)

    def pack_OPEN_DOWNGRADE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_OPEN_DOWNGRADE4resok(data.resok4)
        else:
            pass

    def pack_PUTFH4args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh4(data.object)

    def pack_PUTFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_PUTPUBFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_PUTROOTFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_READ4args(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count4(data.count)

    def pack_READ4resok(self, data):
        if data.eof is None:
            raise TypeError, 'data.eof == None'
        self.pack_bool(data.eof)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_opaque(data.data)

    def pack_READ4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_READ4resok(data.resok4)
        else:
            pass

    def pack_READDIR4args(self, data):
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_nfs_cookie4(data.cookie)
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_verifier4(data.cookieverf)
        if data.dircount is None:
            raise TypeError, 'data.dircount == None'
        self.pack_count4(data.dircount)
        if data.maxcount is None:
            raise TypeError, 'data.maxcount == None'
        self.pack_count4(data.maxcount)
        if data.attr_request is None:
            raise TypeError, 'data.attr_request == None'
        self.pack_bitmap4(data.attr_request)

    def pack_entry4(self, data):
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_nfs_cookie4(data.cookie)
        if data.name is None:
            raise TypeError, 'data.name == None'
        self.pack_component4(data.name)
        if data.attrs is None:
            raise TypeError, 'data.attrs == None'
        self.pack_fattr4(data.attrs)
        if data.nextentry is None:
            raise TypeError, 'data.nextentry == None'
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        self.pack_array(data.nextentry, self.pack_entry4)

    def pack_dirlist4(self, data):
        if data.entries is None:
            raise TypeError, 'data.entries == None'
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        self.pack_array(data.entries, self.pack_entry4)
        if data.eof is None:
            raise TypeError, 'data.eof == None'
        self.pack_bool(data.eof)

    def pack_READDIR4resok(self, data):
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_verifier4(data.cookieverf)
        if data.reply is None:
            raise TypeError, 'data.reply == None'
        self.pack_dirlist4(data.reply)

    def pack_READDIR4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_READDIR4resok(data.resok4)
        else:
            pass

    def pack_READLINK4resok(self, data):
        if data.link is None:
            raise TypeError, 'data.link == None'
        self.pack_linktext4(data.link)

    def pack_READLINK4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_READLINK4resok(data.resok4)
        else:
            pass

    def pack_REMOVE4args(self, data):
        if data.target is None:
            raise TypeError, 'data.target == None'
        self.pack_component4(data.target)

    def pack_REMOVE4resok(self, data):
        if data.cinfo is None:
            raise TypeError, 'data.cinfo == None'
        self.pack_change_info4(data.cinfo)

    def pack_REMOVE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_REMOVE4resok(data.resok4)
        else:
            pass

    def pack_RENAME4args(self, data):
        if data.oldname is None:
            raise TypeError, 'data.oldname == None'
        self.pack_component4(data.oldname)
        if data.newname is None:
            raise TypeError, 'data.newname == None'
        self.pack_component4(data.newname)

    def pack_RENAME4resok(self, data):
        if data.source_cinfo is None:
            raise TypeError, 'data.source_cinfo == None'
        self.pack_change_info4(data.source_cinfo)
        if data.target_cinfo is None:
            raise TypeError, 'data.target_cinfo == None'
        self.pack_change_info4(data.target_cinfo)

    def pack_RENAME4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_RENAME4resok(data.resok4)
        else:
            pass

    def pack_RENEW4args(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)

    def pack_RENEW4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_RESTOREFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_SAVEFH4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_SECINFO4args(self, data):
        if data.name is None:
            raise TypeError, 'data.name == None'
        self.pack_component4(data.name)

    def pack_rpc_gss_svc_t(self, data):
        if data not in [const.RPC_GSS_SVC_NONE, const.RPC_GSS_SVC_INTEGRITY, const.RPC_GSS_SVC_PRIVACY]:
            raise XDRError, 'value=%s not in enum rpc_gss_svc_t' % data
        self.pack_int(data)

    def pack_rpcsec_gss_info(self, data):
        if data.oid is None:
            raise TypeError, 'data.oid == None'
        self.pack_sec_oid4(data.oid)
        if data.qop is None:
            raise TypeError, 'data.qop == None'
        self.pack_qop4(data.qop)
        if data.service is None:
            raise TypeError, 'data.service == None'
        self.pack_rpc_gss_svc_t(data.service)

    def pack_secinfo4(self, data):
        if data.flavor is None:
            raise TypeError, 'data.flavor == None'
        self.pack_uint32_t(data.flavor)
        if data.flavor == const.RPCSEC_GSS:
            if data.flavor_info is None:
                raise TypeError, 'data.flavor_info == None'
            self.pack_rpcsec_gss_info(data.flavor_info)
        else:
            pass

    def pack_SECINFO4resok(self, data):
        self.pack_array(data, self.pack_secinfo4)

    def pack_SECINFO4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_SECINFO4resok(data.resok4)
        else:
            pass

    def pack_SETATTR4args(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr4(data.obj_attributes)

    def pack_SETATTR4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.attrsset is None:
            raise TypeError, 'data.attrsset == None'
        self.pack_bitmap4(data.attrsset)

    def pack_SETCLIENTID4args(self, data):
        if data.client is None:
            raise TypeError, 'data.client == None'
        self.pack_nfs_client_id4(data.client)
        if data.callback is None:
            raise TypeError, 'data.callback == None'
        self.pack_cb_client4(data.callback)
        if data.callback_ident is None:
            raise TypeError, 'data.callback_ident == None'
        self.pack_uint32_t(data.callback_ident)

    def pack_SETCLIENTID4resok(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)
        if data.setclientid_confirm is None:
            raise TypeError, 'data.setclientid_confirm == None'
        self.pack_verifier4(data.setclientid_confirm)

    def pack_SETCLIENTID4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_SETCLIENTID4resok(data.resok4)
        elif data.status == const.NFS4ERR_CLID_INUSE:
            if data.client_using is None:
                raise TypeError, 'data.client_using == None'
            self.pack_clientaddr4(data.client_using)
        else:
            pass

    def pack_SETCLIENTID_CONFIRM4args(self, data):
        if data.clientid is None:
            raise TypeError, 'data.clientid == None'
        self.pack_clientid4(data.clientid)
        if data.setclientid_confirm is None:
            raise TypeError, 'data.setclientid_confirm == None'
        self.pack_verifier4(data.setclientid_confirm)

    def pack_SETCLIENTID_CONFIRM4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_VERIFY4args(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr4(data.obj_attributes)

    def pack_VERIFY4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_stable_how4(self, data):
        if data not in [const.UNSTABLE4, const.DATA_SYNC4, const.FILE_SYNC4]:
            raise XDRError, 'value=%s not in enum stable_how4' % data
        self.pack_int(data)

    def pack_WRITE4args(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset4(data.offset)
        if data.stable is None:
            raise TypeError, 'data.stable == None'
        self.pack_stable_how4(data.stable)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_opaque(data.data)

    def pack_WRITE4resok(self, data):
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count4(data.count)
        if data.committed is None:
            raise TypeError, 'data.committed == None'
        self.pack_stable_how4(data.committed)
        if data.writeverf is None:
            raise TypeError, 'data.writeverf == None'
        self.pack_verifier4(data.writeverf)

    def pack_WRITE4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_WRITE4resok(data.resok4)
        else:
            pass

    def pack_RELEASE_LOCKOWNER4args(self, data):
        if data.lock_owner is None:
            raise TypeError, 'data.lock_owner == None'
        self.pack_lock_owner4(data.lock_owner)

    def pack_RELEASE_LOCKOWNER4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_ILLEGAL4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_nfs_opnum4(self, data):
        if data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_opnum4' % data
        self.pack_int(data)

    def pack_nfs_argop4(self, data):
        if data.argop is None:
            raise TypeError, 'data.argop == None'
        self.pack_nfs_opnum4(data.argop)
        if data.argop == const.OP_ACCESS:
            if data.opaccess is None:
                raise TypeError, 'data.opaccess == None'
            self.pack_ACCESS4args(data.opaccess)
        elif data.argop == const.OP_CLOSE:
            if data.opclose is None:
                raise TypeError, 'data.opclose == None'
            self.pack_CLOSE4args(data.opclose)
        elif data.argop == const.OP_COMMIT:
            if data.opcommit is None:
                raise TypeError, 'data.opcommit == None'
            self.pack_COMMIT4args(data.opcommit)
        elif data.argop == const.OP_CREATE:
            if data.opcreate is None:
                raise TypeError, 'data.opcreate == None'
            self.pack_CREATE4args(data.opcreate)
        elif data.argop == const.OP_DELEGPURGE:
            if data.opdelegpurge is None:
                raise TypeError, 'data.opdelegpurge == None'
            self.pack_DELEGPURGE4args(data.opdelegpurge)
        elif data.argop == const.OP_DELEGRETURN:
            if data.opdelegreturn is None:
                raise TypeError, 'data.opdelegreturn == None'
            self.pack_DELEGRETURN4args(data.opdelegreturn)
        elif data.argop == const.OP_GETATTR:
            if data.opgetattr is None:
                raise TypeError, 'data.opgetattr == None'
            self.pack_GETATTR4args(data.opgetattr)
        elif data.argop == const.OP_GETFH:
            pass
        elif data.argop == const.OP_LINK:
            if data.oplink is None:
                raise TypeError, 'data.oplink == None'
            self.pack_LINK4args(data.oplink)
        elif data.argop == const.OP_LOCK:
            if data.oplock is None:
                raise TypeError, 'data.oplock == None'
            self.pack_LOCK4args(data.oplock)
        elif data.argop == const.OP_LOCKT:
            if data.oplockt is None:
                raise TypeError, 'data.oplockt == None'
            self.pack_LOCKT4args(data.oplockt)
        elif data.argop == const.OP_LOCKU:
            if data.oplocku is None:
                raise TypeError, 'data.oplocku == None'
            self.pack_LOCKU4args(data.oplocku)
        elif data.argop == const.OP_LOOKUP:
            if data.oplookup is None:
                raise TypeError, 'data.oplookup == None'
            self.pack_LOOKUP4args(data.oplookup)
        elif data.argop == const.OP_LOOKUPP:
            pass
        elif data.argop == const.OP_NVERIFY:
            if data.opnverify is None:
                raise TypeError, 'data.opnverify == None'
            self.pack_NVERIFY4args(data.opnverify)
        elif data.argop == const.OP_OPEN:
            if data.opopen is None:
                raise TypeError, 'data.opopen == None'
            self.pack_OPEN4args(data.opopen)
        elif data.argop == const.OP_OPENATTR:
            if data.opopenattr is None:
                raise TypeError, 'data.opopenattr == None'
            self.pack_OPENATTR4args(data.opopenattr)
        elif data.argop == const.OP_OPEN_CONFIRM:
            if data.opopen_confirm is None:
                raise TypeError, 'data.opopen_confirm == None'
            self.pack_OPEN_CONFIRM4args(data.opopen_confirm)
        elif data.argop == const.OP_OPEN_DOWNGRADE:
            if data.opopen_downgrade is None:
                raise TypeError, 'data.opopen_downgrade == None'
            self.pack_OPEN_DOWNGRADE4args(data.opopen_downgrade)
        elif data.argop == const.OP_PUTFH:
            if data.opputfh is None:
                raise TypeError, 'data.opputfh == None'
            self.pack_PUTFH4args(data.opputfh)
        elif data.argop == const.OP_PUTPUBFH:
            pass
        elif data.argop == const.OP_PUTROOTFH:
            pass
        elif data.argop == const.OP_READ:
            if data.opread is None:
                raise TypeError, 'data.opread == None'
            self.pack_READ4args(data.opread)
        elif data.argop == const.OP_READDIR:
            if data.opreaddir is None:
                raise TypeError, 'data.opreaddir == None'
            self.pack_READDIR4args(data.opreaddir)
        elif data.argop == const.OP_READLINK:
            pass
        elif data.argop == const.OP_REMOVE:
            if data.opremove is None:
                raise TypeError, 'data.opremove == None'
            self.pack_REMOVE4args(data.opremove)
        elif data.argop == const.OP_RENAME:
            if data.oprename is None:
                raise TypeError, 'data.oprename == None'
            self.pack_RENAME4args(data.oprename)
        elif data.argop == const.OP_RENEW:
            if data.oprenew is None:
                raise TypeError, 'data.oprenew == None'
            self.pack_RENEW4args(data.oprenew)
        elif data.argop == const.OP_RESTOREFH:
            pass
        elif data.argop == const.OP_SAVEFH:
            pass
        elif data.argop == const.OP_SECINFO:
            if data.opsecinfo is None:
                raise TypeError, 'data.opsecinfo == None'
            self.pack_SECINFO4args(data.opsecinfo)
        elif data.argop == const.OP_SETATTR:
            if data.opsetattr is None:
                raise TypeError, 'data.opsetattr == None'
            self.pack_SETATTR4args(data.opsetattr)
        elif data.argop == const.OP_SETCLIENTID:
            if data.opsetclientid is None:
                raise TypeError, 'data.opsetclientid == None'
            self.pack_SETCLIENTID4args(data.opsetclientid)
        elif data.argop == const.OP_SETCLIENTID_CONFIRM:
            if data.opsetclientid_confirm is None:
                raise TypeError, 'data.opsetclientid_confirm == None'
            self.pack_SETCLIENTID_CONFIRM4args(data.opsetclientid_confirm)
        elif data.argop == const.OP_VERIFY:
            if data.opverify is None:
                raise TypeError, 'data.opverify == None'
            self.pack_VERIFY4args(data.opverify)
        elif data.argop == const.OP_WRITE:
            if data.opwrite is None:
                raise TypeError, 'data.opwrite == None'
            self.pack_WRITE4args(data.opwrite)
        elif data.argop == const.OP_RELEASE_LOCKOWNER:
            if data.oprelease_lockowner is None:
                raise TypeError, 'data.oprelease_lockowner == None'
            self.pack_RELEASE_LOCKOWNER4args(data.oprelease_lockowner)
        elif data.argop == const.OP_ILLEGAL:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.argop

    def pack_nfs_resop4(self, data):
        if data.resop is None:
            raise TypeError, 'data.resop == None'
        self.pack_nfs_opnum4(data.resop)
        if data.resop == const.OP_ACCESS:
            if data.opaccess is None:
                raise TypeError, 'data.opaccess == None'
            self.pack_ACCESS4res(data.opaccess)
        elif data.resop == const.OP_CLOSE:
            if data.opclose is None:
                raise TypeError, 'data.opclose == None'
            self.pack_CLOSE4res(data.opclose)
        elif data.resop == const.OP_COMMIT:
            if data.opcommit is None:
                raise TypeError, 'data.opcommit == None'
            self.pack_COMMIT4res(data.opcommit)
        elif data.resop == const.OP_CREATE:
            if data.opcreate is None:
                raise TypeError, 'data.opcreate == None'
            self.pack_CREATE4res(data.opcreate)
        elif data.resop == const.OP_DELEGPURGE:
            if data.opdelegpurge is None:
                raise TypeError, 'data.opdelegpurge == None'
            self.pack_DELEGPURGE4res(data.opdelegpurge)
        elif data.resop == const.OP_DELEGRETURN:
            if data.opdelegreturn is None:
                raise TypeError, 'data.opdelegreturn == None'
            self.pack_DELEGRETURN4res(data.opdelegreturn)
        elif data.resop == const.OP_GETATTR:
            if data.opgetattr is None:
                raise TypeError, 'data.opgetattr == None'
            self.pack_GETATTR4res(data.opgetattr)
        elif data.resop == const.OP_GETFH:
            if data.opgetfh is None:
                raise TypeError, 'data.opgetfh == None'
            self.pack_GETFH4res(data.opgetfh)
        elif data.resop == const.OP_LINK:
            if data.oplink is None:
                raise TypeError, 'data.oplink == None'
            self.pack_LINK4res(data.oplink)
        elif data.resop == const.OP_LOCK:
            if data.oplock is None:
                raise TypeError, 'data.oplock == None'
            self.pack_LOCK4res(data.oplock)
        elif data.resop == const.OP_LOCKT:
            if data.oplockt is None:
                raise TypeError, 'data.oplockt == None'
            self.pack_LOCKT4res(data.oplockt)
        elif data.resop == const.OP_LOCKU:
            if data.oplocku is None:
                raise TypeError, 'data.oplocku == None'
            self.pack_LOCKU4res(data.oplocku)
        elif data.resop == const.OP_LOOKUP:
            if data.oplookup is None:
                raise TypeError, 'data.oplookup == None'
            self.pack_LOOKUP4res(data.oplookup)
        elif data.resop == const.OP_LOOKUPP:
            if data.oplookupp is None:
                raise TypeError, 'data.oplookupp == None'
            self.pack_LOOKUPP4res(data.oplookupp)
        elif data.resop == const.OP_NVERIFY:
            if data.opnverify is None:
                raise TypeError, 'data.opnverify == None'
            self.pack_NVERIFY4res(data.opnverify)
        elif data.resop == const.OP_OPEN:
            if data.opopen is None:
                raise TypeError, 'data.opopen == None'
            self.pack_OPEN4res(data.opopen)
        elif data.resop == const.OP_OPENATTR:
            if data.opopenattr is None:
                raise TypeError, 'data.opopenattr == None'
            self.pack_OPENATTR4res(data.opopenattr)
        elif data.resop == const.OP_OPEN_CONFIRM:
            if data.opopen_confirm is None:
                raise TypeError, 'data.opopen_confirm == None'
            self.pack_OPEN_CONFIRM4res(data.opopen_confirm)
        elif data.resop == const.OP_OPEN_DOWNGRADE:
            if data.opopen_downgrade is None:
                raise TypeError, 'data.opopen_downgrade == None'
            self.pack_OPEN_DOWNGRADE4res(data.opopen_downgrade)
        elif data.resop == const.OP_PUTFH:
            if data.opputfh is None:
                raise TypeError, 'data.opputfh == None'
            self.pack_PUTFH4res(data.opputfh)
        elif data.resop == const.OP_PUTPUBFH:
            if data.opputpubfh is None:
                raise TypeError, 'data.opputpubfh == None'
            self.pack_PUTPUBFH4res(data.opputpubfh)
        elif data.resop == const.OP_PUTROOTFH:
            if data.opputrootfh is None:
                raise TypeError, 'data.opputrootfh == None'
            self.pack_PUTROOTFH4res(data.opputrootfh)
        elif data.resop == const.OP_READ:
            if data.opread is None:
                raise TypeError, 'data.opread == None'
            self.pack_READ4res(data.opread)
        elif data.resop == const.OP_READDIR:
            if data.opreaddir is None:
                raise TypeError, 'data.opreaddir == None'
            self.pack_READDIR4res(data.opreaddir)
        elif data.resop == const.OP_READLINK:
            if data.opreadlink is None:
                raise TypeError, 'data.opreadlink == None'
            self.pack_READLINK4res(data.opreadlink)
        elif data.resop == const.OP_REMOVE:
            if data.opremove is None:
                raise TypeError, 'data.opremove == None'
            self.pack_REMOVE4res(data.opremove)
        elif data.resop == const.OP_RENAME:
            if data.oprename is None:
                raise TypeError, 'data.oprename == None'
            self.pack_RENAME4res(data.oprename)
        elif data.resop == const.OP_RENEW:
            if data.oprenew is None:
                raise TypeError, 'data.oprenew == None'
            self.pack_RENEW4res(data.oprenew)
        elif data.resop == const.OP_RESTOREFH:
            if data.oprestorefh is None:
                raise TypeError, 'data.oprestorefh == None'
            self.pack_RESTOREFH4res(data.oprestorefh)
        elif data.resop == const.OP_SAVEFH:
            if data.opsavefh is None:
                raise TypeError, 'data.opsavefh == None'
            self.pack_SAVEFH4res(data.opsavefh)
        elif data.resop == const.OP_SECINFO:
            if data.opsecinfo is None:
                raise TypeError, 'data.opsecinfo == None'
            self.pack_SECINFO4res(data.opsecinfo)
        elif data.resop == const.OP_SETATTR:
            if data.opsetattr is None:
                raise TypeError, 'data.opsetattr == None'
            self.pack_SETATTR4res(data.opsetattr)
        elif data.resop == const.OP_SETCLIENTID:
            if data.opsetclientid is None:
                raise TypeError, 'data.opsetclientid == None'
            self.pack_SETCLIENTID4res(data.opsetclientid)
        elif data.resop == const.OP_SETCLIENTID_CONFIRM:
            if data.opsetclientid_confirm is None:
                raise TypeError, 'data.opsetclientid_confirm == None'
            self.pack_SETCLIENTID_CONFIRM4res(data.opsetclientid_confirm)
        elif data.resop == const.OP_VERIFY:
            if data.opverify is None:
                raise TypeError, 'data.opverify == None'
            self.pack_VERIFY4res(data.opverify)
        elif data.resop == const.OP_WRITE:
            if data.opwrite is None:
                raise TypeError, 'data.opwrite == None'
            self.pack_WRITE4res(data.opwrite)
        elif data.resop == const.OP_RELEASE_LOCKOWNER:
            if data.oprelease_lockowner is None:
                raise TypeError, 'data.oprelease_lockowner == None'
            self.pack_RELEASE_LOCKOWNER4res(data.oprelease_lockowner)
        elif data.resop == const.OP_ILLEGAL:
            if data.opillegal is None:
                raise TypeError, 'data.opillegal == None'
            self.pack_ILLEGAL4res(data.opillegal)
        else:
            raise XDRError, 'bad switch=%s' % data.resop

    def pack_COMPOUND4args(self, data):
        if data.tag is None:
            raise TypeError, 'data.tag == None'
        self.pack_utf8str_cs(data.tag)
        if data.minorversion is None:
            raise TypeError, 'data.minorversion == None'
        self.pack_uint32_t(data.minorversion)
        if data.argarray is None:
            raise TypeError, 'data.argarray == None'
        self.pack_array(data.argarray, self.pack_nfs_argop4)

    def pack_COMPOUND4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.tag is None:
            raise TypeError, 'data.tag == None'
        self.pack_utf8str_cs(data.tag)
        if data.resarray is None:
            raise TypeError, 'data.resarray == None'
        self.pack_array(data.resarray, self.pack_nfs_resop4)

    def pack_CB_GETATTR4args(self, data):
        if data.fh is None:
            raise TypeError, 'data.fh == None'
        self.pack_nfs_fh4(data.fh)
        if data.attr_request is None:
            raise TypeError, 'data.attr_request == None'
        self.pack_bitmap4(data.attr_request)

    def pack_CB_GETATTR4resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr4(data.obj_attributes)

    def pack_CB_GETATTR4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError, 'data.resok4 == None'
            self.pack_CB_GETATTR4resok(data.resok4)
        else:
            pass

    def pack_CB_RECALL4args(self, data):
        if data.stateid is None:
            raise TypeError, 'data.stateid == None'
        self.pack_stateid4(data.stateid)
        if data.truncate is None:
            raise TypeError, 'data.truncate == None'
        self.pack_bool(data.truncate)
        if data.fh is None:
            raise TypeError, 'data.fh == None'
        self.pack_nfs_fh4(data.fh)

    def pack_CB_RECALL4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_CB_ILLEGAL4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)

    def pack_nfs_cb_opnum4(self, data):
        if data not in [const.OP_CB_GETATTR, const.OP_CB_RECALL, const.OP_CB_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_cb_opnum4' % data
        self.pack_int(data)

    def pack_nfs_cb_argop4(self, data):
        if data.argop is None:
            raise TypeError, 'data.argop == None'
        self.pack_unsigned(data.argop)
        if data.argop == const.OP_CB_GETATTR:
            if data.opcbgetattr is None:
                raise TypeError, 'data.opcbgetattr == None'
            self.pack_CB_GETATTR4args(data.opcbgetattr)
        elif data.argop == const.OP_CB_RECALL:
            if data.opcbrecall is None:
                raise TypeError, 'data.opcbrecall == None'
            self.pack_CB_RECALL4args(data.opcbrecall)
        elif data.argop == const.OP_CB_ILLEGAL:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.argop

    def pack_nfs_cb_resop4(self, data):
        if data.resop is None:
            raise TypeError, 'data.resop == None'
        self.pack_unsigned(data.resop)
        if data.resop == const.OP_CB_GETATTR:
            if data.opcbgetattr is None:
                raise TypeError, 'data.opcbgetattr == None'
            self.pack_CB_GETATTR4res(data.opcbgetattr)
        elif data.resop == const.OP_CB_RECALL:
            if data.opcbrecall is None:
                raise TypeError, 'data.opcbrecall == None'
            self.pack_CB_RECALL4res(data.opcbrecall)
        elif data.resop == const.OP_CB_ILLEGAL:
            if data.opcbillegal is None:
                raise TypeError, 'data.opcbillegal == None'
            self.pack_CB_ILLEGAL4res(data.opcbillegal)
        else:
            raise XDRError, 'bad switch=%s' % data.resop

    def pack_CB_COMPOUND4args(self, data):
        if data.tag is None:
            raise TypeError, 'data.tag == None'
        self.pack_utf8str_cs(data.tag)
        if data.minorversion is None:
            raise TypeError, 'data.minorversion == None'
        self.pack_uint32_t(data.minorversion)
        if data.callback_ident is None:
            raise TypeError, 'data.callback_ident == None'
        self.pack_uint32_t(data.callback_ident)
        if data.argarray is None:
            raise TypeError, 'data.argarray == None'
        self.pack_array(data.argarray, self.pack_nfs_cb_argop4)

    def pack_CB_COMPOUND4res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat4(data.status)
        if data.tag is None:
            raise TypeError, 'data.tag == None'
        self.pack_utf8str_cs(data.tag)
        if data.resarray is None:
            raise TypeError, 'data.resarray == None'
        self.pack_array(data.resarray, self.pack_nfs_cb_resop4)

class NFS4Unpacker(xdrlib.Unpacker):
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_bool = xdrlib.Unpacker.unpack_bool
    unpack_int32_t = unpack_int

    unpack_uint32_t = unpack_uint

    unpack_int64_t = unpack_hyper

    unpack_uint64_t = unpack_uhyper

    def unpack_nfs_ftype4(self):
        data = self.unpack_int()
        if data not in [const.NF4REG, const.NF4DIR, const.NF4BLK, const.NF4CHR, const.NF4LNK, const.NF4SOCK, const.NF4FIFO, const.NF4ATTRDIR, const.NF4NAMEDATTR]:
            raise XDRError, 'value=%s not in enum nfs_ftype4' % data
        return data

    def unpack_nfsstat4(self):
        data = self.unpack_int()
        if data not in [const.NFS4_OK, const.NFS4ERR_PERM, const.NFS4ERR_NOENT, const.NFS4ERR_IO, const.NFS4ERR_NXIO, const.NFS4ERR_ACCESS, const.NFS4ERR_EXIST, const.NFS4ERR_XDEV, const.NFS4ERR_NOTDIR, const.NFS4ERR_ISDIR, const.NFS4ERR_INVAL, const.NFS4ERR_FBIG, const.NFS4ERR_NOSPC, const.NFS4ERR_ROFS, const.NFS4ERR_MLINK, const.NFS4ERR_NAMETOOLONG, const.NFS4ERR_NOTEMPTY, const.NFS4ERR_DQUOT, const.NFS4ERR_STALE, const.NFS4ERR_BADHANDLE, const.NFS4ERR_BAD_COOKIE, const.NFS4ERR_NOTSUPP, const.NFS4ERR_TOOSMALL, const.NFS4ERR_SERVERFAULT, const.NFS4ERR_BADTYPE, const.NFS4ERR_DELAY, const.NFS4ERR_SAME, const.NFS4ERR_DENIED, const.NFS4ERR_EXPIRED, const.NFS4ERR_LOCKED, const.NFS4ERR_GRACE, const.NFS4ERR_FHEXPIRED, const.NFS4ERR_SHARE_DENIED, const.NFS4ERR_WRONGSEC, const.NFS4ERR_CLID_INUSE, const.NFS4ERR_RESOURCE, const.NFS4ERR_MOVED, const.NFS4ERR_NOFILEHANDLE, const.NFS4ERR_MINOR_VERS_MISMATCH, const.NFS4ERR_STALE_CLIENTID, const.NFS4ERR_STALE_STATEID, const.NFS4ERR_OLD_STATEID, const.NFS4ERR_BAD_STATEID, const.NFS4ERR_BAD_SEQID, const.NFS4ERR_NOT_SAME, const.NFS4ERR_LOCK_RANGE, const.NFS4ERR_SYMLINK, const.NFS4ERR_RESTOREFH, const.NFS4ERR_LEASE_MOVED, const.NFS4ERR_ATTRNOTSUPP, const.NFS4ERR_NO_GRACE, const.NFS4ERR_RECLAIM_BAD, const.NFS4ERR_RECLAIM_CONFLICT, const.NFS4ERR_BADXDR, const.NFS4ERR_LOCKS_HELD, const.NFS4ERR_OPENMODE, const.NFS4ERR_BADOWNER, const.NFS4ERR_BADCHAR, const.NFS4ERR_BADNAME, const.NFS4ERR_BAD_RANGE, const.NFS4ERR_LOCK_NOTSUPP, const.NFS4ERR_OP_ILLEGAL, const.NFS4ERR_DEADLOCK, const.NFS4ERR_FILE_OPEN, const.NFS4ERR_ADMIN_REVOKED, const.NFS4ERR_CB_PATH_DOWN]:
            raise XDRError, 'value=%s not in enum nfsstat4' % data
        return data

    def unpack_bitmap4(self):
        data = self.unpack_array(self.unpack_uint32_t)
        return data

    unpack_offset4 = unpack_uint64_t

    unpack_count4 = unpack_uint32_t

    unpack_length4 = unpack_uint64_t

    unpack_clientid4 = unpack_uint64_t

    unpack_seqid4 = unpack_uint32_t

    def unpack_utf8string(self):
        data = self.unpack_opaque()
        return data

    unpack_utf8str_cis = unpack_utf8string

    unpack_utf8str_cs = unpack_utf8string

    unpack_utf8str_mixed = unpack_utf8string

    unpack_component4 = unpack_utf8str_cs

    def unpack_pathname4(self):
        data = self.unpack_array(self.unpack_component4)
        return data

    unpack_nfs_lockid4 = unpack_uint64_t

    unpack_nfs_cookie4 = unpack_uint64_t

    unpack_linktext4 = unpack_utf8str_cs

    def unpack_sec_oid4(self):
        data = self.unpack_opaque()
        return data

    unpack_qop4 = unpack_uint32_t

    unpack_mode4 = unpack_uint32_t

    unpack_changeid4 = unpack_uint64_t

    def unpack_verifier4(self):
        data = self.unpack_fopaque(const.NFS4_VERIFIER_SIZE)
        return data

    def unpack_nfstime4(self):
        data = types.nfstime4()
        data.seconds = self.unpack_int64_t()
        data.nseconds = self.unpack_uint32_t()
        return data

    def unpack_time_how4(self):
        data = self.unpack_int()
        if data not in [const.SET_TO_SERVER_TIME4, const.SET_TO_CLIENT_TIME4]:
            raise XDRError, 'value=%s not in enum time_how4' % data
        return data

    def unpack_settime4(self):
        data = types.settime4()
        data.set_it = self.unpack_time_how4()
        if data.set_it == const.SET_TO_CLIENT_TIME4:
            data.time = self.unpack_nfstime4()
            data.arm = data.time
        else:
            pass
            data.arm = None
        return data

    def unpack_nfs_fh4(self):
        data = self.unpack_opaque()
        if len(data) > const.NFS4_FHSIZE:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_fsid4(self):
        data = types.fsid4()
        data.major = self.unpack_uint64_t()
        data.minor = self.unpack_uint64_t()
        return data

    def unpack_fs_location4(self):
        data = types.fs_location4()
        data.server = self.unpack_array(self.unpack_utf8str_cis)
        data.rootpath = self.unpack_pathname4()
        return data

    def unpack_fs_locations4(self):
        data = types.fs_locations4()
        data.fs_root = self.unpack_pathname4()
        data.locations = self.unpack_array(self.unpack_fs_location4)
        return data

    unpack_acetype4 = unpack_uint32_t

    unpack_aceflag4 = unpack_uint32_t

    unpack_acemask4 = unpack_uint32_t

    def unpack_nfsace4(self):
        data = types.nfsace4()
        data.type = self.unpack_acetype4()
        data.flag = self.unpack_aceflag4()
        data.access_mask = self.unpack_acemask4()
        data.who = self.unpack_utf8str_mixed()
        return data

    def unpack_specdata4(self):
        data = types.specdata4()
        data.specdata1 = self.unpack_uint32_t()
        data.specdata2 = self.unpack_uint32_t()
        return data

    unpack_fattr4_supported_attrs = unpack_bitmap4

    unpack_fattr4_type = unpack_nfs_ftype4

    unpack_fattr4_fh_expire_type = unpack_uint32_t

    unpack_fattr4_change = unpack_changeid4

    unpack_fattr4_size = unpack_uint64_t

    unpack_fattr4_link_support = unpack_bool

    unpack_fattr4_symlink_support = unpack_bool

    unpack_fattr4_named_attr = unpack_bool

    unpack_fattr4_fsid = unpack_fsid4

    unpack_fattr4_unique_handles = unpack_bool

    unpack_fattr4_lease_time = unpack_uint32_t

    unpack_fattr4_rdattr_error = unpack_nfsstat4

    def unpack_fattr4_acl(self):
        data = self.unpack_array(self.unpack_nfsace4)
        return data

    unpack_fattr4_aclsupport = unpack_uint32_t

    unpack_fattr4_archive = unpack_bool

    unpack_fattr4_cansettime = unpack_bool

    unpack_fattr4_case_insensitive = unpack_bool

    unpack_fattr4_case_preserving = unpack_bool

    unpack_fattr4_chown_restricted = unpack_bool

    unpack_fattr4_fileid = unpack_uint64_t

    unpack_fattr4_files_avail = unpack_uint64_t

    unpack_fattr4_filehandle = unpack_nfs_fh4

    unpack_fattr4_files_free = unpack_uint64_t

    unpack_fattr4_files_total = unpack_uint64_t

    unpack_fattr4_fs_locations = unpack_fs_locations4

    unpack_fattr4_hidden = unpack_bool

    unpack_fattr4_homogeneous = unpack_bool

    unpack_fattr4_maxfilesize = unpack_uint64_t

    unpack_fattr4_maxlink = unpack_uint32_t

    unpack_fattr4_maxname = unpack_uint32_t

    unpack_fattr4_maxread = unpack_uint64_t

    unpack_fattr4_maxwrite = unpack_uint64_t

    unpack_fattr4_mimetype = unpack_utf8str_cs

    unpack_fattr4_mode = unpack_mode4

    unpack_fattr4_mounted_on_fileid = unpack_uint64_t

    unpack_fattr4_no_trunc = unpack_bool

    unpack_fattr4_numlinks = unpack_uint32_t

    unpack_fattr4_owner = unpack_utf8str_mixed

    unpack_fattr4_owner_group = unpack_utf8str_mixed

    unpack_fattr4_quota_avail_hard = unpack_uint64_t

    unpack_fattr4_quota_avail_soft = unpack_uint64_t

    unpack_fattr4_quota_used = unpack_uint64_t

    unpack_fattr4_rawdev = unpack_specdata4

    unpack_fattr4_space_avail = unpack_uint64_t

    unpack_fattr4_space_free = unpack_uint64_t

    unpack_fattr4_space_total = unpack_uint64_t

    unpack_fattr4_space_used = unpack_uint64_t

    unpack_fattr4_system = unpack_bool

    unpack_fattr4_time_access = unpack_nfstime4

    unpack_fattr4_time_access_set = unpack_settime4

    unpack_fattr4_time_backup = unpack_nfstime4

    unpack_fattr4_time_create = unpack_nfstime4

    unpack_fattr4_time_delta = unpack_nfstime4

    unpack_fattr4_time_metadata = unpack_nfstime4

    unpack_fattr4_time_modify = unpack_nfstime4

    unpack_fattr4_time_modify_set = unpack_settime4

    def unpack_attrlist4(self):
        data = self.unpack_opaque()
        return data

    def unpack_fattr4(self):
        data = types.fattr4()
        data.attrmask = self.unpack_bitmap4()
        data.attr_vals = self.unpack_attrlist4()
        return data

    def unpack_change_info4(self):
        data = types.change_info4()
        data.atomic = self.unpack_bool()
        data.before = self.unpack_changeid4()
        data.after = self.unpack_changeid4()
        return data

    def unpack_clientaddr4(self):
        data = types.clientaddr4()
        data.r_netid = self.unpack_string()
        data.r_addr = self.unpack_string()
        return data

    def unpack_cb_client4(self):
        data = types.cb_client4()
        data.cb_program = self.unpack_uint32_t()
        data.cb_location = self.unpack_clientaddr4()
        return data

    def unpack_stateid4(self):
        data = types.stateid4()
        data.seqid = self.unpack_uint32_t()
        data.other = self.unpack_fopaque(12)
        return data

    def unpack_nfs_client_id4(self):
        data = types.nfs_client_id4()
        data.verifier = self.unpack_verifier4()
        data.id = self.unpack_opaque()
        if len(data.id) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.id'
        return data

    def unpack_open_owner4(self):
        data = types.open_owner4()
        data.clientid = self.unpack_clientid4()
        data.owner = self.unpack_opaque()
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.owner'
        return data

    def unpack_lock_owner4(self):
        data = types.lock_owner4()
        data.clientid = self.unpack_clientid4()
        data.owner = self.unpack_opaque()
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT:
            raise XDRError, 'array length too long for data.owner'
        return data

    def unpack_nfs_lock_type4(self):
        data = self.unpack_int()
        if data not in [const.READ_LT, const.WRITE_LT, const.READW_LT, const.WRITEW_LT]:
            raise XDRError, 'value=%s not in enum nfs_lock_type4' % data
        return data

    def unpack_ACCESS4args(self):
        data = types.ACCESS4args()
        data.access = self.unpack_uint32_t()
        return data

    def unpack_ACCESS4resok(self):
        data = types.ACCESS4resok()
        data.supported = self.unpack_uint32_t()
        data.access = self.unpack_uint32_t()
        return data

    def unpack_ACCESS4res(self):
        data = types.ACCESS4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_ACCESS4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_CLOSE4args(self):
        data = types.CLOSE4args()
        data.seqid = self.unpack_seqid4()
        data.open_stateid = self.unpack_stateid4()
        return data

    def unpack_CLOSE4res(self):
        data = types.CLOSE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.open_stateid = self.unpack_stateid4()
            data.arm = data.open_stateid
        else:
            pass
            data.arm = None
        return data

    def unpack_COMMIT4args(self):
        data = types.COMMIT4args()
        data.offset = self.unpack_offset4()
        data.count = self.unpack_count4()
        return data

    def unpack_COMMIT4resok(self):
        data = types.COMMIT4resok()
        data.writeverf = self.unpack_verifier4()
        return data

    def unpack_COMMIT4res(self):
        data = types.COMMIT4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_COMMIT4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_createtype4(self):
        data = types.createtype4()
        data.type = self.unpack_nfs_ftype4()
        if data.type == const.NF4LNK:
            data.linkdata = self.unpack_linktext4()
            data.arm = data.linkdata
        elif data.type == const.NF4BLK or data.type == const.NF4CHR:
            data.devdata = self.unpack_specdata4()
            data.arm = data.devdata
        elif data.type == const.NF4SOCK or data.type == const.NF4FIFO or data.type == const.NF4DIR:
            pass
            data.arm = None
        else:
            pass
            data.arm = None
        return data

    def unpack_CREATE4args(self):
        data = types.CREATE4args()
        data.objtype = self.unpack_createtype4()
        data.objname = self.unpack_component4()
        data.createattrs = self.unpack_fattr4()
        return data

    def unpack_CREATE4resok(self):
        data = types.CREATE4resok()
        data.cinfo = self.unpack_change_info4()
        data.attrset = self.unpack_bitmap4()
        return data

    def unpack_CREATE4res(self):
        data = types.CREATE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_CREATE4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_DELEGPURGE4args(self):
        data = types.DELEGPURGE4args()
        data.clientid = self.unpack_clientid4()
        return data

    def unpack_DELEGPURGE4res(self):
        data = types.DELEGPURGE4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_DELEGRETURN4args(self):
        data = types.DELEGRETURN4args()
        data.deleg_stateid = self.unpack_stateid4()
        return data

    def unpack_DELEGRETURN4res(self):
        data = types.DELEGRETURN4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_GETATTR4args(self):
        data = types.GETATTR4args()
        data.attr_request = self.unpack_bitmap4()
        return data

    def unpack_GETATTR4resok(self):
        data = types.GETATTR4resok()
        data.obj_attributes = self.unpack_fattr4()
        return data

    def unpack_GETATTR4res(self):
        data = types.GETATTR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_GETATTR4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_GETFH4resok(self):
        data = types.GETFH4resok()
        data.object = self.unpack_nfs_fh4()
        return data

    def unpack_GETFH4res(self):
        data = types.GETFH4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_GETFH4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_LINK4args(self):
        data = types.LINK4args()
        data.newname = self.unpack_component4()
        return data

    def unpack_LINK4resok(self):
        data = types.LINK4resok()
        data.cinfo = self.unpack_change_info4()
        return data

    def unpack_LINK4res(self):
        data = types.LINK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_LINK4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_open_to_lock_owner4(self):
        data = types.open_to_lock_owner4()
        data.open_seqid = self.unpack_seqid4()
        data.open_stateid = self.unpack_stateid4()
        data.lock_seqid = self.unpack_seqid4()
        data.lock_owner = self.unpack_lock_owner4()
        return data

    def unpack_exist_lock_owner4(self):
        data = types.exist_lock_owner4()
        data.lock_stateid = self.unpack_stateid4()
        data.lock_seqid = self.unpack_seqid4()
        return data

    def unpack_locker4(self):
        data = types.locker4()
        data.new_lock_owner = self.unpack_bool()
        if data.new_lock_owner == const.TRUE:
            data.open_owner = self.unpack_open_to_lock_owner4()
            data.arm = data.open_owner
        elif data.new_lock_owner == const.FALSE:
            data.lock_owner = self.unpack_exist_lock_owner4()
            data.arm = data.lock_owner
        else:
            raise XDRError, 'bad switch=%s' % data.new_lock_owner
        return data

    def unpack_LOCK4args(self):
        data = types.LOCK4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.reclaim = self.unpack_bool()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.locker = self.unpack_locker4()
        return data

    def unpack_LOCK4denied(self):
        data = types.LOCK4denied()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.locktype = self.unpack_nfs_lock_type4()
        data.owner = self.unpack_lock_owner4()
        return data

    def unpack_LOCK4resok(self):
        data = types.LOCK4resok()
        data.lock_stateid = self.unpack_stateid4()
        return data

    def unpack_LOCK4res(self):
        data = types.LOCK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_LOCK4resok()
            data.arm = data.resok4
        elif data.status == const.NFS4ERR_DENIED:
            data.denied = self.unpack_LOCK4denied()
            data.arm = data.denied
        else:
            pass
            data.arm = None
        return data

    def unpack_LOCKT4args(self):
        data = types.LOCKT4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.owner = self.unpack_lock_owner4()
        return data

    def unpack_LOCKT4res(self):
        data = types.LOCKT4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4ERR_DENIED:
            data.denied = self.unpack_LOCK4denied()
            data.arm = data.denied
        elif data.status == const.NFS4_OK:
            pass
            data.arm = None
        else:
            pass
            data.arm = None
        return data

    def unpack_LOCKU4args(self):
        data = types.LOCKU4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.seqid = self.unpack_seqid4()
        data.lock_stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        return data

    def unpack_LOCKU4res(self):
        data = types.LOCKU4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.lock_stateid = self.unpack_stateid4()
            data.arm = data.lock_stateid
        else:
            pass
            data.arm = None
        return data

    def unpack_LOOKUP4args(self):
        data = types.LOOKUP4args()
        data.objname = self.unpack_component4()
        return data

    def unpack_LOOKUP4res(self):
        data = types.LOOKUP4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_LOOKUPP4res(self):
        data = types.LOOKUPP4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_NVERIFY4args(self):
        data = types.NVERIFY4args()
        data.obj_attributes = self.unpack_fattr4()
        return data

    def unpack_NVERIFY4res(self):
        data = types.NVERIFY4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_createmode4(self):
        data = self.unpack_int()
        if data not in [const.UNCHECKED4, const.GUARDED4, const.EXCLUSIVE4]:
            raise XDRError, 'value=%s not in enum createmode4' % data
        return data

    def unpack_createhow4(self):
        data = types.createhow4()
        data.mode = self.unpack_createmode4()
        if data.mode == const.UNCHECKED4 or data.mode == const.GUARDED4:
            data.createattrs = self.unpack_fattr4()
            data.arm = data.createattrs
        elif data.mode == const.EXCLUSIVE4:
            data.createverf = self.unpack_verifier4()
            data.arm = data.createverf
        else:
            raise XDRError, 'bad switch=%s' % data.mode
        return data

    def unpack_opentype4(self):
        data = self.unpack_int()
        if data not in [const.OPEN4_NOCREATE, const.OPEN4_CREATE]:
            raise XDRError, 'value=%s not in enum opentype4' % data
        return data

    def unpack_openflag4(self):
        data = types.openflag4()
        data.opentype = self.unpack_opentype4()
        if data.opentype == const.OPEN4_CREATE:
            data.how = self.unpack_createhow4()
            data.arm = data.how
        else:
            pass
            data.arm = None
        return data

    def unpack_limit_by4(self):
        data = self.unpack_int()
        if data not in [const.NFS_LIMIT_SIZE, const.NFS_LIMIT_BLOCKS]:
            raise XDRError, 'value=%s not in enum limit_by4' % data
        return data

    def unpack_nfs_modified_limit4(self):
        data = types.nfs_modified_limit4()
        data.num_blocks = self.unpack_uint32_t()
        data.bytes_per_block = self.unpack_uint32_t()
        return data

    def unpack_nfs_space_limit4(self):
        data = types.nfs_space_limit4()
        data.limitby = self.unpack_limit_by4()
        if data.limitby == const.NFS_LIMIT_SIZE:
            data.filesize = self.unpack_uint64_t()
            data.arm = data.filesize
        elif data.limitby == const.NFS_LIMIT_BLOCKS:
            data.mod_blocks = self.unpack_nfs_modified_limit4()
            data.arm = data.mod_blocks
        else:
            raise XDRError, 'bad switch=%s' % data.limitby
        return data

    def unpack_open_delegation_type4(self):
        data = self.unpack_int()
        if data not in [const.OPEN_DELEGATE_NONE, const.OPEN_DELEGATE_READ, const.OPEN_DELEGATE_WRITE]:
            raise XDRError, 'value=%s not in enum open_delegation_type4' % data
        return data

    def unpack_open_claim_type4(self):
        data = self.unpack_int()
        if data not in [const.CLAIM_NULL, const.CLAIM_PREVIOUS, const.CLAIM_DELEGATE_CUR, const.CLAIM_DELEGATE_PREV]:
            raise XDRError, 'value=%s not in enum open_claim_type4' % data
        return data

    def unpack_open_claim_delegate_cur4(self):
        data = types.open_claim_delegate_cur4()
        data.delegate_stateid = self.unpack_stateid4()
        data.file = self.unpack_component4()
        return data

    def unpack_open_claim4(self):
        data = types.open_claim4()
        data.claim = self.unpack_open_claim_type4()
        if data.claim == const.CLAIM_NULL:
            data.file = self.unpack_component4()
            data.arm = data.file
        elif data.claim == const.CLAIM_PREVIOUS:
            data.delegate_type = self.unpack_open_delegation_type4()
            data.arm = data.delegate_type
        elif data.claim == const.CLAIM_DELEGATE_CUR:
            data.delegate_cur_info = self.unpack_open_claim_delegate_cur4()
            data.arm = data.delegate_cur_info
        elif data.claim == const.CLAIM_DELEGATE_PREV:
            data.file_delegate_prev = self.unpack_component4()
            data.arm = data.file_delegate_prev
        else:
            raise XDRError, 'bad switch=%s' % data.claim
        return data

    def unpack_OPEN4args(self):
        data = types.OPEN4args()
        data.seqid = self.unpack_seqid4()
        data.share_access = self.unpack_uint32_t()
        data.share_deny = self.unpack_uint32_t()
        data.owner = self.unpack_open_owner4()
        data.openhow = self.unpack_openflag4()
        data.claim = self.unpack_open_claim4()
        return data

    def unpack_open_read_delegation4(self):
        data = types.open_read_delegation4()
        data.stateid = self.unpack_stateid4()
        data.recall = self.unpack_bool()
        data.permissions = self.unpack_nfsace4()
        return data

    def unpack_open_write_delegation4(self):
        data = types.open_write_delegation4()
        data.stateid = self.unpack_stateid4()
        data.recall = self.unpack_bool()
        data.space_limit = self.unpack_nfs_space_limit4()
        data.permissions = self.unpack_nfsace4()
        return data

    def unpack_open_delegation4(self):
        data = types.open_delegation4()
        data.delegation_type = self.unpack_open_delegation_type4()
        if data.delegation_type == const.OPEN_DELEGATE_NONE:
            pass
            data.arm = None
        elif data.delegation_type == const.OPEN_DELEGATE_READ:
            data.read = self.unpack_open_read_delegation4()
            data.arm = data.read
        elif data.delegation_type == const.OPEN_DELEGATE_WRITE:
            data.write = self.unpack_open_write_delegation4()
            data.arm = data.write
        else:
            raise XDRError, 'bad switch=%s' % data.delegation_type
        return data

    def unpack_OPEN4resok(self):
        data = types.OPEN4resok()
        data.stateid = self.unpack_stateid4()
        data.cinfo = self.unpack_change_info4()
        data.rflags = self.unpack_uint32_t()
        data.attrset = self.unpack_bitmap4()
        data.delegation = self.unpack_open_delegation4()
        return data

    def unpack_OPEN4res(self):
        data = types.OPEN4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_OPENATTR4args(self):
        data = types.OPENATTR4args()
        data.createdir = self.unpack_bool()
        return data

    def unpack_OPENATTR4res(self):
        data = types.OPENATTR4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_OPEN_CONFIRM4args(self):
        data = types.OPEN_CONFIRM4args()
        data.open_stateid = self.unpack_stateid4()
        data.seqid = self.unpack_seqid4()
        return data

    def unpack_OPEN_CONFIRM4resok(self):
        data = types.OPEN_CONFIRM4resok()
        data.open_stateid = self.unpack_stateid4()
        return data

    def unpack_OPEN_CONFIRM4res(self):
        data = types.OPEN_CONFIRM4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN_CONFIRM4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_OPEN_DOWNGRADE4args(self):
        data = types.OPEN_DOWNGRADE4args()
        data.open_stateid = self.unpack_stateid4()
        data.seqid = self.unpack_seqid4()
        data.share_access = self.unpack_uint32_t()
        data.share_deny = self.unpack_uint32_t()
        return data

    def unpack_OPEN_DOWNGRADE4resok(self):
        data = types.OPEN_DOWNGRADE4resok()
        data.open_stateid = self.unpack_stateid4()
        return data

    def unpack_OPEN_DOWNGRADE4res(self):
        data = types.OPEN_DOWNGRADE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN_DOWNGRADE4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_PUTFH4args(self):
        data = types.PUTFH4args()
        data.object = self.unpack_nfs_fh4()
        return data

    def unpack_PUTFH4res(self):
        data = types.PUTFH4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_PUTPUBFH4res(self):
        data = types.PUTPUBFH4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_PUTROOTFH4res(self):
        data = types.PUTROOTFH4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_READ4args(self):
        data = types.READ4args()
        data.stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.count = self.unpack_count4()
        return data

    def unpack_READ4resok(self):
        data = types.READ4resok()
        data.eof = self.unpack_bool()
        data.data = self.unpack_opaque()
        return data

    def unpack_READ4res(self):
        data = types.READ4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READ4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_READDIR4args(self):
        data = types.READDIR4args()
        data.cookie = self.unpack_nfs_cookie4()
        data.cookieverf = self.unpack_verifier4()
        data.dircount = self.unpack_count4()
        data.maxcount = self.unpack_count4()
        data.attr_request = self.unpack_bitmap4()
        return data

    def unpack_entry4(self):
        data = types.entry4()
        data.cookie = self.unpack_nfs_cookie4()
        data.name = self.unpack_component4()
        data.attrs = self.unpack_fattr4()
        data.nextentry = self.unpack_array(self.unpack_entry4)
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        return data

    def unpack_dirlist4(self):
        data = types.dirlist4()
        data.entries = self.unpack_array(self.unpack_entry4)
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        data.eof = self.unpack_bool()
        return data

    def unpack_READDIR4resok(self):
        data = types.READDIR4resok()
        data.cookieverf = self.unpack_verifier4()
        data.reply = self.unpack_dirlist4()
        return data

    def unpack_READDIR4res(self):
        data = types.READDIR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READDIR4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_READLINK4resok(self):
        data = types.READLINK4resok()
        data.link = self.unpack_linktext4()
        return data

    def unpack_READLINK4res(self):
        data = types.READLINK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READLINK4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_REMOVE4args(self):
        data = types.REMOVE4args()
        data.target = self.unpack_component4()
        return data

    def unpack_REMOVE4resok(self):
        data = types.REMOVE4resok()
        data.cinfo = self.unpack_change_info4()
        return data

    def unpack_REMOVE4res(self):
        data = types.REMOVE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_REMOVE4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_RENAME4args(self):
        data = types.RENAME4args()
        data.oldname = self.unpack_component4()
        data.newname = self.unpack_component4()
        return data

    def unpack_RENAME4resok(self):
        data = types.RENAME4resok()
        data.source_cinfo = self.unpack_change_info4()
        data.target_cinfo = self.unpack_change_info4()
        return data

    def unpack_RENAME4res(self):
        data = types.RENAME4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_RENAME4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_RENEW4args(self):
        data = types.RENEW4args()
        data.clientid = self.unpack_clientid4()
        return data

    def unpack_RENEW4res(self):
        data = types.RENEW4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_RESTOREFH4res(self):
        data = types.RESTOREFH4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_SAVEFH4res(self):
        data = types.SAVEFH4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_SECINFO4args(self):
        data = types.SECINFO4args()
        data.name = self.unpack_component4()
        return data

    def unpack_rpc_gss_svc_t(self):
        data = self.unpack_int()
        if data not in [const.RPC_GSS_SVC_NONE, const.RPC_GSS_SVC_INTEGRITY, const.RPC_GSS_SVC_PRIVACY]:
            raise XDRError, 'value=%s not in enum rpc_gss_svc_t' % data
        return data

    def unpack_rpcsec_gss_info(self):
        data = types.rpcsec_gss_info()
        data.oid = self.unpack_sec_oid4()
        data.qop = self.unpack_qop4()
        data.service = self.unpack_rpc_gss_svc_t()
        return data

    def unpack_secinfo4(self):
        data = types.secinfo4()
        data.flavor = self.unpack_uint32_t()
        if data.flavor == const.RPCSEC_GSS:
            data.flavor_info = self.unpack_rpcsec_gss_info()
            data.arm = data.flavor_info
        else:
            pass
            data.arm = None
        return data

    def unpack_SECINFO4resok(self):
        data = self.unpack_array(self.unpack_secinfo4)
        return data

    def unpack_SECINFO4res(self):
        data = types.SECINFO4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_SECINFO4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_SETATTR4args(self):
        data = types.SETATTR4args()
        data.stateid = self.unpack_stateid4()
        data.obj_attributes = self.unpack_fattr4()
        return data

    def unpack_SETATTR4res(self):
        data = types.SETATTR4res()
        data.status = self.unpack_nfsstat4()
        data.attrsset = self.unpack_bitmap4()
        return data

    def unpack_SETCLIENTID4args(self):
        data = types.SETCLIENTID4args()
        data.client = self.unpack_nfs_client_id4()
        data.callback = self.unpack_cb_client4()
        data.callback_ident = self.unpack_uint32_t()
        return data

    def unpack_SETCLIENTID4resok(self):
        data = types.SETCLIENTID4resok()
        data.clientid = self.unpack_clientid4()
        data.setclientid_confirm = self.unpack_verifier4()
        return data

    def unpack_SETCLIENTID4res(self):
        data = types.SETCLIENTID4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_SETCLIENTID4resok()
            data.arm = data.resok4
        elif data.status == const.NFS4ERR_CLID_INUSE:
            data.client_using = self.unpack_clientaddr4()
            data.arm = data.client_using
        else:
            pass
            data.arm = None
        return data

    def unpack_SETCLIENTID_CONFIRM4args(self):
        data = types.SETCLIENTID_CONFIRM4args()
        data.clientid = self.unpack_clientid4()
        data.setclientid_confirm = self.unpack_verifier4()
        return data

    def unpack_SETCLIENTID_CONFIRM4res(self):
        data = types.SETCLIENTID_CONFIRM4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_VERIFY4args(self):
        data = types.VERIFY4args()
        data.obj_attributes = self.unpack_fattr4()
        return data

    def unpack_VERIFY4res(self):
        data = types.VERIFY4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_stable_how4(self):
        data = self.unpack_int()
        if data not in [const.UNSTABLE4, const.DATA_SYNC4, const.FILE_SYNC4]:
            raise XDRError, 'value=%s not in enum stable_how4' % data
        return data

    def unpack_WRITE4args(self):
        data = types.WRITE4args()
        data.stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.stable = self.unpack_stable_how4()
        data.data = self.unpack_opaque()
        return data

    def unpack_WRITE4resok(self):
        data = types.WRITE4resok()
        data.count = self.unpack_count4()
        data.committed = self.unpack_stable_how4()
        data.writeverf = self.unpack_verifier4()
        return data

    def unpack_WRITE4res(self):
        data = types.WRITE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_WRITE4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_RELEASE_LOCKOWNER4args(self):
        data = types.RELEASE_LOCKOWNER4args()
        data.lock_owner = self.unpack_lock_owner4()
        return data

    def unpack_RELEASE_LOCKOWNER4res(self):
        data = types.RELEASE_LOCKOWNER4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_ILLEGAL4res(self):
        data = types.ILLEGAL4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_nfs_opnum4(self):
        data = self.unpack_int()
        if data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_opnum4' % data
        return data

    def unpack_nfs_argop4(self):
        data = types.nfs_argop4()
        data.argop = self.unpack_nfs_opnum4()
        if data.argop == const.OP_ACCESS:
            data.opaccess = self.unpack_ACCESS4args()
            data.arm = data.opaccess
        elif data.argop == const.OP_CLOSE:
            data.opclose = self.unpack_CLOSE4args()
            data.arm = data.opclose
        elif data.argop == const.OP_COMMIT:
            data.opcommit = self.unpack_COMMIT4args()
            data.arm = data.opcommit
        elif data.argop == const.OP_CREATE:
            data.opcreate = self.unpack_CREATE4args()
            data.arm = data.opcreate
        elif data.argop == const.OP_DELEGPURGE:
            data.opdelegpurge = self.unpack_DELEGPURGE4args()
            data.arm = data.opdelegpurge
        elif data.argop == const.OP_DELEGRETURN:
            data.opdelegreturn = self.unpack_DELEGRETURN4args()
            data.arm = data.opdelegreturn
        elif data.argop == const.OP_GETATTR:
            data.opgetattr = self.unpack_GETATTR4args()
            data.arm = data.opgetattr
        elif data.argop == const.OP_GETFH:
            pass
            data.arm = None
        elif data.argop == const.OP_LINK:
            data.oplink = self.unpack_LINK4args()
            data.arm = data.oplink
        elif data.argop == const.OP_LOCK:
            data.oplock = self.unpack_LOCK4args()
            data.arm = data.oplock
        elif data.argop == const.OP_LOCKT:
            data.oplockt = self.unpack_LOCKT4args()
            data.arm = data.oplockt
        elif data.argop == const.OP_LOCKU:
            data.oplocku = self.unpack_LOCKU4args()
            data.arm = data.oplocku
        elif data.argop == const.OP_LOOKUP:
            data.oplookup = self.unpack_LOOKUP4args()
            data.arm = data.oplookup
        elif data.argop == const.OP_LOOKUPP:
            pass
            data.arm = None
        elif data.argop == const.OP_NVERIFY:
            data.opnverify = self.unpack_NVERIFY4args()
            data.arm = data.opnverify
        elif data.argop == const.OP_OPEN:
            data.opopen = self.unpack_OPEN4args()
            data.arm = data.opopen
        elif data.argop == const.OP_OPENATTR:
            data.opopenattr = self.unpack_OPENATTR4args()
            data.arm = data.opopenattr
        elif data.argop == const.OP_OPEN_CONFIRM:
            data.opopen_confirm = self.unpack_OPEN_CONFIRM4args()
            data.arm = data.opopen_confirm
        elif data.argop == const.OP_OPEN_DOWNGRADE:
            data.opopen_downgrade = self.unpack_OPEN_DOWNGRADE4args()
            data.arm = data.opopen_downgrade
        elif data.argop == const.OP_PUTFH:
            data.opputfh = self.unpack_PUTFH4args()
            data.arm = data.opputfh
        elif data.argop == const.OP_PUTPUBFH:
            pass
            data.arm = None
        elif data.argop == const.OP_PUTROOTFH:
            pass
            data.arm = None
        elif data.argop == const.OP_READ:
            data.opread = self.unpack_READ4args()
            data.arm = data.opread
        elif data.argop == const.OP_READDIR:
            data.opreaddir = self.unpack_READDIR4args()
            data.arm = data.opreaddir
        elif data.argop == const.OP_READLINK:
            pass
            data.arm = None
        elif data.argop == const.OP_REMOVE:
            data.opremove = self.unpack_REMOVE4args()
            data.arm = data.opremove
        elif data.argop == const.OP_RENAME:
            data.oprename = self.unpack_RENAME4args()
            data.arm = data.oprename
        elif data.argop == const.OP_RENEW:
            data.oprenew = self.unpack_RENEW4args()
            data.arm = data.oprenew
        elif data.argop == const.OP_RESTOREFH:
            pass
            data.arm = None
        elif data.argop == const.OP_SAVEFH:
            pass
            data.arm = None
        elif data.argop == const.OP_SECINFO:
            data.opsecinfo = self.unpack_SECINFO4args()
            data.arm = data.opsecinfo
        elif data.argop == const.OP_SETATTR:
            data.opsetattr = self.unpack_SETATTR4args()
            data.arm = data.opsetattr
        elif data.argop == const.OP_SETCLIENTID:
            data.opsetclientid = self.unpack_SETCLIENTID4args()
            data.arm = data.opsetclientid
        elif data.argop == const.OP_SETCLIENTID_CONFIRM:
            data.opsetclientid_confirm = self.unpack_SETCLIENTID_CONFIRM4args()
            data.arm = data.opsetclientid_confirm
        elif data.argop == const.OP_VERIFY:
            data.opverify = self.unpack_VERIFY4args()
            data.arm = data.opverify
        elif data.argop == const.OP_WRITE:
            data.opwrite = self.unpack_WRITE4args()
            data.arm = data.opwrite
        elif data.argop == const.OP_RELEASE_LOCKOWNER:
            data.oprelease_lockowner = self.unpack_RELEASE_LOCKOWNER4args()
            data.arm = data.oprelease_lockowner
        elif data.argop == const.OP_ILLEGAL:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.argop
        return data

    def unpack_nfs_resop4(self):
        data = types.nfs_resop4()
        data.resop = self.unpack_nfs_opnum4()
        if data.resop == const.OP_ACCESS:
            data.opaccess = self.unpack_ACCESS4res()
            data.arm = data.opaccess
        elif data.resop == const.OP_CLOSE:
            data.opclose = self.unpack_CLOSE4res()
            data.arm = data.opclose
        elif data.resop == const.OP_COMMIT:
            data.opcommit = self.unpack_COMMIT4res()
            data.arm = data.opcommit
        elif data.resop == const.OP_CREATE:
            data.opcreate = self.unpack_CREATE4res()
            data.arm = data.opcreate
        elif data.resop == const.OP_DELEGPURGE:
            data.opdelegpurge = self.unpack_DELEGPURGE4res()
            data.arm = data.opdelegpurge
        elif data.resop == const.OP_DELEGRETURN:
            data.opdelegreturn = self.unpack_DELEGRETURN4res()
            data.arm = data.opdelegreturn
        elif data.resop == const.OP_GETATTR:
            data.opgetattr = self.unpack_GETATTR4res()
            data.arm = data.opgetattr
        elif data.resop == const.OP_GETFH:
            data.opgetfh = self.unpack_GETFH4res()
            data.arm = data.opgetfh
        elif data.resop == const.OP_LINK:
            data.oplink = self.unpack_LINK4res()
            data.arm = data.oplink
        elif data.resop == const.OP_LOCK:
            data.oplock = self.unpack_LOCK4res()
            data.arm = data.oplock
        elif data.resop == const.OP_LOCKT:
            data.oplockt = self.unpack_LOCKT4res()
            data.arm = data.oplockt
        elif data.resop == const.OP_LOCKU:
            data.oplocku = self.unpack_LOCKU4res()
            data.arm = data.oplocku
        elif data.resop == const.OP_LOOKUP:
            data.oplookup = self.unpack_LOOKUP4res()
            data.arm = data.oplookup
        elif data.resop == const.OP_LOOKUPP:
            data.oplookupp = self.unpack_LOOKUPP4res()
            data.arm = data.oplookupp
        elif data.resop == const.OP_NVERIFY:
            data.opnverify = self.unpack_NVERIFY4res()
            data.arm = data.opnverify
        elif data.resop == const.OP_OPEN:
            data.opopen = self.unpack_OPEN4res()
            data.arm = data.opopen
        elif data.resop == const.OP_OPENATTR:
            data.opopenattr = self.unpack_OPENATTR4res()
            data.arm = data.opopenattr
        elif data.resop == const.OP_OPEN_CONFIRM:
            data.opopen_confirm = self.unpack_OPEN_CONFIRM4res()
            data.arm = data.opopen_confirm
        elif data.resop == const.OP_OPEN_DOWNGRADE:
            data.opopen_downgrade = self.unpack_OPEN_DOWNGRADE4res()
            data.arm = data.opopen_downgrade
        elif data.resop == const.OP_PUTFH:
            data.opputfh = self.unpack_PUTFH4res()
            data.arm = data.opputfh
        elif data.resop == const.OP_PUTPUBFH:
            data.opputpubfh = self.unpack_PUTPUBFH4res()
            data.arm = data.opputpubfh
        elif data.resop == const.OP_PUTROOTFH:
            data.opputrootfh = self.unpack_PUTROOTFH4res()
            data.arm = data.opputrootfh
        elif data.resop == const.OP_READ:
            data.opread = self.unpack_READ4res()
            data.arm = data.opread
        elif data.resop == const.OP_READDIR:
            data.opreaddir = self.unpack_READDIR4res()
            data.arm = data.opreaddir
        elif data.resop == const.OP_READLINK:
            data.opreadlink = self.unpack_READLINK4res()
            data.arm = data.opreadlink
        elif data.resop == const.OP_REMOVE:
            data.opremove = self.unpack_REMOVE4res()
            data.arm = data.opremove
        elif data.resop == const.OP_RENAME:
            data.oprename = self.unpack_RENAME4res()
            data.arm = data.oprename
        elif data.resop == const.OP_RENEW:
            data.oprenew = self.unpack_RENEW4res()
            data.arm = data.oprenew
        elif data.resop == const.OP_RESTOREFH:
            data.oprestorefh = self.unpack_RESTOREFH4res()
            data.arm = data.oprestorefh
        elif data.resop == const.OP_SAVEFH:
            data.opsavefh = self.unpack_SAVEFH4res()
            data.arm = data.opsavefh
        elif data.resop == const.OP_SECINFO:
            data.opsecinfo = self.unpack_SECINFO4res()
            data.arm = data.opsecinfo
        elif data.resop == const.OP_SETATTR:
            data.opsetattr = self.unpack_SETATTR4res()
            data.arm = data.opsetattr
        elif data.resop == const.OP_SETCLIENTID:
            data.opsetclientid = self.unpack_SETCLIENTID4res()
            data.arm = data.opsetclientid
        elif data.resop == const.OP_SETCLIENTID_CONFIRM:
            data.opsetclientid_confirm = self.unpack_SETCLIENTID_CONFIRM4res()
            data.arm = data.opsetclientid_confirm
        elif data.resop == const.OP_VERIFY:
            data.opverify = self.unpack_VERIFY4res()
            data.arm = data.opverify
        elif data.resop == const.OP_WRITE:
            data.opwrite = self.unpack_WRITE4res()
            data.arm = data.opwrite
        elif data.resop == const.OP_RELEASE_LOCKOWNER:
            data.oprelease_lockowner = self.unpack_RELEASE_LOCKOWNER4res()
            data.arm = data.oprelease_lockowner
        elif data.resop == const.OP_ILLEGAL:
            data.opillegal = self.unpack_ILLEGAL4res()
            data.arm = data.opillegal
        else:
            raise XDRError, 'bad switch=%s' % data.resop
        return data

    def unpack_COMPOUND4args(self):
        data = types.COMPOUND4args()
        data.tag = self.unpack_utf8str_cs()
        data.minorversion = self.unpack_uint32_t()
        data.argarray = self.unpack_array(self.unpack_nfs_argop4)
        return data

    def unpack_COMPOUND4res(self):
        data = types.COMPOUND4res()
        data.status = self.unpack_nfsstat4()
        data.tag = self.unpack_utf8str_cs()
        data.resarray = self.unpack_array(self.unpack_nfs_resop4)
        return data

    def unpack_CB_GETATTR4args(self):
        data = types.CB_GETATTR4args()
        data.fh = self.unpack_nfs_fh4()
        data.attr_request = self.unpack_bitmap4()
        return data

    def unpack_CB_GETATTR4resok(self):
        data = types.CB_GETATTR4resok()
        data.obj_attributes = self.unpack_fattr4()
        return data

    def unpack_CB_GETATTR4res(self):
        data = types.CB_GETATTR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_CB_GETATTR4resok()
            data.arm = data.resok4
        else:
            pass
            data.arm = None
        return data

    def unpack_CB_RECALL4args(self):
        data = types.CB_RECALL4args()
        data.stateid = self.unpack_stateid4()
        data.truncate = self.unpack_bool()
        data.fh = self.unpack_nfs_fh4()
        return data

    def unpack_CB_RECALL4res(self):
        data = types.CB_RECALL4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_CB_ILLEGAL4res(self):
        data = types.CB_ILLEGAL4res()
        data.status = self.unpack_nfsstat4()
        return data

    def unpack_nfs_cb_opnum4(self):
        data = self.unpack_int()
        if data not in [const.OP_CB_GETATTR, const.OP_CB_RECALL, const.OP_CB_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_cb_opnum4' % data
        return data

    def unpack_nfs_cb_argop4(self):
        data = types.nfs_cb_argop4()
        data.argop = self.unpack_unsigned()
        if data.argop == const.OP_CB_GETATTR:
            data.opcbgetattr = self.unpack_CB_GETATTR4args()
            data.arm = data.opcbgetattr
        elif data.argop == const.OP_CB_RECALL:
            data.opcbrecall = self.unpack_CB_RECALL4args()
            data.arm = data.opcbrecall
        elif data.argop == const.OP_CB_ILLEGAL:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.argop
        return data

    def unpack_nfs_cb_resop4(self):
        data = types.nfs_cb_resop4()
        data.resop = self.unpack_unsigned()
        if data.resop == const.OP_CB_GETATTR:
            data.opcbgetattr = self.unpack_CB_GETATTR4res()
            data.arm = data.opcbgetattr
        elif data.resop == const.OP_CB_RECALL:
            data.opcbrecall = self.unpack_CB_RECALL4res()
            data.arm = data.opcbrecall
        elif data.resop == const.OP_CB_ILLEGAL:
            data.opcbillegal = self.unpack_CB_ILLEGAL4res()
            data.arm = data.opcbillegal
        else:
            raise XDRError, 'bad switch=%s' % data.resop
        return data

    def unpack_CB_COMPOUND4args(self):
        data = types.CB_COMPOUND4args()
        data.tag = self.unpack_utf8str_cs()
        data.minorversion = self.unpack_uint32_t()
        data.callback_ident = self.unpack_uint32_t()
        data.argarray = self.unpack_array(self.unpack_nfs_cb_argop4)
        return data

    def unpack_CB_COMPOUND4res(self):
        data = types.CB_COMPOUND4res()
        data.status = self.unpack_nfsstat4()
        data.tag = self.unpack_utf8str_cs()
        data.resarray = self.unpack_array(self.unpack_nfs_cb_resop4)
        return data

