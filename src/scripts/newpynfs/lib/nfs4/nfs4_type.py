# Generated by rpcgen.py from nfs4.x on Fri Jan 25 14:59:49 2008
import nfs4_const as const
class nfstime4:
    # XDR definition:
    # struct nfstime4 {
    #     int64_t seconds;
    #     uint32_t nseconds;
    # };
    def __init__(self, seconds=None, nseconds=None):
        self.seconds = seconds
        self.nseconds = nseconds

    def __repr__(self):
        out = []
        if self.seconds is not None:
            out += ['seconds=%s' % repr(self.seconds)]
        if self.nseconds is not None:
            out += ['nseconds=%s' % repr(self.nseconds)]
        return 'nfstime4(%s)' % ', '.join(out)

class settime4:
    # XDR definition:
    # union settime4 switch(time_how4 set_it) {
    #     case SET_TO_CLIENT_TIME4:
    #         nfstime4 time;
    #     default:
    #         void;
    # };
    def __init__(self, set_it=None, time=None):
        self.set_it = set_it
        self.time = time

    def __repr__(self):
        out = []
        if self.set_it is not None:
            out += ['set_it=%s' % const.time_how4.get(self.set_it, self.set_it)]
        if self.time is not None:
            out += ['time=%s' % repr(self.time)]
        return 'settime4(%s)' % ', '.join(out)

class fsid4:
    # XDR definition:
    # struct fsid4 {
    #     uint64_t major;
    #     uint64_t minor;
    # };
    def __init__(self, major=None, minor=None):
        self.major = major
        self.minor = minor

    def __repr__(self):
        out = []
        if self.major is not None:
            out += ['major=%s' % repr(self.major)]
        if self.minor is not None:
            out += ['minor=%s' % repr(self.minor)]
        return 'fsid4(%s)' % ', '.join(out)

class fs_location4:
    # XDR definition:
    # struct fs_location4 {
    #     utf8str_cis server<>;
    #     pathname4 rootpath;
    # };
    def __init__(self, server=None, rootpath=None):
        self.server = server
        self.rootpath = rootpath

    def __repr__(self):
        out = []
        if self.server is not None:
            out += ['server=%s' % repr(self.server)]
        if self.rootpath is not None:
            out += ['rootpath=%s' % repr(self.rootpath)]
        return 'fs_location4(%s)' % ', '.join(out)

class fs_locations4:
    # XDR definition:
    # struct fs_locations4 {
    #     pathname4 fs_root;
    #     fs_location4 locations<>;
    # };
    def __init__(self, fs_root=None, locations=None):
        self.fs_root = fs_root
        self.locations = locations

    def __repr__(self):
        out = []
        if self.fs_root is not None:
            out += ['fs_root=%s' % repr(self.fs_root)]
        if self.locations is not None:
            out += ['locations=%s' % repr(self.locations)]
        return 'fs_locations4(%s)' % ', '.join(out)

class nfsace4:
    # XDR definition:
    # struct nfsace4 {
    #     acetype4 type;
    #     aceflag4 flag;
    #     acemask4 access_mask;
    #     utf8str_mixed who;
    # };
    def __init__(self, type=None, flag=None, access_mask=None, who=None):
        self.type = type
        self.flag = flag
        self.access_mask = access_mask
        self.who = who

    def __repr__(self):
        out = []
        if self.type is not None:
            out += ['type=%s' % repr(self.type)]
        if self.flag is not None:
            out += ['flag=%s' % repr(self.flag)]
        if self.access_mask is not None:
            out += ['access_mask=%s' % repr(self.access_mask)]
        if self.who is not None:
            out += ['who=%s' % repr(self.who)]
        return 'nfsace4(%s)' % ', '.join(out)

class specdata4:
    # XDR definition:
    # struct specdata4 {
    #     uint32_t specdata1;
    #     uint32_t specdata2;
    # };
    def __init__(self, specdata1=None, specdata2=None):
        self.specdata1 = specdata1
        self.specdata2 = specdata2

    def __repr__(self):
        out = []
        if self.specdata1 is not None:
            out += ['specdata1=%s' % repr(self.specdata1)]
        if self.specdata2 is not None:
            out += ['specdata2=%s' % repr(self.specdata2)]
        return 'specdata4(%s)' % ', '.join(out)

class fattr4:
    # XDR definition:
    # struct fattr4 {
    #     bitmap4 attrmask;
    #     attrlist4 attr_vals;
    # };
    def __init__(self, attrmask=None, attr_vals=None):
        self.attrmask = attrmask
        self.attr_vals = attr_vals

    def __repr__(self):
        out = []
        if self.attrmask is not None:
            out += ['attrmask=%s' % repr(self.attrmask)]
        if self.attr_vals is not None:
            out += ['attr_vals=%s' % repr(self.attr_vals)]
        return 'fattr4(%s)' % ', '.join(out)

class change_info4:
    # XDR definition:
    # struct change_info4 {
    #     bool atomic;
    #     changeid4 before;
    #     changeid4 after;
    # };
    def __init__(self, atomic=None, before=None, after=None):
        self.atomic = atomic
        self.before = before
        self.after = after

    def __repr__(self):
        out = []
        if self.atomic is not None:
            out += ['atomic=%s' % repr(self.atomic)]
        if self.before is not None:
            out += ['before=%s' % repr(self.before)]
        if self.after is not None:
            out += ['after=%s' % repr(self.after)]
        return 'change_info4(%s)' % ', '.join(out)

class clientaddr4:
    # XDR definition:
    # struct clientaddr4 {
    #     string r_netid<>;
    #     string r_addr<>;
    # };
    def __init__(self, r_netid=None, r_addr=None):
        self.r_netid = r_netid
        self.r_addr = r_addr

    def __repr__(self):
        out = []
        if self.r_netid is not None:
            out += ['r_netid=%s' % repr(self.r_netid)]
        if self.r_addr is not None:
            out += ['r_addr=%s' % repr(self.r_addr)]
        return 'clientaddr4(%s)' % ', '.join(out)

class cb_client4:
    # XDR definition:
    # struct cb_client4 {
    #     uint32_t cb_program;
    #     clientaddr4 cb_location;
    # };
    def __init__(self, cb_program=None, cb_location=None):
        self.cb_program = cb_program
        self.cb_location = cb_location

    def __repr__(self):
        out = []
        if self.cb_program is not None:
            out += ['cb_program=%s' % repr(self.cb_program)]
        if self.cb_location is not None:
            out += ['cb_location=%s' % repr(self.cb_location)]
        return 'cb_client4(%s)' % ', '.join(out)

class stateid4:
    # XDR definition:
    # struct stateid4 {
    #     uint32_t seqid;
    #     opaque other[12];
    # };
    def __init__(self, seqid=None, other=None):
        self.seqid = seqid
        self.other = other

    def __repr__(self):
        out = []
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        if self.other is not None:
            out += ['other=%s' % repr(self.other)]
        return 'stateid4(%s)' % ', '.join(out)

class nfs_client_id4:
    # XDR definition:
    # struct nfs_client_id4 {
    #     verifier4 verifier;
    #     opaque id<NFS4_OPAQUE_LIMIT>;
    # };
    def __init__(self, verifier=None, id=None):
        self.verifier = verifier
        self.id = id

    def __repr__(self):
        out = []
        if self.verifier is not None:
            out += ['verifier=%s' % repr(self.verifier)]
        if self.id is not None:
            out += ['id=%s' % repr(self.id)]
        return 'nfs_client_id4(%s)' % ', '.join(out)

class open_owner4:
    # XDR definition:
    # struct open_owner4 {
    #     clientid4 clientid;
    #     opaque owner<NFS4_OPAQUE_LIMIT>;
    # };
    def __init__(self, clientid=None, owner=None):
        self.clientid = clientid
        self.owner = owner

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        if self.owner is not None:
            out += ['owner=%s' % repr(self.owner)]
        return 'open_owner4(%s)' % ', '.join(out)

class lock_owner4:
    # XDR definition:
    # struct lock_owner4 {
    #     clientid4 clientid;
    #     opaque owner<NFS4_OPAQUE_LIMIT>;
    # };
    def __init__(self, clientid=None, owner=None):
        self.clientid = clientid
        self.owner = owner

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        if self.owner is not None:
            out += ['owner=%s' % repr(self.owner)]
        return 'lock_owner4(%s)' % ', '.join(out)

class ACCESS4args:
    # XDR definition:
    # struct ACCESS4args {
    #     uint32_t access;
    # };
    def __init__(self, access=None):
        self.access = access

    def __repr__(self):
        out = []
        if self.access is not None:
            out += ['access=%s' % repr(self.access)]
        return 'ACCESS4args(%s)' % ', '.join(out)

class ACCESS4resok:
    # XDR definition:
    # struct ACCESS4resok {
    #     uint32_t supported;
    #     uint32_t access;
    # };
    def __init__(self, supported=None, access=None):
        self.supported = supported
        self.access = access

    def __repr__(self):
        out = []
        if self.supported is not None:
            out += ['supported=%s' % repr(self.supported)]
        if self.access is not None:
            out += ['access=%s' % repr(self.access)]
        return 'ACCESS4resok(%s)' % ', '.join(out)

class ACCESS4res:
    # XDR definition:
    # union ACCESS4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         ACCESS4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'ACCESS4res(%s)' % ', '.join(out)

class CLOSE4args:
    # XDR definition:
    # struct CLOSE4args {
    #     seqid4 seqid;
    #     stateid4 open_stateid;
    # };
    def __init__(self, seqid=None, open_stateid=None):
        self.seqid = seqid
        self.open_stateid = open_stateid

    def __repr__(self):
        out = []
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        return 'CLOSE4args(%s)' % ', '.join(out)

class CLOSE4res:
    # XDR definition:
    # union CLOSE4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         stateid4 open_stateid;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, open_stateid=None):
        self.status = status
        self.open_stateid = open_stateid

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        return 'CLOSE4res(%s)' % ', '.join(out)

class COMMIT4args:
    # XDR definition:
    # struct COMMIT4args {
    #     offset4 offset;
    #     count4 count;
    # };
    def __init__(self, offset=None, count=None):
        self.offset = offset
        self.count = count

    def __repr__(self):
        out = []
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.count is not None:
            out += ['count=%s' % repr(self.count)]
        return 'COMMIT4args(%s)' % ', '.join(out)

class COMMIT4resok:
    # XDR definition:
    # struct COMMIT4resok {
    #     verifier4 writeverf;
    # };
    def __init__(self, writeverf=None):
        self.writeverf = writeverf

    def __repr__(self):
        out = []
        if self.writeverf is not None:
            out += ['writeverf=%s' % repr(self.writeverf)]
        return 'COMMIT4resok(%s)' % ', '.join(out)

class COMMIT4res:
    # XDR definition:
    # union COMMIT4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         COMMIT4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'COMMIT4res(%s)' % ', '.join(out)

class createtype4:
    # XDR definition:
    # union createtype4 switch(nfs_ftype4 type) {
    #     case NF4LNK:
    #         linktext4 linkdata;
    #     case NF4BLK:
    #     case NF4CHR:
    #         specdata4 devdata;
    #     case NF4SOCK:
    #     case NF4FIFO:
    #     case NF4DIR:
    #         void;
    #     default:
    #         void;
    # };
    def __init__(self, type=None, linkdata=None, devdata=None):
        self.type = type
        self.linkdata = linkdata
        self.devdata = devdata

    def __repr__(self):
        out = []
        if self.type is not None:
            out += ['type=%s' % const.nfs_ftype4.get(self.type, self.type)]
        if self.linkdata is not None:
            out += ['linkdata=%s' % repr(self.linkdata)]
        if self.devdata is not None:
            out += ['devdata=%s' % repr(self.devdata)]
        return 'createtype4(%s)' % ', '.join(out)

class CREATE4args:
    # XDR definition:
    # struct CREATE4args {
    #     createtype4 objtype;
    #     component4 objname;
    #     fattr4 createattrs;
    # };
    def __init__(self, objtype=None, objname=None, createattrs=None):
        self.objtype = objtype
        self.objname = objname
        self.createattrs = createattrs

    def __repr__(self):
        out = []
        if self.objtype is not None:
            out += ['objtype=%s' % repr(self.objtype)]
        if self.objname is not None:
            out += ['objname=%s' % repr(self.objname)]
        if self.createattrs is not None:
            out += ['createattrs=%s' % repr(self.createattrs)]
        return 'CREATE4args(%s)' % ', '.join(out)

class CREATE4resok:
    # XDR definition:
    # struct CREATE4resok {
    #     change_info4 cinfo;
    #     bitmap4 attrset;
    # };
    def __init__(self, cinfo=None, attrset=None):
        self.cinfo = cinfo
        self.attrset = attrset

    def __repr__(self):
        out = []
        if self.cinfo is not None:
            out += ['cinfo=%s' % repr(self.cinfo)]
        if self.attrset is not None:
            out += ['attrset=%s' % repr(self.attrset)]
        return 'CREATE4resok(%s)' % ', '.join(out)

class CREATE4res:
    # XDR definition:
    # union CREATE4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         CREATE4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'CREATE4res(%s)' % ', '.join(out)

class DELEGPURGE4args:
    # XDR definition:
    # struct DELEGPURGE4args {
    #     clientid4 clientid;
    # };
    def __init__(self, clientid=None):
        self.clientid = clientid

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        return 'DELEGPURGE4args(%s)' % ', '.join(out)

class DELEGPURGE4res:
    # XDR definition:
    # struct DELEGPURGE4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'DELEGPURGE4res(%s)' % ', '.join(out)

class DELEGRETURN4args:
    # XDR definition:
    # struct DELEGRETURN4args {
    #     stateid4 deleg_stateid;
    # };
    def __init__(self, deleg_stateid=None):
        self.deleg_stateid = deleg_stateid

    def __repr__(self):
        out = []
        if self.deleg_stateid is not None:
            out += ['deleg_stateid=%s' % repr(self.deleg_stateid)]
        return 'DELEGRETURN4args(%s)' % ', '.join(out)

class DELEGRETURN4res:
    # XDR definition:
    # struct DELEGRETURN4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'DELEGRETURN4res(%s)' % ', '.join(out)

class GETATTR4args:
    # XDR definition:
    # struct GETATTR4args {
    #     bitmap4 attr_request;
    # };
    def __init__(self, attr_request=None):
        self.attr_request = attr_request

    def __repr__(self):
        out = []
        if self.attr_request is not None:
            out += ['attr_request=%s' % repr(self.attr_request)]
        return 'GETATTR4args(%s)' % ', '.join(out)

class GETATTR4resok:
    # XDR definition:
    # struct GETATTR4resok {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, obj_attributes=None):
        self.obj_attributes = obj_attributes

    def __repr__(self):
        out = []
        if self.obj_attributes is not None:
            out += ['obj_attributes=%s' % repr(self.obj_attributes)]
        return 'GETATTR4resok(%s)' % ', '.join(out)

class GETATTR4res:
    # XDR definition:
    # union GETATTR4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         GETATTR4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'GETATTR4res(%s)' % ', '.join(out)

class GETFH4resok:
    # XDR definition:
    # struct GETFH4resok {
    #     nfs_fh4 object;
    # };
    def __init__(self, object=None):
        self.object = object

    def __repr__(self):
        out = []
        if self.object is not None:
            out += ['object=%s' % repr(self.object)]
        return 'GETFH4resok(%s)' % ', '.join(out)

class GETFH4res:
    # XDR definition:
    # union GETFH4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         GETFH4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'GETFH4res(%s)' % ', '.join(out)

class LINK4args:
    # XDR definition:
    # struct LINK4args {
    #     component4 newname;
    # };
    def __init__(self, newname=None):
        self.newname = newname

    def __repr__(self):
        out = []
        if self.newname is not None:
            out += ['newname=%s' % repr(self.newname)]
        return 'LINK4args(%s)' % ', '.join(out)

class LINK4resok:
    # XDR definition:
    # struct LINK4resok {
    #     change_info4 cinfo;
    # };
    def __init__(self, cinfo=None):
        self.cinfo = cinfo

    def __repr__(self):
        out = []
        if self.cinfo is not None:
            out += ['cinfo=%s' % repr(self.cinfo)]
        return 'LINK4resok(%s)' % ', '.join(out)

class LINK4res:
    # XDR definition:
    # union LINK4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         LINK4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'LINK4res(%s)' % ', '.join(out)

class open_to_lock_owner4:
    # XDR definition:
    # struct open_to_lock_owner4 {
    #     seqid4 open_seqid;
    #     stateid4 open_stateid;
    #     seqid4 lock_seqid;
    #     lock_owner4 lock_owner;
    # };
    def __init__(self, open_seqid=None, open_stateid=None, lock_seqid=None, lock_owner=None):
        self.open_seqid = open_seqid
        self.open_stateid = open_stateid
        self.lock_seqid = lock_seqid
        self.lock_owner = lock_owner

    def __repr__(self):
        out = []
        if self.open_seqid is not None:
            out += ['open_seqid=%s' % repr(self.open_seqid)]
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        if self.lock_seqid is not None:
            out += ['lock_seqid=%s' % repr(self.lock_seqid)]
        if self.lock_owner is not None:
            out += ['lock_owner=%s' % repr(self.lock_owner)]
        return 'open_to_lock_owner4(%s)' % ', '.join(out)

class exist_lock_owner4:
    # XDR definition:
    # struct exist_lock_owner4 {
    #     stateid4 lock_stateid;
    #     seqid4 lock_seqid;
    # };
    def __init__(self, lock_stateid=None, lock_seqid=None):
        self.lock_stateid = lock_stateid
        self.lock_seqid = lock_seqid

    def __repr__(self):
        out = []
        if self.lock_stateid is not None:
            out += ['lock_stateid=%s' % repr(self.lock_stateid)]
        if self.lock_seqid is not None:
            out += ['lock_seqid=%s' % repr(self.lock_seqid)]
        return 'exist_lock_owner4(%s)' % ', '.join(out)

class locker4:
    # XDR definition:
    # union locker4 switch(bool new_lock_owner) {
    #     case TRUE:
    #         open_to_lock_owner4 open_owner;
    #     case FALSE:
    #         exist_lock_owner4 lock_owner;
    # };
    def __init__(self, new_lock_owner=None, open_owner=None, lock_owner=None):
        self.new_lock_owner = new_lock_owner
        self.open_owner = open_owner
        self.lock_owner = lock_owner

    def __repr__(self):
        out = []
        if self.new_lock_owner is not None:
            out += ['new_lock_owner=%s' % repr(self.new_lock_owner)]
        if self.open_owner is not None:
            out += ['open_owner=%s' % repr(self.open_owner)]
        if self.lock_owner is not None:
            out += ['lock_owner=%s' % repr(self.lock_owner)]
        return 'locker4(%s)' % ', '.join(out)

class LOCK4args:
    # XDR definition:
    # struct LOCK4args {
    #     nfs_lock_type4 locktype;
    #     bool reclaim;
    #     offset4 offset;
    #     length4 length;
    #     locker4 locker;
    # };
    def __init__(self, locktype=None, reclaim=None, offset=None, length=None, locker=None):
        self.locktype = locktype
        self.reclaim = reclaim
        self.offset = offset
        self.length = length
        self.locker = locker

    def __repr__(self):
        out = []
        if self.locktype is not None:
            out += ['locktype=%s' % const.nfs_lock_type4.get(self.locktype, self.locktype)]
        if self.reclaim is not None:
            out += ['reclaim=%s' % repr(self.reclaim)]
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.length is not None:
            out += ['length=%s' % repr(self.length)]
        if self.locker is not None:
            out += ['locker=%s' % repr(self.locker)]
        return 'LOCK4args(%s)' % ', '.join(out)

class LOCK4denied:
    # XDR definition:
    # struct LOCK4denied {
    #     offset4 offset;
    #     length4 length;
    #     nfs_lock_type4 locktype;
    #     lock_owner4 owner;
    # };
    def __init__(self, offset=None, length=None, locktype=None, owner=None):
        self.offset = offset
        self.length = length
        self.locktype = locktype
        self.owner = owner

    def __repr__(self):
        out = []
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.length is not None:
            out += ['length=%s' % repr(self.length)]
        if self.locktype is not None:
            out += ['locktype=%s' % const.nfs_lock_type4.get(self.locktype, self.locktype)]
        if self.owner is not None:
            out += ['owner=%s' % repr(self.owner)]
        return 'LOCK4denied(%s)' % ', '.join(out)

class LOCK4resok:
    # XDR definition:
    # struct LOCK4resok {
    #     stateid4 lock_stateid;
    # };
    def __init__(self, lock_stateid=None):
        self.lock_stateid = lock_stateid

    def __repr__(self):
        out = []
        if self.lock_stateid is not None:
            out += ['lock_stateid=%s' % repr(self.lock_stateid)]
        return 'LOCK4resok(%s)' % ', '.join(out)

class LOCK4res:
    # XDR definition:
    # union LOCK4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         LOCK4resok resok4;
    #     case NFS4ERR_DENIED:
    #         LOCK4denied denied;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None, denied=None):
        self.status = status
        self.resok4 = resok4
        self.denied = denied

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        if self.denied is not None:
            out += ['denied=%s' % repr(self.denied)]
        return 'LOCK4res(%s)' % ', '.join(out)

class LOCKT4args:
    # XDR definition:
    # struct LOCKT4args {
    #     nfs_lock_type4 locktype;
    #     offset4 offset;
    #     length4 length;
    #     lock_owner4 owner;
    # };
    def __init__(self, locktype=None, offset=None, length=None, owner=None):
        self.locktype = locktype
        self.offset = offset
        self.length = length
        self.owner = owner

    def __repr__(self):
        out = []
        if self.locktype is not None:
            out += ['locktype=%s' % const.nfs_lock_type4.get(self.locktype, self.locktype)]
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.length is not None:
            out += ['length=%s' % repr(self.length)]
        if self.owner is not None:
            out += ['owner=%s' % repr(self.owner)]
        return 'LOCKT4args(%s)' % ', '.join(out)

class LOCKT4res:
    # XDR definition:
    # union LOCKT4res switch(nfsstat4 status) {
    #     case NFS4ERR_DENIED:
    #         LOCK4denied denied;
    #     case NFS4_OK:
    #         void;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, denied=None):
        self.status = status
        self.denied = denied

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.denied is not None:
            out += ['denied=%s' % repr(self.denied)]
        return 'LOCKT4res(%s)' % ', '.join(out)

class LOCKU4args:
    # XDR definition:
    # struct LOCKU4args {
    #     nfs_lock_type4 locktype;
    #     seqid4 seqid;
    #     stateid4 lock_stateid;
    #     offset4 offset;
    #     length4 length;
    # };
    def __init__(self, locktype=None, seqid=None, lock_stateid=None, offset=None, length=None):
        self.locktype = locktype
        self.seqid = seqid
        self.lock_stateid = lock_stateid
        self.offset = offset
        self.length = length

    def __repr__(self):
        out = []
        if self.locktype is not None:
            out += ['locktype=%s' % const.nfs_lock_type4.get(self.locktype, self.locktype)]
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        if self.lock_stateid is not None:
            out += ['lock_stateid=%s' % repr(self.lock_stateid)]
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.length is not None:
            out += ['length=%s' % repr(self.length)]
        return 'LOCKU4args(%s)' % ', '.join(out)

class LOCKU4res:
    # XDR definition:
    # union LOCKU4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         stateid4 lock_stateid;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, lock_stateid=None):
        self.status = status
        self.lock_stateid = lock_stateid

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.lock_stateid is not None:
            out += ['lock_stateid=%s' % repr(self.lock_stateid)]
        return 'LOCKU4res(%s)' % ', '.join(out)

class LOOKUP4args:
    # XDR definition:
    # struct LOOKUP4args {
    #     component4 objname;
    # };
    def __init__(self, objname=None):
        self.objname = objname

    def __repr__(self):
        out = []
        if self.objname is not None:
            out += ['objname=%s' % repr(self.objname)]
        return 'LOOKUP4args(%s)' % ', '.join(out)

class LOOKUP4res:
    # XDR definition:
    # struct LOOKUP4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'LOOKUP4res(%s)' % ', '.join(out)

class LOOKUPP4res:
    # XDR definition:
    # struct LOOKUPP4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'LOOKUPP4res(%s)' % ', '.join(out)

class NVERIFY4args:
    # XDR definition:
    # struct NVERIFY4args {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, obj_attributes=None):
        self.obj_attributes = obj_attributes

    def __repr__(self):
        out = []
        if self.obj_attributes is not None:
            out += ['obj_attributes=%s' % repr(self.obj_attributes)]
        return 'NVERIFY4args(%s)' % ', '.join(out)

class NVERIFY4res:
    # XDR definition:
    # struct NVERIFY4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'NVERIFY4res(%s)' % ', '.join(out)

class createhow4:
    # XDR definition:
    # union createhow4 switch(createmode4 mode) {
    #     case UNCHECKED4:
    #     case GUARDED4:
    #         fattr4 createattrs;
    #     case EXCLUSIVE4:
    #         verifier4 createverf;
    # };
    def __init__(self, mode=None, createattrs=None, createverf=None):
        self.mode = mode
        self.createattrs = createattrs
        self.createverf = createverf

    def __repr__(self):
        out = []
        if self.mode is not None:
            out += ['mode=%s' % const.createmode4.get(self.mode, self.mode)]
        if self.createattrs is not None:
            out += ['createattrs=%s' % repr(self.createattrs)]
        if self.createverf is not None:
            out += ['createverf=%s' % repr(self.createverf)]
        return 'createhow4(%s)' % ', '.join(out)

class openflag4:
    # XDR definition:
    # union openflag4 switch(opentype4 opentype) {
    #     case OPEN4_CREATE:
    #         createhow4 how;
    #     default:
    #         void;
    # };
    def __init__(self, opentype=None, how=None):
        self.opentype = opentype
        self.how = how

    def __repr__(self):
        out = []
        if self.opentype is not None:
            out += ['opentype=%s' % const.opentype4.get(self.opentype, self.opentype)]
        if self.how is not None:
            out += ['how=%s' % repr(self.how)]
        return 'openflag4(%s)' % ', '.join(out)

class nfs_modified_limit4:
    # XDR definition:
    # struct nfs_modified_limit4 {
    #     uint32_t num_blocks;
    #     uint32_t bytes_per_block;
    # };
    def __init__(self, num_blocks=None, bytes_per_block=None):
        self.num_blocks = num_blocks
        self.bytes_per_block = bytes_per_block

    def __repr__(self):
        out = []
        if self.num_blocks is not None:
            out += ['num_blocks=%s' % repr(self.num_blocks)]
        if self.bytes_per_block is not None:
            out += ['bytes_per_block=%s' % repr(self.bytes_per_block)]
        return 'nfs_modified_limit4(%s)' % ', '.join(out)

class nfs_space_limit4:
    # XDR definition:
    # union nfs_space_limit4 switch(limit_by4 limitby) {
    #     case NFS_LIMIT_SIZE:
    #         uint64_t filesize;
    #     case NFS_LIMIT_BLOCKS:
    #         nfs_modified_limit4 mod_blocks;
    # };
    def __init__(self, limitby=None, filesize=None, mod_blocks=None):
        self.limitby = limitby
        self.filesize = filesize
        self.mod_blocks = mod_blocks

    def __repr__(self):
        out = []
        if self.limitby is not None:
            out += ['limitby=%s' % const.limit_by4.get(self.limitby, self.limitby)]
        if self.filesize is not None:
            out += ['filesize=%s' % repr(self.filesize)]
        if self.mod_blocks is not None:
            out += ['mod_blocks=%s' % repr(self.mod_blocks)]
        return 'nfs_space_limit4(%s)' % ', '.join(out)

class open_claim_delegate_cur4:
    # XDR definition:
    # struct open_claim_delegate_cur4 {
    #     stateid4 delegate_stateid;
    #     component4 file;
    # };
    def __init__(self, delegate_stateid=None, file=None):
        self.delegate_stateid = delegate_stateid
        self.file = file

    def __repr__(self):
        out = []
        if self.delegate_stateid is not None:
            out += ['delegate_stateid=%s' % repr(self.delegate_stateid)]
        if self.file is not None:
            out += ['file=%s' % repr(self.file)]
        return 'open_claim_delegate_cur4(%s)' % ', '.join(out)

class open_claim4:
    # XDR definition:
    # union open_claim4 switch(open_claim_type4 claim) {
    #     case CLAIM_NULL:
    #         component4 file;
    #     case CLAIM_PREVIOUS:
    #         open_delegation_type4 delegate_type;
    #     case CLAIM_DELEGATE_CUR:
    #         open_claim_delegate_cur4 delegate_cur_info;
    #     case CLAIM_DELEGATE_PREV:
    #         component4 file_delegate_prev;
    # };
    def __init__(self, claim=None, file=None, delegate_type=None, delegate_cur_info=None, file_delegate_prev=None):
        self.claim = claim
        self.file = file
        self.delegate_type = delegate_type
        self.delegate_cur_info = delegate_cur_info
        self.file_delegate_prev = file_delegate_prev

    def __repr__(self):
        out = []
        if self.claim is not None:
            out += ['claim=%s' % const.open_claim_type4.get(self.claim, self.claim)]
        if self.file is not None:
            out += ['file=%s' % repr(self.file)]
        if self.delegate_type is not None:
            out += ['delegate_type=%s' % const.open_delegation_type4.get(self.delegate_type, self.delegate_type)]
        if self.delegate_cur_info is not None:
            out += ['delegate_cur_info=%s' % repr(self.delegate_cur_info)]
        if self.file_delegate_prev is not None:
            out += ['file_delegate_prev=%s' % repr(self.file_delegate_prev)]
        return 'open_claim4(%s)' % ', '.join(out)

class OPEN4args:
    # XDR definition:
    # struct OPEN4args {
    #     seqid4 seqid;
    #     uint32_t share_access;
    #     uint32_t share_deny;
    #     open_owner4 owner;
    #     openflag4 openhow;
    #     open_claim4 claim;
    # };
    def __init__(self, seqid=None, share_access=None, share_deny=None, owner=None, openhow=None, claim=None):
        self.seqid = seqid
        self.share_access = share_access
        self.share_deny = share_deny
        self.owner = owner
        self.openhow = openhow
        self.claim = claim

    def __repr__(self):
        out = []
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        if self.share_access is not None:
            out += ['share_access=%s' % repr(self.share_access)]
        if self.share_deny is not None:
            out += ['share_deny=%s' % repr(self.share_deny)]
        if self.owner is not None:
            out += ['owner=%s' % repr(self.owner)]
        if self.openhow is not None:
            out += ['openhow=%s' % repr(self.openhow)]
        if self.claim is not None:
            out += ['claim=%s' % repr(self.claim)]
        return 'OPEN4args(%s)' % ', '.join(out)

class open_read_delegation4:
    # XDR definition:
    # struct open_read_delegation4 {
    #     stateid4 stateid;
    #     bool recall;
    #     nfsace4 permissions;
    # };
    def __init__(self, stateid=None, recall=None, permissions=None):
        self.stateid = stateid
        self.recall = recall
        self.permissions = permissions

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.recall is not None:
            out += ['recall=%s' % repr(self.recall)]
        if self.permissions is not None:
            out += ['permissions=%s' % repr(self.permissions)]
        return 'open_read_delegation4(%s)' % ', '.join(out)

class open_write_delegation4:
    # XDR definition:
    # struct open_write_delegation4 {
    #     stateid4 stateid;
    #     bool recall;
    #     nfs_space_limit4 space_limit;
    #     nfsace4 permissions;
    # };
    def __init__(self, stateid=None, recall=None, space_limit=None, permissions=None):
        self.stateid = stateid
        self.recall = recall
        self.space_limit = space_limit
        self.permissions = permissions

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.recall is not None:
            out += ['recall=%s' % repr(self.recall)]
        if self.space_limit is not None:
            out += ['space_limit=%s' % repr(self.space_limit)]
        if self.permissions is not None:
            out += ['permissions=%s' % repr(self.permissions)]
        return 'open_write_delegation4(%s)' % ', '.join(out)

class open_delegation4:
    # XDR definition:
    # union open_delegation4 switch(open_delegation_type4 delegation_type) {
    #     case OPEN_DELEGATE_NONE:
    #         void;
    #     case OPEN_DELEGATE_READ:
    #         open_read_delegation4 read;
    #     case OPEN_DELEGATE_WRITE:
    #         open_write_delegation4 write;
    # };
    def __init__(self, delegation_type=None, read=None, write=None):
        self.delegation_type = delegation_type
        self.read = read
        self.write = write

    def __repr__(self):
        out = []
        if self.delegation_type is not None:
            out += ['delegation_type=%s' % const.open_delegation_type4.get(self.delegation_type, self.delegation_type)]
        if self.read is not None:
            out += ['read=%s' % repr(self.read)]
        if self.write is not None:
            out += ['write=%s' % repr(self.write)]
        return 'open_delegation4(%s)' % ', '.join(out)

class OPEN4resok:
    # XDR definition:
    # struct OPEN4resok {
    #     stateid4 stateid;
    #     change_info4 cinfo;
    #     uint32_t rflags;
    #     bitmap4 attrset;
    #     open_delegation4 delegation;
    # };
    def __init__(self, stateid=None, cinfo=None, rflags=None, attrset=None, delegation=None):
        self.stateid = stateid
        self.cinfo = cinfo
        self.rflags = rflags
        self.attrset = attrset
        self.delegation = delegation

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.cinfo is not None:
            out += ['cinfo=%s' % repr(self.cinfo)]
        if self.rflags is not None:
            out += ['rflags=%s' % repr(self.rflags)]
        if self.attrset is not None:
            out += ['attrset=%s' % repr(self.attrset)]
        if self.delegation is not None:
            out += ['delegation=%s' % repr(self.delegation)]
        return 'OPEN4resok(%s)' % ', '.join(out)

class OPEN4res:
    # XDR definition:
    # union OPEN4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'OPEN4res(%s)' % ', '.join(out)

class OPENATTR4args:
    # XDR definition:
    # struct OPENATTR4args {
    #     bool createdir;
    # };
    def __init__(self, createdir=None):
        self.createdir = createdir

    def __repr__(self):
        out = []
        if self.createdir is not None:
            out += ['createdir=%s' % repr(self.createdir)]
        return 'OPENATTR4args(%s)' % ', '.join(out)

class OPENATTR4res:
    # XDR definition:
    # struct OPENATTR4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'OPENATTR4res(%s)' % ', '.join(out)

class OPEN_CONFIRM4args:
    # XDR definition:
    # struct OPEN_CONFIRM4args {
    #     stateid4 open_stateid;
    #     seqid4 seqid;
    # };
    def __init__(self, open_stateid=None, seqid=None):
        self.open_stateid = open_stateid
        self.seqid = seqid

    def __repr__(self):
        out = []
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        return 'OPEN_CONFIRM4args(%s)' % ', '.join(out)

class OPEN_CONFIRM4resok:
    # XDR definition:
    # struct OPEN_CONFIRM4resok {
    #     stateid4 open_stateid;
    # };
    def __init__(self, open_stateid=None):
        self.open_stateid = open_stateid

    def __repr__(self):
        out = []
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        return 'OPEN_CONFIRM4resok(%s)' % ', '.join(out)

class OPEN_CONFIRM4res:
    # XDR definition:
    # union OPEN_CONFIRM4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN_CONFIRM4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'OPEN_CONFIRM4res(%s)' % ', '.join(out)

class OPEN_DOWNGRADE4args:
    # XDR definition:
    # struct OPEN_DOWNGRADE4args {
    #     stateid4 open_stateid;
    #     seqid4 seqid;
    #     uint32_t share_access;
    #     uint32_t share_deny;
    # };
    def __init__(self, open_stateid=None, seqid=None, share_access=None, share_deny=None):
        self.open_stateid = open_stateid
        self.seqid = seqid
        self.share_access = share_access
        self.share_deny = share_deny

    def __repr__(self):
        out = []
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        if self.seqid is not None:
            out += ['seqid=%s' % repr(self.seqid)]
        if self.share_access is not None:
            out += ['share_access=%s' % repr(self.share_access)]
        if self.share_deny is not None:
            out += ['share_deny=%s' % repr(self.share_deny)]
        return 'OPEN_DOWNGRADE4args(%s)' % ', '.join(out)

class OPEN_DOWNGRADE4resok:
    # XDR definition:
    # struct OPEN_DOWNGRADE4resok {
    #     stateid4 open_stateid;
    # };
    def __init__(self, open_stateid=None):
        self.open_stateid = open_stateid

    def __repr__(self):
        out = []
        if self.open_stateid is not None:
            out += ['open_stateid=%s' % repr(self.open_stateid)]
        return 'OPEN_DOWNGRADE4resok(%s)' % ', '.join(out)

class OPEN_DOWNGRADE4res:
    # XDR definition:
    # union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN_DOWNGRADE4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'OPEN_DOWNGRADE4res(%s)' % ', '.join(out)

class PUTFH4args:
    # XDR definition:
    # struct PUTFH4args {
    #     nfs_fh4 object;
    # };
    def __init__(self, object=None):
        self.object = object

    def __repr__(self):
        out = []
        if self.object is not None:
            out += ['object=%s' % repr(self.object)]
        return 'PUTFH4args(%s)' % ', '.join(out)

class PUTFH4res:
    # XDR definition:
    # struct PUTFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'PUTFH4res(%s)' % ', '.join(out)

class PUTPUBFH4res:
    # XDR definition:
    # struct PUTPUBFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'PUTPUBFH4res(%s)' % ', '.join(out)

class PUTROOTFH4res:
    # XDR definition:
    # struct PUTROOTFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'PUTROOTFH4res(%s)' % ', '.join(out)

class READ4args:
    # XDR definition:
    # struct READ4args {
    #     stateid4 stateid;
    #     offset4 offset;
    #     count4 count;
    # };
    def __init__(self, stateid=None, offset=None, count=None):
        self.stateid = stateid
        self.offset = offset
        self.count = count

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.count is not None:
            out += ['count=%s' % repr(self.count)]
        return 'READ4args(%s)' % ', '.join(out)

class READ4resok:
    # XDR definition:
    # struct READ4resok {
    #     bool eof;
    #     opaque data<>;
    # };
    def __init__(self, eof=None, data=None):
        self.eof = eof
        self.data = data

    def __repr__(self):
        out = []
        if self.eof is not None:
            out += ['eof=%s' % repr(self.eof)]
        if self.data is not None:
            out += ['data=%s' % repr(self.data)]
        return 'READ4resok(%s)' % ', '.join(out)

class READ4res:
    # XDR definition:
    # union READ4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         READ4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'READ4res(%s)' % ', '.join(out)

class READDIR4args:
    # XDR definition:
    # struct READDIR4args {
    #     nfs_cookie4 cookie;
    #     verifier4 cookieverf;
    #     count4 dircount;
    #     count4 maxcount;
    #     bitmap4 attr_request;
    # };
    def __init__(self, cookie=None, cookieverf=None, dircount=None, maxcount=None, attr_request=None):
        self.cookie = cookie
        self.cookieverf = cookieverf
        self.dircount = dircount
        self.maxcount = maxcount
        self.attr_request = attr_request

    def __repr__(self):
        out = []
        if self.cookie is not None:
            out += ['cookie=%s' % repr(self.cookie)]
        if self.cookieverf is not None:
            out += ['cookieverf=%s' % repr(self.cookieverf)]
        if self.dircount is not None:
            out += ['dircount=%s' % repr(self.dircount)]
        if self.maxcount is not None:
            out += ['maxcount=%s' % repr(self.maxcount)]
        if self.attr_request is not None:
            out += ['attr_request=%s' % repr(self.attr_request)]
        return 'READDIR4args(%s)' % ', '.join(out)

class entry4:
    # XDR definition:
    # struct entry4 {
    #     nfs_cookie4 cookie;
    #     component4 name;
    #     fattr4 attrs;
    #     entry4 nextentry<1>;
    # };
    def __init__(self, cookie=None, name=None, attrs=None, nextentry=None):
        self.cookie = cookie
        self.name = name
        self.attrs = attrs
        self.nextentry = nextentry

    def __repr__(self):
        out = []
        if self.cookie is not None:
            out += ['cookie=%s' % repr(self.cookie)]
        if self.name is not None:
            out += ['name=%s' % repr(self.name)]
        if self.attrs is not None:
            out += ['attrs=%s' % repr(self.attrs)]
        if self.nextentry is not None:
            out += ['nextentry=%s' % repr(self.nextentry)]
        return 'entry4(%s)' % ', '.join(out)

class dirlist4:
    # XDR definition:
    # struct dirlist4 {
    #     entry4 entries<1>;
    #     bool eof;
    # };
    def __init__(self, entries=None, eof=None):
        self.entries = entries
        self.eof = eof

    def __repr__(self):
        out = []
        if self.entries is not None:
            out += ['entries=%s' % repr(self.entries)]
        if self.eof is not None:
            out += ['eof=%s' % repr(self.eof)]
        return 'dirlist4(%s)' % ', '.join(out)

class READDIR4resok:
    # XDR definition:
    # struct READDIR4resok {
    #     verifier4 cookieverf;
    #     dirlist4 reply;
    # };
    def __init__(self, cookieverf=None, reply=None):
        self.cookieverf = cookieverf
        self.reply = reply

    def __repr__(self):
        out = []
        if self.cookieverf is not None:
            out += ['cookieverf=%s' % repr(self.cookieverf)]
        if self.reply is not None:
            out += ['reply=%s' % repr(self.reply)]
        return 'READDIR4resok(%s)' % ', '.join(out)

class READDIR4res:
    # XDR definition:
    # union READDIR4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         READDIR4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'READDIR4res(%s)' % ', '.join(out)

class READLINK4resok:
    # XDR definition:
    # struct READLINK4resok {
    #     linktext4 link;
    # };
    def __init__(self, link=None):
        self.link = link

    def __repr__(self):
        out = []
        if self.link is not None:
            out += ['link=%s' % repr(self.link)]
        return 'READLINK4resok(%s)' % ', '.join(out)

class READLINK4res:
    # XDR definition:
    # union READLINK4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         READLINK4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'READLINK4res(%s)' % ', '.join(out)

class REMOVE4args:
    # XDR definition:
    # struct REMOVE4args {
    #     component4 target;
    # };
    def __init__(self, target=None):
        self.target = target

    def __repr__(self):
        out = []
        if self.target is not None:
            out += ['target=%s' % repr(self.target)]
        return 'REMOVE4args(%s)' % ', '.join(out)

class REMOVE4resok:
    # XDR definition:
    # struct REMOVE4resok {
    #     change_info4 cinfo;
    # };
    def __init__(self, cinfo=None):
        self.cinfo = cinfo

    def __repr__(self):
        out = []
        if self.cinfo is not None:
            out += ['cinfo=%s' % repr(self.cinfo)]
        return 'REMOVE4resok(%s)' % ', '.join(out)

class REMOVE4res:
    # XDR definition:
    # union REMOVE4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         REMOVE4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'REMOVE4res(%s)' % ', '.join(out)

class RENAME4args:
    # XDR definition:
    # struct RENAME4args {
    #     component4 oldname;
    #     component4 newname;
    # };
    def __init__(self, oldname=None, newname=None):
        self.oldname = oldname
        self.newname = newname

    def __repr__(self):
        out = []
        if self.oldname is not None:
            out += ['oldname=%s' % repr(self.oldname)]
        if self.newname is not None:
            out += ['newname=%s' % repr(self.newname)]
        return 'RENAME4args(%s)' % ', '.join(out)

class RENAME4resok:
    # XDR definition:
    # struct RENAME4resok {
    #     change_info4 source_cinfo;
    #     change_info4 target_cinfo;
    # };
    def __init__(self, source_cinfo=None, target_cinfo=None):
        self.source_cinfo = source_cinfo
        self.target_cinfo = target_cinfo

    def __repr__(self):
        out = []
        if self.source_cinfo is not None:
            out += ['source_cinfo=%s' % repr(self.source_cinfo)]
        if self.target_cinfo is not None:
            out += ['target_cinfo=%s' % repr(self.target_cinfo)]
        return 'RENAME4resok(%s)' % ', '.join(out)

class RENAME4res:
    # XDR definition:
    # union RENAME4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         RENAME4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'RENAME4res(%s)' % ', '.join(out)

class RENEW4args:
    # XDR definition:
    # struct RENEW4args {
    #     clientid4 clientid;
    # };
    def __init__(self, clientid=None):
        self.clientid = clientid

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        return 'RENEW4args(%s)' % ', '.join(out)

class RENEW4res:
    # XDR definition:
    # struct RENEW4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'RENEW4res(%s)' % ', '.join(out)

class RESTOREFH4res:
    # XDR definition:
    # struct RESTOREFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'RESTOREFH4res(%s)' % ', '.join(out)

class SAVEFH4res:
    # XDR definition:
    # struct SAVEFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'SAVEFH4res(%s)' % ', '.join(out)

class SECINFO4args:
    # XDR definition:
    # struct SECINFO4args {
    #     component4 name;
    # };
    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        out = []
        if self.name is not None:
            out += ['name=%s' % repr(self.name)]
        return 'SECINFO4args(%s)' % ', '.join(out)

class rpcsec_gss_info:
    # XDR definition:
    # struct rpcsec_gss_info {
    #     sec_oid4 oid;
    #     qop4 qop;
    #     rpc_gss_svc_t service;
    # };
    def __init__(self, oid=None, qop=None, service=None):
        self.oid = oid
        self.qop = qop
        self.service = service

    def __repr__(self):
        out = []
        if self.oid is not None:
            out += ['oid=%s' % repr(self.oid)]
        if self.qop is not None:
            out += ['qop=%s' % repr(self.qop)]
        if self.service is not None:
            out += ['service=%s' % const.rpc_gss_svc_t.get(self.service, self.service)]
        return 'rpcsec_gss_info(%s)' % ', '.join(out)

class secinfo4:
    # XDR definition:
    # union secinfo4 switch(uint32_t flavor) {
    #     case RPCSEC_GSS:
    #         rpcsec_gss_info flavor_info;
    #     default:
    #         void;
    # };
    def __init__(self, flavor=None, flavor_info=None):
        self.flavor = flavor
        self.flavor_info = flavor_info

    def __repr__(self):
        out = []
        if self.flavor is not None:
            out += ['flavor=%s' % repr(self.flavor)]
        if self.flavor_info is not None:
            out += ['flavor_info=%s' % repr(self.flavor_info)]
        return 'secinfo4(%s)' % ', '.join(out)

class SECINFO4res:
    # XDR definition:
    # union SECINFO4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         SECINFO4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'SECINFO4res(%s)' % ', '.join(out)

class SETATTR4args:
    # XDR definition:
    # struct SETATTR4args {
    #     stateid4 stateid;
    #     fattr4 obj_attributes;
    # };
    def __init__(self, stateid=None, obj_attributes=None):
        self.stateid = stateid
        self.obj_attributes = obj_attributes

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.obj_attributes is not None:
            out += ['obj_attributes=%s' % repr(self.obj_attributes)]
        return 'SETATTR4args(%s)' % ', '.join(out)

class SETATTR4res:
    # XDR definition:
    # struct SETATTR4res {
    #     nfsstat4 status;
    #     bitmap4 attrsset;
    # };
    def __init__(self, status=None, attrsset=None):
        self.status = status
        self.attrsset = attrsset

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.attrsset is not None:
            out += ['attrsset=%s' % repr(self.attrsset)]
        return 'SETATTR4res(%s)' % ', '.join(out)

class SETCLIENTID4args:
    # XDR definition:
    # struct SETCLIENTID4args {
    #     nfs_client_id4 client;
    #     cb_client4 callback;
    #     uint32_t callback_ident;
    # };
    def __init__(self, client=None, callback=None, callback_ident=None):
        self.client = client
        self.callback = callback
        self.callback_ident = callback_ident

    def __repr__(self):
        out = []
        if self.client is not None:
            out += ['client=%s' % repr(self.client)]
        if self.callback is not None:
            out += ['callback=%s' % repr(self.callback)]
        if self.callback_ident is not None:
            out += ['callback_ident=%s' % repr(self.callback_ident)]
        return 'SETCLIENTID4args(%s)' % ', '.join(out)

class SETCLIENTID4resok:
    # XDR definition:
    # struct SETCLIENTID4resok {
    #     clientid4 clientid;
    #     verifier4 setclientid_confirm;
    # };
    def __init__(self, clientid=None, setclientid_confirm=None):
        self.clientid = clientid
        self.setclientid_confirm = setclientid_confirm

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        if self.setclientid_confirm is not None:
            out += ['setclientid_confirm=%s' % repr(self.setclientid_confirm)]
        return 'SETCLIENTID4resok(%s)' % ', '.join(out)

class SETCLIENTID4res:
    # XDR definition:
    # union SETCLIENTID4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         SETCLIENTID4resok resok4;
    #     case NFS4ERR_CLID_INUSE:
    #         clientaddr4 client_using;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None, client_using=None):
        self.status = status
        self.resok4 = resok4
        self.client_using = client_using

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        if self.client_using is not None:
            out += ['client_using=%s' % repr(self.client_using)]
        return 'SETCLIENTID4res(%s)' % ', '.join(out)

class SETCLIENTID_CONFIRM4args:
    # XDR definition:
    # struct SETCLIENTID_CONFIRM4args {
    #     clientid4 clientid;
    #     verifier4 setclientid_confirm;
    # };
    def __init__(self, clientid=None, setclientid_confirm=None):
        self.clientid = clientid
        self.setclientid_confirm = setclientid_confirm

    def __repr__(self):
        out = []
        if self.clientid is not None:
            out += ['clientid=%s' % repr(self.clientid)]
        if self.setclientid_confirm is not None:
            out += ['setclientid_confirm=%s' % repr(self.setclientid_confirm)]
        return 'SETCLIENTID_CONFIRM4args(%s)' % ', '.join(out)

class SETCLIENTID_CONFIRM4res:
    # XDR definition:
    # struct SETCLIENTID_CONFIRM4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'SETCLIENTID_CONFIRM4res(%s)' % ', '.join(out)

class VERIFY4args:
    # XDR definition:
    # struct VERIFY4args {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, obj_attributes=None):
        self.obj_attributes = obj_attributes

    def __repr__(self):
        out = []
        if self.obj_attributes is not None:
            out += ['obj_attributes=%s' % repr(self.obj_attributes)]
        return 'VERIFY4args(%s)' % ', '.join(out)

class VERIFY4res:
    # XDR definition:
    # struct VERIFY4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'VERIFY4res(%s)' % ', '.join(out)

class WRITE4args:
    # XDR definition:
    # struct WRITE4args {
    #     stateid4 stateid;
    #     offset4 offset;
    #     stable_how4 stable;
    #     opaque data<>;
    # };
    def __init__(self, stateid=None, offset=None, stable=None, data=None):
        self.stateid = stateid
        self.offset = offset
        self.stable = stable
        self.data = data

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.offset is not None:
            out += ['offset=%s' % repr(self.offset)]
        if self.stable is not None:
            out += ['stable=%s' % const.stable_how4.get(self.stable, self.stable)]
        if self.data is not None:
            out += ['data=%s' % repr(self.data)]
        return 'WRITE4args(%s)' % ', '.join(out)

class WRITE4resok:
    # XDR definition:
    # struct WRITE4resok {
    #     count4 count;
    #     stable_how4 committed;
    #     verifier4 writeverf;
    # };
    def __init__(self, count=None, committed=None, writeverf=None):
        self.count = count
        self.committed = committed
        self.writeverf = writeverf

    def __repr__(self):
        out = []
        if self.count is not None:
            out += ['count=%s' % repr(self.count)]
        if self.committed is not None:
            out += ['committed=%s' % const.stable_how4.get(self.committed, self.committed)]
        if self.writeverf is not None:
            out += ['writeverf=%s' % repr(self.writeverf)]
        return 'WRITE4resok(%s)' % ', '.join(out)

class WRITE4res:
    # XDR definition:
    # union WRITE4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         WRITE4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'WRITE4res(%s)' % ', '.join(out)

class RELEASE_LOCKOWNER4args:
    # XDR definition:
    # struct RELEASE_LOCKOWNER4args {
    #     lock_owner4 lock_owner;
    # };
    def __init__(self, lock_owner=None):
        self.lock_owner = lock_owner

    def __repr__(self):
        out = []
        if self.lock_owner is not None:
            out += ['lock_owner=%s' % repr(self.lock_owner)]
        return 'RELEASE_LOCKOWNER4args(%s)' % ', '.join(out)

class RELEASE_LOCKOWNER4res:
    # XDR definition:
    # struct RELEASE_LOCKOWNER4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'RELEASE_LOCKOWNER4res(%s)' % ', '.join(out)

class ILLEGAL4res:
    # XDR definition:
    # struct ILLEGAL4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'ILLEGAL4res(%s)' % ', '.join(out)

class nfs_argop4:
    # XDR definition:
    # union nfs_argop4 switch(nfs_opnum4 argop) {
    #     case OP_ACCESS:
    #         ACCESS4args opaccess;
    #     case OP_CLOSE:
    #         CLOSE4args opclose;
    #     case OP_COMMIT:
    #         COMMIT4args opcommit;
    #     case OP_CREATE:
    #         CREATE4args opcreate;
    #     case OP_DELEGPURGE:
    #         DELEGPURGE4args opdelegpurge;
    #     case OP_DELEGRETURN:
    #         DELEGRETURN4args opdelegreturn;
    #     case OP_GETATTR:
    #         GETATTR4args opgetattr;
    #     case OP_GETFH:
    #         void;
    #     case OP_LINK:
    #         LINK4args oplink;
    #     case OP_LOCK:
    #         LOCK4args oplock;
    #     case OP_LOCKT:
    #         LOCKT4args oplockt;
    #     case OP_LOCKU:
    #         LOCKU4args oplocku;
    #     case OP_LOOKUP:
    #         LOOKUP4args oplookup;
    #     case OP_LOOKUPP:
    #         void;
    #     case OP_NVERIFY:
    #         NVERIFY4args opnverify;
    #     case OP_OPEN:
    #         OPEN4args opopen;
    #     case OP_OPENATTR:
    #         OPENATTR4args opopenattr;
    #     case OP_OPEN_CONFIRM:
    #         OPEN_CONFIRM4args opopen_confirm;
    #     case OP_OPEN_DOWNGRADE:
    #         OPEN_DOWNGRADE4args opopen_downgrade;
    #     case OP_PUTFH:
    #         PUTFH4args opputfh;
    #     case OP_PUTPUBFH:
    #         void;
    #     case OP_PUTROOTFH:
    #         void;
    #     case OP_READ:
    #         READ4args opread;
    #     case OP_READDIR:
    #         READDIR4args opreaddir;
    #     case OP_READLINK:
    #         void;
    #     case OP_REMOVE:
    #         REMOVE4args opremove;
    #     case OP_RENAME:
    #         RENAME4args oprename;
    #     case OP_RENEW:
    #         RENEW4args oprenew;
    #     case OP_RESTOREFH:
    #         void;
    #     case OP_SAVEFH:
    #         void;
    #     case OP_SECINFO:
    #         SECINFO4args opsecinfo;
    #     case OP_SETATTR:
    #         SETATTR4args opsetattr;
    #     case OP_SETCLIENTID:
    #         SETCLIENTID4args opsetclientid;
    #     case OP_SETCLIENTID_CONFIRM:
    #         SETCLIENTID_CONFIRM4args opsetclientid_confirm;
    #     case OP_VERIFY:
    #         VERIFY4args opverify;
    #     case OP_WRITE:
    #         WRITE4args opwrite;
    #     case OP_RELEASE_LOCKOWNER:
    #         RELEASE_LOCKOWNER4args oprelease_lockowner;
    #     case OP_ILLEGAL:
    #         void;
    # };
    def __init__(self, argop=None, opaccess=None, opclose=None, opcommit=None, opcreate=None, opdelegpurge=None, opdelegreturn=None, opgetattr=None, oplink=None, oplock=None, oplockt=None, oplocku=None, oplookup=None, opnverify=None, opopen=None, opopenattr=None, opopen_confirm=None, opopen_downgrade=None, opputfh=None, opread=None, opreaddir=None, opremove=None, oprename=None, oprenew=None, opsecinfo=None, opsetattr=None, opsetclientid=None, opsetclientid_confirm=None, opverify=None, opwrite=None, oprelease_lockowner=None):
        self.argop = argop
        self.opaccess = opaccess
        self.opclose = opclose
        self.opcommit = opcommit
        self.opcreate = opcreate
        self.opdelegpurge = opdelegpurge
        self.opdelegreturn = opdelegreturn
        self.opgetattr = opgetattr
        self.oplink = oplink
        self.oplock = oplock
        self.oplockt = oplockt
        self.oplocku = oplocku
        self.oplookup = oplookup
        self.opnverify = opnverify
        self.opopen = opopen
        self.opopenattr = opopenattr
        self.opopen_confirm = opopen_confirm
        self.opopen_downgrade = opopen_downgrade
        self.opputfh = opputfh
        self.opread = opread
        self.opreaddir = opreaddir
        self.opremove = opremove
        self.oprename = oprename
        self.oprenew = oprenew
        self.opsecinfo = opsecinfo
        self.opsetattr = opsetattr
        self.opsetclientid = opsetclientid
        self.opsetclientid_confirm = opsetclientid_confirm
        self.opverify = opverify
        self.opwrite = opwrite
        self.oprelease_lockowner = oprelease_lockowner

    def __repr__(self):
        out = []
        if self.argop is not None:
            out += ['argop=%s' % const.nfs_opnum4.get(self.argop, self.argop)]
        if self.opaccess is not None:
            out += ['opaccess=%s' % repr(self.opaccess)]
        if self.opclose is not None:
            out += ['opclose=%s' % repr(self.opclose)]
        if self.opcommit is not None:
            out += ['opcommit=%s' % repr(self.opcommit)]
        if self.opcreate is not None:
            out += ['opcreate=%s' % repr(self.opcreate)]
        if self.opdelegpurge is not None:
            out += ['opdelegpurge=%s' % repr(self.opdelegpurge)]
        if self.opdelegreturn is not None:
            out += ['opdelegreturn=%s' % repr(self.opdelegreturn)]
        if self.opgetattr is not None:
            out += ['opgetattr=%s' % repr(self.opgetattr)]
        if self.oplink is not None:
            out += ['oplink=%s' % repr(self.oplink)]
        if self.oplock is not None:
            out += ['oplock=%s' % repr(self.oplock)]
        if self.oplockt is not None:
            out += ['oplockt=%s' % repr(self.oplockt)]
        if self.oplocku is not None:
            out += ['oplocku=%s' % repr(self.oplocku)]
        if self.oplookup is not None:
            out += ['oplookup=%s' % repr(self.oplookup)]
        if self.opnverify is not None:
            out += ['opnverify=%s' % repr(self.opnverify)]
        if self.opopen is not None:
            out += ['opopen=%s' % repr(self.opopen)]
        if self.opopenattr is not None:
            out += ['opopenattr=%s' % repr(self.opopenattr)]
        if self.opopen_confirm is not None:
            out += ['opopen_confirm=%s' % repr(self.opopen_confirm)]
        if self.opopen_downgrade is not None:
            out += ['opopen_downgrade=%s' % repr(self.opopen_downgrade)]
        if self.opputfh is not None:
            out += ['opputfh=%s' % repr(self.opputfh)]
        if self.opread is not None:
            out += ['opread=%s' % repr(self.opread)]
        if self.opreaddir is not None:
            out += ['opreaddir=%s' % repr(self.opreaddir)]
        if self.opremove is not None:
            out += ['opremove=%s' % repr(self.opremove)]
        if self.oprename is not None:
            out += ['oprename=%s' % repr(self.oprename)]
        if self.oprenew is not None:
            out += ['oprenew=%s' % repr(self.oprenew)]
        if self.opsecinfo is not None:
            out += ['opsecinfo=%s' % repr(self.opsecinfo)]
        if self.opsetattr is not None:
            out += ['opsetattr=%s' % repr(self.opsetattr)]
        if self.opsetclientid is not None:
            out += ['opsetclientid=%s' % repr(self.opsetclientid)]
        if self.opsetclientid_confirm is not None:
            out += ['opsetclientid_confirm=%s' % repr(self.opsetclientid_confirm)]
        if self.opverify is not None:
            out += ['opverify=%s' % repr(self.opverify)]
        if self.opwrite is not None:
            out += ['opwrite=%s' % repr(self.opwrite)]
        if self.oprelease_lockowner is not None:
            out += ['oprelease_lockowner=%s' % repr(self.oprelease_lockowner)]
        return 'nfs_argop4(%s)' % ', '.join(out)

class nfs_resop4:
    # XDR definition:
    # union nfs_resop4 switch(nfs_opnum4 resop) {
    #     case OP_ACCESS:
    #         ACCESS4res opaccess;
    #     case OP_CLOSE:
    #         CLOSE4res opclose;
    #     case OP_COMMIT:
    #         COMMIT4res opcommit;
    #     case OP_CREATE:
    #         CREATE4res opcreate;
    #     case OP_DELEGPURGE:
    #         DELEGPURGE4res opdelegpurge;
    #     case OP_DELEGRETURN:
    #         DELEGRETURN4res opdelegreturn;
    #     case OP_GETATTR:
    #         GETATTR4res opgetattr;
    #     case OP_GETFH:
    #         GETFH4res opgetfh;
    #     case OP_LINK:
    #         LINK4res oplink;
    #     case OP_LOCK:
    #         LOCK4res oplock;
    #     case OP_LOCKT:
    #         LOCKT4res oplockt;
    #     case OP_LOCKU:
    #         LOCKU4res oplocku;
    #     case OP_LOOKUP:
    #         LOOKUP4res oplookup;
    #     case OP_LOOKUPP:
    #         LOOKUPP4res oplookupp;
    #     case OP_NVERIFY:
    #         NVERIFY4res opnverify;
    #     case OP_OPEN:
    #         OPEN4res opopen;
    #     case OP_OPENATTR:
    #         OPENATTR4res opopenattr;
    #     case OP_OPEN_CONFIRM:
    #         OPEN_CONFIRM4res opopen_confirm;
    #     case OP_OPEN_DOWNGRADE:
    #         OPEN_DOWNGRADE4res opopen_downgrade;
    #     case OP_PUTFH:
    #         PUTFH4res opputfh;
    #     case OP_PUTPUBFH:
    #         PUTPUBFH4res opputpubfh;
    #     case OP_PUTROOTFH:
    #         PUTROOTFH4res opputrootfh;
    #     case OP_READ:
    #         READ4res opread;
    #     case OP_READDIR:
    #         READDIR4res opreaddir;
    #     case OP_READLINK:
    #         READLINK4res opreadlink;
    #     case OP_REMOVE:
    #         REMOVE4res opremove;
    #     case OP_RENAME:
    #         RENAME4res oprename;
    #     case OP_RENEW:
    #         RENEW4res oprenew;
    #     case OP_RESTOREFH:
    #         RESTOREFH4res oprestorefh;
    #     case OP_SAVEFH:
    #         SAVEFH4res opsavefh;
    #     case OP_SECINFO:
    #         SECINFO4res opsecinfo;
    #     case OP_SETATTR:
    #         SETATTR4res opsetattr;
    #     case OP_SETCLIENTID:
    #         SETCLIENTID4res opsetclientid;
    #     case OP_SETCLIENTID_CONFIRM:
    #         SETCLIENTID_CONFIRM4res opsetclientid_confirm;
    #     case OP_VERIFY:
    #         VERIFY4res opverify;
    #     case OP_WRITE:
    #         WRITE4res opwrite;
    #     case OP_RELEASE_LOCKOWNER:
    #         RELEASE_LOCKOWNER4res oprelease_lockowner;
    #     case OP_ILLEGAL:
    #         ILLEGAL4res opillegal;
    # };
    def __init__(self, resop=None, opaccess=None, opclose=None, opcommit=None, opcreate=None, opdelegpurge=None, opdelegreturn=None, opgetattr=None, opgetfh=None, oplink=None, oplock=None, oplockt=None, oplocku=None, oplookup=None, oplookupp=None, opnverify=None, opopen=None, opopenattr=None, opopen_confirm=None, opopen_downgrade=None, opputfh=None, opputpubfh=None, opputrootfh=None, opread=None, opreaddir=None, opreadlink=None, opremove=None, oprename=None, oprenew=None, oprestorefh=None, opsavefh=None, opsecinfo=None, opsetattr=None, opsetclientid=None, opsetclientid_confirm=None, opverify=None, opwrite=None, oprelease_lockowner=None, opillegal=None):
        self.resop = resop
        self.opaccess = opaccess
        self.opclose = opclose
        self.opcommit = opcommit
        self.opcreate = opcreate
        self.opdelegpurge = opdelegpurge
        self.opdelegreturn = opdelegreturn
        self.opgetattr = opgetattr
        self.opgetfh = opgetfh
        self.oplink = oplink
        self.oplock = oplock
        self.oplockt = oplockt
        self.oplocku = oplocku
        self.oplookup = oplookup
        self.oplookupp = oplookupp
        self.opnverify = opnverify
        self.opopen = opopen
        self.opopenattr = opopenattr
        self.opopen_confirm = opopen_confirm
        self.opopen_downgrade = opopen_downgrade
        self.opputfh = opputfh
        self.opputpubfh = opputpubfh
        self.opputrootfh = opputrootfh
        self.opread = opread
        self.opreaddir = opreaddir
        self.opreadlink = opreadlink
        self.opremove = opremove
        self.oprename = oprename
        self.oprenew = oprenew
        self.oprestorefh = oprestorefh
        self.opsavefh = opsavefh
        self.opsecinfo = opsecinfo
        self.opsetattr = opsetattr
        self.opsetclientid = opsetclientid
        self.opsetclientid_confirm = opsetclientid_confirm
        self.opverify = opverify
        self.opwrite = opwrite
        self.oprelease_lockowner = oprelease_lockowner
        self.opillegal = opillegal

    def __repr__(self):
        out = []
        if self.resop is not None:
            out += ['resop=%s' % const.nfs_opnum4.get(self.resop, self.resop)]
        if self.opaccess is not None:
            out += ['opaccess=%s' % repr(self.opaccess)]
        if self.opclose is not None:
            out += ['opclose=%s' % repr(self.opclose)]
        if self.opcommit is not None:
            out += ['opcommit=%s' % repr(self.opcommit)]
        if self.opcreate is not None:
            out += ['opcreate=%s' % repr(self.opcreate)]
        if self.opdelegpurge is not None:
            out += ['opdelegpurge=%s' % repr(self.opdelegpurge)]
        if self.opdelegreturn is not None:
            out += ['opdelegreturn=%s' % repr(self.opdelegreturn)]
        if self.opgetattr is not None:
            out += ['opgetattr=%s' % repr(self.opgetattr)]
        if self.opgetfh is not None:
            out += ['opgetfh=%s' % repr(self.opgetfh)]
        if self.oplink is not None:
            out += ['oplink=%s' % repr(self.oplink)]
        if self.oplock is not None:
            out += ['oplock=%s' % repr(self.oplock)]
        if self.oplockt is not None:
            out += ['oplockt=%s' % repr(self.oplockt)]
        if self.oplocku is not None:
            out += ['oplocku=%s' % repr(self.oplocku)]
        if self.oplookup is not None:
            out += ['oplookup=%s' % repr(self.oplookup)]
        if self.oplookupp is not None:
            out += ['oplookupp=%s' % repr(self.oplookupp)]
        if self.opnverify is not None:
            out += ['opnverify=%s' % repr(self.opnverify)]
        if self.opopen is not None:
            out += ['opopen=%s' % repr(self.opopen)]
        if self.opopenattr is not None:
            out += ['opopenattr=%s' % repr(self.opopenattr)]
        if self.opopen_confirm is not None:
            out += ['opopen_confirm=%s' % repr(self.opopen_confirm)]
        if self.opopen_downgrade is not None:
            out += ['opopen_downgrade=%s' % repr(self.opopen_downgrade)]
        if self.opputfh is not None:
            out += ['opputfh=%s' % repr(self.opputfh)]
        if self.opputpubfh is not None:
            out += ['opputpubfh=%s' % repr(self.opputpubfh)]
        if self.opputrootfh is not None:
            out += ['opputrootfh=%s' % repr(self.opputrootfh)]
        if self.opread is not None:
            out += ['opread=%s' % repr(self.opread)]
        if self.opreaddir is not None:
            out += ['opreaddir=%s' % repr(self.opreaddir)]
        if self.opreadlink is not None:
            out += ['opreadlink=%s' % repr(self.opreadlink)]
        if self.opremove is not None:
            out += ['opremove=%s' % repr(self.opremove)]
        if self.oprename is not None:
            out += ['oprename=%s' % repr(self.oprename)]
        if self.oprenew is not None:
            out += ['oprenew=%s' % repr(self.oprenew)]
        if self.oprestorefh is not None:
            out += ['oprestorefh=%s' % repr(self.oprestorefh)]
        if self.opsavefh is not None:
            out += ['opsavefh=%s' % repr(self.opsavefh)]
        if self.opsecinfo is not None:
            out += ['opsecinfo=%s' % repr(self.opsecinfo)]
        if self.opsetattr is not None:
            out += ['opsetattr=%s' % repr(self.opsetattr)]
        if self.opsetclientid is not None:
            out += ['opsetclientid=%s' % repr(self.opsetclientid)]
        if self.opsetclientid_confirm is not None:
            out += ['opsetclientid_confirm=%s' % repr(self.opsetclientid_confirm)]
        if self.opverify is not None:
            out += ['opverify=%s' % repr(self.opverify)]
        if self.opwrite is not None:
            out += ['opwrite=%s' % repr(self.opwrite)]
        if self.oprelease_lockowner is not None:
            out += ['oprelease_lockowner=%s' % repr(self.oprelease_lockowner)]
        if self.opillegal is not None:
            out += ['opillegal=%s' % repr(self.opillegal)]
        return 'nfs_resop4(%s)' % ', '.join(out)

class COMPOUND4args:
    # XDR definition:
    # struct COMPOUND4args {
    #     utf8str_cs tag;
    #     uint32_t minorversion;
    #     nfs_argop4 argarray<>;
    # };
    def __init__(self, tag=None, minorversion=None, argarray=None):
        self.tag = tag
        self.minorversion = minorversion
        self.argarray = argarray

    def __repr__(self):
        out = []
        if self.tag is not None:
            out += ['tag=%s' % repr(self.tag)]
        if self.minorversion is not None:
            out += ['minorversion=%s' % repr(self.minorversion)]
        if self.argarray is not None:
            out += ['argarray=%s' % repr(self.argarray)]
        return 'COMPOUND4args(%s)' % ', '.join(out)

class COMPOUND4res:
    # XDR definition:
    # struct COMPOUND4res {
    #     nfsstat4 status;
    #     utf8str_cs tag;
    #     nfs_resop4 resarray<>;
    # };
    def __init__(self, status=None, tag=None, resarray=None):
        self.status = status
        self.tag = tag
        self.resarray = resarray

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.tag is not None:
            out += ['tag=%s' % repr(self.tag)]
        if self.resarray is not None:
            out += ['resarray=%s' % repr(self.resarray)]
        return 'COMPOUND4res(%s)' % ', '.join(out)

class CB_GETATTR4args:
    # XDR definition:
    # struct CB_GETATTR4args {
    #     nfs_fh4 fh;
    #     bitmap4 attr_request;
    # };
    def __init__(self, fh=None, attr_request=None):
        self.fh = fh
        self.attr_request = attr_request

    def __repr__(self):
        out = []
        if self.fh is not None:
            out += ['fh=%s' % repr(self.fh)]
        if self.attr_request is not None:
            out += ['attr_request=%s' % repr(self.attr_request)]
        return 'CB_GETATTR4args(%s)' % ', '.join(out)

class CB_GETATTR4resok:
    # XDR definition:
    # struct CB_GETATTR4resok {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, obj_attributes=None):
        self.obj_attributes = obj_attributes

    def __repr__(self):
        out = []
        if self.obj_attributes is not None:
            out += ['obj_attributes=%s' % repr(self.obj_attributes)]
        return 'CB_GETATTR4resok(%s)' % ', '.join(out)

class CB_GETATTR4res:
    # XDR definition:
    # union CB_GETATTR4res switch(nfsstat4 status) {
    #     case NFS4_OK:
    #         CB_GETATTR4resok resok4;
    #     default:
    #         void;
    # };
    def __init__(self, status=None, resok4=None):
        self.status = status
        self.resok4 = resok4

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.resok4 is not None:
            out += ['resok4=%s' % repr(self.resok4)]
        return 'CB_GETATTR4res(%s)' % ', '.join(out)

class CB_RECALL4args:
    # XDR definition:
    # struct CB_RECALL4args {
    #     stateid4 stateid;
    #     bool truncate;
    #     nfs_fh4 fh;
    # };
    def __init__(self, stateid=None, truncate=None, fh=None):
        self.stateid = stateid
        self.truncate = truncate
        self.fh = fh

    def __repr__(self):
        out = []
        if self.stateid is not None:
            out += ['stateid=%s' % repr(self.stateid)]
        if self.truncate is not None:
            out += ['truncate=%s' % repr(self.truncate)]
        if self.fh is not None:
            out += ['fh=%s' % repr(self.fh)]
        return 'CB_RECALL4args(%s)' % ', '.join(out)

class CB_RECALL4res:
    # XDR definition:
    # struct CB_RECALL4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'CB_RECALL4res(%s)' % ', '.join(out)

class CB_ILLEGAL4res:
    # XDR definition:
    # struct CB_ILLEGAL4res {
    #     nfsstat4 status;
    # };
    def __init__(self, status=None):
        self.status = status

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        return 'CB_ILLEGAL4res(%s)' % ', '.join(out)

class nfs_cb_argop4:
    # XDR definition:
    # union nfs_cb_argop4 switch(unsigned argop) {
    #     case OP_CB_GETATTR:
    #         CB_GETATTR4args opcbgetattr;
    #     case OP_CB_RECALL:
    #         CB_RECALL4args opcbrecall;
    #     case OP_CB_ILLEGAL:
    #         void;
    # };
    def __init__(self, argop=None, opcbgetattr=None, opcbrecall=None):
        self.argop = argop
        self.opcbgetattr = opcbgetattr
        self.opcbrecall = opcbrecall

    def __repr__(self):
        out = []
        if self.argop is not None:
            out += ['argop=%s' % repr(self.argop)]
        if self.opcbgetattr is not None:
            out += ['opcbgetattr=%s' % repr(self.opcbgetattr)]
        if self.opcbrecall is not None:
            out += ['opcbrecall=%s' % repr(self.opcbrecall)]
        return 'nfs_cb_argop4(%s)' % ', '.join(out)

class nfs_cb_resop4:
    # XDR definition:
    # union nfs_cb_resop4 switch(unsigned resop) {
    #     case OP_CB_GETATTR:
    #         CB_GETATTR4res opcbgetattr;
    #     case OP_CB_RECALL:
    #         CB_RECALL4res opcbrecall;
    #     case OP_CB_ILLEGAL:
    #         CB_ILLEGAL4res opcbillegal;
    # };
    def __init__(self, resop=None, opcbgetattr=None, opcbrecall=None, opcbillegal=None):
        self.resop = resop
        self.opcbgetattr = opcbgetattr
        self.opcbrecall = opcbrecall
        self.opcbillegal = opcbillegal

    def __repr__(self):
        out = []
        if self.resop is not None:
            out += ['resop=%s' % repr(self.resop)]
        if self.opcbgetattr is not None:
            out += ['opcbgetattr=%s' % repr(self.opcbgetattr)]
        if self.opcbrecall is not None:
            out += ['opcbrecall=%s' % repr(self.opcbrecall)]
        if self.opcbillegal is not None:
            out += ['opcbillegal=%s' % repr(self.opcbillegal)]
        return 'nfs_cb_resop4(%s)' % ', '.join(out)

class CB_COMPOUND4args:
    # XDR definition:
    # struct CB_COMPOUND4args {
    #     utf8str_cs tag;
    #     uint32_t minorversion;
    #     uint32_t callback_ident;
    #     nfs_cb_argop4 argarray<>;
    # };
    def __init__(self, tag=None, minorversion=None, callback_ident=None, argarray=None):
        self.tag = tag
        self.minorversion = minorversion
        self.callback_ident = callback_ident
        self.argarray = argarray

    def __repr__(self):
        out = []
        if self.tag is not None:
            out += ['tag=%s' % repr(self.tag)]
        if self.minorversion is not None:
            out += ['minorversion=%s' % repr(self.minorversion)]
        if self.callback_ident is not None:
            out += ['callback_ident=%s' % repr(self.callback_ident)]
        if self.argarray is not None:
            out += ['argarray=%s' % repr(self.argarray)]
        return 'CB_COMPOUND4args(%s)' % ', '.join(out)

class CB_COMPOUND4res:
    # XDR definition:
    # struct CB_COMPOUND4res {
    #     nfsstat4 status;
    #     utf8str_cs tag;
    #     nfs_cb_resop4 resarray<>;
    # };
    def __init__(self, status=None, tag=None, resarray=None):
        self.status = status
        self.tag = tag
        self.resarray = resarray

    def __repr__(self):
        out = []
        if self.status is not None:
            out += ['status=%s' % const.nfsstat4.get(self.status, self.status)]
        if self.tag is not None:
            out += ['tag=%s' % repr(self.tag)]
        if self.resarray is not None:
            out += ['resarray=%s' % repr(self.resarray)]
        return 'CB_COMPOUND4res(%s)' % ', '.join(out)

