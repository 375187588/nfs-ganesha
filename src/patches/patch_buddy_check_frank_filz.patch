diff --git a/src/BuddyMalloc/BuddyMalloc.c b/src/BuddyMalloc/BuddyMalloc.c
index 2f740f0..b4a5cb7 100644
--- a/src/BuddyMalloc/BuddyMalloc.c
+++ b/src/BuddyMalloc/BuddyMalloc.c
@@ -1814,6 +1814,180 @@ BUDDY_ADDR_T BuddyCalloc(size_t NumberOfElements, size_t ElementSize)
 
 } /* BuddyCalloc */
 
+#ifdef _DEBUG_MEMLEAKS
+void BuddyPrintLogLabel(BuddyThreadContext_t *context, BuddyBlock_t *p_block)
+{
+  if (p_block->Header.label_file != NULL || p_block->Header.label_func != NULL ||
+      p_block->Header.label_line != 0    || p_block->Header.label_user_defined != NULL)
+  {
+    BuddyPrintLog(context->Config.buddy_error_file,
+                  "Thread %p /!\\ ***** block %p has label : %s:%s:%u:%s *****\n",
+                  (BUDDY_ADDR_T) pthread_self(),
+                  p_block,
+                  p_block->Header.label_file, p_block->Header.label_func,
+                  p_block->Header.label_line, p_block->Header.label_user_defined);
+  }
+}
+#endif
+
+/**
+ *  test memory corruption for a block.
+ */
+int BuddyCheckDbg(BuddyThreadContext_t *context, BuddyBlock_t *p_block)
+{
+  char *block_type = "Standard Block";
+
+  if (IS_EXTRA_BLOCK(p_block))
+    block_type = "Large Block";
+
+  /* check magic number consistency */
+  switch (p_block->Header.status)
+    {
+    case FREE_BLOCK:
+      /* check for magic number */
+      if(p_block->Header.MagicNumber != MAGIC_NUMBER_FREE)
+        {
+#ifdef _DEBUG_MEMLEAKS
+          BuddyBlock_t *guilt_block;
+#endif
+
+          BuddyPrintLog(context->Config.buddy_error_file,
+                        "Thread %p /!\\ ***** BuddyCheck: CRITICAL WARNING : block %p has been overwritten or is not a buddy block (Magic number %8X<>%8X)****** /!\\\n",
+                        (BUDDY_ADDR_T) pthread_self(),
+                        p_block, p_block->Header.MagicNumber, MAGIC_NUMBER_FREE);
+
+#ifdef _DEBUG_MEMLEAKS
+	  BuddyPrintLogLabel(context, p_block);
+
+          /*
+          if((guilt_block = find_previous_allocated(context, p_block)) != NULL)
+            BuddyPrintLog(context->Config.buddy_error_file,
+                          "Thread %p /!\\ ***** The guilt block is %p->%p : %s:%s:%u:%s *****\n",
+                          (BUDDY_ADDR_T) pthread_self(),
+                          guilt_block,
+                          guilt_block + (1 << p_block->Header.StdInfo.k_size) - 1,
+                          guilt_block->Header.label_file, guilt_block->Header.label_func,
+                          guilt_block->Header.label_line,
+                          guilt_block->Header.label_user_defined);
+
+          else
+            BuddyPrintLog(context->Config.buddy_error_file,
+                          "Thread %p /!\\ ***** No previous Block ??? ****\n", (BUDDY_ADDR_T) pthread_self());
+          */
+#endif
+
+          /* doing nothing is safer !!! */
+          return 0;
+        }
+      break;
+
+    case RESERVED_BLOCK:
+      /* check for magic number */
+      if(p_block->Header.MagicNumber != MAGIC_NUMBER_USED)
+        {
+#ifdef _DEBUG_MEMLEAKS
+          BuddyBlock_t *guilt_block;
+#endif
+
+          BuddyPrintLog(context->Config.buddy_error_file,
+                        "Thread %p /!\\ ***** BuddyCheck: CRITICAL WARNING : block %p has been overwritten or is not a buddy block (Magic number %8X<>%8X)****** /!\\\n",
+                        (BUDDY_ADDR_T) pthread_self(),
+                        p_block, p_block->Header.MagicNumber, MAGIC_NUMBER_USED);
+
+#ifdef _DEBUG_MEMLEAKS
+	  BuddyPrintLogLabel(context, p_block);
+
+          /*
+          if((guilt_block = find_previous_allocated(context, p_block)) != NULL)
+            BuddyPrintLog(context->Config.buddy_error_file,
+                          "Thread %p /!\\ ***** The guilt block is %p->%p : %s:%s:%u:%s *****\n",
+                          (BUDDY_ADDR_T) pthread_self(),
+                          guilt_block,
+                          guilt_block + (1 << p_block->Header.StdInfo.k_size) - 1,
+                          guilt_block->Header.label_file, guilt_block->Header.label_func,
+                          guilt_block->Header.label_line,
+                          guilt_block->Header.label_user_defined);
+          else
+            BuddyPrintLog(context->Config.buddy_error_file,
+                          "Thread %p /!\\ ***** No previous Block ??? ****\n", (BUDDY_ADDR_T) pthread_self());
+          */
+#endif
+
+          /* doing nothing is safer !!! */
+          return 0;
+        }
+      break;
+
+    default:
+      /* Invalid Header status : may not be allocated using BuddyMalloc */
+      BuddyPrintLog(context->Config.buddy_error_file,
+                    "Thread %p /!\\ ***** BuddyCheck: CRITICAL WARNING : pointer %p is not a buddy block !!!\n",
+                    (BUDDY_ADDR_T) pthread_self(),
+                    p_block);
+      return 0;
+    }
+
+  /* is it already free ? */
+  if(p_block->Header.status != FREE_BLOCK)
+    {
+#ifdef _DEBUG_MEMLEAKS
+      BuddyBlock_t *guilt_block;
+#endif
+
+      BuddyPrintLog(context->Config.buddy_error_file,
+                    "Thread %p /!\\ ***** WARNING : block %p (%s) was not free ***** /!\\\n",
+                    (BUDDY_ADDR_T) pthread_self(),
+                    p_block,
+                    block_type);
+
+#ifdef _DEBUG_MEMLEAKS
+      BuddyPrintLogLabel(context, p_block);
+
+      /*
+      if((guilt_block = find_previous_allocated(context, p_block)) != NULL)
+        BuddyPrintLog(context->Config.buddy_error_file,
+                      "Thread %p /!\\ ***** guilt block may be %p->%p : %s:%s:%u:%s *****\n",
+                      (BUDDY_ADDR_T) pthread_self(),
+                      guilt_block,
+                      guilt_block + (1 << p_block->Header.StdInfo.k_size) - 1,
+                      guilt_block->Header.label_file, guilt_block->Header.label_func,
+                      guilt_block->Header.label_line,
+                      guilt_block->Header.label_user_defined);
+      */
+#endif
+    }
+
+  if(p_block->Header.OwnerThread != pthread_self())
+    {
+      BuddyPrintLog(context->Config.buddy_error_file,
+                    "Thread %p /!\\ WARNING : block %p has been allocated by thread %p! status=%d\n",
+                    (BUDDY_ADDR_T) pthread_self(),
+                    p_block, (BUDDY_ADDR_T) p_block->Header.OwnerThread,
+                   (BUDDY_ADDR_T) p_block->Header.status);
+#ifdef _DEBUG_MEMLEAKS
+      BuddyPrintLogLabel(context, p_block);
+#endif
+
+      return 0;
+    }
+
+  /* If it is an ExtraBlock, its OK */
+  if(IS_EXTRA_BLOCK(p_block))
+    return 1;
+
+  /* Std blocks sanity checks */
+  if(((BUDDY_ADDR_T) p_block < p_block->Header.Base_ptr) ||
+     ((BUDDY_ADDR_T) p_block > p_block->Header.Base_ptr +
+      (1 << p_block->Header.StdInfo.Base_kSize)))
+    {
+      context->Errno = BUDDY_ERR_EINVAL;
+      return 0;
+    }
+
+  return 1;
+
+}                               /* BuddyCheckDbg */
+
 /**
  *  Release all thread resources.
  */
@@ -1821,7 +1995,7 @@ int BuddyDestroy()
 {
         BuddyThreadContext_t *context;
         BuddyBlock_t *p_block;
-        unsigned int i;
+        unsigned int i, count = 0, count2 = 0, count3 = 0;
 
         /* Ensure thread safety. */
         context = GetThreadContext();
@@ -1839,6 +2013,50 @@ int BuddyDestroy()
         CheckBlocksToBeFreed(context);
 #endif
 
+#ifdef _DEBUG_MEMLEAKS
+  /* Scan Allocated Blocks and Free Them */
+  for(p_block = context->p_allocated;
+      p_block != NULL; p_block = p_block->Header.p_next_allocated)
+    {
+      BuddyCheckDbg(context, p_block);
+      count++;
+    }
+#endif
+
+/*
+  for(i = 0; i < BUDDY_MAX_LOG2_SIZE; i++)
+    {
+
+      p_block = context->MemDesc[i];
+      while(p_block)
+        {
+          BuddyBlock_t *p_next_block = p_block->Content.FreeBlockInfo.NextBlock;
+          if((p_block->Header.Base_ptr == (BUDDY_ADDR_T) p_block)
+             && (p_block->Header.StdInfo.Base_kSize == p_block->Header.StdInfo.k_size))
+          {
+            if (BuddyCheckDbg(context, p_block))
+            {
+              count2++;
+              BuddyPrintLog(context->Config.buddy_error_file, "Thread %p Freeing block %p i=%d k_size=%d count2=%d\n",
+                            (BUDDY_ADDR_T) pthread_self(), p_block, i, p_block->Header.StdInfo.k_size, count2);
+              //free(p_block);
+            }
+            else
+            {
+              count3++;
+            }
+          }
+          else
+          {
+              BuddyPrintLog(context->Config.buddy_error_file, "Thread %p Block %p i=%d not a base block\n",
+                            (BUDDY_ADDR_T) pthread_self(), p_block, i, count2);
+              count3++;
+          }
+          p_block = p_next_block;
+        }
+    }
+*/
+
         /* free largest pages */
         while ( (p_block = context->MemDesc[context->k_size]) != NULL )
         {
@@ -2542,6 +2760,8 @@ int BuddyCheck(BUDDY_ADDR_T ptr)
   /* retrieves block address */
   p_block = (BuddyBlock_t *) (ptr - size_header64);
 
+  BuddyPrintLogLabel(context, p_block);
+
   /* check magic number consistency */
   switch (p_block->Header.status)
     {
diff --git a/src/MainNFSD/nfs_rpc_dispatcher_thread.c b/src/MainNFSD/nfs_rpc_dispatcher_thread.c
index aa1f96e..7dfff39 100644
--- a/src/MainNFSD/nfs_rpc_dispatcher_thread.c
+++ b/src/MainNFSD/nfs_rpc_dispatcher_thread.c
@@ -1751,6 +1751,12 @@ void nfs_rpc_getreq(fd_set * readfds, nfs_parameter_t * pnfs_para)
 #ifdef _DEBUG_DISPATCH
               DisplayLogLevel(NIV_FULL_DEBUG, "A MOUNT UDP request");
 #endif
+              DisplayLog("Thread %p A MOUNT UDP request pnfsreq=%p xprt=%p proto=%d msg=%p",
+                         pthread_self(), pnfsreq, pnfsreq->mnt_udp_xprt, IPPROTO_UDP, &(pnfsreq->msg));
+#ifdef _DEBUG_MEMLEAKS
+              if (BuddyCheck(pnfsreq))
+                DisplayLog("Request %p ok", pnfsreq);
+#endif
               pnfsreq->xprt = pnfsreq->mnt_udp_xprt;
               pnfsreq->ipproto = IPPROTO_UDP;
