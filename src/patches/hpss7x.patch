diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/Makefile.am b/src/FSAL/FSAL_HPSS/HPSSclapiExt/Makefile.am
index 64848a5..09d42e9 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/Makefile.am
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/Makefile.am
@@ -2,4 +2,4 @@ AM_CFLAGS=$(FSAL_CFLAGS) $(SEC_CFLAGS)
 
 noinst_LTLIBRARIES          = libhpssapiext.la 
 
-libhpssapiext_la_SOURCES    = api_fgetattr.c  api_fsetattr.c  api_mkdir.c  api_open.c  api_rddir.c  api_symlink.c  hpssclapiext.h
+libhpssapiext_la_SOURCES    = api_fgetattr.c  api_fsetattr.c  api_mkdir.c  api_rddir.c  api_symlink.c  api_open.c hpssclapiext.h
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fgetattr.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fgetattr.c
index 60b1cc4..a82a3df 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fgetattr.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fgetattr.c
@@ -250,10 +250,12 @@ hpss_fileattr_t   *AttrOut,       /* OUT - attributes after query */
 hpss_xfileattr_t  *XAttrOut)      /* OUT - xattributes after query */
 {
    static char          function_name[] = "HPSSFSAL_Common_FileGetAttributes";
-#ifdef _USE_HPSS_51      
+#if (HPSS_MAJOR_VERSION == 5) || (HPSS_MAJOR_VERSION == 7)
    volatile long	error = 0;        /* return error */
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif (HPSS_MAJOR_VERSION == 6)
    signed32 	error = 0;        /* return error */
+#else
+   #error "Unexpected HPSS VERSION MAJOR"
 #endif
    hpss_AttrBits_t      select_flags;     /* attribute select bits */
    hpss_AttrBits_t      parent_flags;     /* attribute select bits */
@@ -297,7 +299,7 @@ hpss_xfileattr_t  *XAttrOut)      /* OUT - xattributes after query */
       {
 	 return(-EINVAL);
       }
-#ifdef _USE_HPSS_622
+#if ( HPSS_LEVEL >= 622 )
       if  ((Flags & API_GET_XATTRS_NO_BLOCK) != 0)
          xattr_options |= CORE_GETATTRS_NO_BLOCK;
 #endif
@@ -330,7 +332,9 @@ hpss_xfileattr_t  *XAttrOut)      /* OUT - xattributes after query */
 			    &AttrOut->Attrs,
 			    NULL,
 			    NULL,
+#if ( HPSS_MAJOR_VERSION < 7 )
 			    &ta,
+#endif
 			    NULL,
 			    xattr_ptr);
 
@@ -399,7 +403,7 @@ hpss_xfileattr_t  *XAttrOut)      /* OUT - xattributes after query */
  *-------------------------------------------------------------------------*/
 
 /* This function is provided from HPSS 6.2.2 */
-#ifndef _USE_HPSS_622
+#if ( HPSS_LEVEL < 622 )
 int
 HPSSFSAL_FileGetXAttributesHandle(
 ns_ObjHandle_t  *ObjHandle,     /* IN - object handle */
@@ -451,7 +455,11 @@ hpss_xfileattr_t *AttrOut)      /* OUT - attributes after query */
    error = HPSSFSAL_Common_FileGetAttributes(threadcontext,
                                     ObjHandle,
                                     NULL,
+#if ( HPSS_MAJOR_VERSION < 7 )
                                     threadcontext->CwdStackPtr,
+#else
+				    API_NULL_CWD_STACK,
+#endif
                                     rqstid,
                                     Flags,
                                     API_CHASE_ALL,
@@ -460,6 +468,19 @@ hpss_xfileattr_t *AttrOut)      /* OUT - attributes after query */
                                     NULL,
                                     &file_attrs,
                                     AttrOut);
+   error = Common_FileGetAttributes(threadcontext,
+                                    ObjHandle,
+                                    Path,
+                                    API_NULL_CWD_STACK,
+                                    rqstid,
+                                    Flags,
+                                    API_CHASE_ALL,
+                                    StorageLevel,
+                                    ucred_ptr,
+                                    &file_attrs,
+                                    AttrOut);
+
+
 
    if ( error != 0 )
       xdr_free((xdrproc_t)xdr_bf_sc_attrib_t, (void *)AttrOut->SCAttrib);
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fsetattr.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fsetattr.c
index 1c642a2..34c8f87 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fsetattr.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_fsetattr.c
@@ -12,6 +12,9 @@
 
 #define BFS_SET_MAX (32)   
 
+/* these functions are working in HPSS 7.x */
+#if (HPSS_MAJOR_VERSION < 7)
+
 /*
  * Local function definition
  */
@@ -70,6 +73,7 @@ hpss_fileattr_t     *AttrOut);      /* OUT - attributes after change */
  *
  *-------------------------------------------------------------------------*/
 
+
 int
 HPSSFSAL_FileSetAttrHandle(
 ns_ObjHandle_t      *ObjHandle, /* IN  - parent object handle */
@@ -150,6 +154,7 @@ hpss_fileattr_t     *AttrOut)   /* OUT - attributes after change */
 }
 
 
+
 /*============================================================================
  *
  * Function:    Common_FileSetAttributes
@@ -213,9 +218,9 @@ hpss_fileattrbits_t *SelFlagsOut,   /* OUT - attributes fields set */
 hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 {
    unsigned32           call_type;           /* whether to call dmg or ns */
-#ifdef _USE_HPSS_51      
+#if  (HPSS_MAJOR_VERSION == 5)
    volatile long	error = 0;        /* return error */
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#else
    signed32 	    error = 0;        /* return error */
 #endif
    static char          function_name[] = "Common_FileSetAttributes";
@@ -323,6 +328,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
    (void)memset(&select_flags,0,sizeof(select_flags));
    (void)memset(&parent_flags,0,sizeof(parent_flags));
 
+#if HPSS_MAJOR_VERSION < 7
    select_flags = API_AddRegisterValues(cast64m(0), 
 					CORE_ATTR_TYPE,
 					CORE_ATTR_FILESET_ID,
@@ -347,6 +353,24 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 					CORE_ATTR_DM_HANDLE_LENGTH,
 					CORE_ATTR_COS_ID,
 					-1);
+#else
+   select_flags = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_TYPE,
+                                        CORE_ATTR_UID,
+                                        CORE_ATTR_GID,
+                                        CORE_ATTR_ACCOUNT,
+                                        CORE_ATTR_REALM_ID,
+                                        CORE_ATTR_COS_ID,
+                                        CORE_ATTR_USER_PERMS,
+                                        CORE_ATTR_GROUP_PERMS,
+                                        CORE_ATTR_OTHER_PERMS,
+                                        CORE_ATTR_MODE_PERMS,
+                                        -1);
+
+   parent_flags = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_COS_ID,
+                                        -1);
+#endif
      
    /*
     * Zero the output structures
@@ -372,8 +396,12 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 			    &attr,
 			    NULL,
 			    &attr_parent,
+#if HPSS_MAJOR_VERSION < 7
 			    &ta,
 			    path_object,
+#else
+                            NULL,
+#endif
 			    NULL);
      
    if(error != 0)
@@ -426,15 +454,16 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 	 return(error);
       }
         
+#if ( HPSS_MAJOR_VERSION < 7 )
       /*
        *  Determine whether to call the dmg or ns based on whether the
        *  parent directory is dmap managed.
        */
         
-#ifdef _USE_HPSS_51      
+#if ( HPSS_MAJOR_VERSION == 5 )
       call_type = API_DetermineCall(attr_parent.FilesetType,
 				    (long *) &error);
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif ( HPSS_MAJOR_VERSION == 6 )
       call_type = API_DetermineCall(attr_parent.FilesetType, &error);
 #endif
         
@@ -657,6 +686,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 			   function_name);
 #endif
       } /* end "if call_type == DMG" */
+#endif /* end of version < 7 */
    
       if (error == 0)
       {
@@ -739,7 +769,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 		   * attributes and the user's current session account.
 		   */
          
-#ifdef _USE_HPSS_51                    
+#if HPSS_MAJOR_VERSION == 5
 		  error = av_cli_ValidateChown(ls_map.SiteId,
 					       RequestID,
 					       attr.CellId,
@@ -751,7 +781,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 					       attr.GID,
 					       cur_acct_code,
 					       &acct_code);
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622) 
+#elif (HPSS_MAJOR_VERSION == 6)||(HPSS_MAJOR_VERSION == 7)
 		  error = av_cli_ValidateChown(ls_map.SiteId,
 					       RequestID,
 					       attr.RealmId,
@@ -809,7 +839,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 		* Validate that the account code can be changed.
 		*/
 
-#ifdef _USE_HPSS_51                    
+#if HPSS_MAJOR_VERSION == 5
 	       error = av_cli_ValidateChacct(ls_map.SiteId,
 					     RequestID,
 					     Ucred->DCECellId,
@@ -820,7 +850,7 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
 					     attr.Account,
 					     AttrIn->Attrs.Account,
 					     &acct_code);
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622 )             
+#elif (HPSS_MAJOR_VERSION == 6)||(HPSS_MAJOR_VERSION == 7)
 	       error = av_cli_ValidateChacct(ls_map.SiteId,
 					     RequestID,
 					     Ucred->RealmId,
@@ -887,3 +917,5 @@ hpss_fileattr_t     *AttrOut)       /* OUT - attributes after change */
    return(error);
 
 }
+
+#endif /* hpss 7+ */
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_mkdir.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_mkdir.c
index f9ef418..1fc1007 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_mkdir.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_mkdir.c
@@ -186,10 +186,12 @@ TYPE_CRED_HPSS       *Ucred,
 ns_ObjHandle_t        *RetObjHandle,
 hpss_Attrs_t          *RetAttrs)
 {
+#if HPSS_MAJOR_VERSION < 7
     call_type_t       call_type;
-#ifdef _USE_HPSS_51      
+#endif
+#if HPSS_MAJOR_VERSION == 5
    volatile long	error = 0;        /* return error */
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622 )
+#else
    signed32 	error = 0;        /* return error */
 #endif
     static char       function_name[] = "HPSSFSAL_Common_Mkdir";
@@ -265,11 +267,13 @@ hpss_Attrs_t          *RetAttrs)
     
     select_flags = API_AddRegisterValues(cast64m(0),
 					 CORE_ATTR_ACCOUNT,
+#if HPSS_MAJOR_VERSION < 7
 					 CORE_ATTR_FILESET_ID,
 					 CORE_ATTR_FILESET_TYPE,
 					 CORE_ATTR_GATEWAY_UUID,
 					 CORE_ATTR_DM_HANDLE,
 					 CORE_ATTR_DM_HANDLE_LENGTH,
+#endif
 					 -1);
     
     error = API_TraversePath(ThreadContext,
@@ -286,7 +290,9 @@ hpss_Attrs_t          *RetAttrs)
 			     API_NULL_CWD_STACK,
 			     &objhandle_parent,
 			     &attr_parent,
+#if HPSS_MAJOR_VERSION < 7
 			     NULL,
+#endif
 			     NULL,
 			     NULL,
 			     NULL,
@@ -338,7 +344,7 @@ hpss_Attrs_t          *RetAttrs)
 	  /*
 	   * Validate the account.
 	   */
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
 	  error = av_cli_ValidateCreate(siteId,
 					rqstid,
 					Ucred->DCECellId,
@@ -347,7 +353,7 @@ hpss_Attrs_t          *RetAttrs)
 					temp_acct_code,
 					attr_parent.Account,
 					&new_acct_code);
-#elif defined (_USE_HPSS_62) || defined( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
 	  error = av_cli_ValidateCreate(siteId,
 					rqstid,
 					Ucred->RealmId,
@@ -372,23 +378,25 @@ hpss_Attrs_t          *RetAttrs)
     if (error == 0)
     {
 
+#if HPSS_MAJOR_VERSION < 7
+
        /*
 	* Do we call the dmap gateway or the name server?
 	*/
     
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
        call_type = API_DetermineCall(attr_parent.FilesetType,
 				     (long *) &error);
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION == 6
        call_type = API_DetermineCall(attr_parent.FilesetType, &error);
-#endif       
+#endif
            
        switch(call_type) 
        {
     
 	  case API_CALL_DMG:
 
-#if defined ( API_DMAP_SUPPORT ) && !defined (API_DMAP_GATEWAY )
+#if defined ( API_DMAP_SUPPORT ) && !defined ( API_DMAP_GATEWAY )
 	     /*
                  * Call the dmap gateway to create the file.  This will
                  * have the side effect that the dmap will call us to
@@ -481,6 +489,8 @@ hpss_Attrs_t          *RetAttrs)
     
 	  case API_CALL_HPSS:
 
+#endif /* HPSS < 7 */
+
 	     /*
       	         * Set up the parameters for the new directory.
 	         */
@@ -550,6 +560,8 @@ hpss_Attrs_t          *RetAttrs)
 			   SOFTWARE_ERROR,NONE,
 			   API_REQUEST_ERROR, error);
 	     }
+
+#if HPSS_MAJOR_VERSION < 7
 	     break;
     
             default:
@@ -559,6 +571,7 @@ hpss_Attrs_t          *RetAttrs)
 				 function_name);
                break;
             } /* end switch */
+#endif
          
     } /* end (if error == 0) */
 
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_open.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_open.c
index 41ead30..6634e69 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_open.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_open.c
@@ -40,15 +40,26 @@ static int HPSSFSAL_Common_Open(
     ns_ObjHandle_t		*ObjHandle,	/* IN - parent object handle */
     char			*Path,		/* IN - file name */
     api_cwd_stack_t         *CwdStack,      /* IN - cwd stack */
-    int			Oflag,		/* IN - open flags */
+#if HPSS_MAJOR_VERSION < 7
+    int				Oflag,		/* IN - open flags */
     mode_t			Mode,		/* IN - create mode */
     TYPE_CRED_HPSS		*Ucred,		/* IN - user credentials */
+#else
+    TYPE_CRED_HPSS		*Ucred,		/* IN - user credentials */
+    int				Oflag,		/* IN - open flags */
+    mode_t			Mode,		/* IN - create mode */
+#endif
     hpss_cos_hints_t	*HintsIn,	/* IN - creation hints */
     hpss_cos_priorities_t	*HintsPri,	/* IN - hint priorities */
     hpss_cos_hints_t	*HintsOut,	/* OUT - actual hint values used */
     hpss_Attrs_t		*AttrsOut,	/* OUT - returned attributes */
-    ns_ObjHandle_t		*HandleOut,	/* OUT - returned handle */
-    TYPE_TOKEN_HPSS		*AuthzTicket);	/* OUT - returned authorization */
+    ns_ObjHandle_t		*HandleOut	/* OUT - returned handle */
+#if HPSS_MAJOR_VERSION < 7
+    , TYPE_TOKEN_HPSS		*AuthzTicket	/* OUT - returned authorization */
+#elif HPSS_LEVEL >= 730
+    , int                         LoopCount     /* IN  - Recursion Counter */
+#endif
+    );
 
 static int HPSSFSAL_Common_Create(
     apithrdstate_t		*ThreadContext,	/* IN - thread context */
@@ -60,16 +71,21 @@ static int HPSSFSAL_Common_Create(
     TYPE_CRED_HPSS		*Ucred,		/* IN - user credentials */
     hpss_cos_hints_t	*HintsIn,	/* IN - creation hints */
     hpss_cos_priorities_t	*HintsPri,	/* IN - hint priorities */
+#if HPSS_MAJOR_VERSION < 7
     TYPE_TOKEN_HPSS		*AuthzIn,	/* IN - authorization for bfs */
     unsigned32	    	CreateFlags,	/* IN - Bfs flags to set on create */
     ns_ObjHandle_t          *ParentHandle,  /* IN - parent handle */
     hpss_Attrs_t            *ParentAttrs,   /* IN - parent attributes */
     api_dmap_attrs_t        *DMAttrsOut,    /* OUT - DMAP attributes */
     unsigned32              *FilesetCOS,    /* OUT - Fileset COS */
+#endif
     hpss_cos_hints_t	*HintsOut,	/* OUT - actual hint values used */
     hpss_Attrs_t		*AttrsOut,	/* OUT - returned attributes */
-    ns_ObjHandle_t		*HandleOut,	/* OUT - returned handle */
-    TYPE_TOKEN_HPSS		*AuthzOut);	/* OUT - returned authorization */
+    ns_ObjHandle_t		*HandleOut	/* OUT - returned handle */
+#if HPSS_MAJOR_VERSION < 7
+    ,TYPE_TOKEN_HPSS		*AuthzOut /* OUT - returned authorization */
+#endif
+);
 
 static int HPSSFSAL_Common_Open_Bitfile(
     apithrdstate_t	        *ThreadContext,	/* IN - thread context */
@@ -78,20 +94,59 @@ static int HPSSFSAL_Common_Open_Bitfile(
     ns_ObjHandle_t	        *ObjHandlePtr,	/* IN - NS object handle */
     TYPE_CRED_HPSS	        *Ucred,		/* IN - user credentials */
     int		        Oflag,		/* IN - open flags */
+#if HPSS_MAJOR_VERSION < 7
     TYPE_TOKEN_HPSS	        *AuthzTicket,	/* IN - client authorization */
     api_dmap_attrs_t        *DMAttrs,       /* IN - DMAP attributes */
+#endif
     unsigned32              FilesetCOS,     /* IN - fileset containing file */
     filetable_t	        *FTPtr,		/* IN - file table pointer */
     int                     Fildes
-#if defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#if HPSS_MAJOR_VERSION >= 6
     , hpss_cos_hints_t	*HintsOut /* OUT - actual hint values used */
 #endif 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
     , u_signed64              *SegmentSize /* OUT - current storage segment size */
 #endif
     );        /* IN - file table index */
 
 
+#if HPSS_LEVEL >= 711
+static int 
+HPSSFSAL_Common_Open_File(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ParentHandle,  /* IN - parent object handle */
+unsigned32     		FilesetCOS,     /* IN - file set COS */
+char                    *Path,          /* IN - Path to file to be opened */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+acct_rec_t              *ParentAcct,    /* IN - parent account code */
+int                     Oflag,          /* IN - open flags */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut );
+
+static int 
+HPSSFSAL_Common_Create_File(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ParentHandle,  /* IN - parent object handle */
+char                    *Path,          /* IN - Path to file to be opened */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+acct_rec_t              *ParentAcct,    /* IN - parent account code */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut );
+
+#endif
+
+
+
 
 /*============================================================================
  *
@@ -224,15 +279,26 @@ HPSSFSAL_OpenHandle
 		       ObjHandle,
 		       Path,
 		       API_NULL_CWD_STACK,
+#if HPSS_MAJOR_VERSION < 7
 		       Oflag,
 		       Mode,
 		       ucred_ptr,
+#else
+		       ucred_ptr,
+		       Oflag,
+		       Mode,
+#endif
 		       HintsIn,
 		       HintsPri,
 		       HintsOut,
 		       AttrsOut,
-		       HandleOut,
-		       AuthzTicket);
+		       HandleOut
+#if HPSS_MAJOR_VERSION < 7
+		       , AuthzTicket
+#elif HPSS_LEVEL >= 730
+		       , 0
+#endif
+		       );
 			 
    API_RETURN(error);
 }
@@ -386,6 +452,42 @@ HPSSFSAL_CreateHandle
    else
       ucred_ptr = Ucred;
 
+#if HPSS_MAJOR_VERSION >= 7
+   /*
+    *  Call Common_Create() to perform the majority of the common open
+    *  processing.
+    */
+
+   error = HPSSFSAL_Common_Create(threadcontext,
+                         rqstid,
+                         ObjHandle,
+                         Path,
+                         API_NULL_CWD_STACK,
+                         Mode,
+                         ucred_ptr,
+                         HintsIn,
+                         HintsPri,
+                         HintsOut,
+                         AttrsOut,
+			 HandleOut);
+
+   if (error != 0)
+   {
+      API_DEBUG_FPRINTF(DebugFile, &rqstid,
+                        "%s: Common_Create failed, error=%d\n",
+                        function_name, error);
+   }
+
+   /*
+    * Gatekeeper retries have timed-out.
+    */
+
+   if (error == HPSS_ERETRY)
+      error = -EAGAIN;
+
+
+   API_RETURN(error);
+#else
 
    /*
     *  Need to see if the file already exists, and if not,
@@ -489,6 +591,7 @@ HPSSFSAL_CreateHandle
 
 
    API_RETURN(error);
+#endif /* version < 7 */
 }
 
 
@@ -540,6 +643,8 @@ HPSSFSAL_CreateHandle
  *
  *-------------------------------------------------------------------------*/
 
+#if HPSS_MAJOR_VERSION < 7
+
 static int
 HPSSFSAL_Common_Open
 (apithrdstate_t		*ThreadContext,	/* IN - thread context */
@@ -560,9 +665,9 @@ HPSSFSAL_Common_Open
    static char		function_name[] = "HPSSFSAL_Common_Open";
    int			fildes;         /* File descriptor */
    int			checkflag;      /* Oflag check variable */
-#ifdef _USE_HPSS_51      
+#if HPSS_MAJOR_VERSION == 5
    volatile long	error = 0;        /* return error */
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#else
    signed32 	error = 0;        /* return error */
 #endif
    retry_cb_t           retry_cb;       /* retry control block */
@@ -845,8 +950,8 @@ HPSSFSAL_Common_Open
      file_attrs = attr;
 	 fileset_cos = parent_attr.COSId;
      
-#if ( defined(_USE_HPSS_51) && defined(API_DMAP_SUPPORT) ) \
-    || ( (defined(_USE_HPSS_62)||defined( _USE_HPSS_622)) && defined(API_DMAP_SUPPORT) && defined( API_MIRRORED_FILESETS ) )
+#if ( (HPSS_MAJOR_VERSION == 5) && defined(API_DMAP_SUPPORT) ) \
+    || ( (HPSS_MAJOR_VERSION == 6) && defined(API_DMAP_SUPPORT) && defined( API_MIRRORED_FILESETS ) )
      
 	 /*
 	  * If DMAPI support is enabled, then get the
@@ -907,10 +1012,10 @@ HPSSFSAL_Common_Open
 			      fileset_cos,
 			      ftptr,
 			      fildes
-#if defined(_USE_HPSS_62) || defined(_USE_HPSS_622)
+#if HPSS_MAJOR_VERSION == 6
                   ,HintsOut
 #endif
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
 		  ,NULL
 #endif
                   );
@@ -965,6 +1070,423 @@ HPSSFSAL_Common_Open
    return(fildes);
 }
 
+#elif (HPSS_LEVEL == 710) || (HPSS_LEVEL == 711)
+static int
+HPSSFSAL_Common_Open(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ObjHandle,     /* IN - object handle */
+char                    *Path,          /* IN - Path to file to be opened */
+api_cwd_stack_t         *CwdStack,      /* IN - cwd stack */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+int                     Oflag,          /* IN - open flags */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut)     /* OUT - returned handle */
+{
+   static char            function_name[] = "HPSSFSAL_Common_Open";
+   volatile long          error = 0;             /* return error */
+   char                   *file;                 /* file name to create */
+   char                   *parentpath;           /* path to file */
+   ns_ObjHandle_t         hndl;                  /* parent handle */
+   hpss_AttrBits_t        attr_bits;             /* parent attributes bits*/
+   hpss_Attrs_t           attrs;                 /* parent attributes */
+   ns_ObjHandle_t         *hndl_ptr = ObjHandle; /* parent handle pointer */
+   acct_rec_t             *pacct_ptr = NULL;     /* parent account pointer */
+
+
+
+   /*
+    * We want the last component of the supplied path.
+    */
+
+   file = (char *)malloc(HPSS_MAX_FILE_NAME);
+   if ( file == NULL )
+      return(-ENOMEM);
+
+   parentpath = (char *)malloc(HPSS_MAX_PATH_NAME);
+   if ( parentpath == NULL )
+   {
+      free(file);
+      return(-ENOMEM);
+   }
+
+
+   /*
+    * Divide the path into a path and object
+    */
+
+   if((error = API_DivideFilePath(Path, parentpath, file)) != 0)
+   {
+      free(file);
+      free(parentpath);
+      return(error);
+   }
+
+   /*
+    * Get parent's COS ID -- we always need this so we set the
+    * FilesetCOS correctly, which allows us to do changecos.
+    */ 
+
+
+      memset(&attrs,'\0',sizeof(attrs));
+
+      if(API_PATH_NEEDS_TRAVERSAL(parentpath)) {
+      /*
+       * If there is a path provided then, then lookup
+       * the parent handle and account
+       */
+
+      attr_bits = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_ACCOUNT,
+                                        CORE_ATTR_TYPE,
+                                        CORE_ATTR_COS_ID,
+                                        -1);
+      memset(&hndl,'\0',sizeof(hndl));
+
+
+      error = API_TraversePath(ThreadContext,
+                               RequestID,
+                               Ucred, 
+                               ObjHandle,
+                               parentpath,
+                               CwdStack,
+                               API_CHASE_ALL,
+                               0,
+                               0,
+                               attr_bits,
+                               cast64m(0),
+                               API_NULL_CWD_STACK,
+                               &hndl,
+                               &attrs,
+                               (ns_ObjHandle *)NULL,
+                               (hpss_Attrs_t *)NULL,
+                               NULL,
+                               NULL);
+      if(error == 0)
+      {
+         if ( attrs.Type != NS_OBJECT_TYPE_DIRECTORY )
+            error = -ENOTDIR;
+         else 
+         {
+            hndl_ptr = &hndl;
+            pacct_ptr = &attrs.Account;
+         }
+      }
+   }
+   else if(API_PATH_IS_ROOT(parentpath))
+   {
+      /* If needed, use the root handle */
+      error = API_InitRootHandle(ThreadContext,RequestID,&hndl_ptr);
+   }
+   else {
+      /*
+       * Otherwise , just look up the COS Id.
+       */
+      attr_bits = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_COS_ID,
+                                        -1);
+
+      error = API_TraversePath(ThreadContext,
+                               RequestID,
+                               Ucred, 
+                               ObjHandle,
+                               parentpath,
+                               CwdStack,
+                               API_CHASE_ALL,
+                               0,
+                               0,
+                               attr_bits,
+                               cast64m(0),
+                               API_NULL_CWD_STACK,
+                               &hndl,
+                               &attrs,
+                               (ns_ObjHandle *)NULL,
+                               (hpss_Attrs_t *)NULL,
+                               NULL,
+                               NULL);
+   }
+
+   if(error == 0) 
+   {
+      error = HPSSFSAL_Common_Open_File(ThreadContext,
+                               RequestID,
+                               hndl_ptr,
+			       attrs.COSId,
+                               file,
+                               Ucred,
+                               pacct_ptr,
+                               Oflag,
+                               Mode,
+                               HintsIn,
+                               HintsPri,
+                               HintsOut,
+                               AttrsOut,
+			       HandleOut);
+   }
+
+
+   free(file);
+   free(parentpath);
+
+   return(error);
+}
+
+
+#elif HPSS_LEVEL == 730
+static int
+HPSSFSAL_Common_Open(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ObjHandle,     /* IN - object handle */
+char                    *Path,          /* IN - Path to file to be opened */
+api_cwd_stack_t         *CwdStack,      /* IN - cwd stack */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+int                     Oflag,          /* IN - open flags */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut,     /* OUT - returned handle */
+int                     LoopCount)      /* IN  - Recursion Counter */
+{
+   static char            function_name[] = "Common_Open";
+   volatile long          error = 0;             /* return error */
+   char                   *file;                 /* file name to create */
+   char                   *parentpath;           /* path to file */
+   ns_ObjHandle_t         hndl;                  /* parent handle */
+   hpss_AttrBits_t        attr_bits;             /* parent attributes bits*/
+   hpss_Attrs_t           attrs;                 /* parent attributes */
+   ns_ObjHandle_t         *hndl_ptr = ObjHandle; /* parent handle pointer */
+   acct_rec_t             *pacct_ptr = NULL;     /* parent account pointer */
+
+
+
+   /*
+    * We want the last component of the supplied path.
+    */
+
+   file = (char *)malloc(HPSS_MAX_FILE_NAME);
+   if ( file == NULL )
+      return(-ENOMEM);
+
+   parentpath = (char *)malloc(HPSS_MAX_PATH_NAME);
+   if ( parentpath == NULL )
+   {
+      free(file);
+      return(-ENOMEM);
+   }
+
+
+   /*
+    * Divide the path into a path and object
+    */
+
+   if((error = API_DivideFilePath(Path, parentpath, file)) != 0)
+   {
+      free(file);
+      free(parentpath);
+      return(error);
+   }
+
+   /*
+    * Get parent's COS ID -- we always need this so we set the
+    * FilesetCOS correctly, which allows us to do changecos.
+    */ 
+
+
+      memset(&attrs,'\0',sizeof(attrs));
+
+      if(API_PATH_NEEDS_TRAVERSAL(parentpath)) {
+      /*
+       * If there is a path provided then, then lookup
+       * the parent handle and account
+       */
+
+      attr_bits = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_ACCOUNT,
+                                        CORE_ATTR_TYPE,
+                                        CORE_ATTR_COS_ID,
+                                        -1);
+      memset(&hndl,'\0',sizeof(hndl));
+
+
+      error = API_TraversePath(ThreadContext,
+                               RequestID,
+                               Ucred, 
+                               ObjHandle,
+                               parentpath,
+                               CwdStack,
+                               API_CHASE_ALL,
+                               0,
+                               0,
+                               attr_bits,
+                               cast64m(0),
+                               API_NULL_CWD_STACK,
+                               &hndl,
+                               &attrs,
+                               (ns_ObjHandle *)NULL,
+                               (hpss_Attrs_t *)NULL,
+                               NULL,
+                               NULL);
+      if(error == 0)
+      {
+         if ( attrs.Type != NS_OBJECT_TYPE_DIRECTORY )
+            error = -ENOTDIR;
+         else 
+         {
+            hndl_ptr = &hndl;
+            pacct_ptr = &attrs.Account;
+         }
+      }
+   }
+   else if(API_PATH_IS_ROOT(parentpath))
+   {
+      /* If needed, use the root handle */
+      error = API_InitRootHandle(ThreadContext,RequestID,&hndl_ptr);
+   }
+   else {
+      /* Get the Fileset COS from the ThreadState */
+      attrs.COSId = ThreadContext->CwdState.FilesetCOS;
+   }
+
+   if(error == 0) 
+   {
+      error = HPSSFSAL_Common_Open_File(ThreadContext,
+                               RequestID,
+                               hndl_ptr,
+			       attrs.COSId,
+                               file,
+                               Ucred,
+                               pacct_ptr,
+                               Oflag,
+                               Mode,
+                               HintsIn,
+                               HintsPri,
+                               HintsOut,
+                               AttrsOut,
+			       HandleOut);
+      if(error == HPSS_EISDIR)
+      {
+        /*
+         * So we get this error back saying this was a directory.
+         * That means that either 1) this file is a directory, or
+         * 2) less obvious, this file is a symbolic link. Let's find out
+         * which case we're in.
+         */
+         attr_bits = API_AddRegisterValues(cast64m(0),
+                                           CORE_ATTR_TYPE,
+                                           -1);
+ 
+         error = API_core_GetAttrs(ThreadContext,
+                                   RequestID,
+                                   Ucred,
+                                   hndl_ptr,
+                                   file,
+                                   CORE_GETATTRS_DONT_BACKUP,
+                                   0,
+                                   0,
+                                   attr_bits,
+                                   cast64m(0),
+                                   NULL,
+                                   &attrs,
+                                   NULL,
+                                   NULL,
+                                   NULL,
+                                   NULL,
+                                   NULL);
+
+         if(error != 0)
+         {
+            free(file);
+            free(parentpath);
+            return(-EISDIR);
+         }
+         if(attrs.Type == NS_OBJECT_TYPE_SYM_LINK)
+         {
+            char linkpath[HPSS_MAX_PATH_NAME];
+
+           /*
+            * Following symlinks here makes this recursive. To avoid 
+            * symlink loops, we will restrict the number of tries to the
+            * POSIX max number of symlinks which can be traversed during 
+            * pathname resolution.
+            */
+            if(LoopCount >= HPSS_SYMLOOP_MAX)
+            {
+               API_DEBUG_FPRINTF(DebugFile, &RequestID,
+                                 "Too many levels of symlinks."
+                                 " path =%s, errno=%d\n",file, -ELOOP);
+               return (-ELOOP);
+            }
+           /*
+            * Read the link contents so we know what we should try to open
+            * next.
+            */
+            error = hpss_ReadlinkHandle(hndl_ptr,
+                                        file,
+                                        linkpath,
+                                        HPSS_MAX_PATH_NAME,
+                                        Ucred);
+
+           /*
+            * ReadlinkHandle returns the number of
+            * bytes in linkpath on success, so we just need error to be
+            * positive.
+            */
+            if(error > 0)
+            {
+               /*
+                * Okay, so we tracked the symlink back to its humble
+                * file origins and now we're ready to try opening it again
+                * with the assurance that its not a symlink anymore.
+                * This time, its for real.
+                */
+
+                error = HPSSFSAL_Common_Open(ThreadContext,
+                                    RequestID,
+                                    hndl_ptr,
+                                    linkpath,
+                                    CwdStack,
+                                    Ucred,
+                                    Oflag,
+                                    Mode,
+                                    HintsIn,
+                                    HintsPri,
+                                    HintsOut,
+                                    AttrsOut,
+                                    HandleOut,
+                                    ++LoopCount);
+               
+
+            } /* error from ReadlinkHandle > 0 */
+            else
+            {
+                 API_DEBUG_FPRINTF(DebugFile, &RequestID,
+                                   "Could not get path for symlink."
+                                   " path =%s, errno=%d\n", file, -error);
+            }
+         } /* object is a sym link */
+         else
+         {
+            error = -EISDIR;
+         }
+      } /* error == -EISDIR */
+   } /* No error from traverse path */
+
+
+   free(file);
+   free(parentpath);
+
+   return(error);
+}
+
+#endif
+
 
 /*============================================================================
  *
@@ -1019,6 +1541,8 @@ HPSSFSAL_Common_Open
  *
  *-------------------------------------------------------------------------*/
 
+#if HPSS_MAJOR_VERSION < 7
+
 static int
 HPSSFSAL_Common_Create
 (apithrdstate_t		*ThreadContext,	/* IN - thread context */
@@ -1114,7 +1638,7 @@ HPSSFSAL_Common_Create
       return(error);
    }
 
-#ifdef _USE_HPSS_51      
+#if HPSS_MAJOR_VERSION == 5
    error = av_cli_ValidateCreate(site_id,
 				 RequestID,
 				 Ucred->DCECellId,
@@ -1123,7 +1647,7 @@ HPSSFSAL_Common_Create
 				 cur_acct_code,
 				 ParentAttrs->Account,
 				 &new_acct_code);
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif HPSS_MAJOR_VERSION >= 6
    error = av_cli_ValidateCreate(site_id,
 				 RequestID,
 				 Ucred->RealmId,
@@ -1161,9 +1685,9 @@ HPSSFSAL_Common_Create
     * this is (sync or backup).
     */
 
-#ifdef _USE_HPSS_51      
+#if HPSS_MAJOR_VERSION == 5
    call_type = API_DetermineCall(dmap_attrs.FilesetType, &error);
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif HPSS_MAJOR_VERSION == 6
    call_type = API_DetermineCall(dmap_attrs.FilesetType, (signed32 *)&error);
 #endif
 
@@ -1175,8 +1699,8 @@ HPSSFSAL_Common_Create
        * trying to create a object in a DMAP file set.
        */
 
-#if ( defined(_USE_HPSS_51) && defined(API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) )\
-     || ( (defined(_USE_HPSS_62)||defined( _USE_HPSS_622)) && defined(API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY)  && defined( API_MIRRORED_FILESETS ) )
+#if ( (HPSS_MAJOR_VERSION == 5) && defined(API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) )\
+     || ( (HPSS_MAJOR_VERSION == 6) && defined(API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY)  && defined( API_MIRRORED_FILESETS ) )
 
       /*
        * The mode should have the regular file bit set and
@@ -1493,6 +2017,142 @@ HPSSFSAL_Common_Create
    free(file);
    return(error);
 }
+#else /* from version 7 */
+
+static int
+HPSSFSAL_Common_Create(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ObjHandle,     /* IN - parent object handle */
+char                    *Path,          /* IN - file name */
+api_cwd_stack_t         *CwdStack,      /* IN - cwd stack */
+mode_t                  Mode,           /* IN - create mode */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+hpss_cos_hints_t        *HintsIn,       /* IN - creation hints */
+hpss_cos_priorities_t   *HintsPri,      /* IN - hint priorities */
+hpss_cos_hints_t        *HintsOut,      /* OUT - actual hint values used */
+hpss_Attrs_t		*AttrsOut,	/* OUT - returned attributes */
+ns_ObjHandle_t		*HandleOut)	/* OUT - returned handle */
+{
+   static char            function_name[] = "HPSSFSAL_Common_Create";
+   volatile long          error = 0;              /* return error */
+   char                   *file;                  /* file name to create */
+   char                   *parentpath;            /* path to file */
+   ns_ObjHandle_t         hndl;                   /* parent handle */
+   ns_ObjHandle_t         *hndl_ptr = ObjHandle;  /* parent handle pointer */
+   hpss_AttrBits_t        attr_bits;              /* parent attributes bits*/
+   hpss_Attrs_t           attrs;                  /* parent attributes */
+   acct_rec_t             *pacct_ptr = NULL;      /* parent account code pointer */
+
+
+   /*
+    * We want the last component of the supplied path.
+    */
+
+   file = (char *)malloc(HPSS_MAX_FILE_NAME);
+   if ( file == NULL )
+      return(-ENOMEM);
+
+   parentpath = (char *)malloc(HPSS_MAX_PATH_NAME);
+   if ( parentpath == NULL )
+   {
+      free(file);
+      return(-ENOMEM);
+   }
+
+   /*
+    * Divide the path into a path and object
+    */
+
+   if((error = API_DivideFilePath(Path, parentpath, file)) != 0)
+   {
+      free(file);
+      free(parentpath);
+      return(error);
+   }
+
+   /*
+    * Traverse the path to the parent directory, if needed
+    */
+
+   if(API_PATH_NEEDS_TRAVERSAL(parentpath))
+   {
+
+      /*
+       * If there is a path provided then, then lookup
+       * the parent handle and account
+       */
+
+      attr_bits = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_ACCOUNT,
+                                        CORE_ATTR_TYPE,
+					CORE_ATTR_COS_ID,
+                                        -1);
+
+      memset(&attrs,'\0',sizeof(attrs));
+      memset(&hndl,'\0',sizeof(hndl));
+
+      error = API_TraversePath(ThreadContext,
+                               RequestID,
+                               Ucred, 
+                               ObjHandle,
+                               parentpath,
+                               CwdStack,
+                               API_CHASE_ALL,
+                               0,
+                               0,
+                               attr_bits,
+                               cast64m(0),
+                               API_NULL_CWD_STACK,
+                               &hndl,
+                               &attrs,
+                               (ns_ObjHandle *)NULL,
+                               (hpss_Attrs_t *)NULL,
+                               NULL,
+                               NULL);
+      if(error == 0)
+      {
+
+         if ( attrs.Type != NS_OBJECT_TYPE_DIRECTORY )
+            error = -ENOTDIR;
+         else 
+         {
+            hndl_ptr = &hndl;
+            pacct_ptr = &attrs.Account;
+         }
+      }
+   }
+   else if(API_PATH_IS_ROOT(parentpath))
+   {
+      /* If needed, use the root handle */
+      error = API_InitRootHandle(ThreadContext,RequestID,&hndl_ptr);
+   }
+
+   if(error == 0) 
+   {
+      error = HPSSFSAL_Common_Create_File(ThreadContext,
+                                 RequestID,
+                                 hndl_ptr,
+                                 file,
+                                 Ucred,
+                                 pacct_ptr,
+                                 Mode,
+                                 HintsIn,
+                                 HintsPri,
+                                 HintsOut,
+                                 AttrsOut,
+				 HandleOut);
+   }
+
+
+   free(file);
+   free(parentpath);
+
+   return(error);
+
+}
+
+#endif
 
 
 /*============================================================================
@@ -1547,15 +2207,17 @@ hpssoid_t	        *BitFileID,	/* IN - bitfile id */
 ns_ObjHandle_t	        *ObjHandlePtr,	/* IN - NS object handle */
 TYPE_CRED_HPSS	        *Ucred,		/* IN - user credentials */
 int		        Oflag,		/* IN - open flags */
+#if HPSS_MAJOR_VERSION < 7
 TYPE_TOKEN_HPSS	        *AuthzTicket,	/* IN - client authorization */
 api_dmap_attrs_t        *DMAttrs,       /* IN - DMAP attributes */
+#endif
 unsigned32              FilesetCOS,     /* IN - fileset containing file */
 filetable_t	        *FTPtr,		/* IN - file table pointer */
 int                     Fildes         /* IN - file table index */
-#if defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#if HPSS_MAJOR_VERSION >= 6
   , hpss_cos_hints_t	*HintsOut /* OUT - actual hint values used */
 #endif
-#ifdef _USE_HPSS_622 
+#if HPSS_LEVEL >= 622
   , u_signed64          *SegmentSize /* OUT - current storage segment size */
 #endif
 )
@@ -1570,15 +2232,15 @@ int                     Fildes         /* IN - file table index */
    openfiletable_t      *open_ftptr;   /* open file table entry */
    open_bf_desc_t       *open_bfdesc_ptr; /* open bitfile descriptor */
 
-#if defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622)
+#if HPSS_MAJOR_VERSION >= 6
    hpss_cos_md_t        cos_info,      /* COS metadata values */
                         *cos_info_ptr = NULL;  
    hpss_sclass_md_t     sclass_info,   /* SClass metadata values */
                         *sclass_info_ptr = NULL;
 #endif
    
-#if (defined(_USE_HPSS_51) && defined (API_DMAP_SUPPORT)	&& !defined(API_DMAP_GATEWAY))\
-   ||((defined(_USE_HPSS_62)||defined(_USE_HPSS_622)) && defined (API_DMAP_SUPPORT)	&& !defined(API_DMAP_GATEWAY) &&  defined ( API_MIRRORED_FILESETS ))
+#if ((HPSS_MAJOR_VERSION == 5) && defined (API_DMAP_SUPPORT)	&& !defined(API_DMAP_GATEWAY))\
+   ||( (HPSS_MAJOR_VERSION == 6) && defined (API_DMAP_SUPPORT)	&& !defined(API_DMAP_GATEWAY) &&  defined ( API_MIRRORED_FILESETS ))
    dmg_object_attrs_t   dmg_attr;      /* DMAP attributes */
    u_signed64           dmg_attr_bits; /* DMAP attributes bits */
    u_signed64           current_size;  /* current size of the file */
@@ -1597,7 +2259,7 @@ int                     Fildes         /* IN - file table index */
     * Translate the Oflag into BFS open flags.
     */
 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
    if(Oflag & HPSS_O_STAGE_ASYNC && Oflag & HPSS_O_STAGE_BKGRD)
    {
       API_DEBUG_FPRINTF(DebugFile, &RequestID,
@@ -1624,7 +2286,7 @@ int                     Fildes         /* IN - file table index */
    if(Oflag & O_TRUNC)  bfsopenflags |= BFS_OPEN_TRUNCATE;
    if(Oflag & O_NONBLOCK)  bfsopenflags |= BFS_OPEN_NO_STAGE;
 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
    if(Oflag & HPSS_O_STAGE_ASYNC)
    {
       bfsopenflags |= (BFS_OPEN_STAGE_ASYNC);
@@ -1652,14 +2314,14 @@ int                     Fildes         /* IN - file table index */
 #endif
 
 
-#ifdef _USE_HPSS_62
+#if HPSS_LEVEL == 620
    /* have we already gotten hints data? */ 
    if(HintsOut != NULL && HintsOut->COSId == 0) 
    {
       cos_info_ptr = &cos_info;
       sclass_info_ptr = &sclass_info;
    }   
-#elif defined( _USE_HPSS_622 )
+#elif HPSS_LEVEL == 622
    /* have we already gotten hints data? */
    if((HintsOut != NULL && HintsOut->COSId == 0)
       ||
@@ -1668,6 +2330,13 @@ int                     Fildes         /* IN - file table index */
       cos_info_ptr = &cos_info;
       sclass_info_ptr = &sclass_info;
    }
+#elif HPSS_MAJOR_VERSION == 7
+   /* have we already gotten hints data? */
+   if(HintsOut != NULL  || SegmentSize != NULL)
+   {
+      cos_info_ptr = &cos_info;
+      sclass_info_ptr = &sclass_info;
+   }
 #endif   
 
 
@@ -1682,14 +2351,14 @@ int                     Fildes         /* IN - file table index */
    /*
     *  Now try to issue an open the file in the BFS.
     */
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
    error = API_core_OpenFile(ThreadContext,
 			     RequestID,
 			     BitFileID,
 			     *AuthzTicket,
 			     bfsopenflags,
 			     &bfhandle);
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION == 6
    error = API_core_OpenFile(ThreadContext,
 			     RequestID,
 			     BitFileID,
@@ -1698,10 +2367,19 @@ int                     Fildes         /* IN - file table index */
                  	     cos_info_ptr,
                  	     sclass_info_ptr,
 			     &bfhandle);
+#elif HPSS_MAJOR_VERSION == 7
+   error = API_core_OpenBitfile(ThreadContext,
+                                RequestID,
+                                Ucred,
+                                BitFileID,
+                                bfsopenflags,
+                                cos_info_ptr,
+                                sclass_info_ptr,
+                                &bfhandle);
 #endif
 
-#if (defined(_USE_HPSS_51) && defined ( API_DMAP_SUPPORT ) && !defined (API_DMAP_GATEWAY )) \
-    ||((defined(_USE_HPSS_62)||defined(_USE_HPSS_622)) && defined ( API_DMAP_SUPPORT ) && !defined (API_DMAP_GATEWAY ) && defined ( API_MIRRORED_FILESETS ))
+#if ((HPSS_MAJOR_VERSION == 5) && defined ( API_DMAP_SUPPORT ) && !defined (API_DMAP_GATEWAY )) \
+    ||((HPSS_MAJOR_VERSION == 6) && defined ( API_DMAP_SUPPORT ) && !defined (API_DMAP_GATEWAY ) && defined ( API_MIRRORED_FILESETS ))
 
 
    if ( error == HPSS_ENOTVALID ) 
@@ -1791,7 +2469,7 @@ int                     Fildes         /* IN - file table index */
 	 }
       }
    }
-#else
+#elif HPSS_MAJOR_VERSION < 7
    if ( error == HPSS_ENOTVALID )
    {
       API_DEBUG_FPRINTF(DebugFile, &RequestID,
@@ -1821,16 +2499,24 @@ int                     Fildes         /* IN - file table index */
       open_bfdesc_ptr->Offset = cast64m(0);
       open_bfdesc_ptr->OpenFlag = Oflag;
       open_bfdesc_ptr->DataConnPtr = NULL;
+#if HPSS_MAJOR_VERSION < 7
       memset(&open_bfdesc_ptr->DMattrs,0,sizeof(api_dmap_attrs_t));
-      open_bfdesc_ptr->CoreServerUUID = uuid;
       open_bfdesc_ptr->DMattrs.FilesetType = CORE_FS_TYPE_HPSS_ONLY;
+#endif
+      open_bfdesc_ptr->CoreServerUUID = uuid;
       open_bfdesc_ptr->Updates = 0;
+#if HPSS_MAJOR_VERSION < 7
       pthread_mutex_init(&open_bfdesc_ptr->Mutex,
 			 pthread_mutexattr_default);
       pthread_cond_init(&open_bfdesc_ptr->Cond,
 			pthread_condattr_default);
+#else
+      open_bfdesc_ptr->Mutex = pthread_mutex_initializer;
+      open_bfdesc_ptr->Cond = pthread_cond_initializer;
+#endif
 
 
+#if HPSS_MAJOR_VERSION < 7
       if ( DMAttrs != NULL )
       {
          /*
@@ -1840,7 +2526,7 @@ int                     Fildes         /* IN - file table index */
 
          open_bfdesc_ptr->DMattrs = *DMAttrs;
       }
-
+#endif
 
       /*
        *  Get a socket and put out a listen for data transfers.
@@ -1897,7 +2583,7 @@ int                     Fildes         /* IN - file table index */
       open_ftptr->Flags = 0;
       API_UnlockMutex(&FTPtr->Mutex);
 
-#if defined( _USE_HPSS_62 ) || defined (_USE_HPSS_622 )
+#if HPSS_MAJOR_VERSION >= 6
       /*
        * If needed, build the return hints
        */
@@ -1923,7 +2609,7 @@ int                     Fildes         /* IN - file table index */
       }
 #endif
 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
       /*
        * If requested, return the storage segment size
        */
@@ -1932,8 +2618,8 @@ int                     Fildes         /* IN - file table index */
          *SegmentSize = sclass_info.StorageSegmentSize;
 #endif
 
-#if (defined( _USE_HPSS_51) && defined (API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) )\
-  || ((defined( _USE_HPSS_62)||defined( _USE_HPSS_622)) && defined (API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) &&  defined ( API_MIRRORED_FILESETS ) )
+#if (( HPSS_MAJOR_VERSION == 5) && defined (API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) )\
+  || ((HPSS_MAJOR_VERSION == 6) && defined (API_DMAP_SUPPORT) && !defined(API_DMAP_GATEWAY) &&  defined ( API_MIRRORED_FILESETS ) )
       /*
        * If no errors and this file is not in a non-DMAP mannaged
        * area of the name space.
@@ -2001,3 +2687,538 @@ int                     Fildes         /* IN - file table index */
 }
 
 
+#if HPSS_LEVEL >= 711
+static int 
+HPSSFSAL_Common_Open_File(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ParentHandle,  /* IN - parent object handle */
+unsigned32     		FilesetCOS,     /* IN - file set COS */
+char                    *Path,          /* IN - Path to file to be opened */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+acct_rec_t              *ParentAcct,    /* IN - parent account code */
+int                     Oflag,          /* IN - open flags */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut )
+{
+   static char            function_name[] = "Common_Open_File";
+   volatile long          error = 0;        /* return error */
+   filetable_t            *ftptr;           /* file table pointer */
+   int                    fildes;           /* File descriptor */
+   int                    checkflag;        /* check for valid file access */
+   unsigned32             oflags;           /* open flags */
+   hpss_object_handle_t   bfhandle;         /* new open bitfile handle */
+   ns_ObjHandle_t         objhandle;        /* new bitfile object handle  */
+   hpss_AttrBits_t        new_attr_bits;    /* new bitfile attr bits */
+   hpss_Attrs_t           new_attrs;        /* new bitfile attributes */
+   openfiletable_t        *open_ftptr;      /* open file table entry */
+   open_bf_desc_t         *open_bfdesc_ptr; /* open bitfile descriptor */
+   hpss_cos_md_t          cosinfo;          /* returned cos info */
+   hpss_sclass_md_t       sclassinfo;       /* returned storage class info */
+   hpss_AttrBits_t        ret_attr_bits;    /* return attr bits */
+   hpss_Attrs_t           ret_attrs;        /* return attributes */
+   acct_rec_t             pacct;            /* parent account */
+
+
+   API_ENTER(function_name);
+
+
+   /*
+    *  Verify that the Oflag is valid.
+    */
+
+   checkflag = Oflag & O_ACCMODE;
+   if((checkflag != O_RDONLY) 
+      &&
+      (checkflag != O_RDWR)
+      &&
+      (checkflag != O_WRONLY))
+   {
+      return(-EINVAL);
+   }
+
+   /*
+    * Translate the Oflag into BFS open flags.
+    */
+
+   if ((Oflag & O_ACCMODE) == O_RDONLY)
+   {
+      oflags = BFS_OPEN_READ;
+   }
+   else if ((Oflag & O_ACCMODE) == O_WRONLY)
+   {
+      oflags = BFS_OPEN_WRITE;
+   }
+   else
+   {
+      oflags = BFS_OPEN_READ | BFS_OPEN_WRITE;
+   }
+        
+   if(Oflag & O_APPEND) oflags |= BFS_OPEN_APPEND;
+   if(Oflag & O_TRUNC)  oflags |= BFS_OPEN_TRUNCATE;
+   if(Oflag & O_NONBLOCK)  oflags |= BFS_OPEN_NO_STAGE;
+   if(Oflag & O_CREAT)  oflags |= BFS_OPEN_CREAT;
+   if(Oflag & O_EXCL)  oflags |= BFS_OPEN_EXCL;
+
+
+   /*
+    *  Check that we do not have too many descriptors already open.
+    */
+
+   ftptr = ThreadContext->FileTable;
+
+   API_LockMutex(&ftptr->Mutex);
+
+   if(ftptr->NumOpenDesc >= _HPSS_OPEN_MAX)
+   {
+      error = -EMFILE;
+   }
+
+   if(error == 0)
+   {
+      /*
+       *  Allocate a slot for the file to be opened.
+       */
+
+      for(fildes = 0;fildes < _HPSS_OPEN_MAX;fildes++)
+      {
+         if(ftptr->OpenDesc[fildes].Type == NO_OPEN_HANDLE) break;
+      }
+      if(fildes >= _HPSS_OPEN_MAX)
+      {
+         API_DEBUG_FPRINTF(DebugFile,&RequestID,
+                           "%s: Inconsistent descriptor table\n",
+                           function_name);
+         kill(getpid(), SIGABRT);
+      }
+      ftptr->OpenDesc[fildes].Type = BFS_OPEN_HANDLE;
+      ftptr->OpenDesc[fildes].Flags |= ENTRY_BUSY;
+      ftptr->TotalOpens++;
+      ftptr->NumOpenDesc++;
+      ftptr->OpenDesc[fildes].descunion_u.OpenBF.DataDesc = -1;
+      open_ftptr = &ftptr->OpenDesc[fildes];
+      open_bfdesc_ptr = &open_ftptr->descunion_u.OpenBF;
+   }
+
+   API_UnlockMutex(&ftptr->Mutex);
+        
+   if(error != 0)
+   {
+      return(error);
+   }
+
+
+   /* Initialize input to the open */
+
+   memset(&new_attrs,'\0',sizeof(new_attrs));
+   new_attr_bits = ret_attr_bits = cast64m(0);
+
+
+   /*
+    * Are we trying to create this file?
+    */
+
+   if(oflags & BFS_OPEN_CREAT) 
+   {
+      acct_rec_t     cur_acct_code;    /* current site account code */
+      acct_rec_t     new_acct_code;    /* validated account code */
+      hpss_uuid_t    site_id;          /* site */
+
+
+      /*
+       *  Do account validation.
+       */
+
+      if((error = API_DetermineAcct(Ucred,
+                                    ThreadContext,
+                                    ParentHandle->CoreServerUUID,
+                                    RequestID,
+                                    &site_id,
+                                    &cur_acct_code)) != 0)
+      {
+         API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't"
+                           " get the account code from the given"
+                           " information: error= %d\n",
+                           function_name, error);
+      }
+      else 
+      {
+         if(ParentAcct == NULL) 
+         { 
+            ParentAcct = &pacct;
+            if((error = API_GetAcctForParent(ThreadContext,
+                                             RequestID,
+                                             ParentHandle, 
+                                             &pacct)) != 0)  
+            {
+               API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't"
+                                 " get the account id for the given"
+                                 " parent handle: error= %d\n",
+                                 function_name, error);
+            }
+         }
+         
+         if(error == 0) 
+         {
+            if((error = av_cli_ValidateCreate(site_id,
+                                              RequestID,
+                                              Ucred->RealmId,
+                                              Ucred->Uid,
+                                              Ucred->Gid,
+                                              cur_acct_code,
+                                              *ParentAcct,
+                                              &new_acct_code)) != 0)
+            {
+               API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't validate"
+                                 " the account code: error= %d\n",
+                                 function_name, error);
+               error = -EPERM;
+            }
+            else 
+            {
+               /*
+                * Everything went okay, setup the attributes for the new file
+                */
+               API_ConvertPosixModeToMode(Mode & ~ThreadContext->Umask,&new_attrs);
+               Ucred->CurAccount = new_attrs.Account = new_acct_code;
+
+               new_attr_bits = API_AddRegisterValues(cast64m(0),
+                                                     CORE_ATTR_USER_PERMS,
+                                                     CORE_ATTR_GROUP_PERMS,
+                                                     CORE_ATTR_OTHER_PERMS,
+                                                     CORE_ATTR_MODE_PERMS,
+                                                     CORE_ATTR_ACCOUNT,
+                                                     -1);
+
+            }
+         }
+      }
+   }
+
+
+   /*
+    * If everything went okay, open/create the file
+    */
+
+   if(error == 0) 
+   {
+      memset(&objhandle,'\0',sizeof(objhandle));
+      memset(&bfhandle,'\0',sizeof(bfhandle));
+      memset(&cosinfo,'\0',sizeof(cosinfo));
+      memset(&sclassinfo,'\0',sizeof(sclassinfo));
+      if(AttrsOut != NULL) 
+      {
+         memset(&ret_attrs,'\0',sizeof(ret_attrs));
+         ret_attr_bits = API_VAttrAttrBits;
+      }
+
+      error = API_core_OpenFile(ThreadContext,
+                                RequestID,
+                                Ucred,
+                                ParentHandle,
+                                Path,
+                                oflags,
+                                new_attr_bits,
+                                &new_attrs,
+                                HintsIn,
+                                HintsPri,
+                                ret_attr_bits,
+                                &ret_attrs,
+                                &cosinfo,
+                                &sclassinfo,
+                                &bfhandle,
+                                &objhandle);
+   }
+
+   if(error == 0) 
+   {
+      int          lstndesc;
+      data_addr_t  lstnaddr;
+
+      /*
+       *  Get a socket and put out a listen for data transfers.
+       */
+
+      error = API_OpenListenDesc(API_TRANSFER_TCP,&lstndesc, &lstnaddr);
+      if(error != HPSS_E_NOERROR)
+      {
+         API_DEBUG_FPRINTF(DebugFile, &RequestID,
+                           "Could not get listen socket."
+                           " errno =%d\n",-error);
+
+         API_LogMsg(function_name,RequestID,CS_DEBUG,
+                    COMMUNICATION_ERROR,WARNING,
+                    API_OPEN_LISTEN_DESC_ERROR,error);
+      }
+      else 
+      {
+
+         /*
+          *  We found an open table descriptor
+          *  Fill in the descriptor with the open file state.
+          */
+
+         open_ftptr->Type = BFS_OPEN_HANDLE;
+         open_bfdesc_ptr->FilesetCOS = FilesetCOS;
+         open_ftptr->ObjectHandle = objhandle;
+         open_bfdesc_ptr->BFHandle = bfhandle;
+         open_bfdesc_ptr->Offset = cast64m(0);
+         open_bfdesc_ptr->OpenFlag = Oflag;
+         open_bfdesc_ptr->DataConnPtr = NULL;
+         open_bfdesc_ptr->CoreServerUUID = objhandle.CoreServerUUID;
+         open_bfdesc_ptr->Updates = 0;
+         open_bfdesc_ptr->Mutex = pthread_mutex_initializer;
+         open_bfdesc_ptr->Cond = pthread_cond_initializer;
+         open_bfdesc_ptr->ListenDesc = lstndesc;
+         open_bfdesc_ptr->ListenAddr_u = lstnaddr;
+
+         API_OpenThrdCntlDesc(open_bfdesc_ptr);
+
+         /*
+          * Mark the file table entry as not busy.
+          */
+
+         API_LockMutex(&ftptr->Mutex);
+         open_ftptr->Flags = 0;
+         API_UnlockMutex(&ftptr->Mutex);
+
+         /*
+          *  The file now exists, go ahead and convert
+          *  the returned name server attributes.
+          */
+
+         if(AttrsOut != NULL)
+            *AttrsOut = ret_attrs;
+
+	 if(HandleOut != NULL)
+	    *HandleOut = objhandle;
+
+         if(HintsOut != NULL) 
+         {
+            HintsOut->COSId = cosinfo.COSId;
+            strncpy((char *)HintsOut->COSName,
+                    (char *)cosinfo.COSName,
+                     HPSS_MAX_COS_NAME);
+            HintsOut->Flags = cosinfo.Flags;
+            HintsOut->OptimumAccessSize = cast64m(cosinfo.OptimumAccessSize);
+            HintsOut->MinFileSize = cosinfo.MinFileSize;
+            HintsOut->MaxFileSize = cosinfo.MaxFileSize;
+            HintsOut->AccessFrequency = cosinfo.AccessFrequency;
+            HintsOut->TransferRate = cosinfo.TransferRate;
+            HintsOut->AvgLatency = cosinfo.AvgLatency;
+            HintsOut->WriteOps = cosinfo.WriteOps;
+            HintsOut->ReadOps = cosinfo.ReadOps;
+            HintsOut->StageCode = cosinfo.StageCode;
+            HintsOut->StripeWidth = sclassinfo.StripeWidth;
+            HintsOut->StripeLength = sclassinfo.StripeLength;
+         }
+      }
+   }
+
+   if(error != 0)
+   {
+      /*
+       *  We had an open problem. Free up the allocated slot.
+       */
+
+      API_LockMutex(&ftptr->Mutex);
+
+      open_ftptr->Type = NO_OPEN_HANDLE;
+      open_ftptr->Flags = 0;
+      ftptr->TotalOpens--;
+      ftptr->NumOpenDesc--;
+
+      API_UnlockMutex(&ftptr->Mutex);
+
+      return(error);
+   }
+
+   return(fildes);
+}
+
+
+static int 
+HPSSFSAL_Common_Create_File(
+apithrdstate_t          *ThreadContext, /* IN - thread context */
+hpss_reqid_t            RequestID,      /* IN - request id */
+ns_ObjHandle_t          *ParentHandle,  /* IN - parent object handle */
+char                    *Path,          /* IN - Path to file to be opened */
+sec_cred_t              *Ucred,         /* IN - user credentials */
+acct_rec_t              *ParentAcct,    /* IN - parent account code */
+mode_t                  Mode,           /* IN - create mode */
+hpss_cos_hints_t        *HintsIn,       /* IN - Desired class of service */
+hpss_cos_priorities_t   *HintsPri,      /* IN - Priorities of hint struct */
+hpss_cos_hints_t        *HintsOut,      /* OUT - Granted class of service */
+hpss_Attrs_t            *AttrsOut,      /* OUT - returned attributes */
+ns_ObjHandle_t          *HandleOut )
+{
+   static char            function_name[] = "Common_Create_File";
+   long                   error;            /* return error */
+   ns_ObjHandle_t         obj_handle;       /* object handle */
+   hpss_AttrBits_t        select_flags;     /* retrieve object attr bits */
+   hpss_AttrBits_t        update_flags;     /* updated object attr bits */
+   hpss_Attrs_t           new_attr;         /* object attributes */
+   hpss_Attrs_t           attr_out;         /* returned object attributes */
+   hpss_cos_md_t          cos_info;         /* returned COS information */
+   hpss_sclass_md_t       sclass_info;      /* returned level 0 sclass info */
+   acct_rec_t             cur_acct_code;    /* current site account code */
+   acct_rec_t             new_acct_code;    /* validated account code */
+   hpss_uuid_t            site_id;          /* site */
+   acct_rec_t             pacct;            /* parent account */
+
+
+
+   /*
+    *  Do account validation.
+    */
+
+   error = API_DetermineAcct(Ucred,
+                             ThreadContext,
+                             ParentHandle->CoreServerUUID,
+                             RequestID,
+                             &site_id,
+                             &cur_acct_code);
+   if (error != 0)
+   {
+      API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't"
+                        " get the account code from the given"
+                        " information: error= %d\n",
+                        function_name, error);
+      return(error);
+   }
+
+
+   /*
+    * Try to get an account for the specified pareht handle 
+    */
+   if(ParentAcct == NULL) 
+   {
+      ParentAcct = &pacct;
+      if((error = API_GetAcctForParent(ThreadContext,
+                                       RequestID,
+                                       ParentHandle,
+                                       &pacct)) != 0) 
+      {
+          API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't"
+                            " get the account id for the given"
+                            " parent handle: error= %d\n",
+                            function_name, error);
+          return(error);
+      }
+   }
+
+   error = av_cli_ValidateCreate(site_id,
+                                 RequestID,
+                                 Ucred->RealmId,
+                                 Ucred->Uid,
+                                 Ucred->Gid,
+                                 cur_acct_code,
+                                 *ParentAcct,
+                                 &new_acct_code);
+   if (error != 0)
+   {
+      API_DEBUG_FPRINTF(DebugFile, &RequestID, "%s: couldn't validate"
+                        " the account code: error= %d\n",
+                        function_name, error);
+      return(-EPERM);
+   }
+
+   Ucred->CurAccount = new_acct_code;
+
+
+   /*
+    *  Create the file in HPSS.
+    */
+
+   memset(&new_attr,0,sizeof(new_attr));
+   memset(&attr_out,0,sizeof(attr_out));
+   memset(&obj_handle,0,sizeof(obj_handle));
+
+   memset(&cos_info,0,sizeof(cos_info));
+   memset(&sclass_info,0,sizeof(sclass_info));
+   memset(&obj_handle,0,sizeof(obj_handle));
+
+
+   /*
+    * Setup the input attributes.
+    */
+
+   API_ConvertPosixModeToMode(Mode & ~ThreadContext->Umask,&new_attr);
+   new_attr.Account = new_acct_code;
+   update_flags = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_USER_PERMS,
+                                        CORE_ATTR_GROUP_PERMS,
+                                        CORE_ATTR_OTHER_PERMS,
+                                        CORE_ATTR_MODE_PERMS,
+                                        CORE_ATTR_ACCOUNT,
+                                        -1);
+
+
+   /*
+    *  Only request returned attributes if we have somewhere to
+    *  put them.
+    */
+
+   if (AttrsOut != (hpss_Attrs_t *)NULL)
+      select_flags = API_AddAllRegisterValues(MAX_CORE_ATTR_INDEX);
+   else
+      select_flags = cast64m(0);
+
+   error = API_core_CreateFile(ThreadContext,
+                               RequestID,
+                               Ucred,
+                               ParentHandle,
+                               Path,
+                               HintsIn,
+                               HintsPri,
+			       update_flags,
+			       &new_attr,
+			       select_flags,
+			       &attr_out,
+			       &obj_handle,
+			       &cos_info,
+			       &sclass_info);
+
+   if ( error == 0 && HintsOut != NULL )
+   {
+      /*
+       *  The file now exists, go ahead and convert
+       *  the returned hints, if requested.
+       */
+
+     HintsOut->COSId = cos_info.COSId;
+     strncpy((char *)HintsOut->COSName,
+             (char *)cos_info.COSName,
+             HPSS_MAX_COS_NAME);
+     HintsOut->OptimumAccessSize = cast64m(cos_info.OptimumAccessSize);
+     HintsOut->MinFileSize = cos_info.MinFileSize;
+     HintsOut->MaxFileSize = cos_info.MaxFileSize;
+     HintsOut->AccessFrequency = cos_info.AccessFrequency;
+     HintsOut->TransferRate = cos_info.TransferRate;
+     HintsOut->AvgLatency = cos_info.AvgLatency;
+     HintsOut->WriteOps = cos_info.WriteOps;
+     HintsOut->ReadOps = cos_info.ReadOps;
+     HintsOut->StageCode = cos_info.StageCode;
+     HintsOut->StripeWidth = sclass_info.StripeWidth;
+     HintsOut->StripeLength = sclass_info.StripeLength;
+   }
+
+   if ( error == 0 ) 
+   {
+      /*
+       *  The file now exists
+       */
+      if ( AttrsOut != NULL )
+      	      *AttrsOut = attr_out;
+      if ( HandleOut != NULL )
+	      *HandleOut = obj_handle;
+   }
+
+   return(error);
+}
+
+#endif
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_rddir.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_rddir.c
index f791d08..aae0fa2 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_rddir.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_rddir.c
@@ -228,14 +228,14 @@ ns_DirEntry_t              *DirentPtr)
    long                    error = 0;
    char                    function_name[] = "HPSSFSAL_Common_ReadAttrs";
    unsigned32              i;
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
    unsigned32		   entry_cnt;
 #endif
    ns_DirEntry_t           *outptr;
    hpss_reqid_t            rqstid;
    u_signed64              select_flags;
 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
    /* figure out how many entries will fit in the clients buffer */
    entry_cnt = BufferSize / sizeof(ns_DirEntry_t);
 #endif
@@ -254,8 +254,10 @@ ns_DirEntry_t              *DirentPtr)
 
       select_flags = API_AddAllRegisterValues(MAX_CORE_ATTR_INDEX);
       select_flags = API_RemoveRegisterValues(select_flags,
+#if HPSS_MAJOR_VERSION < 7
 					      CORE_ATTR_DM_DATA_STATE_FLAGS,
 					      CORE_ATTR_DONT_PURGE,
+#endif
 					      CORE_ATTR_REGISTER_BITMAP,
 					      CORE_ATTR_OPEN_COUNT,
 					      CORE_ATTR_READ_COUNT,
@@ -322,7 +324,7 @@ ns_DirEntry_t              *DirentPtr)
       cnt = 0;
 
 
-#ifdef _USE_HPSS_622
+#if HPSS_LEVEL >= 622
       for ( i = 0; i < direntbuf.DirEntry.DirEntry_len && i < entry_cnt; ++i )
 #else
       for ( i = 0; i < direntbuf.DirEntry.DirEntry_len; ++i )
@@ -366,7 +368,9 @@ ns_DirEntry_t              *DirentPtr)
                                      &attrs,
 				     NULL,
                                      NULL,
+#if HPSS_MAJOR_VERSION < 7
                                      NULL,
+#endif
                                      NULL,
                                      NULL);
 
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_symlink.c b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_symlink.c
index dc24e79..fef0a4f 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_symlink.c
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/api_symlink.c
@@ -16,7 +16,7 @@
 TYPE_TOKEN_HPSS	null_ticket;
 
 
-
+#if HPSS_MAJOR_VERSION < 7
 
 static int
 HPSSFSAL_Common_Symlink(
@@ -32,9 +32,9 @@ hpss_Attrs_t            *AttrsOut)
 {
    static char		function_name[] = "HPSSFSAL_Common_Symlink";
    
-#ifdef _USE_HPSS_51      
+#if HPSS_MAJOR_VERSION == 5
    volatile long	error = 0;        /* return error */
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif HPSS_MAJOR_VERSION >= 6
    signed32 	error = 0;        /* return error */
 #endif
    
@@ -132,6 +132,7 @@ hpss_Attrs_t            *AttrsOut)
 
    if(error == 0)
    {
+
       /*
        * Call this function to determine which interface
        * to call (DMAP Gateway or the Core Server) depending
@@ -139,9 +140,9 @@ hpss_Attrs_t            *AttrsOut)
        * the library this is, what type of DMAP file set
        * this is (sync or backup).
        */
-#ifdef _USE_HPSS_51        
+#if HPSS_MAJOR_VERSION == 5
       call_type = API_DetermineCall(parent_attrs.FilesetType, (long *)&error);
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622)
+#elif HPSS_MAJOR_VERSION == 6
       call_type = API_DetermineCall(parent_attrs.FilesetType, &error);
 #endif        
         
@@ -196,6 +197,7 @@ hpss_Attrs_t            *AttrsOut)
 			      "%s: can't make symlink, error=%d\n,",
 			      function_name,error);
 	 }
+
       }
    
       /*
@@ -262,6 +264,182 @@ hpss_Attrs_t            *AttrsOut)
    free(file);
    return(error);
 }
+#else /* from v7 */
+
+static int
+HPSSFSAL_Common_Symlink(
+apithrdstate_t		*ThreadContext,
+hpss_reqid_t            RequestID,
+ns_ObjHandle_t		*ObjHandle,
+sec_cred_t		*Ucred,
+char			*Path,
+api_cwd_stack_t         *CwdStack,
+char			*Contents,
+ns_ObjHandle_t          *HandleOut,
+hpss_Attrs_t            *AttrsOut)
+{
+   static char		function_name[] = "Common_Symlink";
+   signed32             error = 0;             /* return error */
+   ns_ObjHandle_t       parent_handle;         /* parent object handle */
+   char                 *file;                 /* name of the new object */
+   char                 *parentpath;           /* name of existing parent */
+   hpss_AttrBits_t      attr_bits;             /* parent attributes bits*/
+   hpss_Attrs_t         attrs;                 /* parent attributes */
+   ns_ObjHandle_t       *hndl_ptr = ObjHandle; /* parent handle pointer */
+   ns_ObjHandle_t	new_handle;            /* new object handle */
+   ns_ObjHandle_t	ret_handle;            /* returned new object handle */
+   u_signed64		new_attr_bits;         /* object attribute bits */
+   hpss_Attrs_t   	new_attrs;             /* new object handle */
+
+
+   /*
+    * Allocate memory for object name and parent name
+    */
+
+   file = (char *)malloc(HPSS_MAX_FILE_NAME);
+   if ( file == NULL )
+      return(-ENOMEM);
+
+   parentpath = (char *)malloc(HPSS_MAX_PATH_NAME);
+   if ( parentpath == NULL )
+   {
+      free(file);
+      return(-ENOMEM);
+   }
+
+   /*
+    * Divide the object component from the rest of the path
+    */
+
+   if((error = API_DivideFilePath(Path, parentpath, file)) != 0)
+   {
+      free(file);
+      free(parentpath);
+      return(error);
+   }
+
+
+   if(API_PATH_NEEDS_TRAVERSAL(parentpath))
+   {
+      /*
+       * If there is a path provided then, then lookup
+       * the parent handle
+       */
+
+      attr_bits = API_AddRegisterValues(cast64m(0),
+                                        CORE_ATTR_TYPE,
+                                        -1);
+
+      memset(&parent_handle,0,sizeof(parent_handle));
+      memset(&attrs,'\0',sizeof(attrs));
+
+      /*
+       * Traverse the path to the parent and get it's handle.
+       */
+     
+      error =  API_TraversePath(ThreadContext,
+			        RequestID,
+			        Ucred,
+			        ObjHandle,
+			        parentpath,
+			        CwdStack,
+			        API_CHASE_ALL,
+			        0,
+			        0,
+			        attr_bits,
+			        cast64m(0),
+			        API_NULL_CWD_STACK,
+			        &parent_handle,
+			        &attrs,
+                                (ns_ObjHandle *)NULL,
+                                (hpss_Attrs_t *)NULL,
+			        NULL,
+			        NULL);
+
+      if(error == 0)
+      {
+         if ( attrs.Type != NS_OBJECT_TYPE_DIRECTORY )
+            error = -ENOTDIR;
+         else 
+         {
+            hndl_ptr = &parent_handle;
+         }
+      }
+   }
+   else if(API_PATH_IS_ROOT(parentpath)) 
+   {
+      /* If needed, use the root handle */
+      error = API_InitRootHandle(ThreadContext,RequestID,&hndl_ptr);
+   }
+
+   if (error == 0)
+   {
+      error = API_core_MkSymLink(ThreadContext,
+				 RequestID,
+				 Ucred,
+				 hndl_ptr,
+				 file,
+				 Contents,
+				 &new_handle);
+      
+      if(error != 0)
+      {
+         API_DEBUG_FPRINTF(DebugFile, &RequestID,
+			   "%s: can't make symlink, error=%d\n,",
+			   function_name,error);
+      }
+   }
+        
+        
+   /*
+    * If requested, return the vattr for the newly created link
+    */
+        
+   if ( error == 0 && AttrsOut != (hpss_Attrs_t *)NULL )
+   {
+      new_attr_bits = API_VAttrAttrBits;
+      (void)memset(&ret_handle,0,sizeof(ret_handle));
+      (void)memset(&new_attrs,0,sizeof(new_attrs));
+        
+      error = API_TraversePath(ThreadContext,
+			       RequestID,
+			       Ucred,
+			       &new_handle,
+			       NULL,
+			       API_NULL_CWD_STACK,
+			       API_CHASE_NONE,
+			       0,
+			       0,
+			       new_attr_bits,
+			       cast64m(0),
+			       API_NULL_CWD_STACK,
+			       &ret_handle,
+			       &new_attrs,
+			       NULL,
+			       NULL,
+			       NULL,
+			       NULL);
+   
+      if(error != 0)
+      {
+         API_DEBUG_FPRINTF(DebugFile, &RequestID,
+			   "%s: Could not get attributes.\n",
+			   function_name);
+      }
+      else
+      {
+	 *AttrsOut = new_attrs;
+	 *HandleOut = ret_handle;
+      }
+   }
+
+   free(file);
+   free(parentpath);
+
+   return(error);
+}
+
+#endif
 
 
 
diff --git a/src/FSAL/FSAL_HPSS/HPSSclapiExt/hpssclapiext.h b/src/FSAL/FSAL_HPSS/HPSSclapiExt/hpssclapiext.h
index 7e77906..562f949 100644
--- a/src/FSAL/FSAL_HPSS/HPSSclapiExt/hpssclapiext.h
+++ b/src/FSAL/FSAL_HPSS/HPSSclapiExt/hpssclapiext.h
@@ -10,22 +10,31 @@
 
 #include <hpss_types.h>
 #include <hpss_api.h>
+#include <hpss_version.h>
 
 #ifndef _HPSSCLAPIEXT_H
 #define _HPSSCLAPIEXT_H
 
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
 
 #define TYPE_CRED_HPSS  hsec_UserCred_t
 #define TYPE_TOKEN_HPSS  gss_token_t
 #define TYPE_UUID_HPSS  uuid_t
 
-#elif defined( _USE_HPSS_62) || defined( _USE_HPSS_622)
+#elif HPSS_MAJOR_VERSION == 6
 
 #define TYPE_CRED_HPSS  sec_cred_t
 #define TYPE_TOKEN_HPSS  hpss_authz_token_t
 #define TYPE_UUID_HPSS  hpss_uuid_t
 
+#elif HPSS_MAJOR_VERSION == 7
+
+#define TYPE_CRED_HPSS  sec_cred_t
+typedef void * TYPE_TOKEN_HPSS; 
+#define TYPE_UUID_HPSS  hpss_uuid_t
+
+#else
+   #error "Unexpected HPSS VERSION"
 #endif
 
 
@@ -59,6 +68,7 @@ TYPE_TOKEN_HPSS *AuthzTicket,   /* OUT - returned authorization */
 hpss_Attrs_t    *AttrsOut);     /* OUT - returned attributes */
 
 
+#if (HPSS_MAJOR_VERSION < 7)
 int
 HPSSFSAL_FileSetAttrHandle(
 ns_ObjHandle_t      *ObjHandle, /* IN  - parent object handle */
@@ -67,6 +77,9 @@ TYPE_CRED_HPSS     *Ucred,     /* IN  - user credentials */
 hpss_fileattrbits_t SelFlags,   /* IN - attributes fields to set */
 hpss_fileattr_t     *AttrIn,    /* IN  - input attributes */
 hpss_fileattr_t     *AttrOut);  /* OUT - attributes after change */
+#else
+#define HPSSFSAL_FileSetAttrHandle hpss_FileSetAttributesHandle
+#endif
 
 
 int
@@ -108,7 +121,7 @@ unsigned32              *End,           /* OUT - hit end of directory */
 u_signed64              *OffsetOut,     /* OUT - resulting directory position */
 ns_DirEntry_t           *DirentPtr);    /* OUT - directory entry information */
 
-#ifndef _USE_HPSS_622
+#if (HPSS_LEVEL < 622)
 int
 HPSSFSAL_FileGetXAttributesHandle(
 ns_ObjHandle_t  *ObjHandle,     /* IN - object handle */
diff --git a/src/FSAL/FSAL_HPSS/fsal_access.c b/src/FSAL/FSAL_HPSS/fsal_access.c
index b332325..6fe5bd0 100644
--- a/src/FSAL/FSAL_HPSS/fsal_access.c
+++ b/src/FSAL/FSAL_HPSS/fsal_access.c
@@ -19,6 +19,8 @@
 #include "fsal_internal.h"
 #include "fsal_convert.h"
 
+#include <hpss_errno.h>
+
 
 /**
  * FSAL_access :
@@ -84,8 +86,11 @@ fsal_status_t FSAL_access(
                   &(object_handle->ns_handle), /* IN - parent object handle */
                   NULL,                /* IN - path of file to check access rights */
                   hpss_test_mode,      /* IN - Type of access to be checked */
-                  &p_context->credential.hpss_usercred, /* IN - user credentials */
-                  NULL                 /* OUT - authorization ticket */ );
+                  &p_context->credential.hpss_usercred /* IN - user credentials */
+        #if HPSS_MAJOR_VERSION < 7
+                , NULL                 /* OUT - authorization ticket */
+        #endif
+ );
   
   ReleaseTokenFSCall();
   
diff --git a/src/FSAL/FSAL_HPSS/fsal_attrs.c b/src/FSAL/FSAL_HPSS/fsal_attrs.c
index f6ac1f5..c8b3e23 100644
--- a/src/FSAL/FSAL_HPSS/fsal_attrs.c
+++ b/src/FSAL/FSAL_HPSS/fsal_attrs.c
@@ -20,6 +20,8 @@
 #include "fsal_convert.h"
 #include "HPSSclapiExt/hpssclapiext.h"
 
+#include <hpss_errno.h>
+
 /**
  * FSAL_getattrs:
  * Get attributes for the object specified by its filehandle.
diff --git a/src/FSAL/FSAL_HPSS/fsal_common.c b/src/FSAL/FSAL_HPSS/fsal_common.c
index ffdb94f..b863961 100644
--- a/src/FSAL/FSAL_HPSS/fsal_common.c
+++ b/src/FSAL/FSAL_HPSS/fsal_common.c
@@ -13,6 +13,8 @@
 #include "fsal_common.h"
 #include "fsal_internal.h"
 
+#include <hpss_errno.h>
+
 #define STRCMP strcasecmp
 
 /**
diff --git a/src/FSAL/FSAL_HPSS/fsal_context.c b/src/FSAL/FSAL_HPSS/fsal_context.c
index 3908350..f82c8c1 100644
--- a/src/FSAL/FSAL_HPSS/fsal_context.c
+++ b/src/FSAL/FSAL_HPSS/fsal_context.c
@@ -208,7 +208,7 @@ fsal_status_t FSAL_InitClientContext( fsal_op_context_t * p_thr_context )
   /* sets the credential time */
   p_thr_context->credential.last_update = time( NULL );
   
-#if defined( _DEBUG_FSAL ) && defined ( _USE_HPSS_51 )
+#if defined( _DEBUG_FSAL ) && (HPSS_MAJOR_VERSION == 5)
   
    /* traces: prints p_credential structure */
   
@@ -222,7 +222,7 @@ fsal_status_t FSAL_InitClientContext( fsal_op_context_t * p_thr_context )
      DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
         p_thr_context->credential.hpss_usercred.AltGroups[i] );
 
-#elif defined( _DEBUG_FSAL ) && ( defined ( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 ) )
+#elif defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION == 6 )
 
    /* traces: prints p_credential structure */
   
@@ -235,6 +235,21 @@ fsal_status_t FSAL_InitClientContext( fsal_op_context_t * p_thr_context )
    for ( i=0; i< p_thr_context->credential.hpss_usercred.NumGroups; i++ )
      DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
         p_thr_context->credential.hpss_usercred.AltGroups[i] );
+
+#elif defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION == 7 )
+
+   /* traces: prints p_credential structure */
+  
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "credential created:");
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tuid = %d, gid = %d",
+      p_thr_context->credential.hpss_usercred.Uid, p_thr_context->credential.hpss_usercred.Gid);
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tName = %s",
+      p_thr_context->credential.hpss_usercred.Name);
+   
+   for ( i=0; i< p_thr_context->credential.hpss_usercred.NumGroups; i++ )
+     DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
+        p_thr_context->credential.hpss_usercred.AltGroups[i] );
+
        
 #endif  
      
@@ -298,14 +313,14 @@ fsal_status_t FSAL_GetClientContext(
     
   /* Extracted from  /opt/hpss/src/nfs/nfsd/nfs_Dispatch.c */
   
-#if defined( _USE_HPSS_51 )
+#if HPSS_MAJOR_VERSION == 5
   strcpy( p_thr_context->credential.hpss_usercred.SecPWent.Name, "NFS.User" );
   p_thr_context->credential.hpss_usercred.SecLabel = 0;	/* Symbol? */
   p_thr_context->credential.hpss_usercred.CurAccount = ACCT_REC_DEFAULT;
   p_thr_context->credential.hpss_usercred.DefAccount = ACCT_REC_DEFAULT;
   p_thr_context->credential.hpss_usercred.SecPWent.Uid = uid ;
   p_thr_context->credential.hpss_usercred.SecPWent.Gid = gid ;
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif  (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
   strcpy( p_thr_context->credential.hpss_usercred.Name, "NFS.User" );
   p_thr_context->credential.hpss_usercred.CurAccount = ACCT_REC_DEFAULT;
   p_thr_context->credential.hpss_usercred.DefAccount = ACCT_REC_DEFAULT;
@@ -324,7 +339,7 @@ fsal_status_t FSAL_GetClientContext(
   for ( i = 0 ; i < ng; i++ )
     p_thr_context->credential.hpss_usercred.AltGroups[i] = alt_groups[i];
 
-#if defined( _DEBUG_FSAL ) && defined( _USE_HPSS_51 )
+#if defined( _DEBUG_FSAL ) && (HPSS_MAJOR_VERSION == 5)
   
    /* traces: prints p_credential structure */
   
@@ -338,7 +353,7 @@ fsal_status_t FSAL_GetClientContext(
      DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
         p_thr_context->credential.hpss_usercred.AltGroups[i] );
 
-#elif defined( _DEBUG_FSAL ) && ( defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 ) )
+#elif defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION == 6 )
 
       /* traces: prints p_credential structure */
   
@@ -351,6 +366,21 @@ fsal_status_t FSAL_GetClientContext(
    for ( i=0; i< p_thr_context->credential.hpss_usercred.NumGroups; i++ )
      DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
         p_thr_context->credential.hpss_usercred.AltGroups[i] );       
+
+#elif defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION == 7 )
+
+      /* traces: prints p_credential structure */
+  
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "credential modified:");
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tuid = %d, gid = %d",
+      p_thr_context->credential.hpss_usercred.Uid, p_thr_context->credential.hpss_usercred.Gid);
+   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tName = %s",
+      p_thr_context->credential.hpss_usercred.Name);
+   
+   for ( i=0; i< p_thr_context->credential.hpss_usercred.NumGroups; i++ )
+     DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "\tAlt grp: %d",
+        p_thr_context->credential.hpss_usercred.AltGroups[i] );       
+
 #endif
     
   Return( ERR_FSAL_NO_ERROR, 0, INDEX_FSAL_GetClientContext );
diff --git a/src/FSAL/FSAL_HPSS/fsal_convert.c b/src/FSAL/FSAL_HPSS/fsal_convert.c
index 5f663d4..e573a55 100644
--- a/src/FSAL/FSAL_HPSS/fsal_convert.c
+++ b/src/FSAL/FSAL_HPSS/fsal_convert.c
@@ -19,6 +19,8 @@
 #include <sys/types.h>
 #include <errno.h>
 
+#include <hpss_errno.h>
+
 
 #define MAX_2( x, y )    ( (x) > (y) ? (x) : (y) )
 #define MAX_3( x, y, z ) ( (x) > (y) ? MAX_2((x),(z)) : MAX_2((y),(z)) )
@@ -183,18 +185,25 @@ int hpss2fsal_error(int hpss_errorcode){
 
     default:
       
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
         
       /* hsec error code regarding security (-3000...)*/
       if ( ( hpss_errorcode <= -3000 ) && ( hpss_errorcode > -4000 ))
         return ERR_FSAL_SEC;
     
-#elif  defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION == 6
     
       /* hsec error code regarding security (-11000...)*/
       if ( ( hpss_errorcode <= HPSS_SEC_ENOT_AUTHORIZED )
           && ( hpss_errorcode >= HPSS_SEC_LDAP_ERROR ) )
         return ERR_FSAL_SEC;      
+#elif HPSS_MAJOR_VERSION == 7
+    
+      /* hsec error code regarding security (-11000...)*/
+      if ( ( hpss_errorcode <= HPSS_SEC_ENOT_AUTHORIZED )
+          && ( hpss_errorcode >= HPSS_SEC_LDAP_RETRY ) )
+        return ERR_FSAL_SEC;      
+
 #endif
       
       /* other unexpected errors */    
@@ -555,9 +564,13 @@ fsal_accessmode_t hpss2fsal_mode(
  */
 void fsal2hpss_mode( 
     fsal_accessmode_t fsal_mode,
+#if HPSS_MAJOR_VERSION < 7
     unsigned32 * uid_bit,
     unsigned32 * gid_bit,
     unsigned32 * sticky_bit,
+#else
+    unsigned32 * mode_perms,
+#endif
     unsigned32 * user_perms,
     unsigned32 * group_perms,
     unsigned32 * other_perms
@@ -565,18 +578,28 @@ void fsal2hpss_mode(
   
   /* init outputs */
   
+#if HPSS_MAJOR_VERSION < 7
   *uid_bit = 0;
   *gid_bit = 0;
   *sticky_bit = 0;
+#else
+  *mode_perms = 0;
+#endif
   *user_perms = 0;
   *group_perms = 0;
   *other_perms = 0;
   
   /* special bits */
   
+#if HPSS_MAJOR_VERSION < 7
   if ( fsal_mode & FSAL_MODE_SUID )  *uid_bit = 1;
   if ( fsal_mode & FSAL_MODE_SGID )  *gid_bit = 1;
   if ( fsal_mode & FSAL_MODE_SVTX )  *sticky_bit = 1;
+#else
+  if ( fsal_mode & FSAL_MODE_SUID )  (*mode_perms) |= NS_PERMS_RD;
+  if ( fsal_mode & FSAL_MODE_SGID )  (*mode_perms) |= NS_PERMS_WR;
+  if ( fsal_mode & FSAL_MODE_SVTX )  (*mode_perms) |= NS_PERMS_XS;
+#endif
   
   /* user perms */
   
@@ -705,12 +728,18 @@ fsal_status_t hpss2fsal_attributes(  ns_ObjHandle_t * p_hpss_handle_in,
                   hpss_GetObjId( p_hpss_handle_in );
   }
     
-  if ( FSAL_TEST_MASK(p_fsalattr_out->asked_attributes,
-      FSAL_ATTR_MODE)){
+  if ( FSAL_TEST_MASK(p_fsalattr_out->asked_attributes, FSAL_ATTR_MODE))
+  {
         p_fsalattr_out->mode = hpss2fsal_mode(
+#if HPSS_MAJOR_VERSION < 7
             p_hpss_attr_in->SetUIDBit,
             p_hpss_attr_in->SetGIDBit,
             p_hpss_attr_in->SetStickyBit,
+#else
+            p_hpss_attr_in->ModePerms & NS_PERMS_RD,
+            p_hpss_attr_in->ModePerms & NS_PERMS_WR,
+            p_hpss_attr_in->ModePerms & NS_PERMS_XS,
+#endif
             p_hpss_attr_in->UserPerms,
             p_hpss_attr_in->GroupPerms,
             p_hpss_attr_in->OtherPerms
@@ -1001,16 +1030,24 @@ fsal_status_t fsal2hpss_attribset(  fsal_handle_t  * p_fsal_handle,
                                CORE_ATTR_USER_PERMS,
                                CORE_ATTR_GROUP_PERMS,
                                CORE_ATTR_OTHER_PERMS,
+#if HPSS_MAJOR_VERSION < 7
                                CORE_ATTR_SET_GID,
                                CORE_ATTR_SET_UID,
                                CORE_ATTR_SET_STICKY,
+#else
+                               CORE_ATTR_MODE_PERMS,
+#endif
                                -1);
     
     /* convert mode and set output structure. */
     fsal2hpss_mode( p_attrib_set->mode, 
+#if HPSS_MAJOR_VERSION < 7
             &(p_hpss_attrs->SetUIDBit),
             &(p_hpss_attrs->SetGIDBit),
             &(p_hpss_attrs->SetStickyBit),
+#else
+            &(p_hpss_attrs->ModePerms),
+#endif
             &(p_hpss_attrs->UserPerms),
             &(p_hpss_attrs->GroupPerms),
             &(p_hpss_attrs->OtherPerms)
diff --git a/src/FSAL/FSAL_HPSS/fsal_convert.h b/src/FSAL/FSAL_HPSS/fsal_convert.h
index e15559b..9c089a4 100644
--- a/src/FSAL/FSAL_HPSS/fsal_convert.h
+++ b/src/FSAL/FSAL_HPSS/fsal_convert.h
@@ -56,9 +56,13 @@ fsal_accessmode_t hpss2fsal_mode(
 /** converts HPSS access mode to FSAL mode */
 void fsal2hpss_mode( 
     fsal_accessmode_t fsal_mode,
+#if HPSS_MAJOR_VERSION < 7
     unsigned32 * uid_bit,
     unsigned32 * gid_bit,
     unsigned32 * sticky_bit,
+#else
+    unsigned32 * mode_perms,
+#endif
     unsigned32 * user_perms,
     unsigned32 * group_perms,
     unsigned32 * other_perms
diff --git a/src/FSAL/FSAL_HPSS/fsal_create.c b/src/FSAL/FSAL_HPSS/fsal_create.c
index 2363755..7e42f1c 100644
--- a/src/FSAL/FSAL_HPSS/fsal_create.c
+++ b/src/FSAL/FSAL_HPSS/fsal_create.c
@@ -21,6 +21,7 @@
 #include "fsal_common.h"
 #include "HPSSclapiExt/hpssclapiext.h"
 
+#include <hpss_errno.h>
 
 
 /**
diff --git a/src/FSAL/FSAL_HPSS/fsal_fileop.c b/src/FSAL/FSAL_HPSS/fsal_fileop.c
index 158c127..48a8d03 100644
--- a/src/FSAL/FSAL_HPSS/fsal_fileop.c
+++ b/src/FSAL/FSAL_HPSS/fsal_fileop.c
@@ -18,6 +18,7 @@
 #include "fsal_convert.h"
 #include "HPSSclapiExt/hpssclapiext.h"
 
+#include <hpss_errno.h>
 
 
 /**
@@ -188,7 +189,9 @@ fsal_status_t FSAL_open(
   /* fills output struct */
   
   file_descriptor->filedes = rc;
+#if HPSS_MAJOR_VERSION < 7
   file_descriptor->fileauthz = hpss_authz;
+#endif
 
     
   /* set output attributes if asked */
diff --git a/src/FSAL/FSAL_HPSS/fsal_fsinfo.c b/src/FSAL/FSAL_HPSS/fsal_fsinfo.c
index b4b2ffb..f97e65a 100644
--- a/src/FSAL/FSAL_HPSS/fsal_fsinfo.c
+++ b/src/FSAL/FSAL_HPSS/fsal_fsinfo.c
@@ -19,7 +19,7 @@
 #include "fsal_internal.h"
 #include "fsal_convert.h"
               
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
   /* for struct statfs */
 # include <sys/types.h>
 #endif
@@ -88,9 +88,9 @@ fsal_status_t  FSAL_dynamic_fsinfo(
     fsal_dynamicfsinfo_t *   dynamicinfo         /* OUT */
 ){
 
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
   struct statfs hpss_statfs;
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION >= 6
   hpss_statfs_t hpss_statfs;
 #endif
   
diff --git a/src/FSAL/FSAL_HPSS/fsal_init.c b/src/FSAL/FSAL_HPSS/fsal_init.c
index 38291fa..54efd67 100644
--- a/src/FSAL/FSAL_HPSS/fsal_init.c
+++ b/src/FSAL/FSAL_HPSS/fsal_init.c
@@ -20,7 +20,7 @@
 #include "fsal_common.h"
 #include "HPSSclapiExt/hpssclapiext.h"
 
-#if defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#if HPSS_MAJOR_VERSION >= 6
 #include <hpss_Getenv.h>
 
 static hpss_authn_mech_t  FSAL_auth_mech;
@@ -36,7 +36,7 @@ static int HPSSFSAL_SecInit( fs_specific_initinfo_t * hpss_init_info ){
 
   int rc;
 
-#ifdef _USE_HPSS_51    
+#if HPSS_MAJOR_VERSION == 5
   /** @todo : hpss_SetLoginContext : is it a good way of proceeding ? */
     
   rc = hpss_SetLoginContext( FSAL_PrincipalName, FSAL_KeytabPath );
@@ -46,7 +46,7 @@ static int HPSSFSAL_SecInit( fs_specific_initinfo_t * hpss_init_info ){
   DisplayLogJdLevel( fsal_log, NIV_DEBUG, "FSAL SEC INIT: Keytab is set to '%s'",
     FSAL_KeytabPath );
   
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 ) 
+#elif HPSS_MAJOR_VERSION >= 6
   hpss_rpc_auth_type_t auth_type;
   
   rc = hpss_GetAuthType( FSAL_auth_mech, &auth_type );
@@ -141,7 +141,7 @@ static int HPSSFSAL_Init( fs_specific_initinfo_t * hpss_init_info ){
     return rc;
   
 
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
     
   /* Then analyze user's init info. */
   
@@ -152,7 +152,7 @@ static int HPSSFSAL_Init( fs_specific_initinfo_t * hpss_init_info ){
   strcpy(FSAL_PrincipalName, hpss_config.PrincipalName );
   strcpy(FSAL_KeytabPath, hpss_config.KeytabPath );
     
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION >= 6
   
 #define API_DEBUG_ERROR    (1)
 #define API_DEBUG_REQUEST  (2)
@@ -273,7 +273,7 @@ fsal_status_t  FSAL_Init(
     DisplayLog("FSAL INIT: *** WARNING: No logging file specified for FileSystem Abstraction Layer.");
   }
 
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
   
   if ( init_info->fs_specific_info.behaviors.KeytabPath == FSAL_INIT_FS_DEFAULT )
   {
@@ -289,7 +289,7 @@ fsal_status_t  FSAL_Init(
     DisplayLog("FSAL INIT: ***          Set %s::PrincipalName into config file to use another principal", CONF_LABEL_FS_SPECIFIC);
   }
   
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION >= 6
   
   if ( init_info->fs_specific_info.behaviors.AuthnMech == FSAL_INIT_FS_DEFAULT )
   {
diff --git a/src/FSAL/FSAL_HPSS/fsal_internal.h b/src/FSAL/FSAL_HPSS/fsal_internal.h
index 15838cd..3a17ac2 100644
--- a/src/FSAL/FSAL_HPSS/fsal_internal.h
+++ b/src/FSAL/FSAL_HPSS/fsal_internal.h
@@ -11,7 +11,7 @@
  
 #include  "fsal.h"
 
-#if defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#if HPSS_MAJOR_VERSION >= 6
 #include <hpss_mech.h>
 #include <hpss_String.h>
 #endif
diff --git a/src/FSAL/FSAL_HPSS/fsal_local_op.c b/src/FSAL/FSAL_HPSS/fsal_local_op.c
index 3fd8074..8931807 100644
--- a/src/FSAL/FSAL_HPSS/fsal_local_op.c
+++ b/src/FSAL/FSAL_HPSS/fsal_local_op.c
@@ -149,10 +149,10 @@ fsal_status_t FSAL_test_access(
   
   /* test root access */
   
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   if ( p_context->credential.hpss_usercred.SecPWent.Uid == 0 )
     Return(ERR_FSAL_NO_ERROR ,0 , INDEX_FSAL_test_access );
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
   if ( p_context->credential.hpss_usercred.Uid == 0 )
     Return(ERR_FSAL_NO_ERROR ,0 , INDEX_FSAL_test_access );
 #endif
@@ -167,17 +167,17 @@ fsal_status_t FSAL_test_access(
     
   /* Test if file belongs to user. */
  
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   if ( p_context->credential.hpss_usercred.SecPWent.Uid == object_attributes->owner )
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
   if ( p_context->credential.hpss_usercred.Uid == object_attributes->owner )
 #endif
   {
     
-#if defined( _DEBUG_FSAL ) && defined( _USE_HPSS_51 )
+#if defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION == 5 )
    DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "File belongs to user %d",
        p_context->credential.hpss_usercred.SecPWent.Uid );
-#elif defined( _DEBUG_FSAL ) && ( defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 ) )
+#elif defined( _DEBUG_FSAL ) && ( HPSS_MAJOR_VERSION >= 6 )
    DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, "File belongs to user %d",
        p_context->credential.hpss_usercred.Uid );
 #endif
@@ -203,7 +203,7 @@ fsal_status_t FSAL_test_access(
   
   /* Test if the file belongs to user's group. */
 
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   is_grp = ( p_context->credential.hpss_usercred.SecPWent.Gid == object_attributes->group );
   
 # ifdef _DEBUG_FSAL
@@ -213,7 +213,7 @@ fsal_status_t FSAL_test_access(
 # endif
   
 
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION >= 6
   is_grp = ( p_context->credential.hpss_usercred.Gid == object_attributes->group );
     
 # ifdef _DEBUG_FSAL
@@ -324,18 +324,18 @@ fsal_status_t FSAL_setattr_access(
     Return( ERR_FSAL_FAULT ,0 , INDEX_FSAL_setattr_access );
 
   /* Root has full power... */
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   if ( p_context->credential.hpss_usercred.SecPWent.Uid == 0 )
     Return(ERR_FSAL_NO_ERROR ,0 , INDEX_FSAL_setattr_access );
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
   if ( p_context->credential.hpss_usercred.Uid == 0 )
     Return(ERR_FSAL_NO_ERROR ,0 , INDEX_FSAL_setattr_access );
 #endif
 
   /* Check for owner access */
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   if ( p_context->credential.hpss_usercred.SecPWent.Uid == pobject_attributes->owner )
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
   if ( p_context->credential.hpss_usercred.Uid == pobject_attributes->owner )
 #endif
     {
diff --git a/src/FSAL/FSAL_HPSS/fsal_lookup.c b/src/FSAL/FSAL_HPSS/fsal_lookup.c
index eeb619a..bebc7ba 100644
--- a/src/FSAL/FSAL_HPSS/fsal_lookup.c
+++ b/src/FSAL/FSAL_HPSS/fsal_lookup.c
@@ -20,6 +20,8 @@
 #include "fsal_common.h"
 #include "HPSSclapiExt/hpssclapiext.h"
 
+#include <hpss_errno.h>
+
 
 /**
  * FSAL_lookup :
diff --git a/src/FSAL/FSAL_HPSS/fsal_rename.c b/src/FSAL/FSAL_HPSS/fsal_rename.c
index c2e3ce3..08dd1f9 100644
--- a/src/FSAL/FSAL_HPSS/fsal_rename.c
+++ b/src/FSAL/FSAL_HPSS/fsal_rename.c
@@ -20,6 +20,7 @@
 #include "fsal_convert.h"
 #include "fsal_common.h"
 
+#include <hpss_errno.h>
 
 
 /**
diff --git a/src/FSAL/FSAL_HPSS/fsal_symlinks.c b/src/FSAL/FSAL_HPSS/fsal_symlinks.c
index 22201d0..2ea969b 100644
--- a/src/FSAL/FSAL_HPSS/fsal_symlinks.c
+++ b/src/FSAL/FSAL_HPSS/fsal_symlinks.c
@@ -21,6 +21,7 @@
 #include <string.h>
 #include "HPSSclapiExt/hpssclapiext.h"
 
+#include <hpss_errno.h>
 
 
 /**
diff --git a/src/FSAL/FSAL_HPSS/fsal_tools.c b/src/FSAL/FSAL_HPSS/fsal_tools.c
index c0fe468..5a9de9b 100644
--- a/src/FSAL/FSAL_HPSS/fsal_tools.c
+++ b/src/FSAL/FSAL_HPSS/fsal_tools.c
@@ -25,21 +25,18 @@
 /* case unsensitivity */
 #define STRCMP   strcasecmp
 
-#ifdef _USE_HPSS_51
+#if HPSS_VERSION_MAJOR == 5
 #define TYPE_UUIDT  uuid_t
-#elif defined( _USE_HPSS_62) || defined ( _USE_HPSS_622 )
+#else
 #define TYPE_UUIDT  hpss_uuid_t
 #endif
 
+#define INTMACRO_TO_STR(_x) _DEREF(_x)
+#define _DEREF(_x) #_x
+
 char * FSAL_GetFSName()
 {
-#ifdef _USE_HPSS_51
-        return "HPSS 5.1";
-#elif defined( _USE_HPSS_62) || defined ( _USE_HPSS_622 )
-        return "HPSS 6.2";
-#else
-        return "HPSS";
-#endif
+        return "HPSS " INTMACRO_TO_STR( HPSS_MAJOR_VERSION ) "." INTMACRO_TO_STR( HPSS_MINOR_VERSION ) "." INTMACRO_TO_STR( HPSS_PATCH_LEVEL );
 }
 
 
@@ -584,12 +581,12 @@ fsal_status_t  FSAL_SetDefault_FS_specific_parameter(
   
   /* set default values for all parameters of fs_specific_info */
   
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   
   FSAL_SET_INIT_DEFAULT( out_parameter->fs_specific_info, PrincipalName);
   FSAL_SET_INIT_DEFAULT( out_parameter->fs_specific_info, KeytabPath);
   
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif HPSS_MAJOR_VERSION >= 6
   
   FSAL_SET_INIT_DEFAULT( out_parameter->fs_specific_info, AuthnMech);
   FSAL_SET_INIT_DEFAULT( out_parameter->fs_specific_info, NumRetries);
@@ -1003,7 +1000,7 @@ fsal_status_t  FSAL_load_FS_specific_parameter_from_conf(
       ReturnCode( ERR_FSAL_SERVERFAULT, err );
     }
     
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
     /* does the variable exists ? */
     if ( !STRCMP( key_name, "PrincipalName" ) )
       {
@@ -1023,7 +1020,7 @@ fsal_status_t  FSAL_load_FS_specific_parameter_from_conf(
             key_value );
             
       }    
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
     /* does the variable exists ? */
     if ( !STRCMP( key_name, "PrincipalName" ) )
       {        
diff --git a/src/FSAL/FSAL_HPSS/fsal_truncate.c b/src/FSAL/FSAL_HPSS/fsal_truncate.c
index 5b97912..d2af2a1 100644
--- a/src/FSAL/FSAL_HPSS/fsal_truncate.c
+++ b/src/FSAL/FSAL_HPSS/fsal_truncate.c
@@ -19,7 +19,7 @@
 #include "fsal_internal.h"
 #include "fsal_convert.h"
 
-
+#include <hpss_errno.h>
 
 
 /**
diff --git a/src/FSAL/FSAL_HPSS/fsal_xattrs.c b/src/FSAL/FSAL_HPSS/fsal_xattrs.c
index 708bb21..f5adada 100644
--- a/src/FSAL/FSAL_HPSS/fsal_xattrs.c
+++ b/src/FSAL/FSAL_HPSS/fsal_xattrs.c
@@ -16,6 +16,8 @@
 #include "HPSSclapiExt/hpssclapiext.h"
 #include "hpss_uuid.h"
 
+#include <hpss_errno.h>
+
 /* generic definitions for extended attributes */
 
 #define XATTR_FOR_FILE     0x00000001
@@ -145,12 +147,12 @@ int get_file_slevel( fsal_handle_t     * p_objecthandle,  /* IN */
   
   TakeTokenFSCall();
   
-#ifndef _USE_HPSS_622
+#if HPSS_LEVEL < 622
   rc = HPSSFSAL_FileGetXAttributesHandle(
         &(p_objecthandle->ns_handle),
         API_GET_STATS_FOR_ALL_LEVELS, 0,
         &hpss_xattr);
-#else
+#elif HPSS_LEVEL == 622
   rc = hpss_FileGetXAttributesHandle(
 		&(p_objecthandle->ns_handle),
 		NULL,
@@ -158,6 +160,13 @@ int get_file_slevel( fsal_handle_t     * p_objecthandle,  /* IN */
 		API_GET_STATS_FOR_ALL_LEVELS, 0,
 		NULL,
 		&hpss_xattr);	
+#elif HPSS_MAJOR_VERSION >= 7
+  rc = hpss_FileGetXAttributesHandle(
+                &(p_objecthandle->ns_handle),
+                NULL,
+                &(p_context->credential.hpss_usercred),
+                API_GET_STATS_FOR_ALL_LEVELS, 0,
+                &hpss_xattr);
 #endif
   
   ReleaseTokenFSCall();
diff --git a/src/FSAL/FSAL_HPSS/test_fsal.c b/src/FSAL/FSAL_HPSS/test_fsal.c
index 94eb3ac..ab0caba 100644
--- a/src/FSAL/FSAL_HPSS/test_fsal.c
+++ b/src/FSAL/FSAL_HPSS/test_fsal.c
@@ -212,7 +212,7 @@ int main(int argc, char ** argv){
   
   /* 1 - fs specific info */
   
-#ifdef _USE_HPSS_51  
+#if HPSS_MAJOR_VERSION == 5
   
   init_param.fs_specific_info.behaviors.PrincipalName = FSAL_INIT_FORCE_VALUE ;
   strcpy(init_param.fs_specific_info.hpss_config.PrincipalName,"hpss_nfs");
@@ -220,7 +220,7 @@ int main(int argc, char ** argv){
   init_param.fs_specific_info.behaviors.KeytabPath = FSAL_INIT_FORCE_VALUE ;
   strcpy(init_param.fs_specific_info.hpss_config.KeytabPath,"/krb5/hpssserver.keytab");
 
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#else
   init_param.fs_specific_info.behaviors.AuthnMech = FSAL_INIT_FORCE_VALUE ;
   init_param.fs_specific_info.hpss_config.AuthnMech = hpss_authn_mech_krb5 ;
   
diff --git a/src/NFS_Protocols/nfs4_op_access.c b/src/NFS_Protocols/nfs4_op_access.c
index 61c342f..10e1306 100644
--- a/src/NFS_Protocols/nfs4_op_access.c
+++ b/src/NFS_Protocols/nfs4_op_access.c
@@ -199,7 +199,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
 
 #if defined( _USE_POSIX )
   credentials =  data->pcontext->credential ;
-#elif defined( _USE_HPSS_62 ) || defined( _USE_HPSS_622 )
+#elif defined( _USE_HPSS )
    credentials =  data->pcontext->credential ; 
 #elif defined( _USE_FUSE )
   credentials =  data->pcontext->credential ;
@@ -213,7 +213,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
 #error "This FSAL is not supported"
 #endif
 
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
   if( credentials.user == attr.owner )
 #else
   if( credentials.hpss_usercred.Uid == attr.owner ) 
@@ -223,7 +223,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
     write_flag = FSAL_MODE_WUSR ;
     exec_flag = FSAL_MODE_XUSR;
    } 
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
   else if( credentials.group == attr.group ) /** @todo make smater group ownership test */
 #else
   else if( credentials.hpss_usercred.Gid == attr.group ) 
@@ -243,7 +243,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( arg_ACCESS4.access & ACCESS4_READ )    
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_READ ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if( ( attr.mode & read_flag ) 
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
@@ -258,7 +258,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( ( arg_ACCESS4.access & ACCESS4_LOOKUP ) && ( attr.type == FSAL_TYPE_DIR ) )
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_LOOKUP ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if( ( attr.mode & exec_flag )
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
@@ -273,7 +273,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( arg_ACCESS4.access & ACCESS4_MODIFY ) 
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_MODIFY ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if ( ( attr.mode & write_flag )
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
@@ -288,7 +288,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( arg_ACCESS4.access & ACCESS4_EXTEND )
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_EXTEND ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if ( ( attr.mode & write_flag )
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
@@ -303,7 +303,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( ( arg_ACCESS4.access & ACCESS4_DELETE ) && ( attr.type == FSAL_TYPE_DIR) )
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_DELETE ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if ( ( attr.mode & write_flag )
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
@@ -318,7 +318,7 @@ int nfs4_op_access(  struct nfs_argop4 * op ,
   if( ( arg_ACCESS4.access & ACCESS4_EXECUTE ) && ( attr.type != FSAL_TYPE_DIR) )
    {
      res_ACCESS4.ACCESS4res_u.resok4.supported |= ACCESS4_EXECUTE ;
-#if !defined( _USE_HPSS_62) && !defined( _USE_HPSS_622)
+#if !defined( _USE_HPSS )
      if ( ( attr.mode & exec_flag )
 	 || ( ( data->pexport->options & EXPORT_OPTION_ROOT) && credentials.user == 0  ) )
 #else
diff --git a/src/cmdline_tools/Convert_FSAL_Handle.c b/src/cmdline_tools/Convert_FSAL_Handle.c
index e98d98f..77b7446 100644
--- a/src/cmdline_tools/Convert_FSAL_Handle.c
+++ b/src/cmdline_tools/Convert_FSAL_Handle.c
@@ -93,7 +93,7 @@
 #include "stuff_alloc.h"
 #include "fsal.h"
 
-#ifdef _USE_HPSS_62
+#ifdef _USE_HPSS
 #include "../FSAL/FSAL_HPSS/HPSSclapiExt/hpssclapiext.h"
 #endif
 
@@ -110,7 +110,7 @@ int main( int argc, char * argv[] )
  char                      exec_name[MAXPATHLEN] ;
  char                    * tempo_exec_name       = NULL ;
  
-#ifdef _USE_HPSS_62
+#ifdef _USE_HPSS
  char                      buffer[CMD_BUFFER_SIZE] ; 
  fsal_handle_t             fsal_handle;
  char                      str[2*CMD_BUFFER_SIZE] ;
@@ -158,7 +158,7 @@ int main( int argc, char * argv[] )
         exit(1);
   }
 
-#ifdef _USE_HPSS_62 
+#ifdef _USE_HPSS
   sscanHandle(&fsal_handle,argv[optind]);
    
   snprintmem( (caddr_t)str, 2*CMD_BUFFER_SIZE, (caddr_t)&fsal_handle.ns_handle, sizeof( ns_ObjHandle_t) )  ;
diff --git a/src/configure.ac b/src/configure.ac
index 6d8b55d..382cbeb 100644
--- a/src/configure.ac
+++ b/src/configure.ac
@@ -311,7 +311,7 @@ AM_CONDITIONAL(USE_MFSL_PROXY_RPCSECGSS, test "$MFSL" = "PROXY_RPCSECGSS")
 AM_CONDITIONAL(USE_MFSL,                 test "$MFSL" != "NONE" ) 
 
 # HPSS version switch 
-AC_ARG_WITH( [hpss-version], AS_HELP_STRING([--with-hpss-version=5.1|6.2|6.2.2 (default=6.2.2)],[specify HPSS version] ),
+AC_ARG_WITH( [hpss-version], AS_HELP_STRING([--with-hpss-version=5.1|6.2|6.2.2|7.1|7.3 (default=6.2.2)],[specify HPSS version] ),
 		HPSS="$withval", HPSS="6.2.2" )
 
 # Database switch (for POSIX FSAL)
@@ -350,6 +350,7 @@ FS_ALL_LIST="PROXY SNMP FUSE POSIX"
 
 case $FSAL in
 	HPSS)
+		AC_DEFINE([_USE_HPSS], 1, [GANESHA is compiled with HPSS FSAL])
 		FSAL_CFLAGS="-I/opt/hpss/include"
 		FSAL_LDFLAGS="-L/opt/hpss/lib -Wl,-rpath,/opt/hpss/lib -lhpss"
         	FSAL_LIB="\$(top_builddir)/FSAL/FSAL_HPSS/libfsalhpss.la \$(top_builddir)/FSAL/FSAL_HPSS/HPSSclapiExt/libhpssapiext.la"
@@ -358,18 +359,8 @@ case $FSAL in
 
 		case "$HPSS" in
 			"5.1")
-				AC_DEFINE([_USE_HPSS_51], 1, [Using HPSS version 5.1])
 				FSAL_LDFLAGS="$FSAL_LDFLAGS -L/opt/dcelocal/lib -ldce -ldcepthreads"
 				;;
-			"6.2")
-				AC_DEFINE([_USE_HPSS_62], 1, [Using HPSS version 6.2])
-                                ;;
-			"6.2.2")
-				AC_DEFINE([_USE_HPSS_622], 1, [Using HPSS version 6.2.2])
-                                ;;
-			*)
-				AC_MSG_ERROR([Never heard about this HPSS release ! ($HPSS)])
-				;;
 		esac 
 		;;
 	PROXY)
diff --git a/src/connectathon/basic/connectathon.tests.conf b/src/connectathon/basic/connectathon.tests.conf
index 4820838..d22d9ae 100644
--- a/src/connectathon/basic/connectathon.tests.conf
+++ b/src/connectathon/basic/connectathon.tests.conf
@@ -1,8 +1,5 @@
 test_params {
-	#test_directory = "/mnt/TEST_64/connectathon_2" ;
-	#test_directory = "/mnt/posix_fs/connectathon" ;
-	#test_directory = "/mnt/proxy/itchy/root/phil/rep" ;
-	test_directory = "/mnt/phil/rep" ;
+	test_directory = "/mnt/nfs/connectathon";
 	#test_directory = " /mnt/proxy/itchy/root/phil/tmp/conn" ;
         log_file = "/tmp/logfile.txt";
 
diff --git a/src/include/FSAL/FSAL_HPSS/fsal_types.h b/src/include/FSAL/FSAL_HPSS/fsal_types.h
index 43a5ded..74a252f 100644
--- a/src/include/FSAL/FSAL_HPSS/fsal_types.h
+++ b/src/include/FSAL/FSAL_HPSS/fsal_types.h
@@ -90,13 +90,14 @@
 /*
  * FS relative includes
  */
+#include <hpss_version.h>
 
-#if defined(_USE_HPSS_51)
+#if HPSS_MAJOR_VERSION == 5
 
 #include <u_signed64.h> /* for cast64 function */
 #include <hpss_api.h>
 
-#elif defined (_USE_HPSS_62) || defined ( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
 
 #include <u_signed64.h> /* for cast64 function */
 #include <hpss_api.h>
@@ -161,7 +162,7 @@ typedef struct fsal_handle__ {
   
 /** FSAL security context */
 
-#ifdef _USE_HPSS_51
+#if HPSS_MAJOR_VERSION == 5
 
 typedef struct {
   
@@ -171,7 +172,7 @@ typedef struct {
 } fsal_cred_t;
 
 
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
 
 typedef struct {
   
@@ -200,10 +201,10 @@ typedef struct {
       
 } fsal_op_context_t;
 
-#ifdef _USE_HPSS_51
+#if (HPSS_MAJOR_VERSION == 5)
 #define FSAL_OP_CONTEXT_TO_UID( pcontext ) ( pcontext->credential.hpss_usercred.SecPwent.Uid )
 #define FSAL_OP_CONTEXT_TO_GID( pcontext ) ( pcontext->credential.hpss_usercred.SecPwent.Gid )
-#elif defined( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
 #define FSAL_OP_CONTEXT_TO_UID( pcontext ) ( pcontext->credential.hpss_usercred.Uid )
 #define FSAL_OP_CONTEXT_TO_GID( pcontext ) ( pcontext->credential.hpss_usercred.Gid )
 #endif
@@ -218,30 +219,34 @@ typedef struct fsal_dir__ {
 
 /** FSAL file descriptor */
 
-#ifdef _USE_HPSS_51
+#if (HPSS_MAJOR_VERSION == 5)
 
 typedef struct fsal_file__ {
     int              filedes;   /* file descriptor. */
     gss_token_t      fileauthz; /* data access credential. */
 } fsal_file_t;
 
-#define FSAL_FILENO( p_fsal_file )  ( (p_fsal_file)->filedes )
-
-#elif defined ( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6)
 
 typedef struct fsal_file__ {
     int                 filedes;   /* file descriptor. */
     hpss_authz_token_t  fileauthz; /* data access credential. */
 } fsal_file_t;
 
-#define FSAL_FILENO( p_fsal_file )  ( (p_fsal_file)->filedes )
+#elif (HPSS_MAJOR_VERSION == 7)
+
+typedef struct fsal_file__ {
+    int                 filedes;   /* file descriptor. */
+} fsal_file_t;
 
 #endif
+
+#define FSAL_FILENO( p_fsal_file )  ( (p_fsal_file)->filedes )
     
 
 /** HPSS specific init info */
 
-#ifdef _USE_HPSS_51
+#if (HPSS_MAJOR_VERSION == 5)
 
 typedef struct fs_specific_initinfo__{
 
@@ -268,7 +273,7 @@ typedef struct fs_specific_initinfo__{
     
 } fs_specific_initinfo_t;
 
-#elif defined ( _USE_HPSS_62 ) || defined ( _USE_HPSS_622 )
+#elif (HPSS_MAJOR_VERSION == 6) || (HPSS_MAJOR_VERSION == 7)
 
 typedef struct fs_specific_initinfo__{
 
diff --git a/src/include/fsal_types.h b/src/include/fsal_types.h
index a09447f..e30702b 100644
--- a/src/include/fsal_types.h
+++ b/src/include/fsal_types.h
@@ -246,7 +246,7 @@ typedef enum fsal_nodetype__
 
 #include "FSAL/FSAL_GHOST_FS/fsal_types.h"
 
-#elif defined(_USE_HPSS_51) || defined(_USE_HPSS_62) || defined(_USE_HPSS_622)
+#elif defined(_USE_HPSS)
 
 #include "FSAL/FSAL_HPSS/fsal_types.h"
 
@@ -779,7 +779,7 @@ typedef struct fsal_buffdesc__ {
 #define FSAL_DIGEST_SIZE_FILEID3 (sizeof(fsal_u64_t))
 #define FSAL_DIGEST_SIZE_FILEID4 (sizeof(fsal_u64_t))
 
-#if defined(_USE_HPSS_51) || defined(_USE_HPSS_62) || defined(_USE_HPSS_622) || defined(_USE_POSIX)
+#if defined(_USE_HPSS) || defined(_USE_POSIX)
   /* In HPSS, the file handle contains object type. */
 #define FSAL_DIGEST_SIZE_NODETYPE (sizeof(fsal_nodetype_t))
   
@@ -800,7 +800,7 @@ typedef enum fsal_digesttype_t {
   FSAL_DIGEST_FILEID3,    
   FSAL_DIGEST_FILEID4
   
-#if defined(_USE_HPSS_51) || defined(_USE_HPSS_62) || defined(_USE_HPSS_622) || defined(_USE_POSIX)
+#if defined(_USE_HPSS) || defined(_USE_POSIX)
   /* In HPSS, the object type can be
    * extracted from the handle.
    */
