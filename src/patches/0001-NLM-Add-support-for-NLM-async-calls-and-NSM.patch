From f297a85d3a3f928dae016e96b1eb295de146f84b Mon Sep 17 00:00:00 2001
From: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date: Thu, 6 May 2010 11:26:00 +0530
Subject: [PATCH] NLM: Add support for NLM async calls and NSM

This patch add support for different NLM Async services. The patch also contain
NSM support. I also fixed some of the NLM related bug found during testing.

The patch updates NLM to not take fcntl lock on local file system. There is
no easy way to do that in a threaded file server like ganesha that also garbage
collect file descriptor. What the above implies is even if a client has taken
the lock on a file object, application running locally on the server will still
be able to take the lock. Going forward to make sure multiple file servers like
SAMBA and NFS ganesha follow the locking rule we may want to look at the use of
CTDB (http://ctdb.samba.org/) which is already used by SAMBA for tracking file locks.

Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
---
 src/FSAL/FSAL_POSIX/fsal_lock.c        |   23 +-
 src/MainNFSD/nfs_init.c                |   16 +-
 src/MainNFSD/nfs_worker_thread.c       |  118 +++---
 src/NFS_Protocols/Makefile.am          |   16 +-
 src/NFS_Protocols/nlm_Cancel.c         |   24 +-
 src/NFS_Protocols/nlm_Cancel_Message.c |  118 +++++
 src/NFS_Protocols/nlm_Granted_Res.c    |  129 +++++
 src/NFS_Protocols/nlm_Lock.c           |   78 ++--
 src/NFS_Protocols/nlm_Lock_Message.c   |  127 +++++
 src/NFS_Protocols/nlm_Sm_Notify.c      |  105 ++++
 src/NFS_Protocols/nlm_Test.c           |   44 +--
 src/NFS_Protocols/nlm_Test_Message.c   |  117 +++++
 src/NFS_Protocols/nlm_Unlock.c         |   64 ++--
 src/NFS_Protocols/nlm_Unlock_Message.c |  116 +++++
 src/XDR/Makefile.am                    |    2 +-
 src/XDR/nlm4.x                         |   13 +
 src/XDR/nlm4_xdr.c                     |  393 ++++++++--------
 src/XDR/nsm.x                          |   52 ++
 src/XDR/nsm_xdr.c                      |   79 +++
 src/include/nfs_proto_functions.h      |   48 ++
 src/include/nlm4.h                     |  584 +++++++++++-----------
 src/include/nlm_async.h                |   49 ++
 src/include/nlm_list.h                 |   28 ++
 src/include/nlm_send_reply.h           |   42 ++
 src/include/nlm_util.h                 |   39 ++-
 src/include/nsm.h                      |   87 ++++
 src/support/Makefile.am                |    2 +-
 src/support/nlm4_send_reply.c          |   86 ++++
 src/support/nlm_async.c                |  140 ++++++
 src/support/nlm_util.c                 |  833 ++++++++++++++++++++++++++++----
 src/support/nsm.c                      |  151 ++++++
 src/test/test_glist.c                  |   16 +
 32 files changed, 2925 insertions(+), 814 deletions(-)
 create mode 100644 src/NFS_Protocols/nlm_Cancel_Message.c
 create mode 100644 src/NFS_Protocols/nlm_Granted_Res.c
 create mode 100644 src/NFS_Protocols/nlm_Lock_Message.c
 create mode 100644 src/NFS_Protocols/nlm_Sm_Notify.c
 create mode 100644 src/NFS_Protocols/nlm_Test_Message.c
 create mode 100644 src/NFS_Protocols/nlm_Unlock_Message.c
 create mode 100644 src/XDR/nsm.x
 create mode 100644 src/XDR/nsm_xdr.c
 create mode 100644 src/include/nlm_async.h
 create mode 100644 src/include/nlm_send_reply.h
 create mode 100644 src/include/nsm.h
 create mode 100644 src/support/nlm4_send_reply.c
 create mode 100644 src/support/nlm_async.c
 create mode 100644 src/support/nsm.c

diff --git a/src/FSAL/FSAL_POSIX/fsal_lock.c b/src/FSAL/FSAL_POSIX/fsal_lock.c
index 413d0cf..f9105eb 100644
--- a/src/FSAL/FSAL_POSIX/fsal_lock.c
+++ b/src/FSAL/FSAL_POSIX/fsal_lock.c
@@ -84,23 +84,18 @@ fsal_status_t FSAL_lock(fsal_file_t * obj_handle,
    * a child and do a waiting lock
    */
   retval = fcntl(fd, F_SETLK, &ldesc->flock);
-  if(retval && ((errno == EACCES) || (errno == EAGAIN)))
+  if (retval)
     {
-      if(blocking)
-        {
-          /*
-           * Conflicting lock present create a child and
-           * do F_SETLKW if we can block. The lock is already
-           * added to the blocking list.
-           */
-          do_blocking_lock(obj_handle, ldesc);
-          /* We need to send NLM4_BLOCKED reply */
-          Return(posix2fsal_error(errno), errno, INDEX_FSAL_lock);
-        }
+      if ((errno == EACCES) || (errno == EAGAIN))
+	{
+	  if (blocking)
+	    {
+	      do_blocking_lock(obj_handle, ldesc);
+	    }
+	}
       Return(posix2fsal_error(errno), errno, INDEX_FSAL_lock);
-
     }
-  /* granted lock. Now ask NSM to monitor the host */
+  /* granted lock */
   Return(ERR_FSAL_NO_ERROR, 0, INDEX_FSAL_lock);
 }
 
diff --git a/src/MainNFSD/nfs_init.c b/src/MainNFSD/nfs_init.c
index 49f8780..35ae393 100644
--- a/src/MainNFSD/nfs_init.c
+++ b/src/MainNFSD/nfs_init.c
@@ -206,10 +206,6 @@ int nfs_print_param_config(nfs_parameter_t * p_nfs_param)
   return 0;
 }                               /* nfs_print_param_config */
 
-#ifdef _USE_NLM
-extern void nlm_init_locklist(void);
-#endif
-
 /**
  * nfs_set_param_default:
  * Set p_nfs_param structure to default parameters.
@@ -543,10 +539,6 @@ int nfs_set_param_default(nfs_parameter_t * p_nfs_param)
   p_nfs_param->extern_param.snmp_adm.export_fsal_calls_detail = FALSE;
 #endif
 
-#ifdef _USE_NLM
-  nlm_init_locklist();
-#endif
-
   return 0;
 }                               /* nfs_set_param_default */
 
@@ -1848,6 +1840,14 @@ int nfs_start(nfs_parameter_t * p_nfs_param, nfs_start_info_t * p_start_info)
     }
   else
     {
+#ifdef _USE_NLM
+      /*
+       * initialize nlm only in actual server mode.
+       * Don't do this in flusher mode
+       */
+      nlm_init();
+#endif
+
       /* Populate the ID_MAPPER file with mapping file if needed */
       if(!strncmp(nfs_param.uidmap_cache_param.mapfile, "", MAXPATHLEN))
         {
diff --git a/src/MainNFSD/nfs_worker_thread.c b/src/MainNFSD/nfs_worker_thread.c
index 6689d57..dd8224d 100644
--- a/src/MainNFSD/nfs_worker_thread.c
+++ b/src/MainNFSD/nfs_worker_thread.c
@@ -247,86 +247,85 @@ const nfs_function_desc_t mnt3_func_desc[] = {
 #ifdef _USE_NLM
 const nfs_function_desc_t nlm4_func_desc[] = {
   [NLMPROC4_NULL] = {
-                     nlm_Null, nlm_Null_Free, (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-                     "nlm_Null", NOTHING_SPECIAL},
+    nlm_Null, nlm_Null_Free, (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm_Null", NOTHING_SPECIAL},
   [NLMPROC4_TEST] = {
-                     nlm4_Test, nlm4_Test_Free, (xdrproc_t) xdr_nlm4_testargs,
-                     (xdrproc_t) xdr_nlm4_testres, "nlm4_Test", NEEDS_CRED},
+    nlm4_Test, nlm4_Test_Free, (xdrproc_t) xdr_nlm4_testargs,
+    (xdrproc_t) xdr_nlm4_testres, "nlm4_Test", NEEDS_CRED},
   [NLMPROC4_LOCK] = {
-                     nlm4_Lock, nlm4_Lock_Free, (xdrproc_t) xdr_nlm4_lockargs,
-                     (xdrproc_t) xdr_nlm4_res, "nlm4_Lock", NEEDS_CRED},
+    nlm4_Lock, nlm4_Lock_Free, (xdrproc_t) xdr_nlm4_lockargs,
+    (xdrproc_t) xdr_nlm4_res, "nlm4_Lock", NEEDS_CRED},
   [NLMPROC4_CANCEL] = {
-                       nlm4_Cancel, nlm4_Cancel_Free, (xdrproc_t) xdr_nlm4_cancargs,
-                       (xdrproc_t) xdr_nlm4_res, "nlm4_Cancel", NEEDS_CRED},
+    nlm4_Cancel, nlm4_Cancel_Free, (xdrproc_t) xdr_nlm4_cancargs,
+    (xdrproc_t) xdr_nlm4_res, "nlm4_Cancel", NEEDS_CRED},
   [NLMPROC4_UNLOCK] = {
-                       nlm4_Unlock, nlm4_Unlock_Free, (xdrproc_t) xdr_nlm4_unlockargs,
-                       (xdrproc_t) xdr_nlm4_res, "nlm4_Unlock", NEEDS_CRED},
+    nlm4_Unlock, nlm4_Unlock_Free, (xdrproc_t) xdr_nlm4_unlockargs,
+    (xdrproc_t) xdr_nlm4_res, "nlm4_Unlock", NEEDS_CRED},
   [NLMPROC4_GRANTED] = {
-                        nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                        (xdrproc_t) xdr_void, "nlm4_Granted", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Granted", NOTHING_SPECIAL},
   [NLMPROC4_TEST_MSG] = {
-                         nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                         (xdrproc_t) xdr_void, "nlm4_Test_msg", NOTHING_SPECIAL},
+    nlm4_Test_Message, nlm4_Test_Message_Free, (xdrproc_t) xdr_nlm4_testargs,
+    (xdrproc_t) xdr_void, "nlm4_Test_msg", NEEDS_CRED},
   [NLMPROC4_LOCK_MSG] = {
-                         nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                         (xdrproc_t) xdr_void, "nlm4_Lock_msg", NOTHING_SPECIAL},
+    nlm4_Lock_Message, nlm4_Lock_Message_Free, (xdrproc_t) xdr_nlm4_lockargs,
+    (xdrproc_t) xdr_void, "nlm4_Lock_msg", NEEDS_CRED},
   [NLMPROC4_CANCEL_MSG] = {
-                           nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                           (xdrproc_t) xdr_void, "nlm4_Cancel_msg", NOTHING_SPECIAL},
+    nlm4_Cancel_Message, nlm4_Cancel_Message_Free, (xdrproc_t) xdr_nlm4_cancargs,
+    (xdrproc_t) xdr_void, "nlm4_Cancel_msg", NEEDS_CRED},
   [NLMPROC4_UNLOCK_MSG] = {
-                           nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                           (xdrproc_t) xdr_void, "nlm4_Unlock_msg", NOTHING_SPECIAL},
+    nlm4_Unlock_Message, nlm4_Unlock_Message_Free, (xdrproc_t) xdr_nlm4_unlockargs,
+    (xdrproc_t) xdr_void, "nlm4_Unlock_msg", NEEDS_CRED},
   [NLMPROC4_GRANTED_MSG] = {
-                            nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                            (xdrproc_t) xdr_void, "nlm4_Granted_msg", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Granted_msg", NOTHING_SPECIAL},
   [NLMPROC4_TEST_RES] = {
-                         nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                         (xdrproc_t) xdr_void, "nlm4_Test_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Test_res", NOTHING_SPECIAL},
   [NLMPROC4_LOCK_RES] = {
-                         nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                         (xdrproc_t) xdr_void, "nlm4_Lock_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Lock_res", NOTHING_SPECIAL},
   [NLMPROC4_CANCEL_RES] = {
-                           nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                           (xdrproc_t) xdr_void, "nlm4_Cancel_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Cancel_res", NOTHING_SPECIAL},
   [NLMPROC4_UNLOCK_RES] = {
-                           nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                           (xdrproc_t) xdr_void, "nlm4_Unlock_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Unlock_res", NOTHING_SPECIAL},
   [NLMPROC4_GRANTED_RES] = {
-                            nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
-                            (xdrproc_t) xdr_void, "nlm4_Granted_res", NOTHING_SPECIAL},
-/* gap fill */
-  [16] = {
-          nlm4_Unsupported, nlm4_Unsupported_Free,
-          (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-          "nlm4_Granted_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free, (xdrproc_t) xdr_void,
+    (xdrproc_t) xdr_void, "nlm4_Granted_res", NOTHING_SPECIAL},
+  [NLMPROC4_SM_NOTIFY] = {
+    nlm4_Sm_Notify, nlm4_Sm_Notify_Free,
+    (xdrproc_t) xdr_nlm4_sm_notifyargs, (xdrproc_t) xdr_void,
+    "nlm4_sm_notify", NOTHING_SPECIAL},
   [17] = {
-          nlm4_Unsupported, nlm4_Unsupported_Free,
-          (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-          "nlm4_Granted_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Granted_res", NOTHING_SPECIAL},
   [18] = {
-          nlm4_Unsupported, nlm4_Unsupported_Free,
-          (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-          "nlm4_Granted_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Granted_res", NOTHING_SPECIAL},
   [19] = {
-          nlm4_Unsupported, nlm4_Unsupported_Free,
-          (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-          "nlm4_Granted_res", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Granted_res", NOTHING_SPECIAL},
   [NLMPROC4_SHARE] {
-                    nlm4_Unsupported, nlm4_Unsupported_Free,
-                    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-                    "nlm4_Share", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Share", NOTHING_SPECIAL},
   [NLMPROC4_UNSHARE] = {
-                        nlm4_Unsupported, nlm4_Unsupported_Free,
-                        (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-                        "nlm4_Unshare", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Unshare", NOTHING_SPECIAL},
   [NLMPROC4_NM_LOCK] = {
-                        nlm4_Unsupported, nlm4_Unsupported_Free,
-                        (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-                        "nlm4_Nm_lock", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Nm_lock", NOTHING_SPECIAL},
   [NLMPROC4_FREE_ALL] = {
-                         nlm4_Unsupported, nlm4_Unsupported_Free,
-                         (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
-                         "nlm4_Free_all", NOTHING_SPECIAL},
+    nlm4_Unsupported, nlm4_Unsupported_Free,
+    (xdrproc_t) xdr_void, (xdrproc_t) xdr_void,
+    "nlm4_Free_all", NOTHING_SPECIAL},
 };
 #endif
 
@@ -465,9 +464,6 @@ static void nfs_rpc_execute(nfs_request_data_t * preqnfs,
           if(ptr_req->rq_proc > NLMPROC4_FREE_ALL)
             {
               DisplayLog("NFS DISPATCHER: NLM proc number %d unknown", ptr_req->rq_proc);
-              printf("Unhandled NLM request: Program %d, Version %d, Function %d\n",
-                     (int)ptr_req->rq_prog, (int)ptr_req->rq_vers, (int)ptr_req->rq_proc);
-
               svcerr_decode(ptr_svc);
               return;
             }
diff --git a/src/NFS_Protocols/Makefile.am b/src/NFS_Protocols/Makefile.am
index b9a3549..756db73 100644
--- a/src/NFS_Protocols/Makefile.am
+++ b/src/NFS_Protocols/Makefile.am
@@ -99,11 +99,17 @@ libnfsproto_la_SOURCES = mnt_Export.c			  \
                          ../include/nfs_file_handle.h
 
 if USE_NLM
-libnfsproto_la_SOURCES += nlm_Unlock.c	  \
-                          nlm_Cancel.c	  \
-                          nlm_Lock.c	  \
-                          nlm_Test.c	  \
-                          nlm_Null.c			  
+libnfsproto_la_SOURCES += nlm_Unlock.c	  	\
+                          nlm_Cancel.c	  	\
+                          nlm_Lock.c	  	\
+                          nlm_Test.c	  	\
+                          nlm_Null.c	  	\
+                          nlm_Sm_Notify.c 	\
+                          nlm_Test_Message.c	\
+                          nlm_Cancel_Message.c	\
+                          nlm_Lock_Message.c	\
+                          nlm_Unlock_Message.c  \
+                          nlm_Granted_Res.c
 endif
 
 
diff --git a/src/NFS_Protocols/nlm_Cancel.c b/src/NFS_Protocols/nlm_Cancel.c
index adb336d..7541967 100644
--- a/src/NFS_Protocols/nlm_Cancel.c
+++ b/src/NFS_Protocols/nlm_Cancel.c
@@ -61,12 +61,10 @@
 #include "nfs_proto_functions.h"
 #include "nlm_util.h"
 
-static void do_cancel_lock(nlm_lock_t * nlmb)
+static void do_cancel_lock(nlm_lock_entry_t *nlm_entry)
 {
-  /* kill the child waiting on the lock */
-
   /* remove the lock from the blocklist */
-  nlm_remove_from_locklist(nlmb);
+  nlm_remove_from_locklist(nlm_entry);
 }
 
 /**
@@ -90,18 +88,22 @@ int nlm4_Cancel(nfs_arg_t * parg /* IN     */ ,
                 struct svc_req *preq /* IN     */ ,
                 nfs_res_t * pres /* OUT    */ )
 {
-  nlm_lock_t *nlmb;
-  fsal_file_t *fd;
-  fsal_status_t retval;
   nlm4_cancargs *arg;
   cache_entry_t *pentry;
   fsal_attrib_list_t attr;
+  nlm_lock_entry_t *nlm_entry;
   cache_inode_status_t cache_status;
   cache_inode_fsal_data_t fsal_data;
 
   DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
                     "REQUEST PROCESSING: Calling nlm4_Lock");
 
+  if (in_nlm_grace_period())
+    {
+      pres->res_nlm4test.test_stat.stat = NLM4_DENIED_GRACE_PERIOD;
+      return NFS_REQ_OK;
+    }
+
   /* Convert file handle into a cache entry */
   arg = &parg->arg_nlm4_cancel;
   if(!nfs3_FhandleToFSAL((nfs_fh3 *) & (arg->alock.fh), &fsal_data.handle, pcontext))
@@ -123,14 +125,14 @@ int nlm4_Cancel(nfs_arg_t * parg /* IN     */ ,
       pres->res_nlm4.stat.stat = NLM4_STALE_FH;
       return NFS_REQ_OK;
     }
-  fd = &pentry->object.file.open_fd.fd;
-  nlmb = nlm_find_lock_entry(&(arg->alock), arg->exclusive, NLM4_BLOCKED);
-  if(!nlmb)
+  nlm_entry = nlm_find_lock_entry(&(arg->alock), arg->exclusive, NLM4_BLOCKED);
+  if (!nlm_entry)
     {
       pres->res_nlm4.stat.stat = NLM4_DENIED;
       return NFS_REQ_OK;
     }
-  do_cancel_lock(nlmb);
+  do_cancel_lock(nlm_entry);
+  nlm_lock_entry_dec_ref(nlm_entry);
   pres->res_nlm4.stat.stat = NLM4_GRANTED;
   return NFS_REQ_OK;
 }                               /* nlm4_Cancel */
diff --git a/src/NFS_Protocols/nlm_Cancel_Message.c b/src/NFS_Protocols/nlm_Cancel_Message.c
new file mode 100644
index 0000000..7685e06
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Cancel_Message.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: M. Mohan Kumar <mohan@in.ibm.com>
+ *               Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+#include "nlm4.h"
+#include "nlm_async.h"
+#include "nlm_send_reply.h"
+
+static void nlm4_cancel_message_resp(void *arg)
+{
+  nlm_async_res_t *res = arg;
+  nlm_send_reply(NLMPROC4_CANCEL_RES, res->caller_name, &(res->pres), NULL);
+  Mem_Free(arg);
+}
+
+/* Asynchronous Message Entry Point */
+
+/**
+ * nlm4_Cancel_Message: Cancel Lock Message
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+int nlm4_Cancel_Message(nfs_arg_t * parg /* IN     */ ,
+                exportlist_t * pexport /* IN     */ ,
+                fsal_op_context_t * pcontext /* IN     */ ,
+                cache_inode_client_t * pclient /* INOUT  */ ,
+                hash_table_t * ht /* INOUT  */ ,
+                struct svc_req *preq /* IN     */ ,
+                nfs_res_t * pres /* OUT    */ )
+{
+  nlm_async_res_t *arg;
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+                    "REQUEST PROCESSING: Calling nlm_Cancel_Message");
+  nlm4_Cancel(parg, pexport, pcontext, pclient, ht, preq, pres);
+  arg = nlm_build_async_res(parg->arg_nlm4_cancel.alock.caller_name, pres);
+  nlm_async_callback(nlm4_cancel_message_resp, arg);
+
+  return NFS_REQ_OK;
+}
+
+/**
+ * nlm4_Cancel_Message_Free: Frees the result structure allocated for nlm4_Lock
+ *
+ * Frees the result structure allocated for nlm4_Lock. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Cancel_Message_Free(nfs_res_t * pres)
+{
+    return;
+}
diff --git a/src/NFS_Protocols/nlm_Granted_Res.c b/src/NFS_Protocols/nlm_Granted_Res.c
new file mode 100644
index 0000000..8e02111
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Granted_Res.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: M. Mohan Kumar <mohan@in.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+#include "nlm4.h"
+#include "nlm_async.h"
+
+/**
+ * nlm4_Granted_Res: Lock Granted Result Handler
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+int nlm4_Granted_Res(nfs_arg_t * parg /* IN     */ ,
+              exportlist_t * pexport /* IN     */ ,
+              fsal_op_context_t * pcontext /* IN     */ ,
+              cache_inode_client_t * pclient /* INOUT  */ ,
+              hash_table_t * ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t * pres /* OUT    */ )
+{
+  nlm4_res *arg;
+  nlm_lock_entry_t *nlm_entry;
+
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+		    "REQUEST PROCESSING: Calling nlm_Granted_Res");
+
+  arg = &parg->arg_nlm4_res;
+  nlm_entry = nlm_find_lock_entry_by_cookie(&arg->cookie);
+  if (!nlm_entry)
+    return NFS_REQ_OK;
+
+  if (arg->stat.stat == NLM4_DENIED_GRACE_PERIOD)
+    {
+      DisplayLogLevel(NIV_MAJ,
+		      "%s: Granted call failed due to client grace period\n");
+      DisplayLogLevel(NIV_MAJ, "Retrying...\n");
+
+      /*
+       * nlm_resend_grant_msg will drop the lock entry ref count
+       */
+      nlm_async_callback(nlm_resend_grant_msg, (void *)nlm_entry);
+    }
+  else
+    nlm_lock_entry_dec_ref(nlm_entry);
+  /*
+   * Consider all other return status as success
+   * nlm_entry is already marked NLM4_GRANTED
+   */
+  return NFS_REQ_OK;
+}
+
+/**
+ * nlm4_Granted_Res_Free: Frees the result structure allocated for
+ * nlm4_Granted_Res
+ *
+ * Frees the result structure allocated for nlm4_Granted_Res. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Granted_Res_Free(nfs_res_t * pres)
+{
+    return;
+}
diff --git a/src/NFS_Protocols/nlm_Lock.c b/src/NFS_Protocols/nlm_Lock.c
index 82e626d..6ebb059 100644
--- a/src/NFS_Protocols/nlm_Lock.c
+++ b/src/NFS_Protocols/nlm_Lock.c
@@ -61,17 +61,6 @@
 #include "nfs_proto_functions.h"
 #include "nlm_util.h"
 
-static int nlm_should_track(nlm_lock_t * nlmb)
-{
-  if(nlmb->state == NLM4_GRANTED)
-    return 1;
-  /*
-   * FIXME!! we should also track NLM4_BLOCKED locks
-   * when we do problem blocke lock support
-   */
-  return 0;
-}
-
 /**
  * nlm4_Lock: Set a range lock
  *
@@ -93,13 +82,10 @@ int nlm4_Lock(nfs_arg_t * parg /* IN     */ ,
               struct svc_req *preq /* IN     */ ,
               nfs_res_t * pres /* OUT    */ )
 {
-  fsal_file_t *fd;
-  fsal_status_t retval;
   nlm4_lockargs *arg;
   cache_entry_t *pentry;
   fsal_attrib_list_t attr;
-  fsal_lockdesc_t *lock_desc;
-  nlm_lock_t *nlmb = NULL;
+  nlm_lock_entry_t *nlm_entry = NULL;
   cache_inode_status_t cache_status;
   cache_inode_fsal_data_t fsal_data;
 
@@ -127,51 +113,45 @@ int nlm4_Lock(nfs_arg_t * parg /* IN     */ ,
       pres->res_nlm4.stat.stat = NLM4_STALE_FH;
       return NFS_REQ_OK;
     }
-  fd = &pentry->object.file.open_fd.fd;
-  lock_desc = nlm_lock_to_fsal_lockdesc(&(arg->alock), arg->exclusive);
-  if(!lock_desc)
+
+  /* allow only reclaim lock request during recovery */
+  if (in_nlm_grace_period() && !arg->reclaim)
     {
-      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
+      pres->res_nlm4.stat.stat = NLM4_DENIED_GRACE_PERIOD;
       return NFS_REQ_OK;
     }
-  /*
-   * add to the lock list expecting that we will probably block
-   * This make sure that FSAL can safely create a child and wait
-   * on lock without worrying about whether we were able to add
-   * the lock to the block list
-   */
-  nlmb = nlm_add_to_locklist(&(arg->alock), arg->exclusive);
-  if(!nlmb)
+  if (!in_nlm_grace_period() && arg->reclaim)
     {
-      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
+      pres->res_nlm4.stat.stat = NLM4_DENIED_GRACE_PERIOD;
       return NFS_REQ_OK;
     }
 
-  retval = FSAL_lock(fd, lock_desc, arg->block);
-  if(!FSAL_IS_ERROR(retval))
-    {
-      pres->res_nlm4.stat.stat = NLM4_GRANTED;
-    }
-  else
+  /* add the host to monitor list */
+  if (nlm_monitor_host(arg->alock.caller_name))
     {
-      if(fsal_is_retryable(retval) && arg->block)
-        {
-          /* FIXME!! fsal_is_retryable don't check for EACCESS */
-          pres->res_nlm4.stat.stat = NLM4_BLOCKED;
-        }
-      else
-        {
-          pres->res_nlm4.stat.stat = NLM4_DENIED;
-        }
-    }
+      /*
+       * ok failed to register monitor for the host
+       */
+      DisplayLog("Failed to register a monitor for the host %s\n",
+		 arg->alock.caller_name);
+      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
+      return NFS_REQ_OK;
 
-  if(!nlmb)
+    }
+  /*
+   * Add lock details to the lock list. This check for conflicting
+   * locks and add entry with correct state value.
+   */
+  nlm_entry = nlm_add_to_locklist(arg);
+  if (!nlm_entry)
     {
-      nlmb->state = pres->res_nlm4.stat.stat;
-      if(!nlm_should_track(nlmb))
-        nlm_remove_from_locklist(nlmb);
+      /* We failed to create a lock entry and add to the list */
+      nlm_unmonitor_host(arg->alock.caller_name);
+      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
+      return NFS_REQ_OK;
     }
-  Mem_Free(lock_desc);
+  pres->res_nlm4.stat.stat = nlm_entry->state;
+  nlm_lock_entry_dec_ref(nlm_entry);
   return NFS_REQ_OK;
 }
 
diff --git a/src/NFS_Protocols/nlm_Lock_Message.c b/src/NFS_Protocols/nlm_Lock_Message.c
new file mode 100644
index 0000000..593e9ba
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Lock_Message.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: M. Mohan Kumar <mohan@in.ibm.com>
+ *               Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+#include "nlm4.h"
+#include "nlm_async.h"
+#include "nlm_send_reply.h"
+
+
+static void nlm4_lock_message_resp(void *arg)
+{
+  int proc;
+  nlm_async_res_t *res = arg;
+
+  if (res->pres.res_nlm4.stat.stat == NLM4_GRANTED) {
+    proc = NLMPROC4_GRANTED_MSG;
+  } else {
+    proc = NLMPROC4_LOCK_RES;
+  }
+  nlm_send_reply(proc, res->caller_name, &(res->pres), NULL);
+  Mem_Free(arg);
+}
+
+/**
+ * nlm4_Lock_Message: Lock Message
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+int nlm4_Lock_Message(nfs_arg_t * parg /* IN     */ ,
+              exportlist_t * pexport /* IN     */ ,
+              fsal_op_context_t * pcontext /* IN     */ ,
+              cache_inode_client_t * pclient /* INOUT  */ ,
+              hash_table_t * ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t * pres /* OUT    */ )
+{
+  nlm_async_res_t *arg;
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+		    "REQUEST PROCESSING: Calling nlm_Lock_Message");
+
+  nlm4_Lock(parg, pexport, pcontext, pclient, ht, preq, pres);
+
+  arg = nlm_build_async_res(parg->arg_nlm4_lock.alock.caller_name, pres);
+  nlm_async_callback(nlm4_lock_message_resp, arg);
+
+  return NFS_REQ_OK;
+
+}
+
+/**
+ * nlm4_Lock_Message_Free: Frees the result structure allocated for nlm4_Lock
+ *
+ * Frees the result structure allocated for nlm4_Lock. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Lock_Message_Free(nfs_res_t * pres)
+{
+    return;
+}
diff --git a/src/NFS_Protocols/nlm_Sm_Notify.c b/src/NFS_Protocols/nlm_Sm_Notify.c
new file mode 100644
index 0000000..2b0e4e8
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Sm_Notify.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.v  <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+
+/**
+ * nlm4_Sm_Notify: NSM notification
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+
+int nlm4_Sm_Notify(nfs_arg_t * parg /* IN     */ ,
+                exportlist_t * pexport /* IN     */ ,
+                fsal_op_context_t * pcontext /* IN     */ ,
+                cache_inode_client_t * pclient /* INOUT  */ ,
+                hash_table_t * ht /* INOUT  */ ,
+                struct svc_req *preq /* IN     */ ,
+                nfs_res_t * pres /* OUT    */ )
+{
+  nlm4_sm_notifyargs *arg;
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+                    "REQUEST PROCESSING: Calling nlm4_sm_notify");
+
+  arg = &parg->arg_nlm4_sm_notify;
+  nlm_node_recovery(arg->name, pcontext, pclient, ht);
+  return NFS_REQ_OK;
+}
+
+/**
+ * nlm4_Sm_Notify_Free: Frees the result structure allocated for nlm4_Sm_Notify
+ *
+ * Frees the result structure allocated for nlm4_Sm_Notify. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Sm_Notify_Free(nfs_res_t * pres)
+{
+  return;
+}
diff --git a/src/NFS_Protocols/nlm_Test.c b/src/NFS_Protocols/nlm_Test.c
index 0c886f6..92f0185 100644
--- a/src/NFS_Protocols/nlm_Test.c
+++ b/src/NFS_Protocols/nlm_Test.c
@@ -82,25 +82,23 @@ int nlm4_Test(nfs_arg_t * parg /* IN     */ ,
               struct svc_req *preq /* IN     */ ,
               nfs_res_t * pres /* OUT    */ )
 {
-  fsal_file_t *fd;
-  fsal_status_t retval;
   nlm4_testargs *arg;
   cache_entry_t *pentry;
   fsal_attrib_list_t attr;
-  fsal_lockdesc_t *lock_desc;
+  nlm_lock_entry_t *nlm_entry;
   cache_inode_status_t cache_status;
   cache_inode_fsal_data_t fsal_data;
 
   DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
                     "REQUEST PROCESSING: Calling nlm_Test");
 
-  /* Convert file handle into a cache entry */
+  if (in_nlm_grace_period())
+    {
+      pres->res_nlm4test.test_stat.stat = NLM4_DENIED_GRACE_PERIOD;
+      return NFS_REQ_OK;
+    }
 
-  /* FIXME!!
-   * NFS helper functions are really confusing. So code
-   * it here.
-   */
-  /* FIXME!! right now we look at only nfs3 handles */
+  /* Convert file handle into a cache entry */
   arg = &parg->arg_nlm4_test;
   if(!nfs3_FhandleToFSAL((nfs_fh3 *) & (arg->alock.fh), &fsal_data.handle, pcontext))
     {
@@ -121,31 +119,19 @@ int nlm4_Test(nfs_arg_t * parg /* IN     */ ,
       pres->res_nlm4test.test_stat.stat = NLM4_STALE_FH;
       return NFS_REQ_OK;
     }
-  fd = &pentry->object.file.open_fd.fd;
-  lock_desc = nlm_lock_to_fsal_lockdesc(&(arg->alock), arg->exclusive);
-  if(!lock_desc)
+  nlm_entry = nlm_overlapping_entry(&(arg->alock), arg->exclusive);
+  if (!nlm_entry)
     {
-      pres->res_nlm4test.test_stat.stat = NLM4_DENIED_NOLOCKS;
-      /* FIXME!!
-       * should we update the attribute values here now that
-       * now that we are able to find the inode
-       */
-      return NFS_REQ_OK;
+      pres->res_nlm4test.test_stat.stat = NLM4_GRANTED;
     }
-
-  retval = FSAL_getlock(fd, lock_desc);
-  if(!FSAL_IS_ERROR(retval))
+  else
     {
-      lock_desc->flock.l_type = F_UNLCK;
-
-      /* we can place the lock */
-      pres->res_nlm4test.test_stat.stat = NLM4_GRANTED;
-      Mem_Free(lock_desc);
-      return NFS_REQ_OK;
+      pres->res_nlm4test.test_stat.stat = NLM4_DENIED;
+      nlm_lock_entry_to_nlm_holder(nlm_entry,
+				   &pres->res_nlm4test.test_stat.nlm4_testrply_u.holder);
+      nlm_lock_entry_dec_ref(nlm_entry);
     }
 
-  pres->res_nlm4test.test_stat.stat = NLM4_DENIED_NOLOCKS;
-  Mem_Free(lock_desc);
   return NFS_REQ_OK;
 }
 
diff --git a/src/NFS_Protocols/nlm_Test_Message.c b/src/NFS_Protocols/nlm_Test_Message.c
new file mode 100644
index 0000000..0ee8773
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Test_Message.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: M. Mohan Kumar <mohan@in.ibm.com>
+ *               Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+#include "nlm4.h"
+#include "nlm_async.h"
+#include "nlm_send_reply.h"
+
+static void nlm4_test_message_resp(void *arg)
+{
+  nlm_async_res_t *res = arg;
+  nlm_send_reply(NLMPROC4_TEST_RES, res->caller_name, &(res->pres), NULL);
+  Mem_Free(arg);
+}
+
+/**
+ * nlm4_Test_Message: Test lock Message
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+
+int nlm4_Test_Message(nfs_arg_t *parg /* IN     */ ,
+              exportlist_t *pexport /* IN     */ ,
+              fsal_op_context_t *pcontext /* IN     */ ,
+              cache_inode_client_t *pclient /* INOUT  */ ,
+              hash_table_t *ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t *pres /* OUT    */ )
+{
+  struct nlm_async_res *arg;
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+                    "REQUEST PROCESSING: Calling nlm_Test_Message");
+  nlm4_Test(parg, pexport, pcontext, pclient, ht, preq, pres);
+  arg = nlm_build_async_res(parg->arg_nlm4_test.alock.caller_name, pres);
+  nlm_async_callback(nlm4_test_message_resp, arg);
+
+  return NFS_REQ_OK;
+}
+
+/**
+ * nlm_Test_Message_Free: Frees the result structure allocated for nlm_Null
+ *
+ * Frees the result structure allocated for nlm_Null. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Test_Message_Free(nfs_res_t * pres)
+{
+    return;
+}
diff --git a/src/NFS_Protocols/nlm_Unlock.c b/src/NFS_Protocols/nlm_Unlock.c
index c3ca0d5..bb85938 100644
--- a/src/NFS_Protocols/nlm_Unlock.c
+++ b/src/NFS_Protocols/nlm_Unlock.c
@@ -34,6 +34,7 @@
 #include <pthread.h>
 #include <fcntl.h>
 #include <sys/file.h>           /* for having FNDELAY */
+#include <assert.h>
 #include "HashData.h"
 #include "HashTable.h"
 #ifdef _USE_GSSRPC
@@ -82,19 +83,23 @@ int nlm4_Unlock(nfs_arg_t * parg /* IN     */ ,
                 struct svc_req *preq /* IN     */ ,
                 nfs_res_t * pres /* OUT    */ )
 {
-  nlm_lock_t *nlmb;
-  fsal_file_t *fd;
-  fsal_status_t retval;
+  int lck_cnt,lck_state;
   nlm4_unlockargs *arg;
   cache_entry_t *pentry;
   fsal_attrib_list_t attr;
-  fsal_lockdesc_t *lock_desc;
+  nlm_lock_entry_t *nlm_entry;
   cache_inode_status_t cache_status;
   cache_inode_fsal_data_t fsal_data;
 
   DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
                     "REQUEST PROCESSING: Calling nlm4_Lock");
 
+  if (in_nlm_grace_period())
+    {
+      pres->res_nlm4test.test_stat.stat = NLM4_DENIED_GRACE_PERIOD;
+      return NFS_REQ_OK;
+    }
+
   /* Convert file handle into a cache entry */
   arg = &parg->arg_nlm4_unlock;
   if(!nfs3_FhandleToFSAL((nfs_fh3 *) & (arg->alock.fh), &fsal_data.handle, pcontext))
@@ -116,40 +121,31 @@ int nlm4_Unlock(nfs_arg_t * parg /* IN     */ ,
       pres->res_nlm4.stat.stat = NLM4_STALE_FH;
       return NFS_REQ_OK;
     }
-  fd = &pentry->object.file.open_fd.fd;
-  lock_desc = nlm_lock_to_fsal_lockdesc(&(arg->alock), 0);
-  if(!lock_desc)
-    {
-      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
-      return NFS_REQ_OK;
-    }
-  nlmb = nlm_find_lock_entry(&(arg->alock), 0, NLM4_GRANTED);
-  if(!nlmb)
-    {
-      /*FIXME!! XNFS doesn't say what should be the return */
-      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
-      Mem_Free(lock_desc);
-      return NFS_REQ_OK;
-    }
 
-  retval = FSAL_unlock(fd, lock_desc);
-  if(!FSAL_IS_ERROR(retval))
+  /*
+   * nlm_find_lock_entry with state NLM4_GRANTED will search for lock
+   * in both blocked and granted state. We can get an unlock request
+   * even for a lock in blocked state because grant rpc response could
+   * get dropped and the client can think that lock is granted but the
+   * server still consider it locked.
+   */
+  nlm_entry = nlm_find_lock_entry(&(arg->alock), 0, NLM4_GRANTED);
+  if (!nlm_entry)
     {
-      pres->res_nlm4.stat.stat = NLM4_GRANTED;
-      nlm_delete_lock_entry(nlmb, &(arg->alock));
-      Mem_Free(lock_desc);
-      return NFS_REQ_OK;
-    }
-  else
-    {
-      /*FIXME check with RFC Whether we can return nlm4_denied */
-      pres->res_nlm4.stat.stat = NLM4_DENIED;
-      Mem_Free(lock_desc);
+      pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
       return NFS_REQ_OK;
     }
-  /*FIXME check with RFC Whether we can return nlm4_denied */
-  pres->res_nlm4.stat.stat = NLM4_DENIED_NOLOCKS;
-  Mem_Free(lock_desc);
+  lck_state = nlm_lock_entry_get_state(nlm_entry);
+  pres->res_nlm4.stat.stat = NLM4_GRANTED;
+  lck_cnt = nlm_delete_lock_entry(&(arg->alock));
+  nlm_unmonitor_host(arg->alock.caller_name);
+  /*
+   * Now check whether we have blocked locks.
+   * if found grant them the lock
+   */
+  if (lck_state == NLM4_GRANTED)
+    nlm_grant_blocked_locks(&(arg->alock.fh));
+  nlm_lock_entry_dec_ref(nlm_entry);
   return NFS_REQ_OK;
 }
 
diff --git a/src/NFS_Protocols/nlm_Unlock_Message.c b/src/NFS_Protocols/nlm_Unlock_Message.c
new file mode 100644
index 0000000..1923189
--- /dev/null
+++ b/src/NFS_Protocols/nlm_Unlock_Message.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: M. Mohan Kumar <mohan@in.ibm.com>
+ *               Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/file.h>           /* for having FNDELAY */
+#include "HashData.h"
+#include "HashTable.h"
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#include <gssrpc/auth.h>
+#include <gssrpc/pmap_clnt.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#include <rpc/auth.h>
+#include <rpc/pmap_clnt.h>
+#endif
+#include "log_functions.h"
+#include "stuff_alloc.h"
+#include "nfs23.h"
+#include "nfs4.h"
+#include "nfs_core.h"
+#include "cache_inode.h"
+#include "cache_content.h"
+#include "nfs_exports.h"
+#include "nfs_creds.h"
+#include "nfs_tools.h"
+#include "mount.h"
+#include "nfs_proto_functions.h"
+#include "nlm_util.h"
+#include "nlm4.h"
+#include "nlm_async.h"
+#include "nlm_send_reply.h"
+
+static void nlm4_unlock_message_resp(void *arg)
+{
+  nlm_async_res_t *res = arg;
+  nlm_send_reply(NLMPROC4_UNLOCK_RES, res->caller_name, &(res->pres), NULL);
+  Mem_Free(arg);
+}
+
+/**
+ * nlm4_Unlock_Message: Unlock Message
+ *
+ *  @param parg        [IN]
+ *  @param pexportlist [IN]
+ *  @param pcontextp   [IN]
+ *  @param pclient     [INOUT]
+ *  @param ht          [INOUT]
+ *  @param preq        [IN]
+ *  @param pres        [OUT]
+ *
+ */
+int nlm4_Unlock_Message(nfs_arg_t * parg /* IN     */ ,
+                exportlist_t * pexport /* IN     */ ,
+                fsal_op_context_t * pcontext /* IN     */ ,
+                cache_inode_client_t * pclient /* INOUT  */ ,
+                hash_table_t * ht /* INOUT  */ ,
+                struct svc_req *preq /* IN     */ ,
+                nfs_res_t * pres /* OUT    */ )
+{
+  nlm_async_res_t *arg;
+  DisplayLogJdLevel(pclient->log_outputs, NIV_FULL_DEBUG,
+                    "REQUEST PROCESSING: Calling nlm_Unlock_Message");
+  nlm4_Unlock(parg, pexport, pcontext, pclient, ht, preq, pres);
+
+  arg = nlm_build_async_res(parg->arg_nlm4_unlock.alock.caller_name, pres);
+  nlm_async_callback(nlm4_unlock_message_resp, arg);
+  return NFS_REQ_OK;
+}
+
+/**
+ * nlm4_Unlock_Message_Free: Frees the result structure allocated for nlm4_Unlock
+ *
+ * Frees the result structure allocated for nlm4_Unlock. Does Nothing in fact.
+ *
+ * @param pres        [INOUT]   Pointer to the result structure.
+ *
+ */
+void nlm4_Unlock_Message_Free(nfs_res_t * pres)
+{
+    return;
+}
diff --git a/src/XDR/Makefile.am b/src/XDR/Makefile.am
index 23ffd43..2245399 100644
--- a/src/XDR/Makefile.am
+++ b/src/XDR/Makefile.am
@@ -11,7 +11,7 @@ libnfs_mnt_xdr_la_SOURCES = xdr_mount.c           \
                             ../include/extended_types.h
 
 if USE_NLM
-libnfs_mnt_xdr_la_SOURCES += nlm4_xdr.c
+libnfs_mnt_xdr_la_SOURCES += nlm4_xdr.c nsm_xdr.c
 endif
 
 if USE_NFS4_1
diff --git a/src/XDR/nlm4.x b/src/XDR/nlm4.x
index 82c4f6b..7d40243 100644
--- a/src/XDR/nlm4.x
+++ b/src/XDR/nlm4.x
@@ -5,6 +5,9 @@ const LM_MAXSTRLEN = 1024;
 const LM_MAXNAMELEN = 1025;
 const MAXNETOBJ_SZ = 1024;
 
+/* NSM related constatnts */
+const SM_MAXSTRLEN = 1024;
+const SM_PRIV_SZ   = 16;
 /*
  * Basic typedefs for RFC 1832 data type definitions
  */
@@ -135,6 +138,15 @@ struct nlm4_notify {
 	int64_t state;
 };
 
+struct nlm4_sm_notifyargs {
+	string name<SM_MAXSTRLEN>;
+	int32_t state;
+	opaque priv[SM_PRIV_SZ];
+};
+
+#ifdef RPC_HDR
+%extern void nlm_init(void);
+#endif
 
 program NLMPROG {
 	version NLM4_VERS {
@@ -154,6 +166,7 @@ program NLMPROG {
 		void NLMPROC4_CANCEL_RES(nlm4_res)			= 13;
 		void NLMPROC4_UNLOCK_RES(nlm4_res)			= 14;
 		void NLMPROC4_GRANTED_RES(nlm4_res)			= 15;
+		void NLMPROC4_SM_NOTIFY(nlm4_sm_notifyargs)		= 16;
 		nlm4_shareres NLMPROC4_SHARE(nlm4_shareargs)		= 20;
 		nlm4_shareres NLMPROC4_UNSHARE(nlm4_shareargs)		= 21;
 		nlm4_res NLMPROC4_NM_LOCK(nlm4_lockargs)		= 22;
diff --git a/src/XDR/nlm4_xdr.c b/src/XDR/nlm4_xdr.c
index aa5e294..30cc13f 100644
--- a/src/XDR/nlm4_xdr.c
+++ b/src/XDR/nlm4_xdr.c
@@ -5,264 +5,257 @@
 
 #include "nlm4.h"
 
-#if 0
-bool_t xdr_int32_t(XDR * xdrs, int32_t * objp)
+bool_t
+xdr_nlm4_stats (XDR *xdrs, nlm4_stats *objp)
 {
-  register int32_t *buf;
+	register int32_t *buf;
 
-  if(!xdr_int(xdrs, objp))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_uint32_t(XDR * xdrs, uint32_t * objp)
+bool_t
+xdr_nlm4_stat (XDR *xdrs, nlm4_stat *objp)
 {
-  register int32_t *buf;
+	register int32_t *buf;
 
-  if(!xdr_u_int(xdrs, objp))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_nlm4_stats (xdrs, &objp->stat))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_int64_t(XDR * xdrs, int64_t * objp)
+bool_t
+xdr_nlm4_res (XDR *xdrs, nlm4_res *objp)
 {
-  register int32_t *buf;
+	register int32_t *buf;
 
-  if(!xdr_quad_t(xdrs, objp))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_nlm4_stat (xdrs, &objp->stat))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_uint64_t(XDR * xdrs, uint64_t * objp)
+bool_t
+xdr_nlm4_holder (XDR *xdrs, nlm4_holder *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_u_quad_t(xdrs, objp))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, &objp->exclusive))
+		 return FALSE;
+	 if (!xdr_int32_t (xdrs, &objp->svid))
+		 return FALSE;
+	 if (!xdr_netobj (xdrs, &objp->oh))
+		 return FALSE;
+	 if (!xdr_uint64_t (xdrs, &objp->l_offset))
+		 return FALSE;
+	 if (!xdr_uint64_t (xdrs, &objp->l_len))
+		 return FALSE;
+	return TRUE;
 }
-#endif
 
-bool_t xdr_nlm4_stats(XDR * xdrs, nlm4_stats * objp)
+bool_t
+xdr_nlm4_testrply (XDR *xdrs, nlm4_testrply *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_enum(xdrs, (enum_t *) objp))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_nlm4_stats (xdrs, &objp->stat))
+		 return FALSE;
+	switch (objp->stat) {
+	case NLM4_DENIED:
+		 if (!xdr_nlm4_holder (xdrs, &objp->nlm4_testrply_u.holder))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
 }
 
-bool_t xdr_nlm4_stat(XDR * xdrs, nlm4_stat * objp)
+bool_t
+xdr_nlm4_testres (XDR *xdrs, nlm4_testres *objp)
 {
-  register int32_t *buf;
+	register int32_t *buf;
 
-  if(!xdr_nlm4_stats(xdrs, &objp->stat))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_nlm4_testrply (xdrs, &objp->test_stat))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_res(XDR * xdrs, nlm4_res * objp)
+bool_t
+xdr_nlm4_lock (XDR *xdrs, nlm4_lock *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_nlm4_stat(xdrs, &objp->stat))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, &objp->caller_name, LM_MAXSTRLEN))
+		 return FALSE;
+	 if (!xdr_netobj (xdrs, &objp->fh))
+		 return FALSE;
+	 if (!xdr_netobj (xdrs, &objp->oh))
+		 return FALSE;
+	 if (!xdr_int32_t (xdrs, &objp->svid))
+		 return FALSE;
+	 if (!xdr_uint64_t (xdrs, &objp->l_offset))
+		 return FALSE;
+	 if (!xdr_uint64_t (xdrs, &objp->l_len))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_holder(XDR * xdrs, nlm4_holder * objp)
+bool_t
+xdr_nlm4_lockargs (XDR *xdrs, nlm4_lockargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_bool(xdrs, &objp->exclusive))
-    return FALSE;
-  if(!xdr_int32_t(xdrs, &objp->svid))
-    return FALSE;
-  if(!xdr_netobj(xdrs, &objp->oh))
-    return FALSE;
-  if(!xdr_uint64_t(xdrs, &objp->l_offset))
-    return FALSE;
-  if(!xdr_uint64_t(xdrs, &objp->l_len))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->block))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->exclusive))
+		 return FALSE;
+	 if (!xdr_nlm4_lock (xdrs, &objp->alock))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->reclaim))
+		 return FALSE;
+	 if (!xdr_int32_t (xdrs, &objp->state))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_testrply(XDR * xdrs, nlm4_testrply * objp)
+bool_t
+xdr_nlm4_cancargs (XDR *xdrs, nlm4_cancargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_nlm4_stats(xdrs, &objp->stat))
-    return FALSE;
-  switch (objp->stat)
-    {
-    case NLM4_DENIED:
-      if(!xdr_nlm4_holder(xdrs, &objp->nlm4_testrply_u.holder))
-        return FALSE;
-      break;
-    default:
-      break;
-    }
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->block))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->exclusive))
+		 return FALSE;
+	 if (!xdr_nlm4_lock (xdrs, &objp->alock))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_testres(XDR * xdrs, nlm4_testres * objp)
+bool_t
+xdr_nlm4_testargs (XDR *xdrs, nlm4_testargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_nlm4_testrply(xdrs, &objp->test_stat))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->exclusive))
+		 return FALSE;
+	 if (!xdr_nlm4_lock (xdrs, &objp->alock))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_lock(XDR * xdrs, nlm4_lock * objp)
+bool_t
+xdr_nlm4_unlockargs (XDR *xdrs, nlm4_unlockargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_string(xdrs, &objp->caller_name, LM_MAXSTRLEN))
-    return FALSE;
-  if(!xdr_netobj(xdrs, &objp->fh))
-    return FALSE;
-  if(!xdr_netobj(xdrs, &objp->oh))
-    return FALSE;
-  if(!xdr_int32_t(xdrs, &objp->svid))
-    return FALSE;
-  if(!xdr_uint64_t(xdrs, &objp->l_offset))
-    return FALSE;
-  if(!xdr_uint64_t(xdrs, &objp->l_len))
-    return FALSE;
-  return TRUE;
-}
+	register int32_t *buf;
 
-bool_t xdr_nlm4_lockargs(XDR * xdrs, nlm4_lockargs * objp)
-{
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->block))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->exclusive))
-    return FALSE;
-  if(!xdr_nlm4_lock(xdrs, &objp->alock))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->reclaim))
-    return FALSE;
-  if(!xdr_int32_t(xdrs, &objp->state))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_nlm4_lock (xdrs, &objp->alock))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_cancargs(XDR * xdrs, nlm4_cancargs * objp)
+bool_t
+xdr_fsh4_mode (XDR *xdrs, fsh4_mode *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->block))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->exclusive))
-    return FALSE;
-  if(!xdr_nlm4_lock(xdrs, &objp->alock))
-    return FALSE;
-  return TRUE;
-}
+	register int32_t *buf;
 
-bool_t xdr_nlm4_testargs(XDR * xdrs, nlm4_testargs * objp)
-{
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->exclusive))
-    return FALSE;
-  if(!xdr_nlm4_lock(xdrs, &objp->alock))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_unlockargs(XDR * xdrs, nlm4_unlockargs * objp)
+bool_t
+xdr_fsh4_access (XDR *xdrs, fsh4_access *objp)
 {
-  register int32_t *buf;
+	register int32_t *buf;
 
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_nlm4_lock(xdrs, &objp->alock))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_fsh4_mode(XDR * xdrs, fsh4_mode * objp)
+bool_t
+xdr_nlm4_share (XDR *xdrs, nlm4_share *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_enum(xdrs, (enum_t *) objp))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, &objp->caller_name, LM_MAXSTRLEN))
+		 return FALSE;
+	 if (!xdr_netobj (xdrs, &objp->fh))
+		 return FALSE;
+	 if (!xdr_netobj (xdrs, &objp->oh))
+		 return FALSE;
+	 if (!xdr_fsh4_mode (xdrs, &objp->mode))
+		 return FALSE;
+	 if (!xdr_fsh4_access (xdrs, &objp->access))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_fsh4_access(XDR * xdrs, fsh4_access * objp)
+bool_t
+xdr_nlm4_shareargs (XDR *xdrs, nlm4_shareargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_enum(xdrs, (enum_t *) objp))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_nlm4_share (xdrs, &objp->share))
+		 return FALSE;
+	 if (!xdr_bool (xdrs, &objp->reclaim))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_share(XDR * xdrs, nlm4_share * objp)
+bool_t
+xdr_nlm4_shareres (XDR *xdrs, nlm4_shareres *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_string(xdrs, &objp->caller_name, LM_MAXSTRLEN))
-    return FALSE;
-  if(!xdr_netobj(xdrs, &objp->fh))
-    return FALSE;
-  if(!xdr_netobj(xdrs, &objp->oh))
-    return FALSE;
-  if(!xdr_fsh4_mode(xdrs, &objp->mode))
-    return FALSE;
-  if(!xdr_fsh4_access(xdrs, &objp->access))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	 if (!xdr_netobj (xdrs, &objp->cookie))
+		 return FALSE;
+	 if (!xdr_nlm4_stats (xdrs, &objp->stat))
+		 return FALSE;
+	 if (!xdr_int32_t (xdrs, &objp->sequence))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_shareargs(XDR * xdrs, nlm4_shareargs * objp)
+bool_t
+xdr_nlm4_notify (XDR *xdrs, nlm4_notify *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_nlm4_share(xdrs, &objp->share))
-    return FALSE;
-  if(!xdr_bool(xdrs, &objp->reclaim))
-    return FALSE;
-  return TRUE;
-}
+	register int32_t *buf;
 
-bool_t xdr_nlm4_shareres(XDR * xdrs, nlm4_shareres * objp)
-{
-  register int32_t *buf;
-
-  if(!xdr_netobj(xdrs, &objp->cookie))
-    return FALSE;
-  if(!xdr_nlm4_stats(xdrs, &objp->stat))
-    return FALSE;
-  if(!xdr_int32_t(xdrs, &objp->sequence))
-    return FALSE;
-  return TRUE;
+	 if (!xdr_string (xdrs, &objp->name, LM_MAXNAMELEN))
+		 return FALSE;
+	 if (!xdr_int64_t (xdrs, &objp->state))
+		 return FALSE;
+	return TRUE;
 }
 
-bool_t xdr_nlm4_notify(XDR * xdrs, nlm4_notify * objp)
+bool_t
+xdr_nlm4_sm_notifyargs (XDR *xdrs, nlm4_sm_notifyargs *objp)
 {
-  register int32_t *buf;
-
-  if(!xdr_string(xdrs, &objp->name, LM_MAXNAMELEN))
-    return FALSE;
-  if(!xdr_int64_t(xdrs, &objp->state))
-    return FALSE;
-  return TRUE;
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_string (xdrs, &objp->name, SM_MAXSTRLEN))
+		 return FALSE;
+	 if (!xdr_int32_t (xdrs, &objp->state))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->priv, SM_PRIV_SZ))
+		 return FALSE;
+	return TRUE;
 }
diff --git a/src/XDR/nsm.x b/src/XDR/nsm.x
new file mode 100644
index 0000000..4ddf9e2
--- /dev/null
+++ b/src/XDR/nsm.x
@@ -0,0 +1,52 @@
+/* NSM Interface */
+
+/*
+ * This defines the maximum length of the string
+ * identifying the caller.
+ */
+
+const SM_MAXSTRLEN = 1024;
+const SM_PROG = 100024;
+const SM_VERS = 1;
+const SM_MON  = 2;
+const SM_UNMON = 3;
+const SM_UNMON_ALL = 4;
+
+enum res {
+  STAT_SUCC = 0,   /*  NSM agrees to monitor.  */
+  STAT_FAIL = 1    /*  NSM cannot monitor.  */
+};
+
+struct sm_stat_res {
+  res    res_stat;
+  int    state;
+
+};
+
+struct sm_stat
+{
+  int state; /* state number of NSM */
+};
+
+struct my_id {
+  string my_name<SM_MAXSTRLEN>;  /*  hostname  */
+  int    my_prog;                /*  RPC program number  */
+  int    my_vers;                /*  program version number  */
+  int    my_proc;                /*  procedure number  */
+};
+
+struct mon_id {
+  string mon_name<SM_MAXSTRLEN>; /* name of the host to be monitored */
+  struct my_id my_id;
+};
+
+struct mon {
+  struct mon_id mon_id;
+  opaque    priv[16];        /*  private information  */
+};
+
+#ifdef RPC_HDR
+%extern int nsm_monitor(char *host);
+%extern int nsm_unmonitor(char *host);
+%extern int nsm_unmonitor_all(void);
+#endif
diff --git a/src/XDR/nsm_xdr.c b/src/XDR/nsm_xdr.c
new file mode 100644
index 0000000..245a70a
--- /dev/null
+++ b/src/XDR/nsm_xdr.c
@@ -0,0 +1,79 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "nsm.h"
+
+bool_t
+xdr_res (XDR *xdrs, res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_sm_stat_res (XDR *xdrs, sm_stat_res *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_res (xdrs, &objp->res_stat))
+		 return FALSE;
+	 if (!xdr_int (xdrs, &objp->state))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_sm_stat (XDR *xdrs, sm_stat *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_int (xdrs, &objp->state))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_my_id (XDR *xdrs, my_id *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, &objp->my_name, SM_MAXSTRLEN))
+		 return FALSE;
+	 if (!xdr_int (xdrs, &objp->my_prog))
+		 return FALSE;
+	 if (!xdr_int (xdrs, &objp->my_vers))
+		 return FALSE;
+	 if (!xdr_int (xdrs, &objp->my_proc))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_mon_id (XDR *xdrs, mon_id *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, &objp->mon_name, SM_MAXSTRLEN))
+		 return FALSE;
+	 if (!xdr_my_id (xdrs, &objp->my_id))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_mon (XDR *xdrs, mon *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_mon_id (xdrs, &objp->mon_id))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->priv, 16))
+		 return FALSE;
+	return TRUE;
+}
diff --git a/src/include/nfs_proto_functions.h b/src/include/nfs_proto_functions.h
index 8f59566..afae331 100644
--- a/src/include/nfs_proto_functions.h
+++ b/src/include/nfs_proto_functions.h
@@ -119,6 +119,8 @@ typedef union nfs_arg__
   nlm4_lockargs arg_nlm4_lock;
   nlm4_cancargs arg_nlm4_cancel;
   nlm4_unlockargs arg_nlm4_unlock;
+  nlm4_sm_notifyargs arg_nlm4_sm_notify;
+  nlm4_res arg_nlm4_res;
 } nfs_arg_t;
 
 typedef union nfs_res__
@@ -296,6 +298,46 @@ int nlm4_Unlock(nfs_arg_t * parg /* IN     */ ,
                 struct svc_req *preq /* IN     */ ,
                 nfs_res_t * pres /* OUT    */ );
 
+int nlm4_Sm_Notify(nfs_arg_t * parg /* IN     */ ,
+              exportlist_t * pexport /* IN     */ ,
+              fsal_op_context_t * pcontext /* IN     */ ,
+              cache_inode_client_t * pclient /* INOUT  */ ,
+              hash_table_t * ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t * pres /* OUT    */ );
+
+int nlm4_Test_Message(nfs_arg_t * parg /* IN     */ ,
+              exportlist_t * pexport /* IN     */ ,
+              fsal_op_context_t * pcontext /* IN     */ ,
+              cache_inode_client_t * pclient /* INOUT  */ ,
+              hash_table_t * ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t * pres /* OUT    */ );
+
+int nlm4_Cancel_Message(nfs_arg_t * parg /* IN     */ ,
+                exportlist_t * pexport /* IN     */ ,
+                fsal_op_context_t * pcontext /* IN     */ ,
+                cache_inode_client_t * pclient /* INOUT  */ ,
+                hash_table_t * ht /* INOUT  */ ,
+                struct svc_req *preq /* IN     */ ,
+                nfs_res_t * pres /* OUT    */ );
+
+int nlm4_Lock_Message(nfs_arg_t * parg /* IN     */ ,
+              exportlist_t * pexport /* IN     */ ,
+              fsal_op_context_t * pcontext /* IN     */ ,
+              cache_inode_client_t * pclient /* INOUT  */ ,
+              hash_table_t * ht /* INOUT  */ ,
+              struct svc_req *preq /* IN     */ ,
+              nfs_res_t * pres /* OUT    */ );
+
+int nlm4_Unlock_Message(nfs_arg_t * parg /* IN     */ ,
+                exportlist_t * pexport /* IN     */ ,
+                fsal_op_context_t * pcontext /* IN     */ ,
+                cache_inode_client_t * pclient /* INOUT  */ ,
+                hash_table_t * ht /* INOUT  */ ,
+                struct svc_req *preq /* IN     */ ,
+                nfs_res_t * pres /* OUT    */ );
+
 /* @}
  * -- End of NLM protocol functions. --
  */
@@ -1106,6 +1148,12 @@ void nlm4_Test_Free(nfs_res_t * pres);
 void nlm4_Lock_Free(nfs_res_t * pres);
 void nlm4_Cancel_Free(nfs_res_t * pres);
 void nlm4_Unlock_Free(nfs_res_t * pres);
+void nlm4_Sm_Notify_Free(nfs_res_t * pres);
+void nlm4_Test_Message_Free(nfs_res_t * pres);
+void nlm4_Cancel_Message_Free(nfs_res_t * pres);
+void nlm4_Lock_Message_Free(nfs_res_t * pres);
+void nlm4_Unlock_Message_Free(nfs_res_t * pres);
+
 
 void nfs_Null_Free(nfs_res_t * resp);
 void nfs_Getattr_Free(nfs_res_t * resp);
diff --git a/src/include/nlm4.h b/src/include/nlm4.h
index ce59599..9763d2a 100644
--- a/src/include/nlm4.h
+++ b/src/include/nlm4.h
@@ -8,6 +8,7 @@
 
 #include <rpc/rpc.h>
 
+
 #ifdef __cplusplus
 extern "C"
 {
@@ -16,348 +17,349 @@ extern "C"
 #define LM_MAXSTRLEN 1024
 #define LM_MAXNAMELEN 1025
 #define MAXNETOBJ_SZ 1024
-
-  typedef int int32_t;
-
-  typedef u_int uint32_t;
-
-  typedef quad_t int64_t;
-
-  typedef u_quad_t uint64_t;
-
-  enum nlm4_stats
-  {
-    NLM4_GRANTED = 0,
-    NLM4_DENIED = 1,
-    NLM4_DENIED_NOLOCKS = 2,
-    NLM4_BLOCKED = 3,
-    NLM4_DENIED_GRACE_PERIOD = 4,
-    NLM4_DEADLCK = 5,
-    NLM4_ROFS = 6,
-    NLM4_STALE_FH = 7,
-    NLM4_FBIG = 8,
-    NLM4_FAILED = 9,
-  };
-  typedef enum nlm4_stats nlm4_stats;
-
-  struct nlm4_stat
-  {
-    nlm4_stats stat;
-  };
-  typedef struct nlm4_stat nlm4_stat;
-
-  struct nlm4_res
-  {
-    netobj cookie;
-    nlm4_stat stat;
-  };
-  typedef struct nlm4_res nlm4_res;
-
-  struct nlm4_holder
-  {
-    bool_t exclusive;
-    int32_t svid;
-    netobj oh;
-    uint64_t l_offset;
-    uint64_t l_len;
-  };
-  typedef struct nlm4_holder nlm4_holder;
-
-  struct nlm4_testrply
-  {
-    nlm4_stats stat;
-    union
-    {
-      struct nlm4_holder holder;
-    } nlm4_testrply_u;
-  };
-  typedef struct nlm4_testrply nlm4_testrply;
-
-  struct nlm4_testres
-  {
-    netobj cookie;
-    nlm4_testrply test_stat;
-  };
-  typedef struct nlm4_testres nlm4_testres;
-
-  struct nlm4_lock
-  {
-    char *caller_name;
-    netobj fh;
-    netobj oh;
-    int32_t svid;
-    uint64_t l_offset;
-    uint64_t l_len;
-  };
-  typedef struct nlm4_lock nlm4_lock;
-
-  struct nlm4_lockargs
-  {
-    netobj cookie;
-    bool_t block;
-    bool_t exclusive;
-    struct nlm4_lock alock;
-    bool_t reclaim;
-    int32_t state;
-  };
-  typedef struct nlm4_lockargs nlm4_lockargs;
-
-  struct nlm4_cancargs
-  {
-    netobj cookie;
-    bool_t block;
-    bool_t exclusive;
-    struct nlm4_lock alock;
-  };
-  typedef struct nlm4_cancargs nlm4_cancargs;
-
-  struct nlm4_testargs
-  {
-    netobj cookie;
-    bool_t exclusive;
-    struct nlm4_lock alock;
-  };
-  typedef struct nlm4_testargs nlm4_testargs;
-
-  struct nlm4_unlockargs
-  {
-    netobj cookie;
-    struct nlm4_lock alock;
-  };
-  typedef struct nlm4_unlockargs nlm4_unlockargs;
-
-  enum fsh4_mode
-  {
-    fsm_DN = 0,
-    fsm_DR = 1,
-    fsm_DW = 2,
-    fsm_DRW = 3,
-  };
-  typedef enum fsh4_mode fsh4_mode;
-
-  enum fsh4_access
-  {
-    fsa_NONE = 0,
-    fsa_R = 1,
-    fsa_W = 2,
-    fsa_RW = 3,
-  };
-  typedef enum fsh4_access fsh4_access;
-
-  struct nlm4_share
-  {
-    char *caller_name;
-    netobj fh;
-    netobj oh;
-    fsh4_mode mode;
-    fsh4_access access;
-  };
-  typedef struct nlm4_share nlm4_share;
-
-  struct nlm4_shareargs
-  {
-    netobj cookie;
-    nlm4_share share;
-    bool_t reclaim;
-  };
-  typedef struct nlm4_shareargs nlm4_shareargs;
-
-  struct nlm4_shareres
-  {
-    netobj cookie;
-    nlm4_stats stat;
-    int32_t sequence;
-  };
-  typedef struct nlm4_shareres nlm4_shareres;
-
-  struct nlm4_notify
-  {
-    char *name;
-    int64_t state;
-  };
-  typedef struct nlm4_notify nlm4_notify;
+#define SM_MAXSTRLEN 1024
+#define SM_PRIV_SZ 16
+
+typedef int int32_t;
+
+typedef u_int uint32_t;
+
+typedef quad_t int64_t;
+
+typedef u_quad_t uint64_t;
+
+enum nlm4_stats {
+	NLM4_GRANTED = 0,
+	NLM4_DENIED = 1,
+	NLM4_DENIED_NOLOCKS = 2,
+	NLM4_BLOCKED = 3,
+	NLM4_DENIED_GRACE_PERIOD = 4,
+	NLM4_DEADLCK = 5,
+	NLM4_ROFS = 6,
+	NLM4_STALE_FH = 7,
+	NLM4_FBIG = 8,
+	NLM4_FAILED = 9,
+};
+typedef enum nlm4_stats nlm4_stats;
+
+struct nlm4_stat {
+	nlm4_stats stat;
+};
+typedef struct nlm4_stat nlm4_stat;
+
+struct nlm4_res {
+	netobj cookie;
+	nlm4_stat stat;
+};
+typedef struct nlm4_res nlm4_res;
+
+struct nlm4_holder {
+	bool_t exclusive;
+	int32_t svid;
+	netobj oh;
+	uint64_t l_offset;
+	uint64_t l_len;
+};
+typedef struct nlm4_holder nlm4_holder;
+
+struct nlm4_testrply {
+	nlm4_stats stat;
+	union {
+		struct nlm4_holder holder;
+	} nlm4_testrply_u;
+};
+typedef struct nlm4_testrply nlm4_testrply;
+
+struct nlm4_testres {
+	netobj cookie;
+	nlm4_testrply test_stat;
+};
+typedef struct nlm4_testres nlm4_testres;
+
+struct nlm4_lock {
+	char *caller_name;
+	netobj fh;
+	netobj oh;
+	int32_t svid;
+	uint64_t l_offset;
+	uint64_t l_len;
+};
+typedef struct nlm4_lock nlm4_lock;
+
+struct nlm4_lockargs {
+	netobj cookie;
+	bool_t block;
+	bool_t exclusive;
+	struct nlm4_lock alock;
+	bool_t reclaim;
+	int32_t state;
+};
+typedef struct nlm4_lockargs nlm4_lockargs;
+
+struct nlm4_cancargs {
+	netobj cookie;
+	bool_t block;
+	bool_t exclusive;
+	struct nlm4_lock alock;
+};
+typedef struct nlm4_cancargs nlm4_cancargs;
+
+struct nlm4_testargs {
+	netobj cookie;
+	bool_t exclusive;
+	struct nlm4_lock alock;
+};
+typedef struct nlm4_testargs nlm4_testargs;
+
+struct nlm4_unlockargs {
+	netobj cookie;
+	struct nlm4_lock alock;
+};
+typedef struct nlm4_unlockargs nlm4_unlockargs;
+
+enum fsh4_mode {
+	fsm_DN = 0,
+	fsm_DR = 1,
+	fsm_DW = 2,
+	fsm_DRW = 3,
+};
+typedef enum fsh4_mode fsh4_mode;
+
+enum fsh4_access {
+	fsa_NONE = 0,
+	fsa_R = 1,
+	fsa_W = 2,
+	fsa_RW = 3,
+};
+typedef enum fsh4_access fsh4_access;
+
+struct nlm4_share {
+	char *caller_name;
+	netobj fh;
+	netobj oh;
+	fsh4_mode mode;
+	fsh4_access access;
+};
+typedef struct nlm4_share nlm4_share;
+
+struct nlm4_shareargs {
+	netobj cookie;
+	nlm4_share share;
+	bool_t reclaim;
+};
+typedef struct nlm4_shareargs nlm4_shareargs;
+
+struct nlm4_shareres {
+	netobj cookie;
+	nlm4_stats stat;
+	int32_t sequence;
+};
+typedef struct nlm4_shareres nlm4_shareres;
+
+struct nlm4_notify {
+	char *name;
+	int64_t state;
+};
+typedef struct nlm4_notify nlm4_notify;
+
+struct nlm4_sm_notifyargs {
+	char *name;
+	int32_t state;
+	char priv[SM_PRIV_SZ];
+};
+typedef struct nlm4_sm_notifyargs nlm4_sm_notifyargs;
+extern void nlm_init(void);
 
 #define NLMPROG 100021
 #define NLM4_VERS 4
 
 #if defined(__STDC__) || defined(__cplusplus)
 #define NLMPROC4_NULL 0
-  extern void *nlmproc4_null_4(void *, CLIENT *);
-  extern void *nlmproc4_null_4_svc(void *, struct svc_req *);
+extern  void * nlmproc4_null_4(void *, CLIENT *);
+extern  void * nlmproc4_null_4_svc(void *, struct svc_req *);
 #define NLMPROC4_TEST 1
-  extern nlm4_testres *nlmproc4_test_4(nlm4_testargs *, CLIENT *);
-  extern nlm4_testres *nlmproc4_test_4_svc(nlm4_testargs *, struct svc_req *);
+extern  nlm4_testres * nlmproc4_test_4(nlm4_testargs *, CLIENT *);
+extern  nlm4_testres * nlmproc4_test_4_svc(nlm4_testargs *, struct svc_req *);
 #define NLMPROC4_LOCK 2
-  extern nlm4_res *nlmproc4_lock_4(nlm4_lockargs *, CLIENT *);
-  extern nlm4_res *nlmproc4_lock_4_svc(nlm4_lockargs *, struct svc_req *);
+extern  nlm4_res * nlmproc4_lock_4(nlm4_lockargs *, CLIENT *);
+extern  nlm4_res * nlmproc4_lock_4_svc(nlm4_lockargs *, struct svc_req *);
 #define NLMPROC4_CANCEL 3
-  extern nlm4_res *nlmproc4_cancel_4(nlm4_cancargs *, CLIENT *);
-  extern nlm4_res *nlmproc4_cancel_4_svc(nlm4_cancargs *, struct svc_req *);
+extern  nlm4_res * nlmproc4_cancel_4(nlm4_cancargs *, CLIENT *);
+extern  nlm4_res * nlmproc4_cancel_4_svc(nlm4_cancargs *, struct svc_req *);
 #define NLMPROC4_UNLOCK 4
-  extern nlm4_res *nlmproc4_unlock_4(nlm4_unlockargs *, CLIENT *);
-  extern nlm4_res *nlmproc4_unlock_4_svc(nlm4_unlockargs *, struct svc_req *);
+extern  nlm4_res * nlmproc4_unlock_4(nlm4_unlockargs *, CLIENT *);
+extern  nlm4_res * nlmproc4_unlock_4_svc(nlm4_unlockargs *, struct svc_req *);
 #define NLMPROC4_GRANTED 5
-  extern nlm4_res *nlmproc4_granted_4(nlm4_testargs *, CLIENT *);
-  extern nlm4_res *nlmproc4_granted_4_svc(nlm4_testargs *, struct svc_req *);
+extern  nlm4_res * nlmproc4_granted_4(nlm4_testargs *, CLIENT *);
+extern  nlm4_res * nlmproc4_granted_4_svc(nlm4_testargs *, struct svc_req *);
 #define NLMPROC4_TEST_MSG 6
-  extern void *nlmproc4_test_msg_4(nlm4_testargs *, CLIENT *);
-  extern void *nlmproc4_test_msg_4_svc(nlm4_testargs *, struct svc_req *);
+extern  void * nlmproc4_test_msg_4(nlm4_testargs *, CLIENT *);
+extern  void * nlmproc4_test_msg_4_svc(nlm4_testargs *, struct svc_req *);
 #define NLMPROC4_LOCK_MSG 7
-  extern void *nlmproc4_lock_msg_4(nlm4_lockargs *, CLIENT *);
-  extern void *nlmproc4_lock_msg_4_svc(nlm4_lockargs *, struct svc_req *);
+extern  void * nlmproc4_lock_msg_4(nlm4_lockargs *, CLIENT *);
+extern  void * nlmproc4_lock_msg_4_svc(nlm4_lockargs *, struct svc_req *);
 #define NLMPROC4_CANCEL_MSG 8
-  extern void *nlmproc4_cancel_msg_4(nlm4_cancargs *, CLIENT *);
-  extern void *nlmproc4_cancel_msg_4_svc(nlm4_cancargs *, struct svc_req *);
+extern  void * nlmproc4_cancel_msg_4(nlm4_cancargs *, CLIENT *);
+extern  void * nlmproc4_cancel_msg_4_svc(nlm4_cancargs *, struct svc_req *);
 #define NLMPROC4_UNLOCK_MSG 9
-  extern void *nlmproc4_unlock_msg_4(nlm4_unlockargs *, CLIENT *);
-  extern void *nlmproc4_unlock_msg_4_svc(nlm4_unlockargs *, struct svc_req *);
+extern  void * nlmproc4_unlock_msg_4(nlm4_unlockargs *, CLIENT *);
+extern  void * nlmproc4_unlock_msg_4_svc(nlm4_unlockargs *, struct svc_req *);
 #define NLMPROC4_GRANTED_MSG 10
-  extern void *nlmproc4_granted_msg_4(nlm4_testargs *, CLIENT *);
-  extern void *nlmproc4_granted_msg_4_svc(nlm4_testargs *, struct svc_req *);
+extern  void * nlmproc4_granted_msg_4(nlm4_testargs *, CLIENT *);
+extern  void * nlmproc4_granted_msg_4_svc(nlm4_testargs *, struct svc_req *);
 #define NLMPROC4_TEST_RES 11
-  extern void *nlmproc4_test_res_4(nlm4_testres *, CLIENT *);
-  extern void *nlmproc4_test_res_4_svc(nlm4_testres *, struct svc_req *);
+extern  void * nlmproc4_test_res_4(nlm4_testres *, CLIENT *);
+extern  void * nlmproc4_test_res_4_svc(nlm4_testres *, struct svc_req *);
 #define NLMPROC4_LOCK_RES 12
-  extern void *nlmproc4_lock_res_4(nlm4_res *, CLIENT *);
-  extern void *nlmproc4_lock_res_4_svc(nlm4_res *, struct svc_req *);
+extern  void * nlmproc4_lock_res_4(nlm4_res *, CLIENT *);
+extern  void * nlmproc4_lock_res_4_svc(nlm4_res *, struct svc_req *);
 #define NLMPROC4_CANCEL_RES 13
-  extern void *nlmproc4_cancel_res_4(nlm4_res *, CLIENT *);
-  extern void *nlmproc4_cancel_res_4_svc(nlm4_res *, struct svc_req *);
+extern  void * nlmproc4_cancel_res_4(nlm4_res *, CLIENT *);
+extern  void * nlmproc4_cancel_res_4_svc(nlm4_res *, struct svc_req *);
 #define NLMPROC4_UNLOCK_RES 14
-  extern void *nlmproc4_unlock_res_4(nlm4_res *, CLIENT *);
-  extern void *nlmproc4_unlock_res_4_svc(nlm4_res *, struct svc_req *);
+extern  void * nlmproc4_unlock_res_4(nlm4_res *, CLIENT *);
+extern  void * nlmproc4_unlock_res_4_svc(nlm4_res *, struct svc_req *);
 #define NLMPROC4_GRANTED_RES 15
-  extern void *nlmproc4_granted_res_4(nlm4_res *, CLIENT *);
-  extern void *nlmproc4_granted_res_4_svc(nlm4_res *, struct svc_req *);
+extern  void * nlmproc4_granted_res_4(nlm4_res *, CLIENT *);
+extern  void * nlmproc4_granted_res_4_svc(nlm4_res *, struct svc_req *);
+#define NLMPROC4_SM_NOTIFY 16
+extern  void * nlmproc4_sm_notify_4(nlm4_sm_notifyargs *, CLIENT *);
+extern  void * nlmproc4_sm_notify_4_svc(nlm4_sm_notifyargs *, struct svc_req *);
 #define NLMPROC4_SHARE 20
-  extern nlm4_shareres *nlmproc4_share_4(nlm4_shareargs *, CLIENT *);
-  extern nlm4_shareres *nlmproc4_share_4_svc(nlm4_shareargs *, struct svc_req *);
+extern  nlm4_shareres * nlmproc4_share_4(nlm4_shareargs *, CLIENT *);
+extern  nlm4_shareres * nlmproc4_share_4_svc(nlm4_shareargs *, struct svc_req *);
 #define NLMPROC4_UNSHARE 21
-  extern nlm4_shareres *nlmproc4_unshare_4(nlm4_shareargs *, CLIENT *);
-  extern nlm4_shareres *nlmproc4_unshare_4_svc(nlm4_shareargs *, struct svc_req *);
+extern  nlm4_shareres * nlmproc4_unshare_4(nlm4_shareargs *, CLIENT *);
+extern  nlm4_shareres * nlmproc4_unshare_4_svc(nlm4_shareargs *, struct svc_req *);
 #define NLMPROC4_NM_LOCK 22
-  extern nlm4_res *nlmproc4_nm_lock_4(nlm4_lockargs *, CLIENT *);
-  extern nlm4_res *nlmproc4_nm_lock_4_svc(nlm4_lockargs *, struct svc_req *);
+extern  nlm4_res * nlmproc4_nm_lock_4(nlm4_lockargs *, CLIENT *);
+extern  nlm4_res * nlmproc4_nm_lock_4_svc(nlm4_lockargs *, struct svc_req *);
 #define NLMPROC4_FREE_ALL 23
-  extern void *nlmproc4_free_all_4(nlm4_notify *, CLIENT *);
-  extern void *nlmproc4_free_all_4_svc(nlm4_notify *, struct svc_req *);
-  extern int nlmprog_4_freeresult(SVCXPRT *, xdrproc_t, caddr_t);
+extern  void * nlmproc4_free_all_4(nlm4_notify *, CLIENT *);
+extern  void * nlmproc4_free_all_4_svc(nlm4_notify *, struct svc_req *);
+extern int nlmprog_4_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
 
-#else                           /* K&R C */
+#else /* K&R C */
 #define NLMPROC4_NULL 0
-  extern void *nlmproc4_null_4();
-  extern void *nlmproc4_null_4_svc();
+extern  void * nlmproc4_null_4();
+extern  void * nlmproc4_null_4_svc();
 #define NLMPROC4_TEST 1
-  extern nlm4_testres *nlmproc4_test_4();
-  extern nlm4_testres *nlmproc4_test_4_svc();
+extern  nlm4_testres * nlmproc4_test_4();
+extern  nlm4_testres * nlmproc4_test_4_svc();
 #define NLMPROC4_LOCK 2
-  extern nlm4_res *nlmproc4_lock_4();
-  extern nlm4_res *nlmproc4_lock_4_svc();
+extern  nlm4_res * nlmproc4_lock_4();
+extern  nlm4_res * nlmproc4_lock_4_svc();
 #define NLMPROC4_CANCEL 3
-  extern nlm4_res *nlmproc4_cancel_4();
-  extern nlm4_res *nlmproc4_cancel_4_svc();
+extern  nlm4_res * nlmproc4_cancel_4();
+extern  nlm4_res * nlmproc4_cancel_4_svc();
 #define NLMPROC4_UNLOCK 4
-  extern nlm4_res *nlmproc4_unlock_4();
-  extern nlm4_res *nlmproc4_unlock_4_svc();
+extern  nlm4_res * nlmproc4_unlock_4();
+extern  nlm4_res * nlmproc4_unlock_4_svc();
 #define NLMPROC4_GRANTED 5
-  extern nlm4_res *nlmproc4_granted_4();
-  extern nlm4_res *nlmproc4_granted_4_svc();
+extern  nlm4_res * nlmproc4_granted_4();
+extern  nlm4_res * nlmproc4_granted_4_svc();
 #define NLMPROC4_TEST_MSG 6
-  extern void *nlmproc4_test_msg_4();
-  extern void *nlmproc4_test_msg_4_svc();
+extern  void * nlmproc4_test_msg_4();
+extern  void * nlmproc4_test_msg_4_svc();
 #define NLMPROC4_LOCK_MSG 7
-  extern void *nlmproc4_lock_msg_4();
-  extern void *nlmproc4_lock_msg_4_svc();
+extern  void * nlmproc4_lock_msg_4();
+extern  void * nlmproc4_lock_msg_4_svc();
 #define NLMPROC4_CANCEL_MSG 8
-  extern void *nlmproc4_cancel_msg_4();
-  extern void *nlmproc4_cancel_msg_4_svc();
+extern  void * nlmproc4_cancel_msg_4();
+extern  void * nlmproc4_cancel_msg_4_svc();
 #define NLMPROC4_UNLOCK_MSG 9
-  extern void *nlmproc4_unlock_msg_4();
-  extern void *nlmproc4_unlock_msg_4_svc();
+extern  void * nlmproc4_unlock_msg_4();
+extern  void * nlmproc4_unlock_msg_4_svc();
 #define NLMPROC4_GRANTED_MSG 10
-  extern void *nlmproc4_granted_msg_4();
-  extern void *nlmproc4_granted_msg_4_svc();
+extern  void * nlmproc4_granted_msg_4();
+extern  void * nlmproc4_granted_msg_4_svc();
 #define NLMPROC4_TEST_RES 11
-  extern void *nlmproc4_test_res_4();
-  extern void *nlmproc4_test_res_4_svc();
+extern  void * nlmproc4_test_res_4();
+extern  void * nlmproc4_test_res_4_svc();
 #define NLMPROC4_LOCK_RES 12
-  extern void *nlmproc4_lock_res_4();
-  extern void *nlmproc4_lock_res_4_svc();
+extern  void * nlmproc4_lock_res_4();
+extern  void * nlmproc4_lock_res_4_svc();
 #define NLMPROC4_CANCEL_RES 13
-  extern void *nlmproc4_cancel_res_4();
-  extern void *nlmproc4_cancel_res_4_svc();
+extern  void * nlmproc4_cancel_res_4();
+extern  void * nlmproc4_cancel_res_4_svc();
 #define NLMPROC4_UNLOCK_RES 14
-  extern void *nlmproc4_unlock_res_4();
-  extern void *nlmproc4_unlock_res_4_svc();
+extern  void * nlmproc4_unlock_res_4();
+extern  void * nlmproc4_unlock_res_4_svc();
 #define NLMPROC4_GRANTED_RES 15
-  extern void *nlmproc4_granted_res_4();
-  extern void *nlmproc4_granted_res_4_svc();
+extern  void * nlmproc4_granted_res_4();
+extern  void * nlmproc4_granted_res_4_svc();
+#define NLMPROC4_SM_NOTIFY 16
+extern  void * nlmproc4_sm_notify_4();
+extern  void * nlmproc4_sm_notify_4_svc();
 #define NLMPROC4_SHARE 20
-  extern nlm4_shareres *nlmproc4_share_4();
-  extern nlm4_shareres *nlmproc4_share_4_svc();
+extern  nlm4_shareres * nlmproc4_share_4();
+extern  nlm4_shareres * nlmproc4_share_4_svc();
 #define NLMPROC4_UNSHARE 21
-  extern nlm4_shareres *nlmproc4_unshare_4();
-  extern nlm4_shareres *nlmproc4_unshare_4_svc();
+extern  nlm4_shareres * nlmproc4_unshare_4();
+extern  nlm4_shareres * nlmproc4_unshare_4_svc();
 #define NLMPROC4_NM_LOCK 22
-  extern nlm4_res *nlmproc4_nm_lock_4();
-  extern nlm4_res *nlmproc4_nm_lock_4_svc();
+extern  nlm4_res * nlmproc4_nm_lock_4();
+extern  nlm4_res * nlmproc4_nm_lock_4_svc();
 #define NLMPROC4_FREE_ALL 23
-  extern void *nlmproc4_free_all_4();
-  extern void *nlmproc4_free_all_4_svc();
-  extern int nlmprog_4_freeresult();
-#endif                          /* K&R C */
+extern  void * nlmproc4_free_all_4();
+extern  void * nlmproc4_free_all_4_svc();
+extern int nlmprog_4_freeresult ();
+#endif /* K&R C */
 
 /* the xdr functions */
 
 #if defined(__STDC__) || defined(__cplusplus)
-  extern bool_t xdr_int32_t(XDR *, int32_t *);
-  extern bool_t xdr_uint32_t(XDR *, uint32_t *);
-  extern bool_t xdr_int64_t(XDR *, int64_t *);
-  extern bool_t xdr_uint64_t(XDR *, uint64_t *);
-  extern bool_t xdr_nlm4_stats(XDR *, nlm4_stats *);
-  extern bool_t xdr_nlm4_stat(XDR *, nlm4_stat *);
-  extern bool_t xdr_nlm4_res(XDR *, nlm4_res *);
-  extern bool_t xdr_nlm4_holder(XDR *, nlm4_holder *);
-  extern bool_t xdr_nlm4_testrply(XDR *, nlm4_testrply *);
-  extern bool_t xdr_nlm4_testres(XDR *, nlm4_testres *);
-  extern bool_t xdr_nlm4_lock(XDR *, nlm4_lock *);
-  extern bool_t xdr_nlm4_lockargs(XDR *, nlm4_lockargs *);
-  extern bool_t xdr_nlm4_cancargs(XDR *, nlm4_cancargs *);
-  extern bool_t xdr_nlm4_testargs(XDR *, nlm4_testargs *);
-  extern bool_t xdr_nlm4_unlockargs(XDR *, nlm4_unlockargs *);
-  extern bool_t xdr_fsh4_mode(XDR *, fsh4_mode *);
-  extern bool_t xdr_fsh4_access(XDR *, fsh4_access *);
-  extern bool_t xdr_nlm4_share(XDR *, nlm4_share *);
-  extern bool_t xdr_nlm4_shareargs(XDR *, nlm4_shareargs *);
-  extern bool_t xdr_nlm4_shareres(XDR *, nlm4_shareres *);
-  extern bool_t xdr_nlm4_notify(XDR *, nlm4_notify *);
-
-#else                           /* K&R C */
-  extern bool_t xdr_int32_t();
-  extern bool_t xdr_uint32_t();
-  extern bool_t xdr_int64_t();
-  extern bool_t xdr_uint64_t();
-  extern bool_t xdr_nlm4_stats();
-  extern bool_t xdr_nlm4_stat();
-  extern bool_t xdr_nlm4_res();
-  extern bool_t xdr_nlm4_holder();
-  extern bool_t xdr_nlm4_testrply();
-  extern bool_t xdr_nlm4_testres();
-  extern bool_t xdr_nlm4_lock();
-  extern bool_t xdr_nlm4_lockargs();
-  extern bool_t xdr_nlm4_cancargs();
-  extern bool_t xdr_nlm4_testargs();
-  extern bool_t xdr_nlm4_unlockargs();
-  extern bool_t xdr_fsh4_mode();
-  extern bool_t xdr_fsh4_access();
-  extern bool_t xdr_nlm4_share();
-  extern bool_t xdr_nlm4_shareargs();
-  extern bool_t xdr_nlm4_shareres();
-  extern bool_t xdr_nlm4_notify();
-
-#endif                          /* K&R C */
+extern  bool_t xdr_int32_t (XDR *, int32_t*);
+extern  bool_t xdr_uint32_t (XDR *, uint32_t*);
+extern  bool_t xdr_int64_t (XDR *, int64_t*);
+extern  bool_t xdr_uint64_t (XDR *, uint64_t*);
+extern  bool_t xdr_nlm4_stats (XDR *, nlm4_stats*);
+extern  bool_t xdr_nlm4_stat (XDR *, nlm4_stat*);
+extern  bool_t xdr_nlm4_res (XDR *, nlm4_res*);
+extern  bool_t xdr_nlm4_holder (XDR *, nlm4_holder*);
+extern  bool_t xdr_nlm4_testrply (XDR *, nlm4_testrply*);
+extern  bool_t xdr_nlm4_testres (XDR *, nlm4_testres*);
+extern  bool_t xdr_nlm4_lock (XDR *, nlm4_lock*);
+extern  bool_t xdr_nlm4_lockargs (XDR *, nlm4_lockargs*);
+extern  bool_t xdr_nlm4_cancargs (XDR *, nlm4_cancargs*);
+extern  bool_t xdr_nlm4_testargs (XDR *, nlm4_testargs*);
+extern  bool_t xdr_nlm4_unlockargs (XDR *, nlm4_unlockargs*);
+extern  bool_t xdr_fsh4_mode (XDR *, fsh4_mode*);
+extern  bool_t xdr_fsh4_access (XDR *, fsh4_access*);
+extern  bool_t xdr_nlm4_share (XDR *, nlm4_share*);
+extern  bool_t xdr_nlm4_shareargs (XDR *, nlm4_shareargs*);
+extern  bool_t xdr_nlm4_shareres (XDR *, nlm4_shareres*);
+extern  bool_t xdr_nlm4_notify (XDR *, nlm4_notify*);
+extern  bool_t xdr_nlm4_sm_notifyargs (XDR *, nlm4_sm_notifyargs*);
+
+#else /* K&R C */
+extern bool_t xdr_int32_t ();
+extern bool_t xdr_uint32_t ();
+extern bool_t xdr_int64_t ();
+extern bool_t xdr_uint64_t ();
+extern bool_t xdr_nlm4_stats ();
+extern bool_t xdr_nlm4_stat ();
+extern bool_t xdr_nlm4_res ();
+extern bool_t xdr_nlm4_holder ();
+extern bool_t xdr_nlm4_testrply ();
+extern bool_t xdr_nlm4_testres ();
+extern bool_t xdr_nlm4_lock ();
+extern bool_t xdr_nlm4_lockargs ();
+extern bool_t xdr_nlm4_cancargs ();
+extern bool_t xdr_nlm4_testargs ();
+extern bool_t xdr_nlm4_unlockargs ();
+extern bool_t xdr_fsh4_mode ();
+extern bool_t xdr_fsh4_access ();
+extern bool_t xdr_nlm4_share ();
+extern bool_t xdr_nlm4_shareargs ();
+extern bool_t xdr_nlm4_shareres ();
+extern bool_t xdr_nlm4_notify ();
+extern bool_t xdr_nlm4_sm_notifyargs ();
+
+#endif /* K&R C */
 
 #ifdef __cplusplus
 }
 #endif
-#endif                          /* !_NLM4_H_RPCGEN */
+
+#endif /* !_NLM4_H_RPCGEN */
diff --git a/src/include/nlm_async.h b/src/include/nlm_async.h
new file mode 100644
index 0000000..8eaf676
--- /dev/null
+++ b/src/include/nlm_async.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.v  <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifndef NLM_ASYNC_H
+#define NLM_ASYNC_H
+
+#include "nfs_proto_functions.h"
+
+typedef struct nlm_async_res {
+  char *caller_name;
+  nfs_res_t pres;
+} nlm_async_res_t;
+
+typedef void (nlm_callback_func)(void *arg);
+extern int nlm_async_callback_init();
+void nlm_async_callback(nlm_callback_func *func, void *arg);
+extern int nlm_async_callback_init();
+
+static inline nlm_async_res_t *nlm_build_async_res(char *caller_name,
+						   nfs_res_t *pres)
+{
+  nlm_async_res_t *arg;
+  arg = (nlm_async_res_t *)Mem_Alloc(sizeof(nlm_async_res_t));
+  arg->caller_name = strdup(caller_name);
+  memcpy(&(arg->pres), pres, sizeof(nfs_res_t));
+  return arg;
+}
+
+#endif /* NLM_ASYNC_H */
diff --git a/src/include/nlm_list.h b/src/include/nlm_list.h
index d21d68d..cd350ba 100644
--- a/src/include/nlm_list.h
+++ b/src/include/nlm_list.h
@@ -96,6 +96,30 @@ static inline void glist_del(struct glist_head *node)
   node->prev = NULL;
 }
 
+static inline void glist_add_list_tail(struct glist_head *list,
+				       struct glist_head *new)
+{
+  struct glist_head *first = new->next;
+  struct glist_head *last = new->prev;
+
+  if (new->next == new->prev)
+    {
+      /* nothing to add */
+      return;
+    }
+
+  first->prev = list->prev;
+  list->prev->next   = first;
+
+  last->next = list;
+  list->prev = last;
+}
+
+static inline int glist_empty(struct glist_head *head)
+{
+  return head->next == head;
+}
+
 #define glist_for_each(node, head) \
 	for(node = (head)->next; node != head; node = node->next)
 
@@ -105,3 +129,7 @@ static inline void glist_del(struct glist_head *node)
 
 #define glist_entry(node, type, member) \
 	container_of(node, type, member)
+
+#define glist_for_each_safe(node, noden, head)			    \
+  for (node = (head)->next, noden = node->next; node != (head);	    \
+       node = noden, noden = node->next)
diff --git a/src/include/nlm_send_reply.h b/src/include/nlm_send_reply.h
new file mode 100644
index 0000000..aad7f82
--- /dev/null
+++ b/src/include/nlm_send_reply.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.v  <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+#ifndef NLM_SEND_REPLY_H
+#define NLM_SEND_REPLY_H
+
+#ifdef _USE_GSSRPC
+#include <gssrpc/types.h>
+#include <gssrpc/rpc.h>
+#else
+#include <rpc/types.h>
+#include <rpc/rpc.h>
+#endif
+
+typedef struct {
+  xdrproc_t inproc;
+  xdrproc_t outproc;
+} nlm_reply_proc_t;
+
+/* Client routine  to send the asynchrnous response */
+extern int nlm_send_reply(int proc, char *host, void *inarg, void *outarg);
+
+#endif /* NLM_SEND_REPLY_H */
diff --git a/src/include/nlm_util.h b/src/include/nlm_util.h
index 43e34e3..1666ec7 100644
--- a/src/include/nlm_util.h
+++ b/src/include/nlm_util.h
@@ -49,26 +49,43 @@
  */
 #include "nlm_list.h"
 
-struct nlm_lock
-{
+struct nlm_lock_entry {
   char *caller_name;
   netobj fh;
   netobj oh;
+  netobj cookie;
   int32_t svid;
-  uint64_t offset;
+  uint64_t start;
   uint64_t len;
   int state;
   int exclusive;
+  int ref_count;
+  pthread_mutex_t lock;
   struct glist_head lock_list;
 };
 
-typedef struct nlm_lock nlm_lock_t;
+typedef struct nlm_lock_entry nlm_lock_entry_t;
 
-extern fsal_lockdesc_t *nlm_lock_to_fsal_lockdesc(struct nlm4_lock *nlm_lock,
-                                                  bool_t exclusive);
-extern nlm_lock_t *nlm_add_to_locklist(struct nlm4_lock *nlm_lock, int exclusive);
-extern void nlm_remove_from_locklist(nlm_lock_t * nlmb);
-extern void nlm_delete_lock_entry(nlm_lock_t * nlmb, struct nlm4_lock *nlm_lock);
-extern void nlm_init_locklist(void);
-extern nlm_lock_t *nlm_find_lock_entry(struct nlm4_lock *nlm_lock,
+extern void nlm_lock_entry_to_nlm_holder(nlm_lock_entry_t *nlm_entry,
+					 struct nlm4_holder *holder);
+extern int nlm_lock_entry_get_state(nlm_lock_entry_t *nlm_entry);
+extern nlm_lock_entry_t *nlm_overlapping_entry(struct nlm4_lock *nlm_lock, int exclusive);
+extern nlm_lock_entry_t *nlm_add_to_locklist(struct nlm4_lockargs *args);
+extern void nlm_remove_from_locklist(nlm_lock_entry_t *nlm_entry);
+extern int nlm_delete_lock_entry(struct nlm4_lock *nlm_lock);
+extern void nlm_init(void);
+extern nlm_lock_entry_t *nlm_find_lock_entry(struct nlm4_lock *nlm_lock,
                                        int exclusive, int state);
+extern void nlm_lock_entry_dec_ref(nlm_lock_entry_t *nlm_entry);
+extern int start_nlm_grace_period(void);
+extern int in_nlm_grace_period(void);
+extern void nlm_node_recovery(char *name,
+			      fsal_op_context_t *pcontext,
+			      cache_inode_client_t *pclient,
+			      hash_table_t *ht);
+extern int nlm_monitor_host(char *name);
+extern int nlm_unmonitor_host(char *name);
+extern void nlm_grant_blocked_locks(netobj *orig_fh);
+
+extern nlm_lock_entry_t *nlm_find_lock_entry_by_cookie(netobj *cookie);
+extern void nlm_resend_grant_msg(void *arg);
diff --git a/src/include/nsm.h b/src/include/nsm.h
new file mode 100644
index 0000000..d3b23e2
--- /dev/null
+++ b/src/include/nsm.h
@@ -0,0 +1,87 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _NSM_H_RPCGEN
+#define _NSM_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SM_MAXSTRLEN 1024
+#define SM_PROG 100024
+#define SM_VERS 1
+#define SM_MON 2
+#define SM_UNMON 3
+#define SM_UNMON_ALL 4
+
+enum res {
+	STAT_SUCC = 0,
+	STAT_FAIL = 1,
+};
+typedef enum res res;
+
+struct sm_stat_res {
+	res res_stat;
+	int state;
+};
+typedef struct sm_stat_res sm_stat_res;
+
+struct sm_stat {
+	int state;
+};
+typedef struct sm_stat sm_stat;
+
+struct my_id {
+	char *my_name;
+	int my_prog;
+	int my_vers;
+	int my_proc;
+};
+typedef struct my_id my_id;
+
+struct mon_id {
+	char *mon_name;
+	struct my_id my_id;
+};
+typedef struct mon_id mon_id;
+
+struct mon {
+	struct mon_id mon_id;
+	char priv[16];
+};
+typedef struct mon mon;
+extern int nsm_monitor(char *host);
+extern int nsm_unmonitor(char *host);
+extern int nsm_unmonitor_all(void);
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_res (XDR *, res*);
+extern  bool_t xdr_sm_stat_res (XDR *, sm_stat_res*);
+extern  bool_t xdr_sm_stat (XDR *, sm_stat*);
+extern  bool_t xdr_my_id (XDR *, my_id*);
+extern  bool_t xdr_mon_id (XDR *, mon_id*);
+extern  bool_t xdr_mon (XDR *, mon*);
+
+#else /* K&R C */
+extern bool_t xdr_res ();
+extern bool_t xdr_sm_stat_res ();
+extern bool_t xdr_sm_stat ();
+extern bool_t xdr_my_id ();
+extern bool_t xdr_mon_id ();
+extern bool_t xdr_mon ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_NSM_H_RPCGEN */
diff --git a/src/support/Makefile.am b/src/support/Makefile.am
index ddcb44d..c4d3034 100644
--- a/src/support/Makefile.am
+++ b/src/support/Makefile.am
@@ -41,7 +41,7 @@ libsupport_la_SOURCES =  nfs_export_list.c                  \
                          ../include/stuff_alloc.h
 
 if USE_NLM
-libsupport_la_SOURCES += nlm_util.c 
+libsupport_la_SOURCES += nlm_util.c nsm.c nlm_async.c nlm4_send_reply.c
 endif
 
 if USE_NFS4_1
diff --git a/src/support/nlm4_send_reply.c b/src/support/nlm4_send_reply.c
new file mode 100644
index 0000000..5a6f65f
--- /dev/null
+++ b/src/support/nlm4_send_reply.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include "nlm_send_reply.h"
+#include "nlm4.h"
+#include "nfs_proto_functions.h"
+
+nlm_reply_proc_t nlm_reply_proc [] = {
+
+  [NLMPROC4_GRANTED_MSG] = {
+    .inproc  = (xdrproc_t)xdr_nlm4_testargs,
+    .outproc = (xdrproc_t)xdr_void,
+  },
+  [NLMPROC4_TEST_RES] = {
+    .inproc  = (xdrproc_t)xdr_nlm4_testres,
+    .outproc = (xdrproc_t)xdr_void,
+  },
+  [NLMPROC4_LOCK_RES] = {
+    .inproc  = (xdrproc_t)xdr_nlm4_res,
+    .outproc = (xdrproc_t)xdr_void,
+  },
+  [NLMPROC4_CANCEL_RES] = {
+    .inproc  = (xdrproc_t)xdr_nlm4_res,
+    .outproc = (xdrproc_t)xdr_void,
+  },
+  [NLMPROC4_UNLOCK_RES] = {
+    .inproc  = (xdrproc_t)xdr_nlm4_res,
+    .outproc = (xdrproc_t)xdr_void,
+  },
+};
+
+/* Client routine  to send the asynchrnous response */
+int nlm_send_reply(int proc, char *host, void *inarg, void *outarg)
+{
+    CLIENT *clnt;
+    struct timeval tout = { 5, 0 };
+    xdrproc_t inproc = NULL, outproc = NULL;
+    int retval;
+
+    clnt = clnt_create(host, NLMPROG, NLM4_VERS, "tcp");
+    if (!clnt)
+      {
+	DisplayLogLevel(NIV_MAJ, "%s: Cannot create connection to %s client\n",
+			__func__, host);
+        return -1;
+    }
+    inproc = nlm_reply_proc[proc].inproc;
+    outproc = nlm_reply_proc[proc].outproc;
+
+    retval = clnt_call(clnt, proc, inproc, inarg, outproc, outarg, tout);
+    if (retval != RPC_SUCCESS) {
+      DisplayLogLevel(NIV_MAJ,
+		      "%s: Client procedure call %d failed\n", __func__, proc);
+    }
+
+    clnt_destroy(clnt);
+    return retval;
+}
diff --git a/src/support/nlm_async.c b/src/support/nlm_async.c
new file mode 100644
index 0000000..e98783d
--- /dev/null
+++ b/src/support/nlm_async.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _SOLARIS
+#include "solaris_port.h"
+#endif
+
+#include <stdio.h>
+#include <pthread.h>
+#include <sys/time.h>
+
+#include "stuff_alloc.h"
+#include "nlm_list.h"
+#include "nlm_async.h"
+
+static pthread_t nlm_async_thread;
+static pthread_mutex_t nlm_async_queue_mutex;
+static struct glist_head nlm_async_queue;
+static pthread_cond_t nlm_async_queue_cond;
+
+typedef struct {
+  nlm_callback_func *func;
+  void *arg;
+  struct glist_head glist;
+} nlm_queue_t;
+
+/* Execute a func from the async queue */
+void *nlm_async_func(void *argp)
+{
+  int rc;
+  nlm_queue_t *entry;
+  struct timeval now;
+  struct timespec timeout;
+  struct glist_head nlm_async_tmp_queue;
+  struct glist_head *glist, *glistn;
+
+  SetNameFunction("nlm_async_thread");
+
+#ifndef _NO_BUDDY_SYSTEM
+  if ((rc = BuddyInit(NULL)) != BUDDY_SUCCESS)
+    {
+      /* Failed init */
+      DisplayLog("NLM async thread: Memory manager could not be initialized, exiting...");
+      exit(1);
+    }
+  DisplayLogLevel(NIV_EVENT, "NLM async thread: Memory manager successfully initialized");
+#endif
+  DisplayLogLevel(NIV_DEBUG, "NLM async thread: my pthread id is %p", (caddr_t) pthread_self());
+
+  while(1)
+    {
+      pthread_mutex_lock(&nlm_async_queue_mutex);
+ restart:
+      while (glist_empty(&nlm_async_queue))
+	{
+	  gettimeofday(&now, NULL);
+	  timeout.tv_sec  = 10 + now.tv_sec;
+	  timeout.tv_nsec = 0;
+	  pthread_cond_timedwait(&nlm_async_queue_cond,
+				 &nlm_async_queue_mutex, &timeout);
+	}
+      init_glist(&nlm_async_tmp_queue);
+      /* Collect all the work items and add it to the temp
+       * list. Later we iterate over tmp list without holding
+       * the nlm_async_queue_mutex
+       */
+      glist_for_each_safe(glist, glistn, &nlm_async_queue)
+	{
+	  glist_del(glist);
+	  glist_add(&nlm_async_tmp_queue, glist);
+
+	}
+      pthread_mutex_unlock(&nlm_async_queue_mutex);
+      glist_for_each_safe(glist, glistn, &nlm_async_tmp_queue)
+	{
+	  entry = glist_entry(glist, nlm_queue_t, glist);
+	  glist_del(&entry->glist);
+          /* FIXME should we handle error here ? */
+	  (*(entry->func))(entry->arg);
+	  Mem_Free(entry);
+	}
+    }
+
+}
+
+/* Insert 'func' to async queue */
+void nlm_async_callback(nlm_callback_func *func, void *arg)
+{
+    nlm_queue_t *q;
+
+    q = (nlm_queue_t *)Mem_Alloc(sizeof(nlm_queue_t));
+    q->func = func;
+    q->arg  = arg;
+
+    pthread_mutex_lock(&nlm_async_queue_mutex);
+    glist_add_tail(&nlm_async_queue, &q->glist);
+    pthread_mutex_unlock(&nlm_async_queue_mutex);
+    pthread_cond_signal(&nlm_async_queue_cond);
+}
+
+int nlm_async_callback_init()
+{
+  int rc;
+
+  pthread_mutex_init(&nlm_async_queue_mutex, NULL);
+  pthread_cond_init(&nlm_async_queue_cond, NULL);
+  init_glist(&nlm_async_queue);
+
+  rc = pthread_create(&nlm_async_thread, NULL, nlm_async_func, NULL);
+  if (rc < 0)
+    {
+      return -1;
+    }
+
+  return 0;
+}
diff --git a/src/support/nlm_util.c b/src/support/nlm_util.c
index 8f1e1fb..f808e25 100644
--- a/src/support/nlm_util.c
+++ b/src/support/nlm_util.c
@@ -47,6 +47,7 @@
 #include <rpc/auth.h>
 #include <rpc/pmap_clnt.h>
 #endif
+#include <sys/time.h>
 #include "log_functions.h"
 #include "stuff_alloc.h"
 #include "nfs23.h"
@@ -60,30 +61,39 @@
 #include "mount.h"
 #include "nfs_proto_functions.h"
 #include "nlm_util.h"
+#include "nsm.h"
+#include "nlm_async.h"
+#include "nlm_send_reply.h"
 
+/*
+ * nlm_lock_entry_t locking rule:
+ * The value is always updated/read with nlm_lock_entry->lock held
+ * If we have nlm_lock_list mutex held we can read it safely, because the
+ * value is always updated while walking the list with nlm_lock_list_mutex held.
+ * The updation happens as below:
+ *  pthread_mutex_lock(nlm_lock_list_mutex)
+ *  pthread_mutex_lock(nlm_entry->lock)
+ *    update the nlm_entry value
+ *  ........
+ * The value is ref counted with nlm_lock_entry->ref_count so that a
+ * parallel cancel/unlock won't endup freeing the datastructure. The last
+ * release on the data structure ensure that it is freed.
+ */
 static struct glist_head nlm_lock_list;
 static pthread_mutex_t nlm_lock_list_mutex;
 
-fsal_lockdesc_t *nlm_lock_to_fsal_lockdesc(struct nlm4_lock *nlm_lock, bool_t exclusive)
-{
-  fsal_lockdesc_t *fldesc;
-
-  fldesc = (fsal_lockdesc_t *) Mem_Alloc(sizeof(fsal_lockdesc_t));
-  if(!fldesc)
-    return NULL;
-
-  if(exclusive)
-    fldesc->flock.l_type = F_WRLCK;
-  else
-    fldesc->flock.l_type = F_RDLCK;
-  fldesc->flock.l_whence = SEEK_SET;
-  fldesc->flock.l_start = nlm_lock->l_offset;
-  fldesc->flock.l_len = nlm_lock->l_len;
-  return fldesc;
-}
+/* nlm grace time tracking */
+static struct timeval nlm_grace_tv;
+#define NLM4_GRACE_PERIOD 10
+/*
+ * Time after which we should retry the granted
+ * message request again
+ */
+#define NLM4_CLIENT_GRACE_PERIOD 3
 
-static netobj *copy_netobj(netobj * dst, netobj * src)
+static netobj *copy_netobj(netobj *dst, netobj *src)
 {
+  dst->n_len = 0;
   dst->n_bytes = (char *)Mem_Alloc(src->n_len);
   if(!dst->n_bytes)
     return NULL;
@@ -92,89 +102,322 @@ static netobj *copy_netobj(netobj * dst, netobj * src)
   return dst;
 }
 
-static void net_obj_free(netobj * obj)
+static void netobj_free(netobj * obj)
 {
   if(obj->n_bytes)
     Mem_Free(obj->n_bytes);
 }
 
-static int netobj_compare(netobj obj1, netobj obj2)
+static int netobj_compare(netobj *obj1, netobj *obj2)
 {
-  if(obj1.n_len != obj2.n_len)
+  if (obj1->n_len != obj2->n_len)
     return 1;
-  if(memcmp(obj1.n_bytes, obj2.n_bytes, obj1.n_len))
+  if (memcmp(obj1->n_bytes, obj2->n_bytes, obj1->n_len))
     return 1;
   return 0;
 }
 
-static nlm_lock_t *nlm4_lock_to_nlm_lock(struct nlm4_lock *nlm_lock, int exclusive)
+static nlm_lock_entry_t *nlm4_lock_to_nlm_lock_entry(struct nlm4_lockargs *args)
 {
-  nlm_lock_t *nlmb;
-  nlmb = (nlm_lock_t *) Mem_Calloc(1, sizeof(nlm_lock_t));
-  if(!nlmb)
+  nlm_lock_entry_t *nlm_entry;
+  int exclusive = args->exclusive;
+  nlm4_lock *nlm_lock = &args->alock;
+
+  nlm_entry = (nlm_lock_entry_t *) Mem_Calloc(1, sizeof(nlm_lock_entry_t));
+  if (!nlm_entry)
     return NULL;
-  nlmb->caller_name = strdup(nlm_lock->caller_name);
-  if(!copy_netobj(&nlmb->fh, &nlm_lock->fh))
+  nlm_entry->caller_name = strdup(nlm_lock->caller_name);
+  if (!copy_netobj(&nlm_entry->fh, &nlm_lock->fh))
+    goto err_out;
+  if (!copy_netobj(&nlm_entry->oh, &nlm_lock->oh))
     goto err_out;
-  if(!copy_netobj(&nlmb->oh, &nlm_lock->oh))
+  if (!copy_netobj(&nlm_entry->cookie, &args->cookie))
     goto err_out;
-  nlmb->svid = nlm_lock->svid;
-  nlmb->offset = nlm_lock->l_offset;
-  nlmb->len = nlm_lock->l_len;
-  nlmb->exclusive = exclusive;
-  return nlmb;
+  nlm_entry->svid = nlm_lock->svid;
+  nlm_entry->start = nlm_lock->l_offset;
+  nlm_entry->len =  nlm_lock->l_len;
+  nlm_entry->exclusive = exclusive;
+  nlm_entry->ref_count = 0;
+  pthread_mutex_init(&nlm_entry->lock, NULL);
+  return nlm_entry;
  err_out:
-  free(nlmb->caller_name);
-  net_obj_free(&nlmb->fh);
-  net_obj_free(&nlmb->oh);
-  Mem_Free(nlmb);
+  free(nlm_entry->caller_name);
+  netobj_free(&nlm_entry->fh);
+  netobj_free(&nlm_entry->oh);
+  netobj_free(&nlm_entry->cookie);
+  Mem_Free(nlm_entry);
   return NULL;
 }
 
-nlm_lock_t *nlm_add_to_locklist(struct nlm4_lock * nlm_lock, int exclusive)
+void nlm_lock_entry_to_nlm_holder(nlm_lock_entry_t *nlm_entry,
+				 struct nlm4_holder *holder)
+{
+  /*
+   * Take the lock to make sure other threads don't update
+   * nlm_entry contents in parallel
+   */
+  pthread_mutex_lock(&nlm_entry->lock);
+  holder->exclusive  = nlm_entry->exclusive;
+  holder->oh         = nlm_entry->oh;
+  holder->svid	     = nlm_entry->svid;
+  holder->l_offset   = nlm_entry->start;
+  holder->l_len	     = nlm_entry->len;
+  pthread_mutex_unlock(&nlm_entry->lock);
+}
+
+int nlm_lock_entry_get_state(nlm_lock_entry_t *nlm_entry)
 {
-  nlm_lock_t *nlmb;
-  nlmb = nlm4_lock_to_nlm_lock(nlm_lock, exclusive);
-  if(!nlmb)
+  int lck_state;
+  pthread_mutex_lock(&nlm_entry->lock);
+  lck_state = nlm_entry->state;
+  pthread_mutex_unlock(&nlm_entry->lock);
+  return lck_state;
+}
+
+static void nlm_lock_entry_inc_ref(nlm_lock_entry_t *nlm_entry)
+{
+  pthread_mutex_lock(&nlm_entry->lock);
+  nlm_entry->ref_count++;
+  pthread_mutex_unlock(&nlm_entry->lock);
+}
+
+void nlm_lock_entry_dec_ref(nlm_lock_entry_t *nlm_entry)
+{
+  int to_free = 0;
+  pthread_mutex_lock(&nlm_entry->lock);
+  nlm_entry->ref_count--;
+  if (!nlm_entry->ref_count)
+    {
+      /*
+       * We should already be removed from the lock_list
+       * So we can free the lock_entry without any locking
+       */
+      to_free = 1;
+    }
+  pthread_mutex_unlock(&nlm_entry->lock);
+  if (to_free)
+    {
+      free(nlm_entry->caller_name);
+      netobj_free(&nlm_entry->fh);
+      netobj_free(&nlm_entry->oh);
+      netobj_free(&nlm_entry->cookie);
+      Mem_Free(nlm_entry);
+    }
+}
+
+static nlm_lock_entry_t *get_nlm_overlapping_entry(struct nlm4_lock *nlm_lock,
+						  int exclusive)
+{
+  int overlap = 0;
+  struct glist_head *glist;
+  nlm_lock_entry_t *nlm_entry = NULL;
+  uint64_t nlm_entry_end, nlm_lock_end;
+
+  glist_for_each(glist, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+
+      if (netobj_compare(&nlm_entry->fh, &nlm_lock->fh))
+	continue;
+
+      if (nlm_entry->state != NLM4_GRANTED)
+	continue;
+
+      if (nlm_entry->len)
+	nlm_entry_end = nlm_entry->start + nlm_entry->len;
+      else
+	nlm_entry_end = UINT64_MAX;
+
+      if (nlm_lock->l_len)
+	nlm_lock_end = nlm_lock->l_offset + nlm_lock->l_len;
+      else
+	nlm_lock_end = UINT64_MAX;
+
+      if ((nlm_entry_end > nlm_lock->l_offset) &&
+	  (nlm_lock_end > nlm_entry->start))
+	{
+	  /* lock overlaps see if we can allow */
+	  if (nlm_entry->exclusive || exclusive)
+	    {
+	      overlap = 1;
+	      break;
+	    }
+	}
+    }
+
+  if (!overlap)
     return NULL;
+
+  nlm_lock_entry_inc_ref(nlm_entry);
+  return nlm_entry;
+}
+
+nlm_lock_entry_t *nlm_overlapping_entry(struct nlm4_lock *nlm_lock, int exclusive)
+{
+  nlm_lock_entry_t *nlm_entry;
+
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  nlm_entry = get_nlm_overlapping_entry(nlm_lock, exclusive);
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+
+  return nlm_entry;
+}
+
+nlm_lock_entry_t *nlm_add_to_locklist(struct nlm4_lockargs *arg)
+{
+  int allow = 1;
+  int exclusive;
+  struct glist_head *glist;
+  struct nlm4_lock *nlm_lock;
+  nlm_lock_entry_t *nlm_entry;
+  uint64_t nlm_entry_end, nlm_lock_end;
+
+  nlm_lock = &arg->alock;
+  exclusive = arg->exclusive;
   pthread_mutex_lock(&nlm_lock_list_mutex);
-  glist_add_tail(&nlm_lock_list, &nlmb->lock_list);
+  /*
+   * First search for a blocked request. Client can ignore the blocked
+   * request and keep sending us new lock request again and again. So if
+   * we have a mapping blocked request return that
+   */
+  glist_for_each(glist, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+
+      if (netobj_compare(&nlm_entry->fh, &nlm_lock->fh))
+	continue;
+      if (nlm_entry->state != NLM4_BLOCKED)
+	continue;
+      if (nlm_entry->start != nlm_lock->l_offset)
+	continue;
+      if (nlm_entry->len != nlm_lock->l_len)
+	continue;
+      if (nlm_entry->exclusive != exclusive)
+	continue;
+      /*
+       * We have matched all atribute of the nlm4_lock.
+       * Just return the nlm_entry with ref count inc
+       */
+      nlm_lock_entry_inc_ref(nlm_entry);
+      pthread_mutex_unlock(&nlm_lock_list_mutex);
+      DisplayLogLevel(NIV_FULL_DEBUG, "lock request (but found blocked locks)");
+      return nlm_entry;
+    }
+
+  glist_for_each(glist, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+
+      if (netobj_compare(&nlm_entry->fh, &nlm_lock->fh))
+	continue;
+
+      if (nlm_entry->len)
+	nlm_entry_end = nlm_entry->start + nlm_entry->len;
+      else
+	nlm_entry_end = UINT64_MAX;
+
+      if (nlm_lock->l_len)
+	nlm_lock_end = nlm_lock->l_offset + nlm_lock->l_len;
+      else
+	nlm_lock_end = UINT64_MAX;
+
+      if ((nlm_entry_end > nlm_lock->l_offset) &&
+	  (nlm_lock_end > nlm_entry->start))
+	{
+	  /* lock overlaps see if we can allow */
+	  if (nlm_entry->exclusive || exclusive)
+	    {
+	      allow = 0;
+	      break;
+	    }
+	}
+    }
+  nlm_entry = nlm4_lock_to_nlm_lock_entry(arg);
+  if (!nlm_entry)
+    goto error_out;
+  /*
+   * Add nlm_entry to the lock list with
+   * granted or blocked state. Since we haven't yet added
+   * nlm_lock_entry to the lock list, no other threads can
+   * find this lock entry. So no need to take the lock.
+   */
+  if (allow)
+    {
+      nlm_entry->state = NLM4_GRANTED;
+    }
+  else
+    {
+      nlm_entry->state = NLM4_BLOCKED;
+    }
+  /*
+   * +1 for being on the list
+   * +1 for the refcount returned
+   */
+  nlm_entry->ref_count += 2;
+  glist_add_tail(&nlm_lock_list, &nlm_entry->lock_list);
+
+error_out:
   pthread_mutex_unlock(&nlm_lock_list_mutex);
-  return nlmb;
+  return nlm_entry;
 }
 
-void nlm_remove_from_locklist(nlm_lock_t * nlmb)
+static void do_nlm_remove_from_locklist(nlm_lock_entry_t * nlm_entry)
+{
+  /*
+   * If some other thread is holding a reference to this nlm_lock_entry
+   * don't free the structure. But drop from the lock list
+   */
+  glist_del(&nlm_entry->lock_list);
+
+  pthread_mutex_lock(&nlm_entry->lock);
+  nlm_entry->ref_count--;
+  if (nlm_entry->ref_count)
+    {
+      pthread_mutex_unlock(&nlm_entry->lock);
+      return;
+    }
+  pthread_mutex_unlock(&nlm_entry->lock);
+  /*
+   * We have dropped ourself from the lock list. So other
+   * thread won't be able to find this lock entry. And since
+   * ref_count is 0 there is existing reference to the entry.
+   * So update without lock held.
+   */
+  free(nlm_entry->caller_name);
+  netobj_free(&nlm_entry->fh);
+  netobj_free(&nlm_entry->oh);
+  netobj_free(&nlm_entry->cookie);
+  Mem_Free(nlm_entry);
+}
+
+void nlm_remove_from_locklist(nlm_lock_entry_t * nlm_entry)
 {
   pthread_mutex_lock(&nlm_lock_list_mutex);
-  glist_del(&nlmb->lock_list);
+  do_nlm_remove_from_locklist(nlm_entry);
   pthread_mutex_unlock(&nlm_lock_list_mutex);
-  free(nlmb->caller_name);
-  net_obj_free(&nlmb->fh);
-  net_obj_free(&nlmb->oh);
-  Mem_Free(nlmb);
 }
 
-void nlm_init_locklist(void)
+static void nlm_init_locklist(void)
 {
   init_glist(&nlm_lock_list);
   pthread_mutex_init(&nlm_lock_list_mutex, NULL);
 }
 
-nlm_lock_t *nlm_find_lock_entry(struct nlm4_lock *nlm_lock, int exclusive, int state)
+nlm_lock_entry_t *nlm_find_lock_entry(struct nlm4_lock *nlm_lock, int exclusive, int state)
 {
-  nlm_lock_t *nlmb;
+  nlm_lock_entry_t *nlm_entry;
   struct glist_head *glist;
   pthread_mutex_lock(&nlm_lock_list_mutex);
   glist_for_each(glist, &nlm_lock_list)
   {
-    nlmb = glist_entry(glist, nlm_lock_t, lock_list);
-    if(strcmp(nlmb->caller_name, nlm_lock->caller_name))
+    nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+    if (strcmp(nlm_entry->caller_name, nlm_lock->caller_name))
       continue;
-    if(netobj_compare(nlmb->fh, nlm_lock->fh))
+    if (netobj_compare(&nlm_entry->fh, &nlm_lock->fh))
       continue;
-    if(netobj_compare(nlmb->oh, nlm_lock->oh))
+    if (netobj_compare(&nlm_entry->oh, &nlm_lock->oh))
       continue;
-    if(nlmb->svid != nlm_lock->svid)
+    if (nlm_entry->svid != nlm_lock->svid)
       continue;
     if(state == NLM4_GRANTED)
       {
@@ -187,73 +430,465 @@ nlm_lock_t *nlm_find_lock_entry(struct nlm4_lock *nlm_lock, int exclusive, int s
          */
         break;
       }
-    if(nlmb->offset != nlm_lock->l_offset)
+    if (nlm_entry->start != nlm_lock->l_offset)
       continue;
-    if(nlmb->len != nlm_lock->l_len)
+    if (nlm_entry->len != nlm_lock->l_len)
       continue;
-    if(nlmb->exclusive != exclusive)
+    if (nlm_entry->exclusive != exclusive)
       continue;
-    if(nlmb->state != state)
+    if (nlm_entry->state != state)
       continue;
     /* We have matched all atribute of the nlm4_lock */
     break;
   }
-  pthread_mutex_unlock(&nlm_lock_list_mutex);
   if(glist == &nlm_lock_list)
-    return NULL;
-  return nlmb;
+    nlm_entry = NULL;
+  else
+    nlm_lock_entry_inc_ref(nlm_entry);
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+
+  return nlm_entry;
 }
 
-static nlm_lock_t *nlm_lock_t_dup(nlm_lock_t * orig_nlmb)
+static nlm_lock_entry_t *nlm_lock_entry_t_dup(nlm_lock_entry_t * orig_nlm_entry)
 {
-  nlm_lock_t *nlmb;
-  nlmb = (nlm_lock_t *) Mem_Calloc(1, sizeof(nlm_lock_t));
-  if(!nlmb)
+  nlm_lock_entry_t *nlm_entry;
+  nlm_entry = (nlm_lock_entry_t *) Mem_Calloc(1, sizeof(nlm_lock_entry_t));
+  if (!nlm_entry)
     return NULL;
-  nlmb->caller_name = strdup(orig_nlmb->caller_name);
-  if(!copy_netobj(&nlmb->fh, &orig_nlmb->fh))
+  nlm_entry->caller_name = strdup(orig_nlm_entry->caller_name);
+  if (!copy_netobj(&nlm_entry->fh, &orig_nlm_entry->fh))
     goto err_out;
-  if(!copy_netobj(&nlmb->oh, &orig_nlmb->oh))
+  if (!copy_netobj(&nlm_entry->oh, &orig_nlm_entry->oh))
     goto err_out;
-  nlmb->svid = orig_nlmb->svid;
-  nlmb->offset = orig_nlmb->offset;
-  nlmb->len = orig_nlmb->len;
-  nlmb->state = orig_nlmb->state;
-  nlmb->exclusive = orig_nlmb->exclusive;
-  return nlmb;
+  if (!copy_netobj(&nlm_entry->cookie, &orig_nlm_entry->cookie))
+    goto err_out;
+  nlm_entry->svid = orig_nlm_entry->svid;
+  nlm_entry->start = orig_nlm_entry->start;
+  nlm_entry->len = orig_nlm_entry->len;
+  nlm_entry->state = orig_nlm_entry->state;
+  nlm_entry->exclusive = orig_nlm_entry->exclusive;
+  nlm_entry->ref_count = 0;
+  pthread_mutex_init(&nlm_entry->lock, NULL);
+  return nlm_entry;
  err_out:
-  free(nlmb->caller_name);
-  net_obj_free(&nlmb->fh);
-  net_obj_free(&nlmb->oh);
-  Mem_Free(nlmb);
+  free(nlm_entry->caller_name);
+  netobj_free(&nlm_entry->fh);
+  netobj_free(&nlm_entry->oh);
+  netobj_free(&nlm_entry->cookie);
+  Mem_Free(nlm_entry);
   return NULL;
 
 }
 
-void nlm_delete_lock_entry(nlm_lock_t * nlmb, struct nlm4_lock *nlm_lock)
+static int do_nlm_delete_lock_entry(nlm_lock_entry_t  *nlm_entry,
+			     struct nlm4_lock *nlm_lock,
+			     struct glist_head *split_list)
 {
-  nlm_lock_t *nlmb_left = NULL;
-  nlm_lock_t *nlmb_right = NULL;
-  if(nlm_lock->l_offset > nlmb->offset)
+  int delete_lck_cnt = 0;
+  uint64_t nlm_entry_end;
+  uint64_t nlm_lock_end;
+  nlm_lock_entry_t *nlm_entry_left = NULL;
+  nlm_lock_entry_t *nlm_entry_right = NULL;
+
+  if (nlm_entry->len)
+    nlm_entry_end = nlm_entry->start + nlm_entry->len;
+  else
+    nlm_entry_end = UINT64_MAX;
+
+  if (nlm_lock->l_len)
+    nlm_lock_end = nlm_lock->l_offset + nlm_lock->l_len;
+  else
+    nlm_lock_end = UINT64_MAX;
+
+  if (nlm_lock_end < nlm_entry->start)
+    /* nothing to split */
+    goto done;
+  if (nlm_entry_end < nlm_lock->l_offset)
+    /* nothing to split */
+    goto done;
+  if ((nlm_lock->l_offset <= nlm_entry->start) &&
+      nlm_lock_end >= nlm_entry_end)
+    /* Fully overlap */
+    goto complete_remove;
+  /* Delete the old entry and add the two new entries */
+  if (nlm_lock->l_offset > nlm_entry->start)
     {
-      nlmb_left = nlm_lock_t_dup(nlmb);
+      delete_lck_cnt--;
+      nlm_entry_left = nlm_lock_entry_t_dup(nlm_entry);
       /* FIXME handle error */
-      nlmb_left->len = nlmb->offset - nlm_lock->l_offset;
+      nlm_entry_left->len = nlm_lock->l_offset - nlm_entry->start;
     }
-  if((nlm_lock->l_offset + nlm_lock->l_len) < (nlmb->offset + nlmb->len))
+  if (nlm_lock_end < nlm_entry_end)
     {
-      nlmb_right = nlm_lock_t_dup(nlmb);
+      delete_lck_cnt--;;
+      nlm_entry_right = nlm_lock_entry_t_dup(nlm_entry);
       /* FIXME handle error */
-      nlmb_right->offset = nlm_lock->l_offset + nlm_lock->l_len;
-      nlmb_right->len = (nlmb->offset + nlmb->len) -
-          (nlm_lock->l_offset + nlm_lock->l_len);
+      nlm_entry_right->start = nlm_lock_end;
+      nlm_entry_right->len = nlm_entry_end - nlm_lock_end;
     }
-  /* Delete the old entry and add the two new entries */
-  nlm_remove_from_locklist(nlmb);
+  if (nlm_entry_left)
+    {
+      nlm_lock_entry_inc_ref(nlm_entry_left);
+      glist_add_tail(split_list, &(nlm_entry_left->lock_list));
+    }
+  if (nlm_entry_right)
+    {
+      nlm_lock_entry_inc_ref(nlm_entry_right);
+      glist_add_tail(split_list, &(nlm_entry_right->lock_list));
+    }
+complete_remove:
+  delete_lck_cnt++;
+  do_nlm_remove_from_locklist(nlm_entry);
+done:
+  return delete_lck_cnt;
+}
+
+/* We need to iterate over the full lock list and remove
+ * any mapping entry. And l_offset = 0 and l_len = 0 nlm_lock
+ * implies remove all entries
+ */
+int nlm_delete_lock_entry(struct nlm4_lock *nlm_lock)
+{
+  int delete_lck_cnt = 0;
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head split_lock_list;
+  struct glist_head *glist, *glistn;
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  init_glist(&split_lock_list);
+  glist_for_each_safe(glist, glistn, &nlm_lock_list)
+  {
+    nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+    if (strcmp(nlm_entry->caller_name, nlm_lock->caller_name))
+      continue;
+    if (netobj_compare(&nlm_entry->fh, &nlm_lock->fh))
+      continue;
+    if (netobj_compare(&nlm_entry->oh, &nlm_lock->oh))
+      continue;
+    if (nlm_entry->svid != nlm_lock->svid)
+      continue;
+    /*
+     * We have matched all atribute of the nlm4_lock
+     * Even though we are taking a reference to nlm_entry, we
+     * don't inc the ref count because we want to drop the lock entry.
+     */
+    delete_lck_cnt += do_nlm_delete_lock_entry(nlm_entry, nlm_lock, &split_lock_list);
+  }
+  /* now add the split lock list */
+  glist_add_list_tail(&nlm_lock_list, &split_lock_list);
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+  return delete_lck_cnt;
+}
+
+nlm_lock_entry_t *nlm_find_lock_entry_by_cookie(netobj *cookie)
+{
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head *glist;
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  glist_for_each(glist, &nlm_lock_list)
+  {
+    nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+    if (!netobj_compare(&nlm_entry->cookie, cookie))
+      break;
+  }
+  if(glist == &nlm_lock_list)
+    nlm_entry = NULL;
+  else
+    nlm_lock_entry_inc_ref(nlm_entry);
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+  return nlm_entry;
+}
+
+int start_nlm_grace_period(void)
+{
+  return gettimeofday(&nlm_grace_tv, NULL);
+}
+
+int in_nlm_grace_period(void)
+{
+  struct timeval tv;
+  if (nlm_grace_tv.tv_sec == 0)
+    return 0;
+
+  if (gettimeofday(&tv, NULL) == 0)
+    {
+      if (tv.tv_sec < (nlm_grace_tv.tv_sec + NLM4_GRACE_PERIOD))
+	{
+	  return 1;
+	}
+      else
+	{
+	  nlm_grace_tv.tv_sec = 0;
+	  return 0;
+	}
+    }
+  return 0;
+}
+
+void nlm_init(void)
+{
+  nlm_async_callback_init();
+  nlm_init_locklist();
+  nsm_unmonitor_all();
+  start_nlm_grace_period();
+}
+
+void nlm_node_recovery(char *name,
+		       fsal_op_context_t *pcontext,
+		       cache_inode_client_t *pclient,
+		       hash_table_t *ht)
+{
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head *glist, *glistn;
+
+  DisplayLogLevel(NIV_FULL_DEBUG, "Recovery for host %s\n", name);
+
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  glist_for_each_safe(glist, glistn, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+      if (strcmp(nlm_entry->caller_name, name))
+	continue;
+
+      /*
+       * inc ref so that we can remove entry from the list
+       * and still use the lock entry values
+       */
+      nlm_lock_entry_inc_ref(nlm_entry);
+
+      /*
+       * now remove the from locklist
+       */
+      do_nlm_remove_from_locklist(nlm_entry);
+
+      /*
+       * We don't inc ref count because we want to drop the lock entry
+       */
+      if (nlm_entry->state == NLM4_GRANTED)
+	{
+	  /*
+	   * Submit the async request to send granted response for
+	   * locks that can be granted
+	   */
+	  nlm_grant_blocked_locks(&nlm_entry->fh);
+	}
+      nlm_lock_entry_dec_ref(nlm_entry);
+    }
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+}
+
+int nlm_monitor_host(char *name)
+{
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head *glist;
+
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  glist_for_each(glist, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+      if (!strcmp(nlm_entry->caller_name, name))
+	{
+	  /* there is already a lock with the same
+	   * caller_name. So we should already be monitoring
+	   * the host
+	   */
+	  pthread_mutex_unlock(&nlm_lock_list_mutex);
+	  return 0;
+	}
+    }
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+  /* There is nobody monitoring the host */
+  DisplayLogLevel(NIV_FULL_DEBUG, "Monitoring host %s\n", name);
+  return nsm_monitor(name);
+}
+
+int nlm_unmonitor_host(char *name)
+{
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head *glist;
+
   pthread_mutex_lock(&nlm_lock_list_mutex);
-  if(nlmb_left)
-    glist_add_tail(&nlm_lock_list, &(nlmb_left->lock_list));
-  if(nlmb_right)
-    glist_add_tail(&nlm_lock_list, &(nlmb_right->lock_list));
+  glist_for_each(glist, &nlm_lock_list)
+    {
+      nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+      if (!strcmp(nlm_entry->caller_name, name))
+	{
+	  /* We have locks tracking the same caller_name
+	   * we cannot unmonitor the host now. We will do
+	   * it for the last unlock from the host
+	   */
+	  pthread_mutex_unlock(&nlm_lock_list_mutex);
+	  return 0;
+	}
+    }
   pthread_mutex_unlock(&nlm_lock_list_mutex);
+  /* There is nobody holding a lock with host */
+  DisplayLogLevel(NIV_FULL_DEBUG, "Unmonitoring host %s\n", name);
+  return nsm_unmonitor(name);
+}
+
+static void nlm4_send_grant_msg(void *arg)
+{
+  int retval;
+  struct nlm4_testargs inarg;
+  nlm_lock_entry_t *nlm_entry = (nlm_lock_entry_t *)arg;
+
+  /* If we fail allocation the best is to delete the block entry
+   * so that client can try again and get the lock. May be
+   * by then we are able to allocate objects
+   */
+  if (!copy_netobj(&inarg.alock.fh, &nlm_entry->fh))
+    {
+      goto free_nlm_lock_entry;
+    }
+  if (!copy_netobj(&inarg.alock.oh, &nlm_entry->oh))
+    {
+      netobj_free(&inarg.alock.fh);
+      goto free_nlm_lock_entry;
+    }
+
+  if (!copy_netobj(&inarg.cookie, &nlm_entry->cookie))
+    {
+      netobj_free(&inarg.alock.oh);
+      netobj_free(&inarg.alock.fh);
+      goto free_nlm_lock_entry;
+    }
+  inarg.alock.caller_name = strdup(nlm_entry->caller_name);
+  if (!inarg.alock.caller_name)
+    {
+      netobj_free(&inarg.cookie);
+      netobj_free(&inarg.alock.oh);
+      netobj_free(&inarg.alock.fh);
+      goto free_nlm_lock_entry;
+    }
+  inarg.exclusive = nlm_entry->exclusive;
+  inarg.alock.svid = nlm_entry->svid;
+  inarg.alock.l_offset = nlm_entry->start;
+  inarg.alock.l_len = nlm_entry->len;
+
+  retval = nlm_send_reply(NLMPROC4_GRANTED_MSG, nlm_entry->caller_name,
+			  &inarg, NULL);
+  free(inarg.alock.caller_name);
+  netobj_free(&inarg.alock.fh);
+  netobj_free(&inarg.alock.oh);
+  netobj_free(&inarg.cookie);
+  if (retval != RPC_SUCCESS)
+    {
+      /*
+       * We are not able call granted callback. Some client may retry
+       * the lock again. So remove the existing blocked nlm entry
+       */
+      DisplayLogLevel(NIV_MAJ,
+		      "%s: GRANTED_MSG RPC call failed. Removing the blocking lock\n", __func__);
+      goto free_nlm_lock_entry;
+    }
+  else
+    {
+      /*
+       * We already have marked the locks granted
+       */
+      DisplayLogLevel(NIV_MAJ,
+		      "%s: Granted the blocking lock successfully\n", __func__);
+    }
+free_nlm_lock_entry:
+  nlm_remove_from_locklist(nlm_entry);
+  /*
+   * Submit the async request to send granted response for
+   * locks that can be granted, because of this removal
+   * from the lock list. If the client is lucky. It
+   * will send the lock request again and before the
+   * block locks are granted it gets the lock.
+   */
+  nlm_grant_blocked_locks(&nlm_entry->fh);
+  nlm_lock_entry_dec_ref(nlm_entry);
+  return;
 }
+
+static void do_nlm_grant_blocked_locks(void *arg)
+{
+  netobj *fh;
+  struct nlm4_lock nlm_lock;
+  nlm_lock_entry_t *nlm_entry;
+  struct glist_head *glist, *glistn;
+  nlm_lock_entry_t *nlm_entry_overlap;
+
+  fh = (netobj *)arg;
+  pthread_mutex_lock(&nlm_lock_list_mutex);
+  glist_for_each_safe(glist, glistn, &nlm_lock_list)
+  {
+    nlm_entry = glist_entry(glist, nlm_lock_entry_t, lock_list);
+    if (netobj_compare(&nlm_entry->fh, fh))
+      continue;
+    if (nlm_entry->state != NLM4_BLOCKED)
+      continue;
+    /*
+     * found a blocked entry for this file handle
+     * See if we can place the lock
+     */
+    /* dummy nlm4_lock */
+    if (!copy_netobj(&nlm_lock.fh, &nlm_entry->fh))
+      {
+	/* If we fail the best is to delete the block entry
+	 * so that client can try again and get the lock. May be
+	 * by then we are able to allocate objects
+	 */
+	do_nlm_remove_from_locklist(nlm_entry);
+	continue;
+      }
+    nlm_lock.l_offset = nlm_entry->start;
+    nlm_lock.l_len = nlm_entry->len;
+    nlm_entry_overlap = get_nlm_overlapping_entry(&nlm_lock, nlm_entry->exclusive);
+    netobj_free(&nlm_lock.fh);
+    if (nlm_entry_overlap) {
+      nlm_lock_entry_dec_ref(nlm_entry_overlap);
+      continue;
+    }
+
+    pthread_mutex_lock(&nlm_entry->lock);
+    /*
+     * Mark the nlm_entry as granted and send a grant msg rpc
+     * Some os only support grant msg rpc
+     */
+
+    nlm_entry->state = NLM4_GRANTED;
+    nlm_entry->ref_count++;
+    pthread_mutex_unlock(&nlm_entry->lock);
+    /*
+     * We don't want to send the granted_msg rpc holding
+     * nlm_lock_list_mutex. That will prevent other lock operation
+     * at the server. We have incremented nlm_entry ref_count.
+     */
+    nlm_async_callback(nlm4_send_grant_msg, (void *)nlm_entry);
+  }
+  pthread_mutex_unlock(&nlm_lock_list_mutex);
+  netobj_free(fh);
+  Mem_Free(fh);
+}
+
+void nlm_grant_blocked_locks(netobj *orig_fh)
+{
+  netobj *fh;
+  fh = (netobj *)Mem_Alloc(sizeof(netobj));
+  copy_netobj(fh, orig_fh);
+  /*
+   * We don't want to block the unlock request to wait
+   * for us to grant lock to other host. So create an async
+   * task
+   */
+  nlm_async_callback(do_nlm_grant_blocked_locks, (void *)fh);
+}
+
+/*
+ * called when server get a response from client
+ * saying the grant message is denied due to grace period
+ */
+void nlm_resend_grant_msg(void *arg)
+{
+  /*
+   * We should wait for client grace period
+   */
+  sleep(NLM4_CLIENT_GRACE_PERIOD);
+
+  nlm4_send_grant_msg(arg);
+}
+
diff --git a/src/support/nsm.c b/src/support/nsm.c
new file mode 100644
index 0000000..58d517b
--- /dev/null
+++ b/src/support/nsm.c
@@ -0,0 +1,151 @@
+/*
+ * Copyright IBM Corporation, 2010
+ *  Contributor: Aneesh Kumar K.v  <aneesh.kumar@linux.vnet.ibm.com>
+ *             : M. Mohan Kumar <mohan@in.ibm.com>
+ *
+ * --------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ *
+ */
+
+#include <rpc/rpc.h>
+
+#include "nsm.h"
+#include "nlm4.h"
+
+int nsm_monitor(char *host)
+{
+
+  CLIENT *clnt;
+  enum clnt_stat ret;
+  struct mon nsm_mon;
+  struct sm_stat_res res;
+  struct timeval tout  = { 5, 0 };
+
+  nsm_mon.mon_id.mon_name = strdup(host);
+  nsm_mon.mon_id.my_id.my_name = strdup("localhost");
+  nsm_mon.mon_id.my_id.my_prog = NLMPROG;
+  nsm_mon.mon_id.my_id.my_vers = NLM4_VERS;
+  nsm_mon.mon_id.my_id.my_proc = NLMPROC4_SM_NOTIFY;
+  /* nothing to put in the private data */
+
+  /* create a connection to nsm on the localhost */
+  clnt = clnt_create("localhost", SM_PROG, SM_VERS, "tcp");
+  if (!clnt)
+    {
+      free(nsm_mon.mon_id.mon_name);
+      free(nsm_mon.mon_id.my_id.my_name);
+      return -1;
+    }
+
+  ret = clnt_call(clnt, SM_MON,
+		  (xdrproc_t)xdr_mon, (caddr_t)&nsm_mon,
+		  (xdrproc_t)xdr_sm_stat_res, (caddr_t)&res, tout);
+  if (ret != RPC_SUCCESS)
+    {
+      free(nsm_mon.mon_id.mon_name);
+      free(nsm_mon.mon_id.my_id.my_name);
+      clnt_destroy(clnt);
+      return -1;
+    }
+  if (res.res_stat != STAT_SUCC)
+    {
+      free(nsm_mon.mon_id.mon_name);
+      free(nsm_mon.mon_id.my_id.my_name);
+      clnt_destroy(clnt);
+      return -1;
+    }
+  free(nsm_mon.mon_id.mon_name);
+  free(nsm_mon.mon_id.my_id.my_name);
+  clnt_destroy(clnt);
+  return 0;
+}
+
+int nsm_unmonitor(char *host)
+{
+
+  CLIENT *clnt;
+  enum clnt_stat ret;
+  struct sm_stat res;
+  struct mon_id nsm_mon_id;
+  struct timeval tout  = { 5, 0 };
+
+  nsm_mon_id.mon_name = strdup(host);
+  nsm_mon_id.my_id.my_name = strdup("localhost");
+  nsm_mon_id.my_id.my_prog = NLMPROG;
+  nsm_mon_id.my_id.my_vers = NLM4_VERS;
+  nsm_mon_id.my_id.my_proc = NLMPROC4_SM_NOTIFY;
+
+  /* create a connection to nsm on the localhost */
+  clnt = clnt_create("localhost", SM_PROG, SM_VERS, "tcp");
+  if (!clnt)
+    {
+      free(nsm_mon_id.mon_name);
+      free(nsm_mon_id.my_id.my_name);
+      return -1;
+    }
+
+  ret = clnt_call(clnt, SM_UNMON,
+		  (xdrproc_t)xdr_mon_id, (caddr_t)&nsm_mon_id,
+		  (xdrproc_t)xdr_sm_stat, (caddr_t)&res, tout);
+  if (ret != RPC_SUCCESS)
+    {
+      free(nsm_mon_id.mon_name);
+      free(nsm_mon_id.my_id.my_name);
+      clnt_destroy(clnt);
+      return -1;
+    }
+  free(nsm_mon_id.mon_name);
+  free(nsm_mon_id.my_id.my_name);
+  clnt_destroy(clnt);
+  return 0;
+}
+
+int nsm_unmonitor_all(void)
+{
+  CLIENT *clnt;
+  enum clnt_stat ret;
+  struct sm_stat res;
+  struct my_id nsm_id;
+  struct timeval tout  = { 5, 0 };
+
+  nsm_id.my_name = strdup("localhost");
+  nsm_id.my_prog = NLMPROG;
+  nsm_id.my_vers = NLM4_VERS;
+  nsm_id.my_proc = NLMPROC4_SM_NOTIFY;
+
+  /* create a connection to nsm on the localhost */
+  clnt = clnt_create("localhost", SM_PROG, SM_VERS, "tcp");
+  if (!clnt)
+    {
+      free(nsm_id.my_name);
+      return -1;
+    }
+
+  ret = clnt_call(clnt, SM_UNMON_ALL,
+		  (xdrproc_t)xdr_my_id, (caddr_t)&nsm_id,
+		  (xdrproc_t)xdr_sm_stat, (caddr_t)&res, tout);
+  if (ret != RPC_SUCCESS)
+    {
+      free(nsm_id.my_name);
+      clnt_destroy(clnt);
+      return -1;
+    }
+  free(nsm_id.my_name);
+  clnt_destroy(clnt);
+  return 0;
+}
diff --git a/src/test/test_glist.c b/src/test/test_glist.c
index 92f0786..b252b7e 100644
--- a/src/test/test_glist.c
+++ b/src/test/test_glist.c
@@ -58,6 +58,7 @@ struct myteststruct
 };
 
 struct glist_head mytestglist;
+struct glist_head mytestglist_new;
 
 static void print_glist(struct glist_head *head)
 {
@@ -77,7 +78,10 @@ int main(int argc, char *argv[])
   struct myteststruct node2;
   struct myteststruct node3;
   struct myteststruct node4;
+  struct myteststruct node1_new;
+  struct myteststruct node2_new;
   init_glist(&mytestglist);
+  init_glist(&mytestglist_new);
   node1.value = 10;
   node2.value = 11;
   node3.value = 12;
@@ -93,5 +97,17 @@ int main(int argc, char *argv[])
   printf("Delete test\n");
   glist_del(&node2.glist);
   print_glist(&mytestglist);
+  node1_new.value = 15;
+  node2_new.value = 16;
+  glist_add(&mytestglist_new, &node1_new.glist);
+  glist_add(&mytestglist_new, &node2_new.glist);
+  printf("Add the below two list\n");
+  printf("list1\n");
+  print_glist(&mytestglist);
+  printf("list2\n");
+  print_glist(&mytestglist_new);
+  glist_add_list_tail(&mytestglist, &mytestglist_new);
+  printf("combined list\n");
+  print_glist(&mytestglist);
   return 0;
 }
-- 
1.7.0.4.360.g11766c

