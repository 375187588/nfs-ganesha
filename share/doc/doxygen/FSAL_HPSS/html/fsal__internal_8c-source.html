<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>File System Abstraction Layer (HPSS) library: fsal_internal.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>fsal_internal.c</h1><a href="fsal__internal_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> */</span>
00004 
00015 <span class="preprocessor">#define FSAL_INTERNAL_C</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#include  "fsal.h"</span>
00021 <span class="preprocessor">#include "fsal_internal.h"</span>
00022 <span class="preprocessor">#include "stuff_alloc.h"</span>
00023 <span class="preprocessor">#include "SemN.h"</span>
00024  
00025 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00026 
00027 
00028 <span class="comment">/* credential lifetime (1h) */</span>
00029 fsal_uint_t  CredentialLifetime = 3600 ;
00030 
00031 <span class="comment">/* Behavior for inconsistent direntries */</span>
00032 fsal_uint_t  ReturnInconsistentDirent = FALSE;
00033 
00034 <span class="comment">/* static filesystem info.</span>
00035 <span class="comment"> * The access is thread-safe because</span>
00036 <span class="comment"> * it is read-only, except during initialization.</span>
00037 <span class="comment"> */</span>
00038 fsal_staticfsinfo_t   global_fs_info;
00039 
00040 
00041 <span class="comment">/* filesystem info for HPSS */</span>
00042 <span class="keyword">static</span> fsal_staticfsinfo_t default_hpss_info =
00043   {
00044     0xFFFFFFFFFFFFFFFFLL, <span class="comment">/* max file size (64bits) */</span>
00045     NS_MAX_HARD_LINK_VALUE, <span class="comment">/* max links */</span>
00046     FSAL_MAX_NAME_LEN, <span class="comment">/* max filename */</span>
00047     FSAL_MAX_PATH_LEN, <span class="comment">/* min filename */</span>
00048     TRUE,  <span class="comment">/* no_trunc */</span>
00049     TRUE,  <span class="comment">/* chown restricted */</span>
00050     FALSE, <span class="comment">/* case insensitivity */</span>
00051     TRUE,  <span class="comment">/* case preserving */</span>
00052     FSAL_EXPTYPE_PERSISTENT, <span class="comment">/* FH expire type */</span>
00053     TRUE,  <span class="comment">/* hard link support */</span>
00054     TRUE,  <span class="comment">/* sym link support */</span>
00055     FALSE, <span class="comment">/* lock management */</span>
00056     FALSE, <span class="comment">/* cannot set named attributes */</span>
00057     TRUE,  <span class="comment">/* handles are unique and persistent */</span>
00058     {10,0}, <span class="comment">/* Duration of lease at FS in seconds */</span>
00059     FSAL_ACLSUPPORT_ALLOW,     <span class="comment">/* ACL support */</span>
00060     TRUE,  <span class="comment">/* can change times */</span>
00061     TRUE,  <span class="comment">/* homogenous */</span>
00062     HPSS_SUPPORTED_ATTRIBUTES, <span class="comment">/* supported attributes */</span>
00063     (1024*1024),     <span class="comment">/* maxread size */</span>
00064     (1024*1024),     <span class="comment">/* maxwrite size */</span>
00065     0,     <span class="comment">/* default umask */</span>
00066     0      <span class="comment">/* don't allow cross fileset export path */</span>
00067   };
00068 
00069 
00070 <span class="comment">/*</span>
00071 <span class="comment"> *  Log Descriptor</span>
00072 <span class="comment"> */</span>
00073 log_t   fsal_log;
00074 
00075 
00076 <span class="comment">/* variables for limiting the calls to the filesystem */</span>
00077 <span class="keyword">static</span> <span class="keywordtype">int</span> limit_calls = FALSE;
00078 semaphore_t sem_fs_calls;
00079 
00080 
00081 <span class="comment">/* threads keys for stats */</span>
00082 <span class="keyword">static</span> pthread_key_t key_stats ;
00083 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00084 
00085 <span class="comment">/* init keys */</span>
00086 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00087 {
00088   <span class="keywordflow">if</span>( pthread_key_create( &amp;key_stats, NULL ) == -1 )
00089       DisplayErrorJd( fsal_log, ERR_SYS , ERR_PTHREAD_KEY_CREATE, errno );
00090   
00091   return ;
00092 } <span class="comment">/* init_keys */</span>
00093 
00094 
<a name="l00106"></a><a class="code" href="fsal__internal_8c.html#a14">00106</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a14">fsal_increment_nbcall</a>( <span class="keywordtype">int</span> function_index , fsal_status_t  status )
00107 {
00108   
00109   fsal_statistics_t * bythread_stat = NULL ;
00110 
00111   <span class="comment">/* verify index */</span>
00112   
00113   <span class="keywordflow">if</span> (function_index &gt;= FSAL_NB_FUNC) <span class="keywordflow">return</span>;
00114   
00115   <span class="comment">/* first, we init the keys if this is the first time */</span>
00116   
00117   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 )
00118   {
00119     DisplayErrorJd( fsal_log, ERR_SYS, ERR_PTHREAD_ONCE, errno );
00120     <span class="keywordflow">return</span>;
00121   }
00122   
00123   <span class="comment">/* we get the specific value */</span>
00124   
00125   bythread_stat = (fsal_statistics_t *) pthread_getspecific( key_stats ) ;
00126   
00127   <span class="comment">/* we allocate stats if this is the first time */</span>
00128   
00129   <span class="keywordflow">if</span>( bythread_stat == NULL )
00130   {
00131       <span class="keywordtype">int</span> i;
00132       
00133       bythread_stat =
00134             (fsal_statistics_t *)Mem_Alloc( <span class="keyword">sizeof</span>(fsal_statistics_t )) ;
00135       
00136       <span class="keywordflow">if</span>( bythread_stat == NULL )
00137       {
00138         DisplayErrorJd( fsal_log, ERR_SYS, ERR_MALLOC, Mem_Errno );
00139       }
00140       
00141       <span class="comment">/* inits the struct */</span>
00142       
00143       <span class="keywordflow">for</span> (i=0;i&lt;FSAL_NB_FUNC;i++)
00144       {
00145          bythread_stat-&gt;func_stats.nb_call[i]=0;
00146          bythread_stat-&gt;func_stats.nb_success[i]=0;
00147          bythread_stat-&gt;func_stats.nb_err_retryable[i]=0;
00148          bythread_stat-&gt;func_stats.nb_err_unrecover[i]=0;
00149       }
00150       
00151       <span class="comment">/* set the specific value */</span>
00152       pthread_setspecific( key_stats , (<span class="keywordtype">void</span> *)bythread_stat ) ;
00153 
00154   }
00155     
00156   <span class="comment">/* we increment the values */</span>
00157   
00158   <span class="keywordflow">if</span> ( bythread_stat )
00159   {
00160     bythread_stat-&gt;func_stats.nb_call[function_index]++;
00161     
00162     <span class="keywordflow">if</span> (  ! FSAL_IS_ERROR(status) )
00163       bythread_stat-&gt;func_stats.nb_success[function_index]++;
00164     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="fsal__errors_8c.html#a0">fsal_is_retryable</a>(status) )
00165       bythread_stat-&gt;func_stats.nb_err_retryable[function_index]++;
00166     <span class="keywordflow">else</span> 
00167       bythread_stat-&gt;func_stats.nb_err_unrecover[function_index]++;    
00168   }
00169   
00170   <span class="keywordflow">return</span>;
00171 }
00172 
00173 
00174 
<a name="l00185"></a><a class="code" href="fsal__internal_8c.html#a15">00185</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a15">fsal_internal_getstats</a>(fsal_statistics_t * output_stats)
00186 {
00187 
00188   fsal_statistics_t * bythread_stat = NULL ;
00189     
00190   <span class="comment">/* first, we init the keys if this is the first time */</span>
00191   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00192     DisplayErrorJd(fsal_log, ERR_SYS, ERR_PTHREAD_ONCE, errno );
00193     <span class="keywordflow">return</span>;
00194   }
00195   
00196   <span class="comment">/* we get the specific value */</span>
00197   bythread_stat = (fsal_statistics_t *) pthread_getspecific( key_stats ) ;
00198   
00199   <span class="comment">/* we allocate stats if this is the first time */</span>
00200   <span class="keywordflow">if</span>( bythread_stat == NULL ){
00201       <span class="keywordtype">int</span> i;
00202            
00203       <span class="keywordflow">if</span>( (
00204             bythread_stat =
00205             (fsal_statistics_t *)Mem_Alloc( <span class="keyword">sizeof</span>(fsal_statistics_t ))
00206            ) == NULL )
00207         DisplayErrorJd(fsal_log, ERR_SYS, ERR_MALLOC, Mem_Errno );
00208       
00209       <span class="comment">/* inits the struct */</span>
00210       <span class="keywordflow">for</span> (i=0;i&lt;FSAL_NB_FUNC;i++){
00211          bythread_stat-&gt;func_stats.nb_call[i]=0;
00212          bythread_stat-&gt;func_stats.nb_success[i]=0;
00213          bythread_stat-&gt;func_stats.nb_err_retryable[i]=0;
00214          bythread_stat-&gt;func_stats.nb_err_unrecover[i]=0;
00215       }
00216       
00217       <span class="comment">/* set the specific value */</span>
00218       pthread_setspecific( key_stats , (<span class="keywordtype">void</span> *)bythread_stat ) ;
00219 
00220   }
00221   
00222   <span class="keywordflow">if</span> (output_stats)
00223     (*output_stats)=(*bythread_stat);
00224   
00225   <span class="keywordflow">return</span>;
00226   
00227 }
00228 
00229 
00230 
00231 
<a name="l00242"></a><a class="code" href="fsal__internal_8c.html#a16">00242</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a16">fsal_internal_SetCredentialLifetime</a>(fsal_uint_t lifetime_in)
00243 {
00244   CredentialLifetime = lifetime_in;
00245 }
00246 
00247 
<a name="l00257"></a><a class="code" href="fsal__internal_8c.html#a17">00257</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a17">fsal_internal_SetReturnInconsistentDirent</a>(fsal_uint_t bool_in)
00258 {
00259   ReturnInconsistentDirent = bool_in;
00260 }
00261 
00262 
00263 
<a name="l00267"></a><a class="code" href="fsal__internal_8c.html#a18">00267</a> <span class="keywordtype">void</span>  <a class="code" href="fsal__internal_8c.html#a18">TakeTokenFSCall</a>()
00268 {
00269   <span class="comment">/* no limits */</span>
00270   <span class="keywordflow">if</span> ( limit_calls == FALSE ) <span class="keywordflow">return</span>;
00271   
00272   <span class="comment">/* there is a limit */</span>  
00273   semaphore_P( &amp;sem_fs_calls );
00274   
00275 }
00276 
00277 <span class="keywordtype">void</span>  ReleaseTokenFSCall()
00278 {
00279   <span class="comment">/* no limits */</span>
00280   <span class="keywordflow">if</span> ( limit_calls == FALSE ) <span class="keywordflow">return</span>;
00281   
00282   <span class="comment">/* there is a limit */</span>  
00283   semaphore_V( &amp;sem_fs_calls );
00284   
00285 }
00286 
00287 
00288 
00289 
00290 <span class="preprocessor">#define SET_INTEGER_PARAM( cfg, p_init_info, _field )             \</span>
00291 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00292 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00293 <span class="preprocessor">      </span><span class="comment">/* force the value in any case */</span>                           \
00294       cfg._field = (p_init_info)-&gt;values._field;                  \
00295       break;                                                      \
00296     case FSAL_INIT_MAX_LIMIT :                                    \
00297       <span class="comment">/* check the higher limit */</span>                                \
00298       if ( cfg._field &gt; (p_init_info)-&gt;values._field )            \
00299         cfg._field = (p_init_info)-&gt;values._field ;               \
00300       break;                                                      \
00301     case FSAL_INIT_MIN_LIMIT :                                    \
00302       <span class="comment">/* check the lower limit */</span>                                 \
00303       if ( cfg._field &lt; (p_init_info)-&gt;values._field )            \
00304         cfg._field = (p_init_info)-&gt;values._field ;               \
00305       break;                                                      \
00306     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00307     }
00308     
00309 
00310 <span class="preprocessor">#define SET_BITMAP_PARAM( cfg, p_init_info, _field )              \</span>
00311 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00312 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00313 <span class="preprocessor">        </span><span class="comment">/* force the value in any case */</span>                         \
00314         cfg._field = (p_init_info)-&gt;values._field;                \
00315         break;                                                    \
00316     case FSAL_INIT_MAX_LIMIT :                                    \
00317       <span class="comment">/* proceed a bit AND */</span>                                     \
00318       cfg._field &amp;= (p_init_info)-&gt;values._field ;                \
00319       break;                                                      \
00320     case FSAL_INIT_MIN_LIMIT :                                    \
00321       <span class="comment">/* proceed a bit OR */</span>                                      \
00322       cfg._field |= (p_init_info)-&gt;values._field ;                \
00323       break;                                                      \
00324     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00325     }
00326 
00327 
00328 <span class="preprocessor">#define SET_BOOLEAN_PARAM( cfg, p_init_info, _field )             \</span>
00329 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00330 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00331 <span class="preprocessor">        </span><span class="comment">/* force the value in any case */</span>                         \
00332         cfg._field = (p_init_info)-&gt;values._field;                \
00333         break;                                                    \
00334     case FSAL_INIT_MAX_LIMIT :                                    \
00335       <span class="comment">/* proceed a boolean AND */</span>                                 \
00336       cfg._field = cfg._field &amp;&amp; (p_init_info)-&gt;values._field ;   \
00337       break;                                                      \
00338     case FSAL_INIT_MIN_LIMIT :                                    \
00339       <span class="comment">/* proceed a boolean OR */</span>                                  \
00340       cfg._field = cfg._field &amp;&amp; (p_init_info)-&gt;values._field ;   \
00341       break;                                                      \
00342     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00343     }
00344 
00345             
00346 <span class="comment">/*</span>
00347 <span class="comment"> *  This function initializes shared variables of the fsal.</span>
00348 <span class="comment"> */</span>
00349 fsal_status_t fsal_internal_init_global( fsal_init_info_t      *  fsal_info,
00350                                          fs_common_initinfo_t  *  fs_common_info )
00351 {
00352   
00353   
00354   <span class="comment">/* sanity check */</span>
00355   <span class="keywordflow">if</span> (!fsal_info || !fs_common_info) ReturnCode(ERR_FSAL_FAULT,0);
00356   
00357   <span class="comment">/* Setting log info */</span>
00358   fsal_log = fsal_info-&gt;log_outputs;
00359   
00360   
00361   <span class="comment">/* inits FS call semaphore */</span>
00362   <span class="keywordflow">if</span> ( fsal_info-&gt;max_fs_calls &gt; 0 )
00363   {
00364     <span class="keywordtype">int</span> rc;
00365     
00366     limit_calls = TRUE;
00367     
00368     rc=semaphore_init(&amp;sem_fs_calls, fsal_info-&gt;max_fs_calls);
00369     
00370     <span class="keywordflow">if</span> (rc != 0) ReturnCode(ERR_FSAL_SERVERFAULT,rc);
00371     
00372     DisplayLogJdLevel( fsal_log, NIV_DEBUG,
00373         <span class="stringliteral">"FSAL INIT: Max simultaneous calls to filesystem is limited to %u."</span>, 
00374         fsal_info-&gt;max_fs_calls );
00375     
00376   }
00377   <span class="keywordflow">else</span>
00378   {
00379     DisplayLogJdLevel( fsal_log, NIV_DEBUG,
00380         <span class="stringliteral">"FSAL INIT: Max simultaneous calls to filesystem is unlimited."</span> );
00381   }
00382   
00383   
00384   <span class="comment">/* setting default values. */</span>
00385   global_fs_info = default_hpss_info;
00386 
00387   
00388   <span class="comment">/* Analyzing fs_common_info struct */</span>  
00389   
00390   <span class="keywordflow">if</span> (
00391       (fs_common_info-&gt;behaviors.maxfilesize != FSAL_INIT_FS_DEFAULT ) ||
00392       (fs_common_info-&gt;behaviors.maxlink  != FSAL_INIT_FS_DEFAULT ) ||
00393       (fs_common_info-&gt;behaviors.maxnamelen != FSAL_INIT_FS_DEFAULT ) ||
00394       (fs_common_info-&gt;behaviors.maxpathlen != FSAL_INIT_FS_DEFAULT ) ||
00395       (fs_common_info-&gt;behaviors.no_trunc != FSAL_INIT_FS_DEFAULT ) ||
00396       (fs_common_info-&gt;behaviors.case_insensitive != FSAL_INIT_FS_DEFAULT ) ||
00397       (fs_common_info-&gt;behaviors.case_preserving != FSAL_INIT_FS_DEFAULT ) ||
00398       (fs_common_info-&gt;behaviors.named_attr != FSAL_INIT_FS_DEFAULT ) ||
00399       (fs_common_info-&gt;behaviors.lease_time != FSAL_INIT_FS_DEFAULT ) ||
00400       (fs_common_info-&gt;behaviors.supported_attrs != FSAL_INIT_FS_DEFAULT ) ||
00401       (fs_common_info-&gt;behaviors.homogenous != FSAL_INIT_FS_DEFAULT ) )
00402       ReturnCode(ERR_FSAL_NOTSUPP,0);
00403 
00404   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, symlink_support );
00405   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, link_support );
00406   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, lock_support );
00407   
00408   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, cansettime );
00409   
00410   SET_INTEGER_PARAM( global_fs_info, fs_common_info, maxread );
00411   SET_INTEGER_PARAM( global_fs_info, fs_common_info, maxwrite );
00412   
00413   SET_BITMAP_PARAM( global_fs_info, fs_common_info, umask );
00414 
00415   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, auth_exportpath_xdev );
00416   
00417   
00418   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"FileSystem info :"</span>);
00419   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxfilesize  = %llX    "</span>,global_fs_info.maxfilesize);
00420   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxlink  = %lu   "</span>,global_fs_info.maxlink);
00421   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxnamelen  = %lu  "</span>,global_fs_info.maxnamelen);
00422   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxpathlen  = %lu  "</span>,global_fs_info.maxpathlen);
00423   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  no_trunc  = %d "</span>,global_fs_info.no_trunc);
00424   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  chown_restricted  = %d "</span>,global_fs_info.chown_restricted);
00425   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  case_insensitive  = %d "</span>,global_fs_info.case_insensitive);
00426   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  case_preserving  = %d "</span>,global_fs_info.case_preserving);
00427   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  fh_expire_type  = %hu "</span>,global_fs_info.fh_expire_type);
00428   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  link_support  = %d  "</span>,global_fs_info.link_support);
00429   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  symlink_support  = %d  "</span>,global_fs_info.symlink_support);
00430   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  lock_support  = %d  "</span>,global_fs_info.lock_support);
00431   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  named_attr  = %d  "</span>,global_fs_info.named_attr);
00432   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  unique_handles  = %d  "</span>,global_fs_info.unique_handles);
00433   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  lease_time  = %u.%u     "</span>,global_fs_info.lease_time.seconds, global_fs_info.lease_time.nseconds);
00434   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  acl_support  = %hu  "</span>,global_fs_info.acl_support);
00435   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  cansettime  = %d  "</span>,global_fs_info.cansettime);
00436   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  homogenous  = %d  "</span>,global_fs_info.homogenous);
00437   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  supported_attrs  = %llX  "</span>,global_fs_info.supported_attrs);
00438   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxread  = %llX     "</span>,global_fs_info.maxread);
00439   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxwrite  = %llX     "</span>,global_fs_info.maxwrite);
00440   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  umask  = %X "</span>,global_fs_info.umask);
00441   DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  auth_exportpath_xdev  = %d  "</span>,global_fs_info.auth_exportpath_xdev);
00442   
00443   
00444   ReturnCode(ERR_FSAL_NO_ERROR,0);
00445 }
00446 
00447 
00448 
<a name="l00462"></a><a class="code" href="fsal__internal_8c.html#a21">00462</a> fsal_boolean_t  <a class="code" href="fsal__internal_8c.html#a21">fsal_do_log</a>( fsal_status_t  status )
00463 {
00464 
00465   <span class="keywordflow">switch</span>( status.major )
00466   {
00467     
00468     <span class="comment">/* here are the code, we want to trace*/</span>
00469     <span class="keywordflow">case</span> ERR_FSAL_DELAY:
00470     <span class="keywordflow">case</span> ERR_FSAL_PERM:
00471     <span class="keywordflow">case</span> ERR_FSAL_IO:
00472     <span class="keywordflow">case</span> ERR_FSAL_NXIO:
00473     <span class="keywordflow">case</span> ERR_FSAL_NOT_OPENED:
00474     <span class="keywordflow">case</span> ERR_FSAL_NOMEM:
00475     <span class="keywordflow">case</span> ERR_FSAL_FAULT:
00476     <span class="keywordflow">case</span> ERR_FSAL_XDEV:
00477     <span class="keywordflow">case</span> ERR_FSAL_INVAL:
00478     <span class="keywordflow">case</span> ERR_FSAL_FBIG:
00479     <span class="keywordflow">case</span> ERR_FSAL_NOSPC:
00480     <span class="keywordflow">case</span> ERR_FSAL_MLINK:
00481     <span class="keywordflow">case</span> ERR_FSAL_NAMETOOLONG:
00482     <span class="keywordflow">case</span> ERR_FSAL_SEC:
00483     <span class="keywordflow">case</span> ERR_FSAL_SERVERFAULT:
00484       <span class="keywordflow">return</span> TRUE;
00485       
00486     <span class="keywordflow">default</span> :
00487       <span class="keywordflow">return</span> FALSE;
00488   }
00489 
00490 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:43 2008 for File System Abstraction Layer (HPSS) library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
