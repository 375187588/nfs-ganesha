<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>File System Abstraction Layer (HPSS) library: fsal_dirs.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>fsal_dirs.c</h1><a href="fsal__dirs_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> */</span>
00004 
00013 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00015 <span class="preprocessor">#endif</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#include "fsal.h"</span>
00018 <span class="preprocessor">#include "fsal_internal.h"</span>
00019 <span class="preprocessor">#include "fsal_convert.h"</span>
00020 <span class="preprocessor">#include "HPSSclapiExt/hpssclapiext.h"</span>
00021 <span class="preprocessor">#include &lt;string.h&gt;</span>
00022 
00023 
00024 
<a name="l00049"></a><a class="code" href="fsal__dirs_8c.html#a0">00049</a> fsal_status_t <a class="code" href="fsal__dirs_8c.html#a0">FSAL_opendir</a>(
00050     fsal_handle_t             * dir_handle,           <span class="comment">/* IN */</span>
00051     fsal_op_context_t         * p_context,            <span class="comment">/* IN */</span>
00052     fsal_dir_t                * dir_descriptor,       <span class="comment">/* OUT */</span>
00053     fsal_attrib_list_t        * dir_attributes        <span class="comment">/* [ IN/OUT ] */</span>
00054 ){
00055   <span class="keywordtype">int</span> rc;
00056   fsal_status_t  st;
00057       
00058   <span class="comment">/* sanity checks</span>
00059 <span class="comment">   * note : dir_attributes is optionnal.</span>
00060 <span class="comment">   */</span>
00061   <span class="keywordflow">if</span> (!dir_handle || !p_context || !dir_descriptor)
00062     Return(ERR_FSAL_FAULT ,0 , INDEX_FSAL_opendir);
00063 
00064   <span class="comment">/* Test access rights for this directory</span>
00065 <span class="comment">   * and retrieve asked attributes */</span>
00066     
00067   st = <a class="code" href="fsal__access_8c.html#a0">FSAL_access</a>( dir_handle, p_context, FSAL_R_OK, dir_attributes );
00068   
00069   <span class="keywordflow">if</span> (FSAL_IS_ERROR(st)) Return(st.major,st.minor,INDEX_FSAL_opendir);
00070   
00071   <span class="comment">/* if everything is OK, fills the dir_desc structure */</span>
00072   memcpy( &amp;dir_descriptor-&gt;dir_handle , dir_handle, <span class="keyword">sizeof</span>(fsal_handle_t));
00073   memcpy( &amp;dir_descriptor-&gt;context , p_context, <span class="keyword">sizeof</span>(fsal_op_context_t));
00074       
00075     
00076   Return( ERR_FSAL_NO_ERROR, 0 ,INDEX_FSAL_opendir );
00077 
00078 }
00079 
00080 
00081 
<a name="l00117"></a><a class="code" href="fsal__dirs_8c.html#a1">00117</a> fsal_status_t <a class="code" href="fsal__dirs_8c.html#a1">FSAL_readdir</a>(
00118     fsal_dir_t            * dir_descriptor,     <span class="comment">/* IN */</span>
00119     fsal_cookie_t         start_position ,      <span class="comment">/* IN */</span>
00120     fsal_attrib_mask_t    get_attr_mask,        <span class="comment">/* IN */</span>
00121     fsal_mdsize_t         buffersize,           <span class="comment">/* IN */</span>
00122     fsal_dirent_t         * pdirent,            <span class="comment">/* OUT */</span>
00123     fsal_cookie_t         * end_position,       <span class="comment">/* OUT */</span>
00124     fsal_count_t          * nb_entries,         <span class="comment">/* OUT */</span>
00125     fsal_boolean_t        * end_of_dir          <span class="comment">/* OUT */</span>
00126 ){
00127   <span class="keywordtype">int</span> rc,returned,i;
00128   fsal_status_t st;
00129   
00130   fsal_attrib_mask_t handle_attr_mask;
00131   fsal_count_t  current_nb_entries,
00132                 missing_entries,
00133                 max_dir_entries;
00134      
00135   <span class="comment">/* hpss_ReadRawAttrsHandle arguments. */</span>
00136   
00137   u_signed64 curr_start_position;
00138   unsigned32 buff_size_in;
00139   unsigned32 bool_getattr_in;
00140   unsigned32 bool_eod_out;
00141   u_signed64 last_offset_out;
00142   ns_DirEntry_t outbuff[FSAL_READDIR_SIZE];
00143   
00144   <span class="comment">/* sanity checks */</span>
00145   
00146   <span class="keywordflow">if</span> ( !dir_descriptor || !pdirent || !end_position
00147         || !nb_entries || !end_of_dir )
00148     Return(ERR_FSAL_FAULT ,0 , INDEX_FSAL_readdir);
00149   
00150   
00151   <span class="comment">/* handle provides : suppattr, type, fileid */</span>
00154   handle_attr_mask = FSAL_ATTR_SUPPATTR | FSAL_ATTR_TYPE | FSAL_ATTR_FILEID ;
00155   
00156   <span class="comment">/* if the handle cannot provide the requested attributes,</span>
00157 <span class="comment">   * we have to retrieve file attributes. */</span>
00158   
00159   <span class="keywordflow">if</span> ( get_attr_mask &amp; ( ~ handle_attr_mask) ) bool_getattr_in = TRUE;
00160   <span class="keywordflow">else</span> bool_getattr_in = FALSE;
00161 
00162   
00163   <span class="comment">/* init values */</span>
00164   
00165   curr_start_position = start_position ;
00166   bool_eod_out = 0;
00167   current_nb_entries = 0;
00168   max_dir_entries = (buffersize / <span class="keyword">sizeof</span>(fsal_dirent_t));
00169   
00170   
00171   <span class="comment">/* while we haven't filled the output buffer</span>
00172 <span class="comment">   * and the end of dir has not been reached :</span>
00173 <span class="comment">   */</span>
00174   <span class="keywordflow">while</span> (( current_nb_entries &lt; max_dir_entries ) &amp;&amp; ( !bool_eod_out )){
00175     
00176     missing_entries = max_dir_entries - current_nb_entries;
00177         
00178     <span class="comment">/* If the requested count is smaller than the default FSAL_READDIR_SIZE,</span>
00179 <span class="comment">     * we use a smaller output buffer.</span>
00180 <span class="comment">     */</span>
00181     <span class="keywordflow">if</span> ( missing_entries &lt; FSAL_READDIR_SIZE )
00182       buff_size_in = missing_entries * <span class="keyword">sizeof</span>(ns_DirEntry_t);
00183     <span class="keywordflow">else</span>
00184       buff_size_in = FSAL_READDIR_SIZE * <span class="keyword">sizeof</span>(ns_DirEntry_t);
00185   
00186 
00187 
00188     <span class="comment">/* call to hpss clapi */</span>
00189     
00190     <a class="code" href="fsal__internal_8c.html#a18">TakeTokenFSCall</a>();
00191     
00192     rc = HPSSFSAL_ReadRawAttrsHandle( &amp;(dir_descriptor-&gt;dir_handle.ns_handle),
00193                                   curr_start_position,
00194                                   &amp;dir_descriptor-&gt;context.credential.hpss_usercred,
00195                                   buff_size_in,
00196                                   bool_getattr_in,
00197                                   ReturnInconsistentDirent,
00198                                   &amp;bool_eod_out,
00199                                   &amp;last_offset_out,
00200                                   outbuff );
00201     
00202     ReleaseTokenFSCall();
00203     
00204     <span class="keywordflow">if</span> (rc&lt;0) Return( <a class="code" href="fsal__convert_8c.html#a2">hpss2fsal_error</a>(rc), -rc, INDEX_FSAL_readdir );
00205     <span class="keywordflow">else</span> returned = rc;
00206 
00207     <span class="comment">/* Fills the fsal dirent list. */</span>
00208 
00209     <span class="keywordflow">for</span>( i = 0 ; i &lt; returned; i++){
00210 
00211       pdirent[current_nb_entries].handle.ns_handle = outbuff[i].ObjHandle;
00212       
00213       pdirent[current_nb_entries].handle.obj_type =  <a class="code" href="fsal__convert_8c.html#a7">hpss2fsal_type</a>( outbuff[i].ObjHandle.Type );
00214       
00215       st = <a class="code" href="group__FSALNameFunctions.html#ga0">FSAL_str2name</a>( (<span class="keywordtype">char</span> *)outbuff[i].Name, HPSS_MAX_FILE_NAME,
00216             &amp;pdirent[current_nb_entries].name);    
00217       
00220       pdirent[current_nb_entries].cookie =  outbuff[i].ObjOffset;
00221 
00222       <span class="comment">/* set asked attributes */</span>
00223       pdirent[current_nb_entries].attributes.asked_attributes = get_attr_mask ;
00224 
00225       <span class="keywordflow">if</span> ( bool_getattr_in ) {
00226 
00227         <span class="comment">/* convert HPSS attributes to fsal attributes */</span>
00228         st = <a class="code" href="fsal__convert_8c.html#a14">hpss2fsal_attributes</a>( &amp;outbuff[i].ObjHandle,
00229                                    &amp;outbuff[i].Attrs,
00230                                    &amp;pdirent[current_nb_entries].attributes );
00231 
00232         <span class="comment">/* on error, we set a special bit in the mask. */</span>        
00233         <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00234         {
00235           FSAL_CLEAR_MASK( pdirent[current_nb_entries].attributes.asked_attributes );
00236           FSAL_SET_MASK( pdirent[current_nb_entries].attributes.asked_attributes,
00237               FSAL_ATTR_RDATTR_ERR );
00238         }
00239 
00240       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( get_attr_mask ){
00241 
00242         <span class="comment">/* extract asked attributes from file handle */</span>
00243         st = <a class="code" href="fsal__convert_8c.html#a15">hpssHandle2fsalAttributes</a>( &amp;outbuff[i].ObjHandle,
00244                                         &amp;pdirent[current_nb_entries].attributes );
00245         
00246         <span class="comment">/* on error, we set a special bit in the mask. */</span>        
00247         <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00248         {
00249           FSAL_CLEAR_MASK( pdirent[current_nb_entries].attributes.asked_attributes );
00250           FSAL_SET_MASK( pdirent[current_nb_entries].attributes.asked_attributes,
00251               FSAL_ATTR_RDATTR_ERR );
00252         }
00253 
00254       }
00255 
00256       <span class="comment">/* set the previous' next */</span>
00257       <span class="keywordflow">if</span> (current_nb_entries) pdirent[current_nb_entries-1].nextentry
00258           = &amp;(pdirent[current_nb_entries]);
00259 
00260       <span class="comment">/* current's next */</span>
00261       pdirent[current_nb_entries].nextentry = NULL;
00262 
00263       <span class="comment">/* increment entries count */</span>
00264       current_nb_entries++;
00265       curr_start_position = last_offset_out;
00266     }
00267   
00268   }
00269   
00270   <span class="comment">/* At this point, 2 cases :</span>
00271 <span class="comment">   * - the requested count is reached</span>
00272 <span class="comment">   * - the end of dir is reached.</span>
00273 <span class="comment">   * However, the treatment is the same.</span>
00274 <span class="comment">   */</span>
00275   
00276   <span class="comment">/* setting output vars. */</span>  
00277   
00278   <span class="comment">/* if no item was read, the offset keeps the same. */</span>
00279   * end_position = ( current_nb_entries == 0 ? start_position : last_offset_out );
00280   
00281   * nb_entries = current_nb_entries ;
00282   * end_of_dir = ( bool_eod_out ? TRUE : FALSE);
00283      
00284   
00285   Return( ERR_FSAL_NO_ERROR, 0 ,INDEX_FSAL_readdir );
00286 
00287 }
00288 
00289 
00290 
<a name="l00304"></a><a class="code" href="fsal__dirs_8c.html#a2">00304</a> fsal_status_t <a class="code" href="fsal__dirs_8c.html#a2">FSAL_closedir</a>(
00305     fsal_dir_t * dir_descriptor         <span class="comment">/* IN */</span>
00306 ){
00307   
00308   <span class="keywordtype">int</span> rc;
00309   
00310   <span class="comment">/* sanity checks */</span>
00311   <span class="keywordflow">if</span> ( !dir_descriptor )
00312     Return(ERR_FSAL_FAULT ,0 , INDEX_FSAL_closedir);
00313   
00314   <span class="comment">/* fill dir_descriptor with zeros */</span>
00315   memset( dir_descriptor , 0, <span class="keyword">sizeof</span>(fsal_dir_t) );
00316     
00317   Return( ERR_FSAL_NO_ERROR, 0 ,INDEX_FSAL_closedir );
00318   
00319 }
00320 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:43 2008 for File System Abstraction Layer (HPSS) library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
