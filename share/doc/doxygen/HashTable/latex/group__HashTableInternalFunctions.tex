\section{Hash\-Table\-Internal\-Functions}
\label{group__HashTableInternalFunctions}\index{HashTableInternalFunctions@{HashTableInternalFunctions}}
\subsection*{Modules}
\begin{CompactItemize}
\item 
group {\bf Hash\-Table\-Exported\-Functions}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
unsigned long {\bf simple\_\-hash\_\-func} (hash\_\-parameter\_\-t $\ast$p\_\-hparam, hash\_\-buffer\_\-t $\ast$buffclef)
\item 
unsigned long {\bf double\_\-hash\_\-func} (hash\_\-parameter\_\-t $\ast$p\_\-hparam, hash\_\-buffer\_\-t $\ast$buffclef)
\item 
unsigned int {\bf rbt\_\-hash\_\-func} (hash\_\-parameter\_\-t $\ast$p\_\-hparam, hash\_\-buffer\_\-t $\ast$buffclef)
\end{CompactItemize}


\subsection{Function Documentation}
\index{HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}!double_hash_func@{double\_\-hash\_\-func}}
\index{double_hash_func@{double\_\-hash\_\-func}!HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned long double\_\-hash\_\-func (hash\_\-parameter\_\-t $\ast$ {\em p\_\-hparam}, hash\_\-buffer\_\-t $\ast$ {\em buffclef})}\label{group__HashTableInternalFunctions_ga1}


double\_\-hash\_\-func: This function is used for double hashing, based on another hash function.

This functions uses the hash function contained in hparam to compute a first hash value, then use it to compute a second value like this: h = ( firsthash + ( 8 - ( firsthash  8 ) ) )  hparam.index\_\-size This operation just changes the last 3 bits, but it can be demonstrated that this produced a more efficient and better balanced hash function (See 'Algorithm in C', Robert Sedjewick for more detail on this).

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em hparam}]the parameter structure that was used to define the hashtable \item[{\em buffclef}]the key to compute the hash value on\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the hash value\end{Desc}
\begin{Desc}
\item[See also:]{\bf double\_\-hash\_\-func}{\rm (p.\,\pageref{group__HashTableInternalFunctions_ga1})} \end{Desc}


Definition at line 315 of file Hash\-Table.c.\index{HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}!rbt_hash_func@{rbt\_\-hash\_\-func}}
\index{rbt_hash_func@{rbt\_\-hash\_\-func}!HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int rbt\_\-hash\_\-func (hash\_\-parameter\_\-t $\ast$ {\em p\_\-hparam}, hash\_\-buffer\_\-t $\ast$ {\em buffclef})}\label{group__HashTableInternalFunctions_ga2}


rbt\_\-hash\_\-func: Another hash junction, but to be used for the red-black trees managed internally.

This library uses red-black trees to store data. RB trees use key data too. The hash function has to be different than the one used for find the RB Tree, if not all the entry in the tree will have the same hash value which will lead to a very unbalanced tree

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em hparam}]the parameter structure that was used to define the hashtable \item[{\em buffclef}]the key to compute the hash value on\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the hash value \end{Desc}


Definition at line 345 of file Hash\-Table.c.

Referenced by main().\index{HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}!simple_hash_func@{simple\_\-hash\_\-func}}
\index{simple_hash_func@{simple\_\-hash\_\-func}!HashTableInternalFunctions@{Hash\-Table\-Internal\-Functions}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned long simple\_\-hash\_\-func (hash\_\-parameter\_\-t $\ast$ {\em p\_\-hparam}, hash\_\-buffer\_\-t $\ast$ {\em buffclef})}\label{group__HashTableInternalFunctions_ga0}


simple\_\-hash\_\-func: A template hash function, which considers the hash key as a polynom

A template hash function, which considers the hash key as a polynom. we are supposed to managed string written with ht-$>$alphabet\_\-length different characters We turn the string into a binary by computing str[0]+str[1]$\ast$ht-$>$alphabet\_\-length+str[2]$\ast$ht-$>$alphabet\_\-length$\ast$$\ast$2 + ... ... + str[N]$\ast$ht-$>$alphabet\_\-length$\ast$$\ast$N Then we keep the modulo by index\_\-size. This size has to be a prime integer for performance reason The polynome is computed with the Horner's method.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em hparam}]the parameter structure that was used to define the hashtable \item[{\em buffclef}]the key to compute the hash value on\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the hash value\end{Desc}
\begin{Desc}
\item[See also:]{\bf double\_\-hash\_\-func}{\rm (p.\,\pageref{group__HashTableInternalFunctions_ga1})} \end{Desc}


Definition at line 278 of file Hash\-Table.c.

Referenced by main().