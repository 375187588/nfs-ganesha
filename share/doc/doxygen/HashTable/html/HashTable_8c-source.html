<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Hash Table Library: HashTable.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>HashTable.c</h1><a href="HashTable_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00223 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00225 <span class="preprocessor">#endif</span>
00226 <span class="preprocessor"></span>
00227 
00228 
00229 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00230 <span class="preprocessor">#include &lt;string.h&gt;</span>
00231 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00232 <span class="preprocessor">#include "RW_Lock.h"</span>
00233 <span class="preprocessor">#include "BuddyMalloc.h"</span>
00234 <span class="preprocessor">#include "HashTable.h"</span>
00235 <span class="preprocessor">#include "stuff_alloc.h"</span>
00236 
00237 <span class="preprocessor">#ifndef TRUE</span>
<a name="l00238"></a><a class="code" href="HashTable_8c.html#a0">00238</a> <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1  </span>
00239 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00240 <span class="preprocessor"></span>
00241 <span class="preprocessor">#ifndef FALSE</span>
<a name="l00242"></a><a class="code" href="HashTable_8c.html#a1">00242</a> <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00244 <span class="preprocessor"></span>
00245 <span class="preprocessor">#ifndef P</span>
<a name="l00246"></a><a class="code" href="HashTable_8c.html#a2">00246</a> <span class="preprocessor"></span><span class="preprocessor">#define P( a ) pthread_mutex_lock( &amp;a )</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00248 <span class="preprocessor"></span>
00249 <span class="preprocessor">#ifndef V</span>
<a name="l00250"></a><a class="code" href="HashTable_8c.html#a3">00250</a> <span class="preprocessor"></span><span class="preprocessor">#define V( a ) pthread_mutex_unlock( &amp;a )</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00252 <span class="preprocessor"></span>
00253 <span class="comment">/* ------ This group contains all the functions used to manipulate the hash table internally in this module ------ */</span>
00254 
<a name="l00278"></a><a class="code" href="group__HashTableInternalFunctions.html#ga0">00278</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__HashTableInternalFunctions.html#ga0">simple_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00279 {
00280   <span class="comment">/* we are supposed to managed string written with ht-&gt;alphabet_length different characters </span>
00281 <span class="comment">   * We turn the string into a binary by computing str[0]+str[1]*ht-&gt;alphabet_length+str[2]*ht-&gt;alphabet_length**2 + ...</span>
00282 <span class="comment">   *  ... + str[N]*ht-&gt;alphabet_length**N  </span>
00283 <span class="comment">   * Then we keep the modulo by index_size. This size has to be a prime integer for performance reason</span>
00284 <span class="comment">   * The polynome is computed with the Horner's method */</span>
00285   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0 ;
00286   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> h = 0 ;
00287   <span class="keywordtype">char</span> c         = 0 ;
00288   <span class="keywordtype">char</span> * sobj    = (<span class="keywordtype">char</span> *)(buffclef-&gt;pdata) ;
00289 
00290   <span class="keywordflow">for</span>( i= 0 ; i &lt; buffclef-&gt;len ; i++ )
00291     {
00292       c = sobj[i] ;
00293       h = ( p_hparam-&gt;alphabet_length*h + (<span class="keywordtype">unsigned</span> int)c ) % p_hparam-&gt;index_size ;
00294     }
00295   
00296   <span class="keywordflow">return</span> h;
00297 } <span class="comment">/* hash_func */</span>
00298 
<a name="l00315"></a><a class="code" href="group__HashTableInternalFunctions.html#ga1">00315</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__HashTableInternalFunctions.html#ga1">double_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00316 {
00317   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> firsthash = 0 ;
00318   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> h        = 0 ;
00319   hash_function_t hashfunc = simple_hash_func ;
00320   
00321   <span class="comment">/* first, we find the intial value for simple hashing */</span>
00322   firsthash = hashfunc( p_hparam, buffclef ) ;
00323   
00324   <span class="comment">/* A second value is computed </span>
00325 <span class="comment">   * a second a value is added to the first one, then the modulo is kept </span>
00326 <span class="comment">   * For the second hash, we choose to change the last 3 bit, which is usually a good compromise */</span>
00327   h = ( firsthash + ( 8 - ( firsthash % 8  )  ) ) % p_hparam-&gt;index_size ;
00328 
00329   <span class="keywordflow">return</span> h ;
00330 } <span class="comment">/* double_hash_func */</span>
00331 
<a name="l00345"></a><a class="code" href="group__HashTableInternalFunctions.html#ga2">00345</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__HashTableInternalFunctions.html#ga2">rbt_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00346 {
00347   <span class="keywordtype">char</span> c         = 0 ;
00348   <span class="keywordtype">int</span>  valeur    = atoi(buffclef-&gt;pdata) + 3 ;
00349   
00350   <span class="keywordflow">return</span> valeur;
00351 } <span class="comment">/* hash_func */</span>
00352 
00353 
00354 
00367 <span class="keyword">static</span> hash_data_t * PreAllocPdata( <span class="keywordtype">int</span> nb_alloc )
00368 {
00369   hash_data_t * pdata = NULL ;
00370 
00371 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00372 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00373   BuddySetDebugLabel( <span class="stringliteral">"hash_data_t"</span> ) ;
00374 <span class="preprocessor">#endif</span>
00375 <span class="preprocessor"></span>
00376 <span class="preprocessor">#ifndef _NO_BLOCK_PREALLOC</span>
00377 <span class="preprocessor"></span>  STUFF_PREALLOC( pdata, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)nb_alloc, hash_data_t, next_alloc ) ;
00378   <span class="keywordflow">if</span>( pdata == NULL )
00379     <span class="keywordflow">return</span> NULL ;
00380 <span class="preprocessor">#endif</span>
00381 <span class="preprocessor"></span>
00382 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00383 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00384   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00385 <span class="preprocessor">#endif</span>
00386 <span class="preprocessor"></span>
00387   <span class="keywordflow">return</span> pdata ;
00388 } <span class="comment">/* PreAllocPdata */</span>
00389 
00402 <span class="keyword">static</span> <span class="keyword">struct </span>rbt_node * PreAllocNode( <span class="keywordtype">int</span> nb_alloc )
00403 {
00404   hash_data_t * pdata = NULL ;
00405   <span class="keyword">struct </span>rbt_node * pnode = NULL ;
00406   <span class="keywordtype">int</span> i = 0 ;
00407   
00408 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
00409 <span class="preprocessor"></span>  printf( <span class="stringliteral">"HASH TABLE PREALLOC: Allocating %d new nodes\n"</span>, nb_alloc ) ;
00410 <span class="preprocessor">#endif</span>
00411 <span class="preprocessor"></span>
00412 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00413 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00414   BuddySetDebugLabel( <span class="stringliteral">"rbt_node_t"</span> ) ;
00415 <span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span>
00417 <span class="preprocessor">#ifndef _NO_BLOCK_PREALLOC</span>
00418 <span class="preprocessor"></span>  STUFF_PREALLOC( pnode, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)nb_alloc, rbt_node_t, next ) ;
00419   <span class="keywordflow">if</span>( pnode == NULL )
00420     <span class="keywordflow">return</span> NULL ;
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>  
00423 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00424 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00425   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00426 <span class="preprocessor">#endif</span>
00427 <span class="preprocessor"></span>  
00428   <span class="keywordflow">return</span> pnode ;
00429 } <span class="comment">/* PreAllocNode */</span>
00430 
00447 <span class="keyword">static</span> <span class="keywordtype">int</span> Key_Locate(  hash_table_t * ht, hash_buffer_t * buffkey, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashval, <span class="keywordtype">int</span> rbt_value, <span class="keyword">struct</span> rbt_node ** ppnode )
00448 {
00449   <span class="keyword">struct </span>rbt_head * tete_rbt ;
00450   hash_data_t * pdata = NULL ;
00451   <span class="keyword">struct </span>rbt_node *pn ;
00452   <span class="keywordtype">int</span> found = 0 ;
00453 
00454    <span class="comment">/* Sanity check */</span>
00455   <span class="keywordflow">if</span>( ht == NULL || buffkey == NULL || ppnode == NULL )
00456     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00457    
00458   <span class="comment">/* Find the head of the rbt */</span>
00459   tete_rbt = &amp;(ht-&gt;array_rbt[hashval]) ;
00460 
00461   <span class="comment">/* I get the node with this value that is located on the left (first with this value in the rbtree) */</span>
00462   RBT_FIND_LEFT( tete_rbt, pn, rbt_value ) ;
00463 
00464   <span class="comment">/* Find was successfull ? */</span>
00465   <span class="keywordflow">if</span>( pn == NULL ) 
00466     <span class="keywordflow">return</span> HASHTABLE_ERROR_NO_SUCH_KEY ;
00467   
00468   <span class="comment">/* For each entry with this value, compare the key value */</span>
00469   <span class="keywordflow">while</span>( ( pn != 0) &amp;&amp;  (RBT_VALUE( pn ) == rbt_value) )
00470     {
00471       pdata = (hash_data_t *)RBT_OPAQ( pn ) ;
00472       <span class="comment">/* Verify the key value : this function returns 0 if key are indentical */</span>
00473       <span class="keywordflow">if</span>( !ht-&gt;parameter.compare_key( buffkey, &amp;(pdata-&gt;buffkey) ) )
00474         {
00475           found = 1;
00476           break ; <span class="comment">/* exit the while loop */</span>
00477         }
00478       RBT_INCREMENT(  pn ) ;
00479     }<span class="comment">/* while */</span>
00480    
00481   <span class="comment">/* We didn't find anything */</span>
00482   <span class="keywordflow">if</span>( !found )
00483     <span class="keywordflow">return</span> HASHTABLE_ERROR_NO_SUCH_KEY ;
00484  
00485   <span class="comment">/* Key was found */</span>
00486   *ppnode = pn ;
00487   
00488   <span class="keywordflow">return</span> HASHTABLE_SUCCESS ;
00489 } <span class="comment">/* Key_Locate */</span>
00490 
00491 <span class="comment">/*}@ */</span>
00492 
00493 <span class="comment">/* ------ This group contains all the functions used to manipulate the hash table from outside this module ----- */</span>
00494 
<a name="l00515"></a><a class="code" href="group__HashTableExportedFunctions.html#ga0">00515</a> hash_table_t * <a class="code" href="group__HashTableExportedFunctions.html#ga0">HashTable_Init</a>( hash_parameter_t hparam )
00516 {
00517   hash_table_t * ht ;
00518   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
00519   
00520   pthread_mutexattr_t mutexattr ;
00521   
00522   <span class="comment">/* Sanity check */</span>
00523   <span class="keywordflow">if</span>( ( ht = (hash_table_t *)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( hash_table_t ) ) ) == NULL )
00524     <span class="keywordflow">return</span> NULL ;
00525   
00526   <span class="comment">/* we have to keep the discriminant values */</span>
00527   ht-&gt;parameter   = hparam ;
00528 
00529   <span class="keywordflow">if</span>( pthread_mutexattr_init( &amp;mutexattr ) != 0 )
00530     <span class="keywordflow">return</span> NULL ;
00531   
00532   <span class="comment">/* Initialization of the node array */</span>
00533   <span class="keywordflow">if</span>( ( ht-&gt;array_rbt = (<span class="keyword">struct </span>rbt_head *)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> rbt_head ) * hparam.index_size ) ) == NULL )
00534     <span class="keywordflow">return</span> NULL ;
00535   
00536    <span class="comment">/* Initialization of the stat array */</span>
00537   <span class="keywordflow">if</span>( ( ht-&gt;stat_dynamic = (hash_stat_dynamic_t *)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( hash_stat_dynamic_t ) * hparam.index_size ) ) == NULL )
00538     <span class="keywordflow">return</span> NULL ;
00539   
00540   <span class="comment">/* Initialization of the semaphores array */</span>
00541   <span class="keywordflow">if</span>( ( ht-&gt;array_lock = (pthread_mutex_t *)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( rw_lock_t ) * hparam.index_size ) ) == NULL )
00542     <span class="keywordflow">return</span> NULL ;
00543 
00544   <span class="comment">/* Initialize the array of pre-allocated node */</span>
00545   <span class="keywordflow">if</span>( ( ht-&gt;node_prealloc = (<span class="keyword">struct </span>rbt_node **)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> rbt_node * ) * hparam.index_size ) ) == NULL )
00546     <span class="keywordflow">return</span> NULL ;
00547   
00548   <span class="keywordflow">if</span>( ( ht-&gt;pdata_prealloc = (hash_data_t **)<a class="code" href="test__configurable__hash_8c.html#a9">Mem_Alloc</a>( <span class="keyword">sizeof</span>( hash_data_t *) * hparam.index_size ) ) == NULL )
00549     <span class="keywordflow">return</span> NULL ;
00550 
00551   <span class="keywordflow">for</span>( i = 0 ; i &lt; hparam.index_size ; i++ )
00552     {
00553 <span class="preprocessor">#ifndef _NO_BLOCK_PREALLOC</span>
00554 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( ( ht-&gt;node_prealloc[i] = PreAllocNode( hparam.nb_node_prealloc ) ) == NULL )
00555         <span class="keywordflow">return</span> NULL ;
00556 
00557       <span class="keywordflow">if</span>( ( ht-&gt;pdata_prealloc[i] = PreAllocPdata( hparam.nb_node_prealloc ) ) == NULL )
00558         <span class="keywordflow">return</span> NULL ;
00559 <span class="preprocessor">#else</span>
00560 <span class="preprocessor"></span>      ht-&gt;node_prealloc[i] = PreAllocNode( hparam.nb_node_prealloc );
00561       ht-&gt;pdata_prealloc[i] = PreAllocPdata( hparam.nb_node_prealloc ) ;
00562 <span class="preprocessor">#endif</span>
00563 <span class="preprocessor"></span>    }
00564   
00565   <span class="comment">/* Initialize each of the RB-Tree, mutexes and stats */</span>
00566   <span class="keywordflow">for</span>( i = 0 ; i &lt; hparam.index_size ; i++ )
00567     {      
00568       <span class="comment">/* RBT Init */</span>
00569       RBT_HEAD_INIT( &amp;(ht-&gt;array_rbt[i]) ) ;
00570       
00571       <span class="comment">/* Mutex Init */</span>
00572       <span class="keywordflow">if</span>( rw_lock_init( &amp;(ht-&gt;array_lock[i]) ) !=0 )
00573         <span class="keywordflow">return</span> NULL ;
00574       
00575       <span class="comment">/* Initialization of the stats structure */</span>
00576       ht-&gt;stat_dynamic[i].nb_entries = 0 ;
00577   
00578       ht-&gt;stat_dynamic[i].ok.nb_set  = 0 ;
00579       ht-&gt;stat_dynamic[i].ok.nb_get  = 0 ;
00580       ht-&gt;stat_dynamic[i].ok.nb_del  = 0 ;
00581       ht-&gt;stat_dynamic[i].ok.nb_test = 0 ;
00582                                                                       
00583       ht-&gt;stat_dynamic[i].err.nb_set  = 0 ;
00584       ht-&gt;stat_dynamic[i].err.nb_get  = 0 ;
00585       ht-&gt;stat_dynamic[i].err.nb_del  = 0 ;
00586       ht-&gt;stat_dynamic[i].err.nb_test = 0 ;
00587   
00588       ht-&gt;stat_dynamic[i].notfound.nb_set  = 0 ;
00589       ht-&gt;stat_dynamic[i].notfound.nb_get  = 0 ;
00590       ht-&gt;stat_dynamic[i].notfound.nb_del  = 0 ;
00591       ht-&gt;stat_dynamic[i].notfound.nb_test = 0 ;
00592     }
00593   
00594   
00595   <span class="comment">/* final return, if we arrive here, then everything is alright */</span>
00596   <span class="keywordflow">return</span> ht ;
00597 } <span class="comment">/* HashTable_Init */</span>
00598 
<a name="l00617"></a><a class="code" href="group__HashTableExportedFunctions.html#ga1">00617</a> <span class="keywordtype">int</span> <a class="code" href="group__HashTableExportedFunctions.html#ga1">HashTable_Test_And_Set</a>( hash_table_t * ht, hash_buffer_t * buffkey, hash_buffer_t * buffval, hashtable_set_how_t how )
00618 {
00619   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       hashval   = 0 ;
00620   <span class="keywordtype">int</span>                rbt_value = 0 ;
00621   <span class="keyword">struct </span>rbt_head  * tete_rbt  = NULL ;
00622   <span class="keyword">struct </span>rbt_node  * qn        = NULL ;
00623   <span class="keyword">struct </span>rbt_node  * pn        = NULL ;
00624   hash_data_t      * pdata     = NULL ;
00625 
00626   <span class="comment">/* Sanity check */</span>
00627   <span class="keywordflow">if</span>( ht == NULL )
00628     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00629   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( buffkey == NULL )
00630     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00631   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( buffval == NULL )
00632     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00633     
00634 
00635   <span class="comment">/* Find the RB Tree to be used */</span>
00636   hashval = (*(ht-&gt;parameter.hash_func_key))( &amp;ht-&gt;parameter, buffkey ) ;
00637   tete_rbt = &amp;(ht-&gt;array_rbt[hashval]) ;
00638   rbt_value = (*(ht-&gt;parameter.hash_func_rbt))( &amp;ht-&gt;parameter, buffkey) ;
00639 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
00640 <span class="preprocessor"></span>  printf( <span class="stringliteral">"Key = %p   Value = %p  hashval = %u  rbt_value = %x\n"</span>, buffkey-&gt;pdata, buffval-&gt;pdata, hashval, rbt_value ) ;  
00641 <span class="preprocessor">#endif</span>
00642 <span class="preprocessor"></span>
00643   <span class="comment">/* acquire mutex for protection */</span>
00644   P_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00645   
00646   <span class="keywordflow">if</span>(  Key_Locate( ht, buffkey, hashval, rbt_value, &amp;pn ) == HASHTABLE_SUCCESS )
00647     {
00648       <span class="comment">/* An entry of that key already exists */</span>
00649       <span class="keywordflow">if</span>( how == HASHTABLE_SET_HOW_TEST_ONLY ) 
00650         {
00651           ht-&gt;stat_dynamic[hashval].ok.nb_test += 1 ;
00652           V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00653           <span class="keywordflow">return</span> HASHTABLE_SUCCESS ;
00654         }
00655       
00656       <span class="keywordflow">if</span>( how == HASHTABLE_SET_HOW_SET_NO_OVERWRITE )
00657         {
00658           ht-&gt;stat_dynamic[hashval].err.nb_test += 1 ;
00659           V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00660           <span class="keywordflow">return</span> HASHTABLE_ERROR_KEY_ALREADY_EXISTS ;
00661         }
00662       qn = pn ;
00663       pdata = RBT_OPAQ( qn );
00664 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
00665 <span class="preprocessor"></span>      printf( <span class="stringliteral">"Ecrasement d'une ancienne entree (k=%p,v=%p)\n"</span>, buffkey-&gt;pdata, buffval-&gt;pdata ) ;
00666 <span class="preprocessor">#endif</span>
00667 <span class="preprocessor"></span>    }
00668   <span class="keywordflow">else</span>
00669     {
00670       <span class="comment">/* No entry of that key, add it to the trees */</span>
00671       <span class="keywordflow">if</span>( how == HASHTABLE_SET_HOW_TEST_ONLY ) 
00672         {
00673           ht-&gt;stat_dynamic[hashval].notfound.nb_test += 1 ;
00674           V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00675           <span class="keywordflow">return</span> HASHTABLE_ERROR_NO_SUCH_KEY ;
00676         }
00677       
00678       <span class="comment">/* Insert a new node in the table */</span> 
00679       RBT_FIND( tete_rbt, pn, rbt_value );  
00680 
00681 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00682 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00683   BuddySetDebugLabel( <span class="stringliteral">"rbt_node_t"</span> ) ;
00684 <span class="preprocessor">#endif          </span>
00685 <span class="preprocessor"></span>      <span class="comment">/* This entry does not exist, create it */</span>
00686       <span class="comment">/* First get a new entry in the preallocated node array */</span>
00687       GET_PREALLOC( qn, ht-&gt;node_prealloc[hashval], ht-&gt;parameter.nb_node_prealloc, rbt_node_t, next ) ;
00688       <span class="keywordflow">if</span>( qn == NULL )
00689         {
00690           ht-&gt;stat_dynamic[hashval].err.nb_set += 1 ;
00691           V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00692           <span class="keywordflow">return</span> HASHTABLE_INSERT_MALLOC_ERROR ;
00693         }
00694       
00695 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00696 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00697   BuddySetDebugLabel( <span class="stringliteral">"hash_data_t"</span> ) ;
00698 <span class="preprocessor">#endif</span>
00699 <span class="preprocessor"></span>      GET_PREALLOC( pdata, ht-&gt;pdata_prealloc[hashval], ht-&gt;parameter.nb_node_prealloc, hash_data_t, next_alloc ) ;
00700       <span class="keywordflow">if</span>( pdata == NULL )
00701         {
00702           ht-&gt;stat_dynamic[hashval].err.nb_set += 1 ;
00703           V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00704           <span class="keywordflow">return</span> HASHTABLE_INSERT_MALLOC_ERROR ;
00705         }
00706 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00707 <span class="preprocessor"></span>      <span class="comment">/* For debugging memory leaks */</span>
00708       BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00709 <span class="preprocessor">#endif     </span>
00710 <span class="preprocessor"></span>      RBT_OPAQ( qn ) = pdata ;
00711       RBT_VALUE( qn ) = rbt_value ;
00712       RBT_INSERT( tete_rbt, qn, pn);
00713       
00714 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
00715 <span class="preprocessor"></span>      printf( <span class="stringliteral">"Creation d'une nouvelle entree (k=%p,v=%p), qn=%p, pdata=%p\n"</span>, 
00716               buffkey-&gt;pdata, buffval-&gt;pdata, qn, RBT_OPAQ( qn ) ) ;
00717 <span class="preprocessor">#endif</span>
00718 <span class="preprocessor"></span>    }
00719   
00720   pdata-&gt;buffval.pdata = buffval-&gt;pdata ;
00721   pdata-&gt;buffval.len   = buffval-&gt;len ;
00722   
00723   pdata-&gt;buffkey.pdata = buffkey-&gt;pdata ;
00724   pdata-&gt;buffkey.len   = buffkey-&gt;len ;
00725   
00726   ht-&gt;stat_dynamic[hashval].nb_entries += 1 ;
00727   ht-&gt;stat_dynamic[hashval].ok.nb_set += 1  ;
00728     
00729   <span class="comment">/* Release mutex */</span>
00730   V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00731   
00732   <span class="keywordflow">return</span> HASHTABLE_SUCCESS ;
00733 } <span class="comment">/* HashTable_Set */</span>
00734 
<a name="l00754"></a><a class="code" href="group__HashTableExportedFunctions.html#ga2">00754</a> <span class="keywordtype">int</span> <a class="code" href="group__HashTableExportedFunctions.html#ga2">HashTable_Get</a>( hash_table_t * ht, hash_buffer_t * buffkey, hash_buffer_t * buffval )
00755 {
00756   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashval ;
00757   <span class="keyword">struct </span>rbt_node *pn ;
00758   <span class="keyword">struct </span>rbt_head * tete_rbt ; 
00759   hash_data_t * pdata = NULL ;
00760   <span class="keywordtype">int</span> rbt_value = 0 ;
00761   <span class="keywordtype">int</span> rc = 0 ;
00762   
00763   <span class="comment">/* Sanity check */</span>
00764   <span class="keywordflow">if</span>( ht == NULL || buffkey == NULL || buffval == NULL )
00765     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00766 
00767   <span class="comment">/* Find the RB Tree to be processed */</span>
00768   hashval = (*(ht-&gt;parameter.hash_func_key))( &amp;ht-&gt;parameter, buffkey ) ;
00769   tete_rbt = &amp;(ht-&gt;array_rbt[hashval]) ;
00770   
00771   <span class="comment">/* Seek into the RB Tree */</span>
00772   rbt_value = (*(ht-&gt;parameter.hash_func_rbt))( &amp;ht-&gt;parameter, buffkey ) ;
00773 
00774   <span class="comment">/* Acquire mutex */</span>
00775   P_r( &amp;(ht-&gt;array_lock[hashval]) ) ;
00776   
00777   <span class="comment">/* I get the node with this value that is located on the left (first with this value in the rbtree) */</span>
00778   <span class="keywordflow">if</span>( ( rc = Key_Locate( ht, buffkey, hashval, rbt_value, &amp;pn ) ) != HASHTABLE_SUCCESS )
00779     {
00780       ht-&gt;stat_dynamic[hashval].notfound.nb_get += 1 ;
00781       V_r( &amp;(ht-&gt;array_lock[hashval]) ) ;
00782       <span class="keywordflow">return</span> rc ;
00783     }
00784   
00785   <span class="comment">/* Key was found */</span>
00786   pdata = (hash_data_t *)RBT_OPAQ( pn ) ;
00787   buffval-&gt;pdata = pdata-&gt;buffval.pdata ;
00788   buffval-&gt;len   = pdata-&gt;buffval.len;
00789   
00790   ht-&gt;stat_dynamic[hashval].ok.nb_get += 1 ;
00791 
00792   <span class="comment">/* Release mutex */</span>
00793   V_r( &amp;(ht-&gt;array_lock[hashval]) ) ;
00794   
00795   <span class="keywordflow">return</span> HASHTABLE_SUCCESS ;
00796 } <span class="comment">/* HashTable_Get */</span>
00797 
<a name="l00816"></a><a class="code" href="group__HashTableExportedFunctions.html#ga3">00816</a> <span class="keywordtype">int</span> <a class="code" href="group__HashTableExportedFunctions.html#ga3">HashTable_Del</a>(  hash_table_t * ht, hash_buffer_t  * buffkey,
00817                     hash_buffer_t * p_usedbuffkey,
00818                     hash_buffer_t * p_usedbuffdata )
00819 {
00820   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashval ;
00821   <span class="keyword">struct </span>rbt_node *pn ;
00822   <span class="keywordtype">int</span> rbt_value = 0 ;
00823   <span class="keyword">struct </span>rbt_head * tete_rbt ; 
00824   hash_data_t * pdata = NULL ;
00825   <span class="keywordtype">int</span> rc = 0 ;
00826   
00827   <span class="comment">/* Sanity check */</span>
00828   <span class="keywordflow">if</span>( ht == NULL || buffkey == NULL )
00829     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00830 
00831   <span class="comment">/* Find the RB Tree to be processed */</span>
00832   hashval = (*(ht-&gt;parameter.hash_func_key))( &amp;ht-&gt;parameter, buffkey ) ;
00833   
00834   <span class="comment">/* Find the entry to be deleted */</span>
00835   rbt_value = (*(ht-&gt;parameter.hash_func_rbt))( &amp;ht-&gt;parameter, buffkey ) ;
00836   
00837   <span class="comment">/* acquire mutex */</span>
00838   P_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00839 
00840   <span class="comment">/* We didn't find anything */</span>
00841   <span class="keywordflow">if</span>( ( rc = Key_Locate( ht, buffkey, hashval, rbt_value, &amp;pn ) ) != HASHTABLE_SUCCESS )
00842     {
00843       ht-&gt;stat_dynamic[hashval].notfound.nb_del += 1 ;
00844       V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00845       <span class="keywordflow">return</span> rc ;
00846     }
00847 
00848   pdata = (hash_data_t *)RBT_OPAQ( pn );
00849     
00850   <span class="comment">/* Return the key buffer back to the end user if pusedbuffkey isn't NULL */</span>
00851   <span class="keywordflow">if</span>( p_usedbuffkey != NULL )
00852       *p_usedbuffkey  = pdata-&gt;buffkey;
00853   
00854   <span class="keywordflow">if</span>( p_usedbuffdata != NULL )
00855       *p_usedbuffdata = pdata-&gt;buffval;
00856   
00857 
00858   <span class="comment">/* Key was found */</span>
00859   tete_rbt = &amp;(ht-&gt;array_rbt[hashval]) ;
00860   RBT_UNLINK( tete_rbt, pn);
00861   
00862   <span class="comment">/* the key was located, the deletion is done */</span>
00863   ht-&gt;stat_dynamic[hashval].nb_entries -= 1 ;
00864   
00865   <span class="comment">/* put back the pdata buffer to pool */</span>
00866   RELEASE_PREALLOC( pdata, ht-&gt;pdata_prealloc[hashval], next_alloc ) ;  
00867 
00868   <span class="comment">/* Put the node back in the table of preallocated nodes (it could be reused) */</span>
00869   RELEASE_PREALLOC( pn, ht-&gt;node_prealloc[hashval], next ) ;
00870 
00871   ht-&gt;stat_dynamic[hashval].ok.nb_del += 1 ;
00872 
00873   <span class="comment">/* release mutex */</span>
00874   V_w( &amp;(ht-&gt;array_lock[hashval]) ) ;
00875 
00876   <span class="keywordflow">return</span> HASHTABLE_SUCCESS ;
00877 } <span class="comment">/*  HashTable_Del */</span>
00878 
<a name="l00908"></a><a class="code" href="group__HashTableExportedFunctions.html#ga4">00908</a> <span class="keywordtype">void</span> <a class="code" href="group__HashTableExportedFunctions.html#ga4">HashTable_GetStats</a>( hash_table_t * ht, hash_stat_t * hstat )
00909 {
00910   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
00911   
00912   <span class="comment">/* Sanity check */</span>
00913   <span class="keywordflow">if</span>( ht == NULL || hstat == NULL )
00914     return ;
00915   
00916   <span class="comment">/* Firt, copy the dynamic values */</span>
00917   memcpy( &amp;(hstat-&gt;dynamic), ht-&gt;stat_dynamic, <span class="keyword">sizeof</span>( hash_stat_dynamic_t ) ) ;
00918   
00919   <span class="comment">/* Then computed the other values */</span>
00920   hstat-&gt;computed.min_rbt_num_node = 1&lt;&lt;31 ; <span class="comment">/* A min value hash to be initialized with a huge value */</span>
00921   hstat-&gt;computed.max_rbt_num_node = 0 ;     <span class="comment">/* A max value is initialized with 0 */</span>
00922   hstat-&gt;computed.average_rbt_num_node = 0 ; <span class="comment">/* And so does the averagle value */</span>
00923 
00924   hstat-&gt;dynamic.nb_entries = 0 ;
00925   
00926   hstat-&gt;dynamic.ok.nb_set  = 0 ;
00927   hstat-&gt;dynamic.ok.nb_test = 0 ;
00928   hstat-&gt;dynamic.ok.nb_get  = 0 ;
00929   hstat-&gt;dynamic.ok.nb_del  = 0 ;
00930   
00931   hstat-&gt;dynamic.err.nb_set  = 0 ;
00932   hstat-&gt;dynamic.err.nb_test = 0 ;
00933   hstat-&gt;dynamic.err.nb_get  = 0 ;
00934   hstat-&gt;dynamic.err.nb_del  = 0 ;
00935   
00936   hstat-&gt;dynamic.notfound.nb_set  = 0 ;
00937   hstat-&gt;dynamic.notfound.nb_test = 0 ;
00938   hstat-&gt;dynamic.notfound.nb_get  = 0 ;
00939   hstat-&gt;dynamic.notfound.nb_del  = 0 ;
00940 
00941   <span class="keywordflow">for</span>( i = 0 ; i &lt; ht-&gt;parameter.index_size ; i++ )
00942     { 
00943       <span class="keywordflow">if</span>( ht-&gt;array_rbt[i].rbt_num_node &gt; hstat-&gt;computed.max_rbt_num_node ) 
00944          hstat-&gt;computed.max_rbt_num_node = ht-&gt;array_rbt[i].rbt_num_node ;
00945       
00946       <span class="keywordflow">if</span>( ht-&gt;array_rbt[i].rbt_num_node &lt; hstat-&gt;computed.min_rbt_num_node ) 
00947          hstat-&gt;computed.min_rbt_num_node = ht-&gt;array_rbt[i].rbt_num_node ;
00948 
00949       hstat-&gt;computed.average_rbt_num_node +=  ht-&gt;array_rbt[i].rbt_num_node ;
00950 
00951       hstat-&gt;dynamic.nb_entries += ht-&gt;stat_dynamic[i].nb_entries ; 
00952 
00953       hstat-&gt;dynamic.ok.nb_set  += ht-&gt;stat_dynamic[i].ok.nb_set ; 
00954       hstat-&gt;dynamic.ok.nb_test += ht-&gt;stat_dynamic[i].ok.nb_test ; 
00955       hstat-&gt;dynamic.ok.nb_get  += ht-&gt;stat_dynamic[i].ok.nb_get ; 
00956       hstat-&gt;dynamic.ok.nb_del  += ht-&gt;stat_dynamic[i].ok.nb_del ; 
00957 
00958       hstat-&gt;dynamic.err.nb_set  += ht-&gt;stat_dynamic[i].err.nb_set ; 
00959       hstat-&gt;dynamic.err.nb_test += ht-&gt;stat_dynamic[i].err.nb_test ; 
00960       hstat-&gt;dynamic.err.nb_get  += ht-&gt;stat_dynamic[i].err.nb_get ; 
00961       hstat-&gt;dynamic.err.nb_del  += ht-&gt;stat_dynamic[i].err.nb_del ;
00962 
00963       hstat-&gt;dynamic.notfound.nb_set  += ht-&gt;stat_dynamic[i].notfound.nb_set ; 
00964       hstat-&gt;dynamic.notfound.nb_test += ht-&gt;stat_dynamic[i].notfound.nb_test ; 
00965       hstat-&gt;dynamic.notfound.nb_get  += ht-&gt;stat_dynamic[i].notfound.nb_get ; 
00966       hstat-&gt;dynamic.notfound.nb_del  += ht-&gt;stat_dynamic[i].notfound.nb_del ;
00967     };
00968   
00969   hstat-&gt;computed.average_rbt_num_node /= ht-&gt;parameter.index_size ;
00970 }
00971 
<a name="l00986"></a><a class="code" href="group__HashTableExportedFunctions.html#ga5">00986</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__HashTableExportedFunctions.html#ga5">HashTable_GetSize</a>( hash_table_t * ht )
00987 {  
00988   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i          = 0 ;
00989   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_entries = 0 ;
00990   
00991   <span class="comment">/* Sanity check */</span>
00992   <span class="keywordflow">if</span>( ht == NULL  )
00993     <span class="keywordflow">return</span> HASHTABLE_ERROR_INVALID_ARGUMENT ;
00994   
00995   <span class="keywordflow">for</span>( i = 0 ; i &lt; ht-&gt;parameter.index_size ; i++ )
00996     nb_entries += ht-&gt;stat_dynamic[i].nb_entries ;
00997 
00998   <span class="keywordflow">return</span> nb_entries ;
00999 } <span class="comment">/* HashTable_GetSize */</span>
01000 
<a name="l01015"></a><a class="code" href="group__HashTableExportedFunctions.html#ga6">01015</a> <span class="keywordtype">void</span> <a class="code" href="group__HashTableExportedFunctions.html#ga6">HashTable_Print</a>( hash_table_t * ht )
01016 {
01017   <span class="keyword">struct </span>rbt_node *it;
01018   <span class="keyword">struct </span>rbt_head * tete_rbt ;
01019   hash_data_t * pdata = NULL ;
01020   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashval ;
01021   <span class="keywordtype">char</span> dispkey[HASHTABLE_DISPLAY_STRLEN] ;
01022   <span class="keywordtype">char</span> dispval[HASHTABLE_DISPLAY_STRLEN] ;
01023   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
01024   <span class="keywordtype">int</span> nb_entries = 0 ;
01025 
01026   <span class="comment">/* Sanity check */</span>
01027   <span class="keywordflow">if</span>( ht == NULL  )
01028     return ;
01029 
01030 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
01031 <span class="preprocessor"></span>  printf( <span class="stringliteral">"The hash has %d nodes (this number MUST be a prime integer for performance's issues)\n"</span>, 
01032           ht-&gt;parameter.index_size ) ;
01033 <span class="preprocessor">#endif</span>
01034 <span class="preprocessor"></span>
01035   <span class="keywordflow">for</span>( i = 0 ; i &lt; ht-&gt;parameter.index_size ; i++ )
01036     nb_entries += ht-&gt;stat_dynamic[i].nb_entries ;
01037  
01038 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
01039 <span class="preprocessor"></span>  printf( <span class="stringliteral">"The hash contains %d entries\n"</span>, nb_entries ) ;
01040 <span class="preprocessor">#endif</span>
01041 <span class="preprocessor"></span>  
01042   <span class="keywordflow">for</span>( i = 0 ; i &lt; ht-&gt;parameter.index_size ; i++ )
01043     {
01044       tete_rbt = &amp;((ht-&gt;array_rbt)[i]) ;
01045 <span class="preprocessor">#ifdef _DEBUG_HASHTABLE</span>
01046 <span class="preprocessor"></span>      printf( <span class="stringliteral">"The node in position %d contains:  %d entries \n"</span>, i,  tete_rbt-&gt;rbt_num_node ) ;
01047 <span class="preprocessor">#endif</span>
01048 <span class="preprocessor"></span>      RBT_LOOP( tete_rbt, it )
01049         {
01050           pdata = (hash_data_t *)it-&gt;rbt_opaq ;
01051 
01052           ht-&gt;parameter.key_to_str( &amp;(pdata-&gt;buffkey), dispkey ) ;
01053           ht-&gt;parameter.val_to_str( &amp;(pdata-&gt;buffval), dispval ) ;
01054           
01055           printf( <span class="stringliteral">"%s =&gt; %s; "</span>, dispkey, dispval ) ;
01056           RBT_INCREMENT(it);
01057         }
01058     }
01059   printf( <span class="stringliteral">"\n"</span>) ;
01060 } <span class="comment">/* HashTable_Print */</span>
01061 
01062 <span class="comment">/* @} */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:22 2008 for Hash Table Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
