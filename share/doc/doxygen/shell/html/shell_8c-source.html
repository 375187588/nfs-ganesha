<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ganeshell: shell.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>shell.c</h1><a href="shell_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00147 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00149 <span class="preprocessor">#endif</span>
00150 <span class="preprocessor"></span>
00151 
00152 <span class="preprocessor">#include "<a class="code" href="shell_8h.html">shell.h</a>"</span>
00153 <span class="preprocessor">#include "<a class="code" href="shell__utils_8h.html">shell_utils.h</a>"</span>
00154 <span class="preprocessor">#include "<a class="code" href="shell__vars_8h.html">shell_vars.h</a>"</span>
00155 <span class="preprocessor">#include "log_functions.h"</span>
00156 <span class="preprocessor">#include "<a class="code" href="commands_8h.html">commands.h</a>"</span>
00157 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00158 
00159 <span class="preprocessor">#ifndef _NO_BUDDY_SYSTEM</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#include "BuddyMalloc.h"</span>
00161 <span class="preprocessor">#endif</span>
00162 <span class="preprocessor"></span>
00163 <span class="preprocessor">#include "stuff_alloc.h"</span>
00164 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00165 <span class="preprocessor">#include &lt;string.h&gt;</span>
00166 
00167 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00168 <span class="preprocessor">#include &lt;readline/readline.h&gt;</span>
00169 <span class="preprocessor">#include &lt;readline/history.h&gt;</span>
00170 
00171 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00172 
<a name="l00173"></a><a class="code" href="shell_8c.html#a0">00173</a> <span class="preprocessor">#define MAX_OUTPUT_LEN  (1024*1024) </span><span class="comment">/* 1MB */</span>
00174 
<a name="l00175"></a><a class="code" href="shell_8c.html#a1">00175</a> <span class="preprocessor">#define TRACEBUFFSIZE 1024</span>
00176 <span class="preprocessor"></span>
<a name="l00177"></a><a class="code" href="shell_8c.html#a2">00177</a> <span class="preprocessor">#define PROMPTSIZE 64</span>
00178 <span class="preprocessor"></span>
00179 
00180 <span class="keyword">static</span> <span class="keywordtype">char</span> * skipblanks2( <span class="keywordtype">char</span> * str );
00181 
00182 
00183 <span class="comment">/* ------------------------------------------*</span>
00184 <span class="comment"> *        Barrier management.</span>
00185 <span class="comment"> * ------------------------------------------*/</span>
00186 
<a name="l00187"></a><a class="code" href="shell_8c.html#a3">00187</a> <span class="preprocessor">#define P( _mutex_ ) pthread_mutex_lock( &amp;_mutex_ )</span>
<a name="l00188"></a><a class="code" href="shell_8c.html#a4">00188</a> <span class="preprocessor"></span><span class="preprocessor">#define V( _mutex_ ) pthread_mutex_unlock( &amp;_mutex_ )</span>
00189 <span class="preprocessor"></span>
00190 <span class="comment">/* variables for managing barriers */</span>
00191 
00192 <span class="comment">/* barrier protection */</span>
00193 <span class="keyword">static</span> pthread_mutex_t  barrier_mutex = PTHREAD_MUTEX_INITIALIZER ;
00194 
00195 <span class="comment">/* condition for crossing barrier */</span>
00196 <span class="keyword">static</span> pthread_cond_t   barrier_cond = PTHREAD_COND_INITIALIZER ;
00197 
00198 <span class="comment">/* total number of threads to wait for */</span>
00199 <span class="keyword">static</span> <span class="keywordtype">int</span> total_nb_threads = -1 ; <span class="comment">/* -1 = not initialized */</span>
00200 
00201 <span class="comment">/* number of threads that reached the barrier */</span>
00202 <span class="keyword">static</span> <span class="keywordtype">int</span> nb_waiting_threads = 0;
00203 
00204 
<a name="l00209"></a><a class="code" href="shell_8h.html#a10">00209</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a10">shell_BarrierInit</a>( <span class="keywordtype">int</span> nb_threads )
00210 { 
00211   
00212   <a class="code" href="shell_8c.html#a3">P</a>( barrier_mutex );
00213   
00214   <span class="keywordflow">if</span> ( total_nb_threads == -1 )    
00215   {
00216     total_nb_threads = nb_threads;
00217     <a class="code" href="shell_8c.html#a4">V</a>( barrier_mutex );
00218     <span class="keywordflow">return</span> SHELL_SUCCESS;    
00219   }
00220   <span class="keywordflow">else</span>
00221   {
00222     <a class="code" href="shell_8c.html#a4">V</a>( barrier_mutex );
00223     printf( <span class="stringliteral">"ganeshell: Error: Barrier already initialized\n"</span>);
00224     <span class="keywordflow">return</span> SHELL_ERROR;
00225   }
00226 }
00227 
00228 
00229 <span class="keyword">static</span> <span class="keywordtype">int</span> shell_BarrierWait()
00230 {
00231   
00232   <a class="code" href="shell_8c.html#a3">P</a>( barrier_mutex );
00233 
00234   <span class="comment">/* not used in a single thread environment */</span>
00235   
00236   <span class="keywordflow">if</span> ( total_nb_threads == -1 )
00237   {
00238     <a class="code" href="shell_8c.html#a4">V</a>( barrier_mutex );
00239     <span class="keywordflow">return</span> SHELL_ERROR;
00240   }
00241   
00242   <span class="comment">/* increase number of waiting threads */</span>
00243   
00244   nb_waiting_threads ++ ;
00245   
00246   
00247   <span class="comment">/* test for condition */</span>
00248   
00249   <span class="keywordflow">if</span> ( nb_waiting_threads == total_nb_threads )
00250   {
00251     <span class="comment">/* reset the number of waiting threads */</span>
00252     nb_waiting_threads = 0;
00253     
00254     <span class="comment">/* wake up all threads */</span>
00255     pthread_cond_broadcast( &amp;barrier_cond );
00256     
00257   }
00258   <span class="keywordflow">else</span>
00259     pthread_cond_wait(&amp;barrier_cond,&amp;barrier_mutex);
00260 
00261   <span class="comment">/* leaves the critical section */</span>
00262   
00263   <a class="code" href="shell_8c.html#a4">V</a>( barrier_mutex );    
00264   
00265   <span class="keywordflow">return</span> SHELL_SUCCESS;
00266         
00267 }
00268 
00269 
00270 
00271 <span class="comment">/* ------------------------------------------*</span>
00272 <span class="comment"> *        Thread safety management.</span>
00273 <span class="comment"> * ------------------------------------------*/</span>
00274 
00275 
00276 <span class="comment">/* threads keys */</span>
00277 <span class="keyword">static</span> pthread_key_t thread_key ;
00278 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00279 
00280 
00281 <span class="comment">/* init pthtread_key for current thread */</span>
00282 
00283 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00284 {
00285   <span class="keywordflow">if</span>( pthread_key_create( &amp;thread_key, NULL ) == -1 )
00286     printf( <span class="stringliteral">"Error %d creating pthread key for thread %p : %s\n"</span>,
00287         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00288   
00289   return ;
00290 } <span class="comment">/* init_keys */</span>
00291 
00292 
00297 <span class="keyword">static</span> <a class="code" href="structshell__state____.html">shell_state_t</a>  * GetShellContext(){
00298   
00299   <span class="keywordtype">int</span> i;
00300   <a class="code" href="structshell__state____.html">shell_state_t</a> * p_current_thread_vars ;
00301   
00302   
00303   <span class="comment">/* first, we init the keys if this is the first time */</span>
00304   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00305     printf( <span class="stringliteral">"Error %d calling pthread_once for thread %p : %s\n"</span>,
00306         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00307     <span class="keywordflow">return</span> NULL;
00308   }
00309   
00310   p_current_thread_vars = (<a class="code" href="structshell__state____.html">shell_state_t</a> *)pthread_getspecific( thread_key );
00311   
00312   <span class="comment">/* we allocate the thread context if this is the first time */</span>
00313   <span class="keywordflow">if</span> (p_current_thread_vars==NULL){
00314       
00315     <span class="comment">/* allocates thread structure */</span>
00316     p_current_thread_vars = (<a class="code" href="structshell__state____.html">shell_state_t</a> *)Mem_Alloc(<span class="keyword">sizeof</span>(<a class="code" href="structshell__state____.html">shell_state_t</a>));
00317     
00318     <span class="comment">/* panic !!! */</span>
00319     <span class="keywordflow">if</span> (p_current_thread_vars == NULL) {
00320       printf( <span class="stringliteral">"%p:ganeshell: Not enough memory\n"</span>,(caddr_t)pthread_self());
00321       <span class="keywordflow">return</span> NULL;
00322     }
00323     
00324     <span class="comment">/* Clean thread context */</span>
00325         
00326     memset(  p_current_thread_vars, 0, <span class="keyword">sizeof</span>( <a class="code" href="structshell__state____.html">shell_state_t</a> ) );
00327     
00328     <span class="comment">/* setting default values */</span>
00329     
00330     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> = stdin;
00331     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o1">interactive</a> = TRUE;
00332     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o2">layer</a> = NULL;
00333     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o3">status</a> = 0;
00334     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o4">verbose</a> = 0;
00335     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o5">debug_level</a> = NIV_EVENT;
00336     p_current_thread_vars-&gt;<a class="code" href="structshell__state____.html#o6">line</a> = 0;
00337   
00338     <span class="comment">/* set the specific value */</span>
00339     pthread_setspecific( thread_key , (<span class="keywordtype">void</span> *)p_current_thread_vars ) ;
00340     
00341   }
00342  
00343   <span class="keywordflow">return</span> p_current_thread_vars ;
00344   
00345 }<span class="comment">/* GetShellContext */</span>
00346 
00347 
00348 
00349 <span class="comment">/*------------------------------------------------------------------</span>
00350 <span class="comment"> *                    Main shell routines.</span>
00351 <span class="comment"> *-----------------------------------------------------------------*/</span>
00352 
<a name="l00358"></a><a class="code" href="shell_8h.html#a8">00358</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a8">shell_Init</a>( <span class="keywordtype">int</span> verbose,
00359                 <span class="keywordtype">char</span> * input_file,                
00360                 <span class="keywordtype">char</span> * prompt,
00361                 <span class="keywordtype">int</span> shell_index )
00362 {
00363   
00364   <span class="keywordtype">int</span> rc,i;
00365   <span class="keywordtype">char</span> localmachine[256];  
00366   <a class="code" href="structshell__state____.html">shell_state_t</a>  * context;
00367   
00368   <span class="comment">/* First init Buddy Malloc System */</span>
00369   
00370 <span class="preprocessor">#ifndef _NO_BUDDY_SYSTEM</span>
00371 <span class="preprocessor"></span>  
00372   <span class="comment">/* Init Buddy allocator */</span>
00373   
00374   <span class="keywordflow">if</span> ( ( rc = BuddyInit( <a class="code" href="Getopt_8c.html#a0">NULL</a> )) != BUDDY_SUCCESS )
00375   {
00376     <span class="comment">/* can't use shell tracing functions there */</span>
00377     fprintf( stderr, <span class="stringliteral">"Error %d initializing Buddy allocator.\n"</span>,rc);
00378     <span class="keywordflow">return</span> rc;
00379   }
00380   
00381 <span class="preprocessor">#endif</span>
00382 <span class="preprocessor"></span>   
00383   <span class="comment">/* Init logging */</span>
00384   
00385   SetNamePgm( <span class="stringliteral">"ganeshell"</span> ) ;
00386   SetNameFileLog( <span class="stringliteral">"/dev/tty"</span> ) ;
00387   SetNameFunction( <span class="stringliteral">"shell"</span> ) ;
00388 
00389   <span class="comment">/* getting the hostname */</span>
00390   <span class="keywordflow">if</span>( gethostname( localmachine, <span class="keyword">sizeof</span>( localmachine ) ) != 0 )
00391     {
00392       fprintf( stderr, <span class="stringliteral">"Error %d calling gethostname.\n"</span>,errno );
00393       <span class="keywordflow">return</span> errno;
00394     }
00395   <span class="keywordflow">else</span>
00396     SetNameHost( localmachine ) ;
00397   
00398   InitDebug( NIV_EVENT ) ;
00399 
00400   
00401   <span class="comment">/* retrieve/initialize shell context */</span>
00402   
00403   context = GetShellContext();
00404 
00405   
00406   <span class="comment">/* Initializes verbose mode. */</span>
00407   
00408   <span class="keywordflow">if</span> ( rc = <a class="code" href="shell_8h.html#a21">shell_SetVerbose</a>( context, ( <a class="code" href="main_8c.html#a4">verbose</a> ? <span class="stringliteral">"1"</span>:<span class="stringliteral">"0"</span>) ) ) <span class="keywordflow">return</span> rc;
00409 
00410   
00411   <span class="keywordflow">if</span> ( rc = <a class="code" href="shell_8h.html#a23">shell_SetDbgLvl</a>( context, <span class="stringliteral">"NIV_EVENT"</span> ) )  <span class="keywordflow">return</span> rc;
00412   
00413       
00414   <span class="comment">/* Then, initializes input file. */</span>
00415   
00416   <span class="keywordflow">if</span> ( rc = <a class="code" href="shell_8h.html#a26">shell_SetInput</a>( context, input_file ) )
00417     <span class="keywordflow">return</span> rc;
00418   
00419   
00420   <span class="comment">/* Initialize prompt */</span>
00421   
00422   <span class="keywordflow">if</span> ( rc = <a class="code" href="shell_8h.html#a27">shell_SetPrompt</a>( context, prompt ) )
00423     <span class="keywordflow">return</span> rc;
00424 
00425   <span class="comment">/* Initialize Shell id */</span>
00426  
00427   <span class="keywordflow">if</span> ( rc = <a class="code" href="shell_8h.html#a29">shell_SetShellId</a>( context, shell_index ) )
00428     <span class="keywordflow">return</span> rc;
00429   
00430   
00431   <span class="keywordflow">return</span> SHELL_SUCCESS;
00432   
00433 }
00434 
00435 
00436 
00437 
00438 <span class="comment">/* reads a line from input, and prints a prompt in interactive mode. */</span>
00439 
00440 <span class="keyword">static</span> <span class="keywordtype">char</span> * shell_readline(  <a class="code" href="structshell__state____.html">shell_state_t</a>  * context, <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> n, FILE *stream, <span class="keywordtype">int</span> interactive)
00441 {
00442   
00443   <span class="keywordtype">char</span> * retval = <a class="code" href="shell_8h.html#a28">shell_GetPrompt</a>( context );
00444   <span class="keywordtype">char</span> * l;
00445 
00446   <span class="keywordflow">if</span> ( interactive )
00447   {
00448     <span class="comment">/* use readline */</span>
00449     l = readline( (retval?retval:<span class="stringliteral">""</span>) );    
00450     <span class="keywordflow">if</span> ( l )
00451     {
00452       strncpy( s, l, n );
00453       
00454       <span class="comment">/* add line to history, if it is not empty */</span>
00455       l = skipblanks2( l );
00456       
00457       <span class="keywordflow">if</span> ( l != NULL ) add_history( l );
00458       
00459       <span class="keywordflow">return</span> s;
00460     }
00461     <span class="keywordflow">else</span>
00462       <span class="keywordflow">return</span> NULL;
00463   }
00464   <span class="keywordflow">else</span>
00465     <span class="keywordflow">return</span> fgets(s, n, stream);
00466   
00467 }
00468 
00469 
<a name="l00473"></a><a class="code" href="shell_8h.html#a9">00473</a> <span class="keywordtype">int</span> <a class="code" href="shell_8c.html#a18">shell_Launch</a>()
00474 {
00475   
00476   <span class="keywordtype">char</span> cmdline[<a class="code" href="shell_8h.html#a0">MAX_LINE_LEN</a>+1];
00477   <span class="keywordtype">char</span> * arglist[MAX_ARGS];
00478   <span class="keywordtype">int</span> alloctab[MAX_ARGS];
00479   <span class="keywordtype">int</span> argcount;
00480   <span class="keywordtype">int</span> rc;
00481   
00482   <a class="code" href="structshell__state____.html">shell_state_t</a>  * context =   GetShellContext();
00483   
00484   <span class="keywordflow">while</span> ( shell_readline( context, cmdline, <a class="code" href="shell_8h.html#a0">MAX_LINE_LEN</a>,
00485                           context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a>,
00486                           context-&gt;<a class="code" href="structshell__state____.html#o1">interactive</a>) != NULL )
00487   {
00488     
00489     <span class="comment">/* Increments line number */</span>
00490     
00491     <a class="code" href="shell_8h.html#a30">shell_SetLine</a>( context, <a class="code" href="shell_8h.html#a31">shell_GetLine</a>(context) + 1 );
00492     
00493     <span class="comment">/* Parse command line */</span>
00494     
00495     <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a11">shell_ParseLine</a>( cmdline, arglist, &amp;argcount) )
00496       <span class="keywordflow">continue</span>;
00497         
00498     <span class="comment">/* nothing to do if the line is empty. */</span>
00499     <span class="keywordflow">if</span> ( argcount == 0 ) <span class="keywordflow">continue</span>;
00500     
00501     <span class="comment">/* Evaluates arguments */</span>
00502     
00503     <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a13">shell_SolveArgs</a>( argcount, arglist, alloctab ) )
00504       <span class="keywordflow">continue</span>;
00505     
00506     <span class="comment">/* Execute command */</span>
00507     rc = <a class="code" href="shell_8h.html#a14">shell_Execute</a>( argcount, arglist, stdout );
00508     
00509     <span class="comment">/* clean allocated strings */</span>
00510     <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( argcount, arglist, alloctab );
00511     
00512     <span class="comment">/* set command status */</span>
00513     <a class="code" href="shell_8h.html#a19">shell_SetStatus</a>( context, rc );
00514     
00515     
00516   }
00517     
00518 }
00519 
00520 
00521 
00522 
00523 
00524 
00525 
00526 <span class="comment">/*------------------------------------------------------------------</span>
00527 <span class="comment"> *                Parsing and execution routines.</span>
00528 <span class="comment"> *-----------------------------------------------------------------*/</span>
00529 
00530 
00531 <span class="comment">/* address of the first non blank char if any, null else.*/</span>
00532 
00533 <span class="keyword">static</span> <span class="keywordtype">char</span> * skipblanks( <span class="keywordtype">char</span> * str )
00534 {
00535 
00536   <span class="keywordtype">char</span> * curr = str;
00537   
00538   <span class="keywordflow">while</span>(1)
00539   {
00540     
00541     <span class="keywordflow">switch</span>(*curr)
00542     {
00543       <span class="comment">/* end of lines */</span>
00544       <span class="keywordflow">case</span> <span class="charliteral">'\0'</span>:
00545       <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
00546         <span class="keywordflow">return</span> NULL;
00547         
00548       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00549       <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
00550       <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:  
00551       <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:  
00552         curr++;
00553         <span class="keywordflow">break</span>;
00554         
00555       <span class="keywordflow">default</span> :
00556         <span class="keywordflow">return</span> curr;    
00557       
00558     } <span class="comment">/* switch */</span>
00559     
00560   } <span class="comment">/* while */</span>
00561   
00562 } <span class="comment">/* skipblanks */</span>
00563 
00564 
00565 <span class="comment">/* the same as previous, except it doesnt not trunc line at # sign */</span>
00566 
00567 <span class="keyword">static</span> <span class="keywordtype">char</span> * skipblanks2( <span class="keywordtype">char</span> * str )
00568 {
00569 
00570   <span class="keywordtype">char</span> * curr = str;
00571   
00572   <span class="keywordflow">while</span>(1)
00573   {
00574     
00575     <span class="keywordflow">switch</span>(*curr)
00576     {
00577       <span class="comment">/* end of lines */</span>
00578       <span class="keywordflow">case</span> <span class="charliteral">'\0'</span>:
00579         <span class="keywordflow">return</span> NULL;
00580         
00581       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00582       <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
00583       <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:  
00584       <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:  
00585         curr++;
00586         <span class="keywordflow">break</span>;
00587         
00588       <span class="keywordflow">default</span> :
00589         <span class="keywordflow">return</span> curr;    
00590       
00591     } <span class="comment">/* switch */</span>
00592     
00593   } <span class="comment">/* while */</span>
00594   
00595 } <span class="comment">/* skipblanks2 */</span>
00596 
00597 
00598 
00599 <span class="comment">/* adress of the first blank char</span>
00600 <span class="comment"> * outside a string.</span>
00601 <span class="comment"> */</span>
00602 <span class="keyword">static</span> <span class="keywordtype">char</span> * nextblank( <span class="keywordtype">char</span> * str )
00603 {
00604 
00605   <span class="keywordtype">int</span> dquote_string =0;
00606   <span class="keywordtype">int</span> squote_string =0;
00607   <span class="keywordtype">int</span> bquote_string =0;
00608   
00609   <span class="keywordtype">int</span> escaped = 0;
00610   
00611   <span class="keywordtype">char</span> * curr = str;
00612   
00613   <span class="keywordflow">while</span>(1)
00614   {
00615   
00616     <span class="keywordflow">switch</span>(*curr)
00617     {
00618 
00619       <span class="comment">/* end of lines */</span>
00620       <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00621       <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:        
00622         <span class="keywordflow">if</span> (  !dquote_string
00623            &amp;&amp; !squote_string
00624            &amp;&amp; !bquote_string  ) <span class="keywordflow">return</span> curr;
00625         <span class="keywordflow">else</span> curr++;
00626         <span class="keywordflow">break</span>;
00627         
00628       <span class="keywordflow">case</span> <span class="charliteral">'\0'</span>:
00629       <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:
00630         <span class="keywordflow">return</span> curr;
00631         <span class="keywordflow">break</span>;
00632       
00633       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
00634         <span class="comment">/* escape sequence */</span>
00635         escaped = 1;
00636         curr++;
00637         <span class="keywordflow">break</span>;
00638                 
00639       <span class="keywordflow">case</span> <span class="charliteral">'"'</span> :
00640         <span class="comment">/* start or end of double quoted string */</span>
00641         <span class="keywordflow">if</span> (dquote_string) dquote_string = 0;
00642         <span class="keywordflow">else</span> (dquote_string)=1;
00643         curr++;
00644         <span class="keywordflow">break</span>;
00645         
00646       <span class="keywordflow">case</span> <span class="charliteral">'\''</span> :
00647         <span class="comment">/* start or end of single quoted string */</span>
00648         <span class="keywordflow">if</span> (squote_string) squote_string = 0;
00649         <span class="keywordflow">else</span> (squote_string)=1;
00650         curr++;
00651         <span class="keywordflow">break</span>;
00652         
00653       <span class="keywordflow">case</span> <span class="charliteral">'`'</span> :
00654         <span class="comment">/* start or end of back-quoted string */</span>
00655         <span class="keywordflow">if</span> (bquote_string) bquote_string = 0;
00656         <span class="keywordflow">else</span> (bquote_string)=1;
00657         curr++;
00658         <span class="keywordflow">break</span>;
00659                 
00660       <span class="keywordflow">default</span> :
00661         curr++;
00662          
00663     } <span class="comment">/* switch */</span>
00664     
00665     <span class="comment">/* escape ? */</span>
00666     
00667     <span class="keywordflow">if</span> ( escaped &amp;&amp; (*curr != <span class="charliteral">'\0'</span>) )
00668     {
00669       escaped = 0;
00670       curr++;
00671     }
00672 
00673     
00674   } <span class="comment">/* while */</span>
00675   
00676 } <span class="comment">/* nextblank */</span>
00677 
00678 
00679 
00680 
00681 
00682 
00683 
<a name="l00695"></a><a class="code" href="shell_8h.html#a11">00695</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a11">shell_ParseLine</a>( <span class="keywordtype">char</span> * in_out_line, <span class="keywordtype">char</span> ** out_arglist, <span class="keywordtype">int</span> * p_argcount )
00696 {
00697   
00698     <span class="keywordtype">char</span> * curr_pos = in_out_line;
00699     (*p_argcount) = 0;
00700 
00701     <span class="comment">/* While there is something after the Oblivion... */</span>
00702     
00703     <span class="keywordflow">while</span> ( curr_pos = skipblanks(curr_pos) )
00704     {
00705       out_arglist[(*p_argcount)] = curr_pos;
00706       (*p_argcount) ++;
00707       curr_pos = nextblank(curr_pos);
00708       
00709       <span class="keywordflow">if</span> ( *curr_pos==<span class="charliteral">'\0'</span>)
00710         <span class="keywordflow">break</span>;
00711       <span class="keywordflow">else</span>
00712         *curr_pos=<span class="charliteral">'\0'</span>;
00713       
00714       curr_pos++;
00715     }
00716        
00717     <span class="keywordflow">return</span> SHELL_SUCCESS;
00718   
00719 } <span class="comment">/* shell_ParseLine */</span>
00720 
00721 
00722 
00723 
00729 <span class="keyword">static</span> <span class="keywordtype">int</span> unescape( <span class="keywordtype">char</span> * str )
00730 {
00731     
00732   <span class="keywordtype">char</span> * src = str;
00733   <span class="keywordtype">char</span> * tgt = str;
00734 
00735   <span class="keywordflow">while</span> ( *src != <span class="charliteral">'\0'</span> )
00736   {
00737     <span class="keywordflow">if</span> ( *src == <span class="charliteral">'\\'</span> )
00738     {
00739       src ++;
00740       
00741       <span class="comment">/* escaped null char */</span>
00742       <span class="keywordflow">if</span> (*src == <span class="charliteral">'\0'</span>)
00743       {        
00744 <span class="preprocessor">#ifdef _DEBUG_SHELL</span>
00745 <span class="preprocessor"></span>        printf(<span class="stringliteral">"UNESCAPE ERROR &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [%s][%c][%c]\n"</span>,str, *src, *tgt );
00746 <span class="preprocessor">#endif        </span>
00747 <span class="preprocessor"></span>        <span class="keywordflow">return</span> SHELL_ERROR;
00748       }
00749       
00750     }
00751     
00752     <span class="keywordflow">if</span> ( tgt != src )
00753       *tgt = *src;
00754     
00755     src++;
00756     tgt++;
00757   }
00758   
00759   <span class="comment">/* final zero */</span>
00760   <span class="keywordflow">if</span> ( tgt != src ) 
00761     *tgt=*src;
00762   
00763   <span class="keywordflow">return</span> SHELL_SUCCESS;
00764   
00765 }
00766 
00767 
00773 <span class="keyword">static</span> <span class="keywordtype">int</span> remove_quotes( <span class="keywordtype">char</span> quote, <span class="keywordtype">char</span> ** pstr )
00774 {
00775     
00776   size_t  len = strlen( *pstr );
00777   
00778   <span class="keywordflow">if</span> ( len &lt;= 1 ) <span class="keywordflow">return</span> SHELL_ERROR;
00779   <span class="keywordflow">if</span> ( (*pstr)[len-1] != quote )  <span class="keywordflow">return</span> SHELL_ERROR;
00780   
00781   (*pstr)[len-1] = <span class="charliteral">'\0'</span>;
00782   (*pstr)[0] = <span class="charliteral">'\0'</span>;
00783   
00784   (*pstr) ++;
00785   
00786   <span class="keywordflow">return</span> SHELL_SUCCESS; 
00787   
00788 }
00789 
00790 
00791 
00792 
<a name="l00804"></a><a class="code" href="shell_8h.html#a13">00804</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a13">shell_SolveArgs</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** in_out_argv, <span class="keywordtype">int</span> * out_allocated )
00805 {
00806   
00807   <span class="keywordtype">int</span> i;
00808   <span class="keywordtype">int</span> error = 0;
00809   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
00810 
00811   <a class="code" href="structshell__state____.html">shell_state_t</a>  * context =   GetShellContext();
00812 
00813     
00814 <span class="preprocessor">#ifdef _DEBUG_SHELL</span>
00815 <span class="preprocessor"></span>  printf(<span class="stringliteral">"SOLVE:"</span>);
00816   <span class="keywordflow">for</span> (i=0;i&lt;argc;i++)
00817     printf(<span class="stringliteral">"[%s]"</span>,in_out_argv[i]);
00818   printf(<span class="stringliteral">"\n"</span>);
00819 <span class="preprocessor">#endif</span>
00820 <span class="preprocessor"></span>    
00821   <span class="keywordflow">for</span> ( i=0; i&lt; argc ; i++)
00822   { 
00823     
00824     out_allocated[i] = FALSE;
00825     
00826     <span class="comment">/* double quotes */</span>
00827         
00828     <span class="keywordflow">if</span> ( in_out_argv[i][0] == <span class="charliteral">'"'</span> )
00829     {
00830       
00831       <span class="keywordflow">if</span> ( remove_quotes( <span class="charliteral">'"'</span>, &amp;(in_out_argv[i]) ) )
00832       {
00833         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, <span class="stringliteral">"Syntax error: Missing closing quotes"</span> );
00834         error = SHELL_SYNTAX_ERROR;
00835         <span class="keywordflow">break</span>;
00836       }
00837       
00838       <span class="keywordflow">if</span> ( unescape( in_out_argv[i] ) )
00839       {
00840         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context,<span class="stringliteral">"Syntax error: Invalid escape sequence"</span> );
00841         error = SHELL_SYNTAX_ERROR;
00842         <span class="keywordflow">break</span>;
00843       }
00844 
00845             
00846     }
00847     
00848     <span class="comment">/* single quotes */</span>
00849     
00850     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( in_out_argv[i][0] == <span class="charliteral">'\''</span> )
00851     {
00852       
00853       <span class="keywordflow">if</span> ( remove_quotes( <span class="charliteral">'\''</span>, &amp;(in_out_argv[i]) ) )
00854       {
00855         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context,<span class="stringliteral">"Syntax error: Missing closing quote"</span> );
00856         error = SHELL_SYNTAX_ERROR;
00857         <span class="keywordflow">break</span>;
00858       }
00859       
00860       <span class="keywordflow">if</span> ( unescape( in_out_argv[i] ))
00861       {
00862         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context,<span class="stringliteral">"Syntax error: Invalid escape sequence"</span> );
00863         error = SHELL_SYNTAX_ERROR;
00864         <span class="keywordflow">break</span>;
00865       }
00866       
00867     }
00868         
00869     <span class="comment">/* var name */</span>
00870     
00871     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( in_out_argv[i][0] == <span class="charliteral">'$'</span> )
00872     {
00873       
00874       <span class="keywordtype">char</span> * value = <a class="code" href="shell__vars_8h.html#a2">get_var_value</a>( &amp;(in_out_argv[i][1]) );
00875       
00876       <span class="keywordflow">if</span> (value)
00877         in_out_argv[i] = value;
00878       <span class="keywordflow">else</span>
00879       {
00880         snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
00881             <span class="stringliteral">"Undefined variable \"%s\""</span>, &amp;(in_out_argv[i][1]) );
00882         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
00883         error = SHELL_NOT_FOUND;
00884         <span class="keywordflow">break</span>;
00885       }
00886     
00887     }
00888     
00889     <span class="comment">/* command */</span>
00890     
00891     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( in_out_argv[i][0] == <span class="charliteral">'`'</span> )
00892     {
00893       
00894       <span class="keywordtype">char</span> * arglist[MAX_ARGS];
00895       <span class="keywordtype">int</span> argcount;
00896       <span class="keywordtype">int</span> rc,status;
00897       
00898       <span class="comment">/* remove quotes */</span>
00899       
00900       <span class="keywordflow">if</span> ( remove_quotes( <span class="charliteral">'`'</span>, &amp;(in_out_argv[i]) ) )
00901       {
00902         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, <span class="stringliteral">"Syntax error: Missing closing backquote"</span> );
00903         error = SHELL_SYNTAX_ERROR;
00904         <span class="keywordflow">break</span>;
00905       }
00906       
00907       <span class="keywordflow">if</span> ( unescape( in_out_argv[i] ) )
00908       {
00909         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, <span class="stringliteral">"Syntax error: Invalid escape sequence"</span> );
00910         error = SHELL_SYNTAX_ERROR;
00911         <span class="keywordflow">break</span>;
00912       }
00913 
00914       
00915       <span class="comment">/* Parse command line */</span>
00916 
00917       <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a11">shell_ParseLine</a>( in_out_argv[i], arglist, &amp;argcount) )
00918       {
00919         error = SHELL_SYNTAX_ERROR;
00920         <span class="keywordflow">break</span>;
00921       }
00922       
00923       <span class="comment">/* nothing to do if the command is empty. */</span>
00924       
00925       <span class="keywordflow">if</span> ( argcount == 0 )
00926       {
00927         
00928         <span class="comment">/* empty output */</span>
00929         in_out_argv[i][0] = <span class="charliteral">'\0'</span>;
00930         
00931         <span class="comment">/* command status */</span>
00932         <a class="code" href="shell_8h.html#a19">shell_SetStatus</a>( context, 0 );
00933 
00934       }
00935       <span class="keywordflow">else</span>
00936       {
00937         
00938         <span class="keywordtype">int</span> fd[2];
00939         FILE * output_stream;
00940         <span class="keywordtype">int</span> alloctab[MAX_ARGS];
00941         
00942         <span class="keywordtype">char</span> output_string[MAX_OUTPUT_LEN];
00943         
00944         <span class="comment">/* Evaluates arguments */</span>
00945 
00946         <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a13">shell_SolveArgs</a>( argcount, arglist, alloctab ) )
00947         {
00948           error = SHELL_SYNTAX_ERROR;
00949           <span class="keywordflow">break</span>;
00950         }
00951         
00952         <span class="comment">/* create pipe for command output */</span>
00953         
00954         <span class="keywordflow">if</span> ( pipe(fd) )
00955         {
00956           
00957           snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Can't create pipe: %s (%d)"</span>,
00958                     strerror(errno) , errno );
00959           <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(context, tracebuff);
00960           
00961           <span class="comment">/* clean allocated strings */</span>
00962           <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( argcount, arglist, alloctab );
00963           
00964           error = errno;
00965           <span class="keywordflow">break</span>;
00966           
00967         }
00968         
00969         <span class="comment">/* opening output stream */</span>
00970         
00971         output_stream = fdopen( fd[1], <span class="stringliteral">"a"</span> );
00972          
00973         <span class="keywordflow">if</span> ( output_stream == NULL )
00974         {
00975           
00976           snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Can't open pipe stream: %s (%d)"</span>,
00977                     strerror(errno) , errno );
00978           <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(context,tracebuff);
00979           
00980           <span class="comment">/* clean allocated strings */</span>
00981           <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( argcount, arglist, alloctab );
00982           
00983           <span class="comment">/* close pipe */</span>
00984           close(fd[1]);
00985           close(fd[0]);
00986           
00987           error = errno;
00988           <span class="keywordflow">break</span>;
00989           
00990         }
00991 
00992         <span class="comment">/* @todo : thread for pipe reading */</span>
00993                 
00994         <span class="comment">/* Execute command */</span>
00995         
00996         status = <a class="code" href="shell_8h.html#a14">shell_Execute</a>( argcount, arglist, output_stream );
00997         
00998         <span class="comment">/* closing ouput stream. */</span>
00999         
01000         fclose( output_stream );
01001         close(fd[1]);
01002         
01003         <span class="comment">/* clean allocated strings */</span>
01004         <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( argcount, arglist, alloctab );
01005         
01006         
01007         <span class="comment">/* read the output from pipe */</span>
01008         
01009         rc = read( fd[0], output_string, <a class="code" href="shell_8c.html#a0">MAX_OUTPUT_LEN</a> );
01010         
01011         <span class="comment">/* close pipe */</span>
01012         close(fd[0]);
01013         
01014         <span class="keywordflow">if</span> ( rc == -1 )
01015         {
01016           snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Cannot read from pipe: %s (%d)"</span>,
01017                     strerror(errno) , errno );
01018           <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(context,tracebuff);
01019           
01020           error = errno;
01021           <span class="keywordflow">break</span>;
01022         }        
01023         
01024         <span class="comment">/* allocate and fill output buffer */</span>
01025         
01026         in_out_argv[i] = Mem_Alloc(rc+1);
01027         
01028         <span class="keywordflow">if</span> ( in_out_argv[i] == NULL)
01029         {
01030           <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, <span class="stringliteral">"Malloc error"</span>);
01031           error = -1;
01032           <span class="keywordflow">break</span>;
01033         }
01034         
01035         memcpy( in_out_argv[i], output_string, rc);
01036         
01037         out_allocated[i] = TRUE;
01038         
01039         in_out_argv[i][rc] = <span class="charliteral">'\0'</span>;
01040         
01041         <span class="comment">/* set command status */</span>
01042         
01043         <a class="code" href="shell_8h.html#a19">shell_SetStatus</a>( context, status );
01044 
01045       }
01046       
01047     
01048     }
01049     <span class="comment">/*  normal arg  */</span> 
01050     <span class="keywordflow">else</span>
01051     {      
01052       <span class="keywordflow">if</span> ( unescape( in_out_argv[i] ) )
01053       {
01054         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, <span class="stringliteral">"Syntax error: Invalid escape sequence"</span> );
01055         error = SHELL_SYNTAX_ERROR;
01056         <span class="keywordflow">break</span>;
01057       }
01058 
01059     }  <span class="comment">/* in_out_argv[i][0] */</span>
01060     
01061   } <span class="comment">/* for */</span>
01062   
01063   
01064   <span class="comment">/* the case when we exited the for because of an error. */</span>
01065   
01066   <span class="keywordflow">if</span> ( error )
01067   {
01068     <span class="comment">/* free allocated strings */</span>
01069     <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( i+1, in_out_argv, out_allocated);
01070     <span class="keywordflow">return</span> error;
01071   }
01072     
01073   
01074   <span class="keywordflow">return</span> SHELL_SUCCESS;  
01075   
01076 } <span class="comment">/* shell_SolveArgs */</span>
01077 
01078 
01079 
<a name="l01090"></a><a class="code" href="shell_8h.html#a12">01090</a> <span class="keywordtype">void</span> <a class="code" href="shell_8h.html#a12">shell_CleanArgs</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** in_out_argv, <span class="keywordtype">int</span> * in_allocated )
01091 {
01092   
01093   <span class="keywordtype">int</span> i;
01094   
01095   <span class="keywordflow">for</span> ( i=0; i&lt;argc; i++ )
01096   {
01097     
01098     <span class="keywordflow">if</span> ( in_allocated[i] )
01099     {
01100       Mem_Free( in_out_argv[i] );
01101       in_out_argv[i] = NULL;
01102       in_allocated[i] = FALSE;      
01103     }
01104     
01105   }
01106   
01107   <span class="keywordflow">return</span>;  
01108   
01109 }
01110 
01111 
01112 
<a name="l01123"></a><a class="code" href="shell_8h.html#a14">01123</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a14">shell_Execute</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv, FILE * output )
01124 {
01125   
01126   <span class="comment">/* pointer to the command to be launched */</span>
01127   int  (*command_func)(int,<span class="keywordtype">char</span> **,FILE *) = NULL ;
01128   
01129   <span class="keywordtype">int</span> i;
01130   <span class="keywordtype">int</span> rc;
01131   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01132   
01133   <a class="code" href="structshell__state____.html">shell_state_t</a>  * context =   GetShellContext();  
01134 
01135   <span class="comment">/* First, look at shell internal commands */</span> 
01136   
01137   <span class="keywordflow">for</span> ( i=0; shell_commands[i].command_name; i++ )
01138   {
01139     <span class="keywordflow">if</span> ( !strcmp( argv[0],shell_commands[i].command_name ) )
01140     {
01141        command_func = shell_commands[i].command_func ;
01142        <span class="keywordflow">break</span>;
01143     }
01144   }
01145   
01146   
01147   <span class="comment">/* If not found, look at shell utils commands */</span>
01148   
01149   <span class="keywordflow">if</span> ( ! command_func )
01150   {
01151   
01152     <span class="keywordflow">for</span> ( i=0; shell_utils[i].command_name; i++ )
01153     {
01154       <span class="keywordflow">if</span> ( !strcmp( argv[0],shell_utils[i].command_name ) )
01155       {
01156          command_func = shell_utils[i].command_func ;
01157          <span class="keywordflow">break</span>;
01158       }
01159     }
01160     
01161   }
01162 
01163     
01164   <span class="comment">/* If not found, look at layer commands */</span>
01165   
01166   <span class="keywordflow">if</span> ( ! command_func )
01167   {
01168     <a class="code" href="structlayer__def____.html">layer_def_t</a> * current_layer = <a class="code" href="shell_8h.html#a18">shell_GetLayer</a>( context );
01169     
01170     <span class="keywordflow">if</span> ( current_layer )
01171     {
01172     
01173       <span class="keywordflow">for</span> ( i=0; current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o0">command_name</a>; i++ )
01174       {
01175         <span class="keywordflow">if</span> ( !strcmp( argv[0],current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o0">command_name</a> ) )
01176         {
01177            command_func = current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o1">command_func</a> ;
01178            
01179            <span class="comment">/* set layer's debug level */</span>
01180            current_layer-&gt;<a class="code" href="structlayer__def____.html#o3">setlog_func</a>( <a class="code" href="shell_8h.html#a24">shell_GetDbgLvl</a>(context) );
01181            
01182            <span class="keywordflow">break</span>;
01183         }
01184       } <span class="comment">/* for */</span>
01185       
01186     }<span class="comment">/* if current_layer */</span>
01187     
01188   } <span class="comment">/* if command_func */</span>
01189   
01190   
01191   <span class="comment">/* command not found */</span>
01192   
01193   <span class="keywordflow">if</span> ( ! command_func ) {
01194     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"%s: command not found"</span>, argv[0]);
01195     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );    
01196     <span class="keywordflow">return</span> SHELL_NOT_FOUND;
01197   }
01198   
01199   <span class="comment">/* verbose trace */</span>
01200   
01201   <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a22">shell_GetVerbose</a>( context ) )
01202   {
01203     tracebuff[0]=<span class="charliteral">'\0'</span>;
01204     <span class="keywordflow">for</span> ( i = 0; i &lt; argc; i ++ )
01205     {
01206       <span class="comment">/* + 1 = size of the additional char ( + or space) */</span>
01207       size_t len1 = strlen( tracebuff ) + 1;
01208       size_t len2 = strlen( argv[i] );
01209             
01210       <span class="keywordflow">if</span> ( len1 &gt; <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a> - 1 ) <span class="keywordflow">break</span>;
01211 
01212       <span class="keywordflow">if</span> ( i != 0 ) strcat( tracebuff, <span class="stringliteral">" "</span> );
01213       <span class="keywordflow">else</span> strcat( tracebuff, <span class="stringliteral">"+"</span> );
01214 
01215       <span class="keywordflow">if</span> ( len1 + len2 &gt; <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a> - 1 )
01216       {
01217         <span class="keywordflow">if</span> ( <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a> - 6 - len1 &gt; 0 )
01218           strncat( tracebuff, argv[i], <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a> - 6 - len1 );
01219 
01220         strcat( tracebuff, <span class="stringliteral">"[...]"</span> );
01221         <span class="keywordflow">break</span>;
01222       }
01223       <span class="keywordflow">else</span>
01224       {
01225         strcat(tracebuff,  argv[i] );
01226       }
01227 
01228     }
01229   }
01230   <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>( context, tracebuff );
01231   
01232   <span class="comment">/* execute the command */</span>
01233   
01234   rc =  command_func( argc, argv, output );
01235   
01236   <span class="comment">/* verbose trace */</span>
01237   
01238   snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"%s returned %d"</span>, argv[0], rc );
01239   <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>( context, tracebuff );
01240   
01241   <span class="keywordflow">return</span> rc;
01242   
01243 } <span class="comment">/* shell_Execute */</span>
01244                     
01245 
01246 
01247 
01248 <span class="comment">/*------------------------------------------------------------------</span>
01249 <span class="comment"> *                 Shell ouput routines.</span>
01250 <span class="comment"> *-----------------------------------------------------------------*/</span>
01251 
01252 
<a name="l01257"></a><a class="code" href="shell_8h.html#a15">01257</a> <span class="keywordtype">void</span> <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(   <a class="code" href="structshell__state____.html">shell_state_t</a>  * context, <span class="keywordtype">char</span> * error_msg )
01258 {
01259   
01260   <span class="keywordtype">char</span> * input_name = <a class="code" href="shell__vars_8h.html#a2">get_var_value</a>( <span class="stringliteral">"INPUT"</span> );
01261   
01262   fprintf( stderr, <span class="stringliteral">"******* ERROR in %s line %d: %s\n"</span>,
01263            ( input_name ? input_name : <span class="stringliteral">"?"</span> ),
01264            <a class="code" href="shell_8h.html#a31">shell_GetLine</a>( context ),
01265            error_msg
01266           );
01267   
01268 }
01269 
01270 
<a name="l01275"></a><a class="code" href="shell_8h.html#a16">01275</a> <span class="keywordtype">void</span> <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>(<a class="code" href="structshell__state____.html">shell_state_t</a>  * context, <span class="keywordtype">char</span> * msg )
01276 {
01277   
01278   <span class="keywordtype">char</span> * input_name;
01279   
01280   <span class="keywordflow">if</span> ( <a class="code" href="shell_8h.html#a22">shell_GetVerbose</a>( context ) )
01281   {
01282     input_name = <a class="code" href="shell__vars_8h.html#a2">get_var_value</a>( <span class="stringliteral">"INPUT"</span> );
01283   
01284     fprintf( stderr, <span class="stringliteral">"%s l.%d: %s\n"</span>,
01285              ( input_name ? input_name : <span class="stringliteral">"?"</span> ),
01286              <a class="code" href="shell_8h.html#a31">shell_GetLine</a>(context),
01287              msg
01288             );
01289   }
01290     
01291 }
01292 
01293 
01294 
01295 <span class="comment">/*------------------------------------------------------------------</span>
01296 <span class="comment"> *                 Shell state management routines.</span>
01297 <span class="comment"> *-----------------------------------------------------------------*/</span>
01298 
01299 
<a name="l01306"></a><a class="code" href="shell_8h.html#a17">01306</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a17">shell_SetLayer</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">char</span> * layer_name )
01307 {
01308   
01309   <a class="code" href="structlayer__def____.html">layer_def_t</a> * layer = NULL;
01310   <span class="keywordtype">int</span> i, rc;
01311   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01312   
01313   <span class="comment">/* search for layer */</span>
01314   
01315   <span class="keywordflow">for</span> ( i=0; layer_list[i].layer_name; i++ )
01316   {
01317     <span class="keywordflow">if</span> (!strcasecmp(layer_name,layer_list[i].layer_name))
01318     {
01319        layer = &amp;layer_list[i];
01320        <span class="keywordflow">break</span>;
01321     }
01322   }
01323 
01324   <span class="comment">/* saves current layer */</span>
01325   
01326   <span class="keywordflow">if</span> ( layer )
01327   {
01328     <span class="comment">/* saves layer pointer */</span>
01329     
01330     context-&gt;<a class="code" href="structshell__state____.html#o2">layer</a> = layer;
01331     
01332     <span class="comment">/* stores layer name into vars  */</span>
01333     
01334     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>(<span class="stringliteral">"LAYER"</span>, layer-&gt;<a class="code" href="structlayer__def____.html#o0">layer_name</a> );
01335     
01336     <span class="keywordflow">if</span> ( rc != 0 )
01337     {
01338       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01339           <span class="stringliteral">"Error %d setting LAYER value to %s"</span>, rc, layer-&gt;<a class="code" href="structlayer__def____.html#o0">layer_name</a> );
01340       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01341     }
01342     
01343     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01344         <span class="stringliteral">"Current layer is now %s"</span>, layer-&gt;<a class="code" href="structlayer__def____.html#o0">layer_name</a> );
01345     <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>( context, tracebuff );
01346     
01347     <span class="keywordflow">return</span> SHELL_SUCCESS;
01348     
01349   }
01350   <span class="keywordflow">else</span>
01351   {
01352     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Layer not found: %s"</span>, layer_name );
01353     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01354     <span class="keywordflow">return</span> SHELL_NOT_FOUND;
01355   }
01356   
01357   
01358 } <span class="comment">/* shell_SetLayer */</span>
01359 
01360 
01361 
<a name="l01366"></a><a class="code" href="shell_8h.html#a18">01366</a> <a class="code" href="structlayer__def____.html">layer_def_t</a> * <a class="code" href="shell_8h.html#a18">shell_GetLayer</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01367 {
01368   
01369   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o2">layer</a>;
01370   
01371 }
01372 
01373 
<a name="l01378"></a><a class="code" href="shell_8h.html#a19">01378</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a19">shell_SetStatus</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">int</span> returned_status )
01379 {
01380   
01381   <span class="keywordtype">int</span> rc;
01382   <span class="keywordtype">char</span> str_int[64];
01383   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01384     
01385   context-&gt;<a class="code" href="structshell__state____.html#o3">status</a> = returned_status;
01386   
01387   snprintf( str_int, 64, <span class="stringliteral">"%d"</span>, returned_status);
01388   
01389   rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"STATUS"</span>, str_int );
01390   
01391   <span class="keywordflow">if</span> ( rc != 0 )
01392   {
01393     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01394         <span class="stringliteral">"Error %d setting STATUS value to %s"</span>, rc, str_int );
01395     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01396   }
01397   
01398   rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"?"</span>, str_int );
01399   
01400   <span class="keywordflow">if</span> ( rc != 0 )
01401   {
01402     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01403         <span class="stringliteral">"Error %d setting ? value to %s"</span>, rc, str_int );
01404     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01405   }
01406   
01407   <span class="keywordflow">return</span> SHELL_SUCCESS;
01408   
01409 }
01410 
01411 
<a name="l01416"></a><a class="code" href="shell_8h.html#a20">01416</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a20">shell_GetStatus</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01417 {
01418   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o3">status</a>;
01419 }
01420 
01421 
<a name="l01426"></a><a class="code" href="shell_8h.html#a21">01426</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a21">shell_SetVerbose</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">char</span> * str_verbose )
01427 {
01428 
01429   <span class="keywordtype">int</span> rc;
01430   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01431     
01432   <span class="keywordflow">if</span> (
01433        !strcasecmp(str_verbose,<span class="stringliteral">"ON"</span>) ||
01434        !strcasecmp(str_verbose,<span class="stringliteral">"TRUE"</span>) ||
01435        !strcasecmp(str_verbose,<span class="stringliteral">"YES"</span>) ||
01436        !strcmp(str_verbose,<span class="stringliteral">"1"</span>)
01437       )
01438   {
01439     context-&gt;<a class="code" href="structshell__state____.html#o4">verbose</a> = TRUE;
01440 
01441     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"VERBOSE"</span>, <span class="stringliteral">"1"</span> );
01442 
01443     <span class="keywordflow">if</span> ( rc != 0 )
01444     {
01445       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01446           <span class="stringliteral">"Error %d setting VERBOSE value to %s"</span>, rc, <span class="stringliteral">"1"</span> );
01447       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01448     }
01449     
01450     <span class="keywordflow">return</span> SHELL_SUCCESS;
01451 
01452   }
01453   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (
01454        !strcasecmp(str_verbose,<span class="stringliteral">"OFF"</span>) ||
01455        !strcasecmp(str_verbose,<span class="stringliteral">"FALSE"</span>) ||
01456        !strcasecmp(str_verbose,<span class="stringliteral">"NO"</span>) ||
01457        !strcmp(str_verbose,<span class="stringliteral">"0"</span>)
01458       )
01459   {
01460     context-&gt;<a class="code" href="structshell__state____.html#o4">verbose</a> = FALSE;
01461 
01462     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"VERBOSE"</span>, <span class="stringliteral">"0"</span> );
01463 
01464     <span class="keywordflow">if</span> ( rc != 0 )
01465     {
01466       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01467           <span class="stringliteral">"Error %d setting VERBOSE value to %s"</span>, rc, <span class="stringliteral">"0"</span> );
01468       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01469     }
01470     
01471     <span class="keywordflow">return</span> SHELL_SUCCESS;
01472 
01473   }
01474   <span class="keywordflow">else</span>
01475   {
01476     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01477         <span class="stringliteral">"Unexpected value for VERBOSE: %s"</span>, str_verbose );
01478     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01479     
01480     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;
01481   }
01482   
01483 }
01484 
01485 
<a name="l01490"></a><a class="code" href="shell_8h.html#a22">01490</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a22">shell_GetVerbose</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01491 {
01492   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o4">verbose</a>;
01493 }
01494 
01495 
<a name="l01500"></a><a class="code" href="shell_8h.html#a23">01500</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a23">shell_SetDbgLvl</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">char</span> * str_debug_level )
01501 {
01502   <span class="keywordtype">int</span> level_debug;
01503   <span class="keywordtype">int</span> rc;
01504   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01505   
01506   level_debug = ReturnLevelAscii( str_debug_level );
01507   
01508   <span class="keywordflow">if</span> ( level_debug != -1 )
01509   {
01510     <span class="comment">/* set shell state */</span>
01511     context-&gt;<a class="code" href="structshell__state____.html#o5">debug_level</a> = level_debug;
01512     
01513     <span class="comment">/* call to logfunctions */</span>
01514     SetLevelDebug( level_debug );
01515     
01516     <span class="comment">/* set shell vars */</span>
01517     
01518     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"DEBUG_LEVEL"</span>, str_debug_level );
01519 
01520     <span class="keywordflow">if</span> ( rc != 0 )
01521     {
01522       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01523           <span class="stringliteral">"Error %d setting DEBUG_LEVEL value to %s"</span>, rc, str_debug_level );
01524       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01525     }
01526     
01527     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"DBG_LVL"</span>, str_debug_level );
01528 
01529     <span class="keywordflow">if</span> ( rc != 0 )
01530     {
01531       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01532           <span class="stringliteral">"Error %d setting DBG_LVL value to %s"</span>, rc, str_debug_level );
01533       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01534     }
01535     
01536     <span class="keywordflow">return</span> SHELL_SUCCESS;
01537     
01538   }
01539   <span class="keywordflow">else</span>
01540   {
01541     
01542     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01543       <span class="stringliteral">"Unexpected value for DEBUG_LEVEL: %s"</span>, str_debug_level );
01544     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01545     
01546     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;
01547   }
01548 
01549   
01550 } <span class="comment">/* shell_SetDbgLvl */</span>
01551 
01552 
01553 
<a name="l01558"></a><a class="code" href="shell_8c.html#a36">01558</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a24">shell_GetDbgLvl</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01559 {
01560   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o5">debug_level</a>;
01561 }
01562 
01563 
01564 
<a name="l01573"></a><a class="code" href="shell_8h.html#a26">01573</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a26">shell_SetInput</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">char</span> * file_name )
01574 {
01575   
01576   FILE * stream;
01577   <span class="keywordtype">int</span> rc;
01578   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01579   
01580   <span class="keywordflow">if</span> ( file_name )
01581   {
01582     <span class="keywordflow">if</span> ( (stream = fopen(file_name, <span class="stringliteral">"r"</span>)) == NULL )
01583     {
01584       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Can't open \"%s\": %s (%d)"</span>,
01585          file_name, strerror(errno) , errno ); 
01586       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(context, tracebuff);
01587       <span class="keywordflow">return</span> errno;
01588     }
01589         
01590     
01591     <span class="comment">/* close previous filestream and reset line number */</span>
01592     <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> != NULL )
01593     {
01594       <span class="comment">/* don't close stdin */</span>
01595       <span class="keywordflow">if</span> (context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> != stdin)
01596         fclose( context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> );
01597       
01598       <a class="code" href="shell_8h.html#a30">shell_SetLine</a>( context, 0 );
01599     }
01600     
01601     
01602     <span class="comment">/* set filestream */</span>
01603     context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> = stream;
01604 
01605     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"INPUT"</span>, file_name );
01606 
01607     <span class="keywordflow">if</span> ( rc != 0 )
01608     {
01609       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01610           <span class="stringliteral">"Error %d setting INPUT value to \"%s\""</span>, rc, file_name );
01611       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01612     }    
01613     
01614     <span class="comment">/* set interative mode to FALSE */</span>
01615     
01616     context-&gt;<a class="code" href="structshell__state____.html#o1">interactive</a> = FALSE;
01617     
01618     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"INTERACTIVE"</span>, <span class="stringliteral">"0"</span> );
01619 
01620     <span class="keywordflow">if</span> ( rc != 0 )
01621     {
01622       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01623           <span class="stringliteral">"Error %d setting INTERACTIVE value to %s"</span>, rc, <span class="stringliteral">"0"</span> );
01624       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01625     }    
01626 
01627     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Using script file \"%s\""</span>,file_name);
01628     <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>( context, tracebuff );
01629     
01630     <span class="keywordflow">return</span> SHELL_SUCCESS;
01631         
01632 
01633   }
01634   <span class="keywordflow">else</span>
01635   {
01636     stream = stdin;
01637         
01638     <span class="comment">/* close previous filestream and reset line number */</span>
01639     <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> != NULL )
01640     {
01641       <span class="comment">/* don't close stdin */</span>
01642       <span class="keywordflow">if</span> (context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> != stdin)
01643         fclose( context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> );
01644       <a class="code" href="shell_8h.html#a30">shell_SetLine</a>( context, 0 );
01645     }
01646     
01647     <span class="comment">/* set filestream */</span>
01648     context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> = stream;
01649 
01650     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"INPUT"</span>, <span class="stringliteral">"&lt;stdin&gt;"</span> );
01651 
01652     <span class="keywordflow">if</span> ( rc != 0 )
01653     {
01654       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01655           <span class="stringliteral">"Error %d setting INPUT value to %s"</span>, rc, <span class="stringliteral">"&lt;stdin&gt;"</span> );
01656       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01657     }    
01658     
01659     <span class="comment">/* set interative mode to TRUE */</span>
01660     
01661     context-&gt;<a class="code" href="structshell__state____.html#o1">interactive</a> = TRUE;
01662     
01663     rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"INTERACTIVE"</span>, <span class="stringliteral">"1"</span> );
01664 
01665     <span class="keywordflow">if</span> ( rc != 0 )
01666     {
01667       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01668           <span class="stringliteral">"Error %d setting INTERACTIVE value to %s"</span>, rc, <span class="stringliteral">"1"</span> );
01669       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01670     }    
01671 
01672     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"Using standard input"</span>);
01673     <a class="code" href="shell_8h.html#a16">shell_PrintTrace</a>( context, tracebuff );
01674     
01675     <span class="keywordflow">return</span> SHELL_SUCCESS;
01676     
01677     
01678   }
01679   
01680 } <span class="comment">/* shell_SetInput */</span>
01681 
01682 
01683 
<a name="l01688"></a><a class="code" href="shell_8h.html#a25">01688</a> FILE * <a class="code" href="shell_8h.html#a25">shell_GetInputStream</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01689 {
01690   <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a> )
01691     <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o0">input_stream</a>;
01692   <span class="keywordflow">else</span>
01693     <span class="keywordflow">return</span> stdin;
01694 }
01695 
01696 
01697 
01698 
<a name="l01703"></a><a class="code" href="shell_8h.html#a27">01703</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a27">shell_SetPrompt</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">char</span> * str_prompt )
01704 {
01705     <span class="keywordtype">int</span> rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"PROMPT"</span>, str_prompt );
01706     <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01707 
01708     <span class="keywordflow">if</span> ( rc != 0 )
01709     {
01710       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01711           <span class="stringliteral">"Error %d setting PROMPT value to \"%s\""</span>, rc, str_prompt );
01712       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01713     }
01714     
01715     <span class="keywordflow">return</span> rc;  
01716 }
01717 
01718 
01719 
<a name="l01724"></a><a class="code" href="shell_8h.html#a28">01724</a> <span class="keywordtype">char</span> * <a class="code" href="shell_8h.html#a28">shell_GetPrompt</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01725 {
01726     <span class="keywordflow">return</span> <a class="code" href="shell__vars_8h.html#a2">get_var_value</a>( <span class="stringliteral">"PROMPT"</span> );
01727 }
01728 
01729 
01730 
<a name="l01735"></a><a class="code" href="shell_8h.html#a29">01735</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a29">shell_SetShellId</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">int</span> shell_index )
01736 {
01737   <span class="keywordtype">int</span> rc;
01738   <span class="keywordtype">char</span> str[64];
01739   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01740   
01741   snprintf(str, 64, <span class="stringliteral">"%d"</span>,shell_index);
01742  
01743   rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"SHELLID"</span>, str );
01744   
01745   <span class="keywordflow">if</span> ( rc != 0 )
01746   {
01747     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01748         <span class="stringliteral">"Error %d setting SHELLID value to \"%s\""</span>, rc, str );
01749     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01750   }
01751     
01752   <span class="keywordflow">return</span> SHELL_SUCCESS;
01753 }
01754 
01755 
01756 
<a name="l01761"></a><a class="code" href="shell_8h.html#a30">01761</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a30">shell_SetLine</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context, <span class="keywordtype">int</span> lineno )
01762 {
01763   <span class="keywordtype">int</span> rc;
01764   <span class="keywordtype">char</span> str_line[64];
01765   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01766   
01767   context-&gt;<a class="code" href="structshell__state____.html#o6">line</a> = lineno;
01768   
01769   snprintf(str_line, 64, <span class="stringliteral">"%d"</span>,lineno);
01770  
01771   rc = <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( <span class="stringliteral">"LINE"</span>, str_line );
01772   
01773   <span class="keywordflow">if</span> ( rc != 0 )
01774   {
01775     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01776         <span class="stringliteral">"Error %d setting LINE value to \"%s\""</span>, rc, str_line );
01777     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( context, tracebuff );
01778   }
01779     
01780   <span class="keywordflow">return</span> SHELL_SUCCESS;
01781   
01782 }
01783 
01784 
01785 
<a name="l01790"></a><a class="code" href="shell_8h.html#a31">01790</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a31">shell_GetLine</a>( <a class="code" href="structshell__state____.html">shell_state_t</a> * context )
01791 {
01792   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structshell__state____.html#o6">line</a>;
01793 }
01794 
01795 
01796 
01797 <span class="comment">/*------------------------------------------------------------------</span>
01798 <span class="comment"> *                      Shell commands.</span>
01799 <span class="comment"> *-----------------------------------------------------------------*/</span>
01800 
01801  
<a name="l01802"></a><a class="code" href="shell_8h.html#a32">01802</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a32">shellcmd_help</a>(
01803                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01804                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01805                    FILE * output      <span class="comment">/* IN : output stream          */</span>
01806                   )
01807 {
01808   
01809   <span class="keywordtype">int</span> i;
01810   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01811   <a class="code" href="structlayer__def____.html">layer_def_t</a> * current_layer = <a class="code" href="shell_8h.html#a18">shell_GetLayer</a>(GetShellContext());
01812   
01813   
01814   <span class="comment">/* check args */</span>
01815   
01816   <span class="keywordflow">if</span> ( argc&gt;1 )
01817   {
01818     <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++)
01819     {
01820       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01821           <span class="stringliteral">"%s: Unexpected argument \"%s\""</span>, argv[0], argv[i] );
01822       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
01823     }
01824   }
01825   
01826   <span class="comment">/* List shell build-in commands */</span>
01827   
01828   fprintf(output, <span class="stringliteral">"Shell built-in commands:\n"</span>);
01829   
01830   <span class="keywordflow">for</span> ( i=0; shell_commands[i].command_name; i++ )
01831   {
01832     fprintf(output, <span class="stringliteral">"   %15s: %s\n"</span>, shell_commands[i].command_name,
01833                                    shell_commands[i].command_help );
01834   }
01835   
01836 
01837   <span class="comment">/* List shell tools commands */</span>
01838 
01839   fprintf(output, <span class="stringliteral">"\nShell tools commands:\n"</span>);
01840   
01841   <span class="keywordflow">for</span> ( i=0; shell_utils[i].command_name; i++ )
01842   {
01843     fprintf(output, <span class="stringliteral">"   %15s: %s\n"</span>, shell_utils[i].command_name,
01844                                    shell_utils[i].command_help );
01845   }
01846 
01847   <span class="comment">/* Layer list */</span>  
01848   
01849   fprintf(output, <span class="stringliteral">"\nLayers list:\n"</span>);
01850   
01851   <span class="keywordflow">for</span> ( i=0; layer_list[i].layer_name; i++ )
01852   {
01853     fprintf(output, <span class="stringliteral">"   %15s: %s\n"</span>, layer_list[i].layer_name,
01854                                    layer_list[i].layer_description );
01855   }
01856 
01857   <span class="comment">/* Layer commands */</span>  
01858   
01859   <span class="keywordflow">if</span> ( current_layer )
01860   {
01861   
01862   fprintf(output, <span class="stringliteral">"\n%s layer commands:\n"</span>, current_layer-&gt;<a class="code" href="structlayer__def____.html#o0">layer_name</a> );
01863   
01864     <span class="keywordflow">for</span> ( i=0; current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o0">command_name</a>; i++ )
01865     {
01866       fprintf(output, <span class="stringliteral">"   %15s: %s\n"</span>, current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o0">command_name</a>,
01867                                      current_layer-&gt;<a class="code" href="structlayer__def____.html#o1">command_list</a>[i].<a class="code" href="structcommand__def____.html#o2">command_help</a> );
01868     }
01869     
01870   }
01871   
01872   
01873   <span class="keywordflow">return</span> SHELL_SUCCESS;
01874       
01875 } <span class="comment">/* shellcmd_help */</span>
01876 
01877 
01878 
<a name="l01879"></a><a class="code" href="shell_8h.html#a33">01879</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a33">shellcmd_if</a>(
01880                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01881                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01882                    FILE * output      <span class="comment">/* IN : output stream          */</span>
01883                   )
01884 {
01885 
01886   <span class="keywordtype">int</span> i, rc;
01887   <span class="keywordtype">int</span> index_test    = -1;
01888   <span class="keywordtype">int</span> longueur_test = -1;
01889   <span class="keywordtype">int</span> index_cmd1    = -1;
01890   <span class="keywordtype">int</span> longueur_cmd1 = -1;
01891   <span class="keywordtype">int</span> index_cmd2    = -1;
01892   <span class="keywordtype">int</span> longueur_cmd2 = -1;
01893   
01894   <span class="keyword">static</span> <span class="keywordtype">char</span> * help_if =
01895       <span class="stringliteral">"Usage: if command0 ? command1 [: command2]\n"</span>
01896       <span class="stringliteral">"   Execute command1 if command0 returns a null status.\n"</span>
01897       <span class="stringliteral">"   Else, execute command2 (if any).\n"</span>
01898       <span class="stringliteral">"Ex: if eq -n $STATUS 0 ? print \"status=0\" : print \"status&lt;&gt;0\" \n"</span>;
01899     
01900   
01901   <span class="comment">/* first, check that there is a test */</span>
01902   <span class="keywordflow">if</span> ( argc &gt; 1 )
01903   {
01904   
01905     index_test = 1;
01906     
01907     i = index_test + 1;
01908     
01909     <span class="comment">/* look for command 1 */</span>
01910         
01911     <span class="keywordflow">while</span> ( ( i &lt; argc ) &amp;&amp; strcmp( argv[i], <span class="stringliteral">"?"</span> ) ) i++;
01912       
01913     <span class="keywordflow">if</span> ( i+1 &lt; argc )
01914     {
01915       longueur_test = i - index_test;
01916       index_cmd1 = i+1;
01917       
01918       i = index_cmd1 + 1;
01919 
01920       <span class="comment">/* look for command 2 */</span>
01921       
01922       <span class="keywordflow">while</span> ( ( i &lt; argc ) &amp;&amp; strcmp( argv[i], <span class="stringliteral">":"</span> ) ) i++;
01923       
01924       <span class="keywordflow">if</span> ( i+1 &lt; argc )
01925       {
01926         longueur_cmd1 = i - index_cmd1;
01927         index_cmd2 = i+1;
01928         longueur_cmd2 = argc - index_cmd2;
01929       }
01930       <span class="keywordflow">else</span>
01931       {
01932         longueur_cmd1 = argc - index_cmd1;
01933       }
01934       
01935     }
01936     <span class="keywordflow">else</span>
01937     {
01938       longueur_test = argc - index_test;
01939     }
01940     
01941   }
01942   
01943   <span class="comment">/* test or cmd1 missing */</span>
01944   
01945   <span class="keywordflow">if</span> ( ( longueur_test &lt;= 0 ) || ( longueur_cmd1 &lt;= 0 ) )
01946   {
01947     fprintf(output,help_if);
01948     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;    
01949   }
01950   
01951   <span class="comment">/* executes test */</span>
01952   
01953   rc = <a class="code" href="shell_8h.html#a14">shell_Execute</a>( longueur_test, &amp;(argv[index_test]), output );
01954   
01955     
01956   <span class="comment">/* if rc is not null, executes command 1 */</span>
01957   <span class="keywordflow">if</span> (rc)
01958   {
01959     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a14">shell_Execute</a>( longueur_cmd1, &amp;(argv[index_cmd1]), output );
01960   }
01961   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (longueur_cmd2 &gt; 0)
01962   {
01963     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a14">shell_Execute</a>( longueur_cmd2, &amp;(argv[index_cmd2]), output );
01964   }
01965   
01966   <span class="keywordflow">return</span> 0;
01967     
01968 } <span class="comment">/* shellcmd_if */</span>
01969 
01970 
01971 
01972 
<a name="l01973"></a><a class="code" href="shell_8h.html#a34">01973</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a34">shellcmd_interactive</a>(
01974                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01975                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01976                    FILE * output      <span class="comment">/* IN : output stream          */</span>
01977                   )
01978 {
01979   <span class="keywordtype">int</span> i;
01980   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
01981   
01982   <span class="comment">/* check args */</span>
01983   
01984   <span class="keywordflow">if</span> ( argc&gt;1 )
01985   {
01986     <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++)
01987     {
01988       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
01989           <span class="stringliteral">"%s: Unexpected argument \"%s\""</span>, argv[0], argv[i] );
01990       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
01991     }
01992   }
01993   
01994   <span class="comment">/* set input as stdin */</span>
01995   
01996   <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a26">shell_SetInput</a>( GetShellContext(), <a class="code" href="Getopt_8c.html#a0">NULL</a> );
01997     
01998 } <span class="comment">/* shellcmd_interactive */</span>
01999 
02000 
02001 
02002 
<a name="l02003"></a><a class="code" href="shell_8h.html#a35">02003</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a35">shellcmd_set</a>(
02004                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02005                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02006                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02007                   )
02008 { 
02009   
02010   <span class="keywordtype">int</span> i;
02011   <span class="keywordtype">char</span> * varname;
02012   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
02013   <span class="keywordtype">char</span> varvalue[MAX_OUTPUT_LEN];
02014   
02015   <span class="comment">/* check args */</span>
02016 
02017   <span class="keywordflow">if</span> ( argc &lt; 3 )
02018   {
02019     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02020         <span class="stringliteral">"%s: Usage: %s &lt;var_name&gt; &lt;expr1&gt; [&lt;expr2&gt; ...&lt;exprN&gt;]"</span>,argv[0],argv[0] );
02021     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);
02022         
02023     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;
02024   }
02025   
02026   varname = argv[1];
02027     
02028   varvalue[0] = <span class="charliteral">'\0'</span>;
02029       
02030   <span class="comment">/* concatenation of strings */</span>
02031   
02032   <span class="keywordflow">for</span> ( i = 2; i &lt; argc ; i++)
02033     <span class="keywordflow">if</span> ( <a class="code" href="cmd__tools_8h.html#a17">concat</a>( varvalue , argv[i], <a class="code" href="shell_8c.html#a0">MAX_OUTPUT_LEN</a> ) == NULL )
02034     {
02035       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), <span class="stringliteral">"Output too large."</span>);
02036       <span class="keywordflow">return</span> SHELL_ERROR;
02037     }
02038     
02039   
02040   <span class="comment">/* special variables */</span>
02041   
02042   <span class="keywordflow">if</span> (!strcmp(varname, <span class="stringliteral">"INPUT"</span>))
02043   {
02044     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a26">shell_SetInput</a>(GetShellContext(), varvalue);
02045   }
02046   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(varname, <span class="stringliteral">"INTERACTIVE"</span>))
02047   {
02048     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02049         <span class="stringliteral">"%s: cannot set \"%s\": set the value of \"INPUT\" or use the \"interactive\" command instead."</span>,
02050         argv[0],varname );
02051     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);
02052         
02053     <span class="keywordflow">return</span> SHELL_ERROR;
02054     
02055   }
02056   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(varname, <span class="stringliteral">"LAYER"</span>))
02057   {
02058     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a17">shell_SetLayer</a>( GetShellContext(), varvalue );
02059   }
02060   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(varname, <span class="stringliteral">"STATUS"</span>) || !strcmp(varname, <span class="stringliteral">"?"</span>) )
02061   {
02062     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a19">shell_SetStatus</a>( GetShellContext(), <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( varvalue ) );
02063   }
02064   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(varname, <span class="stringliteral">"VERBOSE"</span>) )
02065   {
02066     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a21">shell_SetVerbose</a>( GetShellContext(), varvalue );
02067   }
02068   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strcmp(varname, <span class="stringliteral">"DEBUG_LEVEL"</span>) || !strcmp(varname, <span class="stringliteral">"DBG_LVL"</span>))
02069   {
02070     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a23">shell_SetDbgLvl</a>( GetShellContext(), varvalue );
02071   }
02072   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strcmp(varname, <span class="stringliteral">"PROMPT"</span>))
02073   {
02074     <span class="keywordflow">return</span> <a class="code" href="shell_8h.html#a27">shell_SetPrompt</a>( GetShellContext(), varvalue );
02075   }
02076   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strcmp(varname, <span class="stringliteral">"LINE"</span>))
02077   {
02078     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"%s: cannot set \"%s\"."</span>, argv[0], varname );
02079     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);        
02080     <span class="keywordflow">return</span> SHELL_ERROR;
02081   }
02082   <span class="keywordflow">else</span>
02083   {  
02084     
02085     
02086     <span class="comment">/* other variables */</span>
02087     
02088     <span class="keywordflow">if</span> ( !<a class="code" href="shell__vars_8h.html#a1">is_authorized_varname</a>(varname) )
02089     {
02090       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"%s: Invalid variable name \"%s\"."</span>, argv[0], varname );
02091       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);
02092       <span class="keywordflow">return</span> SHELL_ERROR;      
02093     }
02094 
02095     <span class="keywordflow">if</span> ( <a class="code" href="shell__vars_8h.html#a3">set_var_value</a>( varname, varvalue) )
02096     {
02097       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>, <span class="stringliteral">"%s: Error setting the value of \"%s\"."</span>, argv[0], varname );
02098       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);
02099       <span class="keywordflow">return</span> SHELL_ERROR;
02100     }
02101     
02102     <span class="keywordflow">return</span> SHELL_SUCCESS;
02103     
02104   }  
02105   
02106   
02107   <span class="comment">/* should never happen */</span>
02108   <span class="keywordflow">return</span> SHELL_ERROR;
02109   
02110 } <span class="comment">/* shellcmd_set */</span>
02111 
02112 
02113 
02114 
<a name="l02115"></a><a class="code" href="shell_8h.html#a36">02115</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a36">shellcmd_unset</a>(
02116                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02117                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02118                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02119                   )
02120 { 
02121   
02122   <span class="keywordtype">int</span> i, arg_idx;
02123   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
02124   <span class="keywordtype">int</span> error = SHELL_SUCCESS;
02125 
02126   <span class="keywordflow">if</span> ( argc&lt;=1 )
02127   {
02128     snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02129         <span class="stringliteral">"%s: Missing argument: &lt;var name&gt;"</span>,argv[0] );
02130     <a class="code" href="shell_8h.html#a15">shell_PrintError</a>(GetShellContext(), tracebuff);
02131         
02132     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;
02133   }
02134 
02135   
02136   <span class="keywordflow">for</span> ( arg_idx = 1 ; arg_idx &lt; argc ; arg_idx ++ )
02137   {  
02138   
02139     <span class="comment">/* check if it is not a special var */</span>
02140 
02141     <span class="keywordflow">for</span> ( i=0; shell_special_vars[i] != NULL ; i++ )
02142     {
02143 
02144       <span class="keywordflow">if</span> ( !strcmp( shell_special_vars[i], argv[arg_idx] ) )
02145       {
02146         
02147         snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02148             <span class="stringliteral">"%s: This special variable cannot be deleted: \"%s\""</span>,argv[0],
02149             argv[arg_idx] );
02150         <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02151         
02152         <span class="keywordflow">return</span> SHELL_ERROR;
02153         
02154       }
02155 
02156     }
02157     
02158     <span class="comment">/* unset the variable */</span>
02159     
02160     <span class="keywordflow">if</span> ( <a class="code" href="shell__vars_8h.html#a4">free_var</a>( argv[arg_idx] ) )
02161     {
02162       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02163             <span class="stringliteral">"%s: Variable not found: \"%s\""</span>,argv[0], argv[arg_idx] );
02164       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02165       
02166       error = SHELL_NOT_FOUND;
02167       <span class="comment">/* however, continue */</span>
02168     }
02169     
02170   }
02171     
02172   <span class="keywordflow">return</span> error;
02173   
02174 } <span class="comment">/* shellcmd_unset */</span>
02175 
02176 
02177 
02178 
<a name="l02179"></a><a class="code" href="shell_8h.html#a37">02179</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a37">shellcmd_print</a>(
02180                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02181                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02182                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02183                   )
02184 { 
02185   
02186   <span class="keywordtype">int</span> i;
02187   
02188   <span class="comment">/* print args */</span>
02189   <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++ )
02190     fprintf(output,<span class="stringliteral">"%s"</span>, argv[i]);
02191   
02192   fprintf( output, <span class="stringliteral">"\n"</span>);
02193   
02194   <span class="keywordflow">return</span> 0;  
02195   
02196 } <span class="comment">/* shellcmd_print */</span>
02197 
02198 
02199 
02200 
<a name="l02201"></a><a class="code" href="shell_8h.html#a38">02201</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a38">shellcmd_varlist</a>(
02202                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02203                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02204                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02205                   )
02206 {
02207   <span class="keywordtype">int</span> i;
02208   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
02209   
02210   <span class="comment">/* check args */</span>
02211   
02212   <span class="keywordflow">if</span> ( argc&gt;1 )
02213   {
02214     <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++)
02215     {
02216       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02217           <span class="stringliteral">"%s: Unexpected argument \"%s\""</span>, argv[0], argv[i] );
02218       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02219     }
02220   }
02221   
02222  <a class="code" href="shell__vars_8h.html#a5">print_varlist</a>( output, <a class="code" href="shell_8h.html#a22">shell_GetVerbose</a>( GetShellContext() ) );
02223  
02224  <span class="keywordflow">return</span> 0;
02225    
02226 } <span class="comment">/* shellcmd_varlist */</span>
02227 
02228 
02229 
02230 
<a name="l02231"></a><a class="code" href="shell_8h.html#a39">02231</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a39">shellcmd_time</a>(
02232                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02233                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02234                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02235                   )
02236 {
02237   
02238   <span class="keyword">static</span> <span class="keywordtype">char</span> * help_time =
02239       <span class="stringliteral">"Usage: time command [args ...]\n"</span>
02240       <span class="stringliteral">"   Measure the time for executing a command.\n"</span>
02241       <span class="stringliteral">"Ex: time shell ls\n"</span>;
02242     
02243   <span class="keyword">struct </span>timeval timer_start;
02244   <span class="keyword">struct </span>timeval timer_stop;
02245   <span class="keyword">struct </span>timeval timer_tmp;
02246 
02247   <span class="keywordtype">int</span> rc;
02248       
02249   <span class="comment">/* first, check that there is a test */</span>
02250   <span class="keywordflow">if</span> ( argc &lt; 2 )
02251   {
02252     fprintf(output,help_time);
02253     <span class="keywordflow">return</span> SHELL_SYNTAX_ERROR;
02254   }
02255   
02256   <span class="keywordflow">if</span> ( gettimeofday(&amp;timer_start,<a class="code" href="Getopt_8c.html#a0">NULL</a>)== -1 ){
02257     fprintf(output,<span class="stringliteral">"Error retrieving system time.\n"</span>);
02258     <span class="keywordflow">return</span> SHELL_ERROR;
02259   }
02260   
02261   rc = <a class="code" href="shell_8h.html#a14">shell_Execute</a>( argc - 1 , &amp;(argv[1]), output );
02262 
02263   <span class="keywordflow">if</span> ( gettimeofday(&amp;timer_stop,<a class="code" href="Getopt_8c.html#a0">NULL</a>)== -1 ){
02264     fprintf(output,<span class="stringliteral">"Error retrieving system time.\n"</span>);
02265     <span class="keywordflow">return</span> SHELL_ERROR;
02266   }
02267   
02268   timer_tmp = <a class="code" href="cmd__tools_8h.html#a24">time_diff</a>( timer_start, timer_stop );
02269   fprintf(output,<span class="stringliteral">"\nExecution time for command \"%s\": "</span>,argv[1]);
02270   <a class="code" href="cmd__tools_8h.html#a0">print_timeval</a>( output, timer_tmp );
02271   
02272   <span class="keywordflow">return</span> rc;
02273   
02274 } <span class="comment">/* shellcmd_time */</span>
02275 
02276 
02277 
<a name="l02278"></a><a class="code" href="shell_8h.html#a40">02278</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a40">shellcmd_quit</a>(
02279                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02280                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02281                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02282                   )
02283 {
02284   <span class="keywordtype">int</span> i;
02285   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
02286   
02287   <span class="comment">/* check args */</span>
02288   
02289   <span class="keywordflow">if</span> ( argc&gt;1 )
02290   {
02291     <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++)
02292     {
02293       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02294           <span class="stringliteral">"%s: Unexpected argument \"%s\""</span>, argv[0], argv[i] );
02295       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02296     }
02297   }
02298   
02299   exit(0);
02300   <span class="keywordflow">return</span> 0;
02301   
02302 } <span class="comment">/* shellcmd_quit */</span>
02303 
02304 
02305 
<a name="l02306"></a><a class="code" href="shell_8h.html#a41">02306</a> <span class="keywordtype">int</span> <a class="code" href="shell_8h.html#a41">shellcmd_barrier</a>(
02307                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02308                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02309                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02310                   )
02311 {
02312   <span class="keywordtype">int</span> i;
02313   <span class="keywordtype">char</span> tracebuff[TRACEBUFFSIZE];
02314   
02315   <span class="comment">/* check args */</span>
02316   
02317   <span class="keywordflow">if</span> ( argc&gt;1 )
02318   {
02319     <span class="keywordflow">for</span> ( i=1; i&lt;argc; i++)
02320     {
02321       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02322           <span class="stringliteral">"%s: Unexpected argument \"%s\""</span>, argv[0], argv[i] );
02323       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02324     }
02325   }
02326   
02327   <span class="comment">/* call shell_BarrierWait */</span>
02328   
02329   <span class="keywordflow">if</span> ( shell_BarrierWait() )
02330   {
02331       snprintf( tracebuff, <a class="code" href="shell_8c.html#a1">TRACEBUFFSIZE</a>,
02332           <span class="stringliteral">"%s: barrier cannot be used in a single thread/script environment."</span>, argv[0] );
02333       <a class="code" href="shell_8h.html#a15">shell_PrintError</a>( GetShellContext(), tracebuff );
02334       <span class="keywordflow">return</span> SHELL_ERROR;
02335   }
02336       
02337   <span class="keywordflow">return</span> SHELL_SUCCESS;
02338   
02339 } <span class="comment">/* shellcmd_quit */</span>
02340 
02341 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:35 2008 for ganeshell by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
