<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ganeshell: commands_NFS_remote.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>commands_NFS_remote.c</h1><a href="commands__NFS__remote_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> */</span>
00076 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>
00080 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00082 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00083 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00084 <span class="preprocessor">#include &lt;gssrpc/clnt.h&gt;</span>
00085 <span class="preprocessor">#else</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00087 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00088 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00089 <span class="preprocessor">#include &lt;rpc/clnt.h&gt;</span>
00090 <span class="preprocessor">#endif</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00092 <span class="preprocessor">#include "fsal.h"</span>
00093 <span class="preprocessor">#include "cache_inode.h"</span>
00094 <span class="preprocessor">#include "cache_content.h"</span>
00095 <span class="preprocessor">#include "<a class="code" href="commands_8h.html">commands.h</a>"</span>
00096 <span class="preprocessor">#include "stuff_alloc.h"</span>
00097 <span class="preprocessor">#include "<a class="code" href="Getopt_8h.html">Getopt.h</a>"</span>
00098 <span class="preprocessor">#include "<a class="code" href="cmd__nfstools_8h.html">cmd_nfstools.h</a>"</span>
00099 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00100 <span class="preprocessor">#include "nfs_file_handle.h"</span>
00101 <span class="preprocessor">#include "nfs_core.h"</span>
00102 
00103 <span class="preprocessor">#include "nfs23.h"</span>
00104 <span class="preprocessor">#include "mount.h"</span>
00105 
00106 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00107 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00108 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00109 <span class="preprocessor">#include &lt;string.h&gt;</span>
00110 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00111 
00112 
<a name="l00113"></a><a class="code" href="commands__NFS__remote_8c.html#a0">00113</a> <span class="preprocessor">#define MAXIT 10</span>
<a name="l00114"></a><a class="code" href="commands__NFS__remote_8c.html#a1">00114</a> <span class="preprocessor"></span><span class="preprocessor">#define MAXRETRY 3</span>
00115 <span class="preprocessor"></span>
00116 <span class="comment">/*char *strndup(const char *s, size_t n); */</span>
00117 
<a name="l00118"></a><a class="code" href="commands__NFS__remote_8c.html#a5">00118</a> nfs_parameter_t      nfs_param ;
00119 
00120 <span class="comment">/* Function used for debugging */</span>
00121 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00122 <span class="preprocessor"></span><span class="keywordtype">void</span> print_nfs_res( nfs_res_t * p_res )
00123 {
00124   <span class="keywordtype">int</span> index;
00125   <span class="keywordflow">for</span> ( index = 0; index &lt; <span class="keyword">sizeof</span>(nfs_res_t); index++ )
00126   {
00127     <span class="keywordflow">if</span> ( (index+1)%32 == 0 )
00128       printf(<span class="stringliteral">"%02X\n"</span>,((<span class="keywordtype">char</span>*)p_res)[index]);
00129     <span class="keywordflow">else</span>
00130       printf(<span class="stringliteral">"%02X."</span>,((<span class="keywordtype">char</span>*)p_res)[index]);
00131   }
00132   printf(<span class="stringliteral">"\n"</span>);
00133 }
00134 <span class="preprocessor">#endif</span>
00135 <span class="preprocessor"></span>
00136 <span class="comment">/* --------------- INTERNAL FH3 REPRESENTATION ---------------- */</span>
00137 <span class="comment">/* used for keeping handle value after</span>
00138 <span class="comment"> * freeing nfs res.</span>
00139 <span class="comment"> */</span>
00140 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structshell__fh3____.html">shell_fh3__</a>
00141 {
<a name="l00142"></a><a class="code" href="structshell__fh3____.html#o0">00142</a>   u_int data_len;
<a name="l00143"></a><a class="code" href="structshell__fh3____.html#o1">00143</a>   <span class="keywordtype">char</span>  data_val[NFS3_FHSIZE];
00144 } <a class="code" href="structshell__fh3____.html">shell_fh3_t</a>;
00145 
00146 <span class="keyword">static</span> <span class="keywordtype">void</span> set_shell_fh3( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_int_fh3, nfs_fh3 * p_nfshdl)
00147 {
00148   p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> = p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a>;
00149   memcpy( p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a>, p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o1">data_val</a>, p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a> );
00150 } 
00151 
00152 <span class="keyword">static</span> <span class="keywordtype">void</span> set_nfs_fh3( nfs_fh3 * p_nfshdl, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_int_fh3 )
00153 {
00154   p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a> = p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> ;
00155   p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o1">data_val</a> = p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a>;
00156 } 
00157 <span class="comment">/* ------------------------- END ------------------------------ */</span>
00158 
00159 
00160 <span class="comment">/* ---------------------- For RPCs----------------------------- */</span>
00161 
00162 <span class="keyword">static</span> <span class="keyword">struct </span>timeval timeout = { 5, 0 };
00163 
00164 
<a name="l00165"></a><a class="code" href="structprog__vers__def____.html">00165</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structprog__vers__def____.html">prog_vers_def__</a> {
<a name="l00166"></a><a class="code" href="structprog__vers__def____.html#o0">00166</a>   <span class="keywordtype">char</span> * name;
<a name="l00167"></a><a class="code" href="structprog__vers__def____.html#o1">00167</a>   u_long prog;
<a name="l00168"></a><a class="code" href="structprog__vers__def____.html#o2">00168</a>   u_long vers;
00169 } <a class="code" href="structprog__vers__def____.html">prog_vers_def_t</a>;
00170 
00171 
00172 <span class="keyword">static</span> <a class="code" href="structprog__vers__def____.html">prog_vers_def_t</a> progvers_rpcs[] = {
00173   {<span class="stringliteral">"nfs2"</span>,   NFS_PROGRAM, NFS_V2},
00174   {<span class="stringliteral">"nfs3"</span>,   NFS_PROGRAM, NFS_V3},
00175   {<span class="stringliteral">"nfs4"</span>,   NFS4_PROGRAM, NFS_V4},
00176   {<span class="stringliteral">"mount1"</span>, MOUNTPROG,   MOUNT_V1},
00177   {<span class="stringliteral">"mount3"</span>, MOUNTPROG,   MOUNT_V3},
00178 
00179   {NULL,     0,           0}
00180 };
00181 
00182 
<a name="l00183"></a><a class="code" href="structprog__vers__client__def____.html">00183</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def__</a> {
<a name="l00184"></a><a class="code" href="structprog__vers__client__def____.html#o0">00184</a>   <span class="keywordtype">char</span>   * name;
<a name="l00185"></a><a class="code" href="structprog__vers__client__def____.html#o1">00185</a>   CLIENT * clnt;
<a name="l00186"></a><a class="code" href="structprog__vers__client__def____.html#o2">00186</a>   <span class="keywordtype">char</span>   * hostname;
<a name="l00187"></a><a class="code" href="structprog__vers__client__def____.html#o3">00187</a>   <span class="keywordtype">char</span>   * proto;
<a name="l00188"></a><a class="code" href="structprog__vers__client__def____.html#o4">00188</a>   <span class="keywordtype">int</span>      port;
00189 } <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a>;
00190 
00191 
00192 <span class="keyword">static</span> <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> progvers_clnts[] = {
00193   {<span class="stringliteral">"nfs2"</span>,   NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00194   {<span class="stringliteral">"nfs3"</span>,   NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00195   {<span class="stringliteral">"nfs4"</span>,   NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00196   {<span class="stringliteral">"mount1"</span>, NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00197   {<span class="stringliteral">"mount3"</span>, NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00198 
00199   {NULL,     NULL, <span class="stringliteral">""</span>, <span class="stringliteral">""</span>, 0},
00200 };
00201 
00202 
<a name="l00204"></a><a class="code" href="commands__NFS__remote_8c.html#a21">00204</a> CLIENT * <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="keywordtype">char</span> * name      <span class="comment">/* IN */</span>
00205          ) 
00206 {
00207   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00208 
00209   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00210     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00211       <span class="keywordflow">return</span> clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o1">clnt</a>;
00212     }
00213     clnts ++;
00214   }
00215   <span class="keywordflow">return</span> NULL;
00216 } <span class="comment">/* getCLIENT */</span>
00217 
00218 
<a name="l00220"></a><a class="code" href="commands__NFS__remote_8c.html#a22">00220</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a22">setCLIENT</a>(<span class="keywordtype">char</span> * name,  <span class="comment">/* IN */</span>
00221               CLIENT * clnt <span class="comment">/* IN */</span>
00222     ) 
00223 {
00224   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00225 
00226   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00227     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00228       clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o1">clnt</a> = clnt;
00229       <span class="keywordflow">return</span> 0;
00230     }
00231     clnts ++;
00232   }
00233   <span class="keywordflow">return</span> -1;
00234 } <span class="comment">/* setCLIENT */</span>
00235 
00236 
<a name="l00238"></a><a class="code" href="commands__NFS__remote_8c.html#a23">00238</a> <span class="keywordtype">char</span> * <a class="code" href="commands__NFS__remote_8c.html#a23">getHostname</a>(<span class="keywordtype">char</span> * name  <span class="comment">/* IN */</span>
00239        )
00240 {
00241   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00242 
00243   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00244     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00245       <span class="keywordflow">return</span> clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o2">hostname</a>;
00246     }
00247     clnts ++;
00248   }
00249   <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00250 } <span class="comment">/* getHostname */</span>
00251 
00252 
<a name="l00254"></a><a class="code" href="commands__NFS__remote_8c.html#a24">00254</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a24">setHostname</a>(<span class="keywordtype">char</span> * name,  <span class="comment">/* IN */</span>
00255                 <span class="keywordtype">char</span> * hostname  <span class="comment">/* IN */</span>
00256     )
00257 {
00258   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00259 
00260   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00261     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00262       clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o2">hostname</a> = (<span class="keywordtype">char</span>*)strndup(hostname, HOST_NAME_MAX);
00263       <span class="keywordflow">return</span> 0;
00264     }
00265     clnts ++;
00266   }
00267   <span class="keywordflow">return</span> -1;
00268 } <span class="comment">/* setHostname */</span>
00269 
00270 
<a name="l00272"></a><a class="code" href="commands__NFS__remote_8c.html#a25">00272</a> <span class="keywordtype">char</span> * <a class="code" href="commands__NFS__remote_8c.html#a25">getProto</a>(<span class="keywordtype">char</span> * name  <span class="comment">/* IN */</span>
00273        )
00274 {
00275   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00276 
00277   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00278     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00279       <span class="keywordflow">return</span> clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o3">proto</a>;
00280     }
00281     clnts ++;
00282   }
00283   <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00284 } <span class="comment">/* getProto */</span>
00285 
00286 
<a name="l00288"></a><a class="code" href="commands__NFS__remote_8c.html#a26">00288</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a26">setProto</a>(<span class="keywordtype">char</span> * name,  <span class="comment">/* IN */</span>
00289              <span class="keywordtype">char</span> * proto  <span class="comment">/* IN */</span>
00290     )
00291 {
00292   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00293 
00294   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00295     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00296       clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o3">proto</a> = (<span class="keywordtype">char</span>*)strndup(proto, 4);
00297       <span class="keywordflow">return</span> 0;
00298     }
00299     clnts ++;
00300   }
00301   <span class="keywordflow">return</span> -1;
00302 } <span class="comment">/* setProto */</span>
00303 
00304 
<a name="l00306"></a><a class="code" href="commands__NFS__remote_8c.html#a27">00306</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a27">getPort</a>(<span class="keywordtype">char</span> * name  <span class="comment">/* IN */</span>
00307     )
00308 {
00309   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00310 
00311   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00312     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00313       <span class="keywordflow">return</span> clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o4">port</a>;
00314     }
00315     clnts ++;
00316   }
00317   <span class="keywordflow">return</span> 0;
00318 } <span class="comment">/* getPort */</span>
00319 
00320 
<a name="l00322"></a><a class="code" href="commands__NFS__remote_8c.html#a28">00322</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a28">setPort</a>(<span class="keywordtype">char</span> * name,  <span class="comment">/* IN */</span>
00323             <span class="keywordtype">int</span>    port  <span class="comment">/* IN */</span>
00324     )
00325 {
00326   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
00327 
00328   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
00329     <span class="keywordflow">if</span> ( !strcmp( clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a>, name ) ) {
00330       clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o4">port</a> = port;
00331       <span class="keywordflow">return</span> 0;
00332     }
00333     clnts ++;
00334   }
00335   <span class="keywordflow">return</span> -1;
00336 } <span class="comment">/* setPort */</span>
00337 
00338 <span class="comment">/* passwd for CLIENT */</span>
<a name="l00339"></a><a class="code" href="commands__NFS__remote_8c.html#a12">00339</a> <span class="keyword">struct </span>passwd * current_pw;
00340 
00341 <span class="comment">/* ------------------------- END ------------------------------ */</span>
00342 
00343 <span class="comment">/* Global variable: local host name */</span>
00344 <span class="keyword">static</span> <span class="keywordtype">char</span> localmachine[256];
00345 
00346 <span class="comment">/* info for advanced commands (pwd, ls, cd, ...) */</span>
00347 <span class="keyword">static</span> <span class="keywordtype">int</span> is_mounted_path;
00348 
00349 <span class="keyword">static</span> <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> mounted_path_hdl;
00350 <span class="keyword">static</span> <span class="keywordtype">char</span> mounted_path[NFS2_MAXPATHLEN];
00351     
00352 <span class="keyword">static</span> <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> current_path_hdl;
00353 <span class="keyword">static</span> <span class="keywordtype">char</span> current_path[NFS2_MAXPATHLEN];
00354 
00355 
<a name="l00357"></a><a class="code" href="commands__NFS__remote_8c.html#a29">00357</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a29">rpc_init</a>(<span class="keywordtype">char</span> * hostname, <span class="comment">/* IN */</span>
00358              <span class="keywordtype">char</span> * name,     <span class="comment">/* IN */</span>
00359              <span class="keywordtype">char</span> * proto,    <span class="comment">/* IN */</span>
00360              <span class="keywordtype">int</span>    port,     <span class="comment">/* IN */</span>
00361              FILE * output    <span class="comment">/* IN */</span>
00362     )
00363 {
00364   <span class="keywordtype">int</span> rc;
00365   u_long prog = 0;
00366   u_long vers = 0;
00367 
00368   CLIENT * clnt_res = NULL;
00369         <span class="keyword">struct </span>hostent *h;
00370         <span class="keyword">struct </span>protoent *p;
00371         <span class="keyword">struct </span>sockaddr_in sin;
00372         <span class="keywordtype">int</span> sock;
00373         <span class="keyword">struct </span>timeval tv;
00374   <span class="keyword">struct </span>passwd * pw_struct;
00375 <span class="preprocessor">#define MAX_GRPS  128</span>
00376 <span class="preprocessor"></span>  gid_t   groups_tab[MAX_GRPS];
00377   <span class="keywordtype">int</span>     nb_grp;
00378 
00379   <a class="code" href="structprog__vers__def____.html">prog_vers_def_t</a> * progvers = progvers_rpcs;
00380   
00381   <span class="keywordflow">while</span> ( progvers-&gt;<a class="code" href="structprog__vers__def____.html#o0">name</a> != NULL ) {
00382     <span class="keywordflow">if</span> ( !strcmp( progvers-&gt;<a class="code" href="structprog__vers__def____.html#o0">name</a>, name ) ) {
00383       prog = progvers-&gt;<a class="code" href="structprog__vers__def____.html#o1">prog</a>;
00384       vers = progvers-&gt;<a class="code" href="structprog__vers__def____.html#o2">vers</a>;
00385       <span class="comment">//fprintf(output, "(%s) Prog : %d - Vers : %d - Proto : %s\n", name, prog, vers, proto);</span>
00386       h = gethostbyname(hostname);
00387       <span class="keywordflow">if</span> (h == NULL) {
00388         rpc_createerr.cf_stat = RPC_UNKNOWNHOST;
00389         fprintf(output, <span class="stringliteral">"rpc_init : unknown host %s\n"</span>, hostname);
00390         <span class="keywordflow">return</span> (-1);
00391       }
00392       <span class="keywordflow">if</span> (h-&gt;h_addrtype != AF_INET) {
00393         <span class="comment">/*</span>
00394 <span class="comment">         * Only support INET for now</span>
00395 <span class="comment">         */</span>
00396         rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00397         rpc_createerr.cf_error.re_errno = EAFNOSUPPORT; 
00398         <span class="keywordflow">return</span> (-1);
00399       }
00400       memset(&amp;sin, 0, <span class="keyword">sizeof</span>(sin));
00401 
00402       sin.sin_family = h-&gt;h_addrtype;
00403       sin.sin_port = htons((u_short)port);
00404       memcpy((<span class="keywordtype">char</span>*)&amp;sin.sin_addr, h-&gt;h_addr, h-&gt;h_length);
00405       
00406       p = getprotobyname(proto);
00407       <span class="keywordflow">if</span> (p == NULL) {
00408         fprintf(output, <span class="stringliteral">"rpc_init : protocol %s not found\n"</span>, proto);
00409         <span class="keywordflow">return</span> (-1);
00410       }
00411       sock = RPC_ANYSOCK;
00412       
00413       <span class="keywordflow">switch</span> (p-&gt;p_proto) {
00414         <span class="keywordflow">case</span> IPPROTO_UDP:
00415           clnt_res = clntudp_bufcreate(&amp;sin, prog, vers,
00416                          timeout, &amp;sock, UDPMSGSIZE, UDPMSGSIZE);
00417           <span class="keywordflow">if</span> (clnt_res == NULL) {
00418             fprintf(output, <span class="stringliteral">"rpc_init : Clntudp_bufcreate failed\n"</span>);
00419             <span class="keywordflow">return</span> (-1);
00420           }
00421           <span class="keywordflow">break</span>;
00422         <span class="keywordflow">case</span> IPPROTO_TCP:
00423           clnt_res = clnttcp_create(&amp;sin, prog, vers, &amp;sock, 8800, 8800);
00424           <span class="keywordflow">if</span> (clnt_res == NULL) {
00425             fprintf(output, <span class="stringliteral">"rpc_init : Clnttcp_create failed\n"</span>);
00426             <span class="keywordflow">return</span> (-1);
00427           }
00428           <span class="keywordflow">break</span>;
00429         <span class="keywordflow">default</span>:
00430           rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00431           rpc_createerr.cf_error.re_errno = EPFNOSUPPORT; 
00432           fprintf(output, <span class="stringliteral">"rpc_init : unknown protocol %d (%s)\n"</span>, p-&gt;p_proto, proto);
00433           <span class="keywordflow">return</span> (-1);
00434       }
00435       
00436       <span class="keywordflow">if</span> (<a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a> == NULL) { <span class="comment">// first rpc_init</span>
00437         pw_struct = getpwuid(getuid()); 
00438         <span class="keywordflow">if</span> ( pw_struct == NULL )
00439         {
00440           fprintf(output, <span class="stringliteral">"getpwuid failed\n"</span>);
00441           <span class="keywordflow">return</span> -1;
00442         }
00443         <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a> = (<span class="keyword">struct </span>passwd*)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> passwd));
00444         memcpy(<a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>, pw_struct, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> passwd));
00445       }
00446       nb_grp = <a class="code" href="cmd__tools_8h.html#a25">getugroups</a>( <a class="code" href="commands__Cache__inode_8c.html#a3">MAX_GRPS</a>, groups_tab, <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_name, <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_gid );
00447 
00448       clnt_res-&gt;cl_auth = authunix_create(localmachine, <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_uid, <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_gid, nb_grp, groups_tab);
00449       <span class="keywordflow">if</span> (clnt_res-&gt;cl_auth == NULL) {
00450         fprintf(stdout, <span class="stringliteral">"rpc_init : error during creating Auth\n"</span>);
00451       }
00452 
00453       rc = <a class="code" href="commands__NFS__remote_8c.html#a22">setCLIENT</a>(name, clnt_res);
00454       <span class="keywordflow">if</span> (rc != 0) {
00455         fprintf(output, <span class="stringliteral">"rpc_init : error during setCLIENT\n"</span>);
00456         <span class="keywordflow">return</span> rc;
00457       }
00458       rc = <a class="code" href="commands__NFS__remote_8c.html#a24">setHostname</a>(name, hostname);
00459       <span class="keywordflow">if</span> (rc != 0) {
00460         fprintf(output, <span class="stringliteral">"rpc_init : error during setHostname\n"</span>);
00461         <span class="keywordflow">return</span> rc;
00462       }
00463       rc = <a class="code" href="commands__NFS__remote_8c.html#a26">setProto</a>(name, proto);
00464       <span class="keywordflow">if</span> (rc != 0) {
00465         fprintf(output, <span class="stringliteral">"rpc_init : error during setProto\n"</span>);
00466         <span class="keywordflow">return</span> rc;
00467       }
00468       rc = <a class="code" href="commands__NFS__remote_8c.html#a28">setPort</a>(name, port);
00469       <span class="keywordflow">if</span> (rc != 0) {
00470         fprintf(output, <span class="stringliteral">"rpc_init : error during setPort\n"</span>);
00471         <span class="keywordflow">return</span> rc;
00472       }
00473 
00474       <span class="comment">//fprintf(output, "rpc_init : %s client set (%s)\n", name, proto);</span>
00475       <span class="keywordflow">return</span> 0;
00476     }
00477 
00478     progvers ++ ;
00479   }
00480   
00481   fprintf(output,<span class="stringliteral">"rpc_init : %s: program not found\n"</span>,name);
00482   <span class="keywordflow">return</span> -1;
00483 } <span class="comment">/* rpc_init */</span>
00484 
00485 
<a name="l00487"></a><a class="code" href="commands__NFS__remote_8c.html#a30">00487</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a30">rpc_reinit</a>(<span class="keywordtype">char</span> * name,  <span class="comment">/* IN */</span>
00488                FILE * output <span class="comment">/* IN */</span>
00489     )
00490 {
00491   <span class="keywordtype">int</span> rc;
00492   
00493   <span class="keywordtype">int</span> port;
00494   <span class="keywordtype">char</span> * proto;
00495   <span class="keywordtype">char</span> * hostname;
00496  
00497   hostname = <a class="code" href="commands__NFS__remote_8c.html#a23">getHostname</a>(name);
00498   <span class="keywordflow">if</span> (strlen(hostname) == 0) {
00499     fprintf(output, <span class="stringliteral">"rpc_reinit client %s : getHostname failed\n"</span>, name);
00500     <span class="keywordflow">return</span> -1;
00501   }
00502   proto = <a class="code" href="commands__NFS__remote_8c.html#a25">getProto</a>(name);
00503   <span class="keywordflow">if</span> (strlen(proto) == 0) {
00504     fprintf(output, <span class="stringliteral">"rpc_reinit client %s : getProto failed\n"</span>, name);
00505     <span class="keywordflow">return</span> -1;
00506   }
00507   port = <a class="code" href="commands__NFS__remote_8c.html#a27">getPort</a>(name);
00508 
00509   rc = <a class="code" href="commands__NFS__remote_8c.html#a29">rpc_init</a>(hostname, name, proto, port, output);
00510   <span class="keywordflow">if</span> (rc != 0) {
00511     fprintf(output, <span class="stringliteral">"rpc_reinit failed\n"</span>);
00512     <span class="keywordflow">return</span> -1;
00513   }
00514 
00515   <span class="keywordflow">return</span> rc;
00516 } <span class="comment">/* rpc_reinit */</span>
00517 
00518 
<a name="l00520"></a><a class="code" href="commands__NFS__remote_8c.html#a31">00520</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a31">try_rpc_reinit</a>(<span class="keywordtype">char</span> * name,       <span class="comment">/* IN */</span>
00521                    <span class="keywordtype">int</span>    error,      <span class="comment">/* IN */</span>
00522                    FILE * output      <span class="comment">/* IN */</span>
00523     )
00524 {
00525   <span class="keywordtype">int</span> rc;
00526   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00527 
00528   <span class="keywordflow">for</span> (i=1; i&lt;=MAXIT; i++) {
00529     <span class="keywordflow">if</span> (<a class="code" href="commands__NFS__remote_8c.html#a30">rpc_reinit</a>(name, output) == 0) <span class="keywordflow">break</span>;
00530     <span class="keywordflow">if</span> (i&gt;=MAXIT) {
00531       <span class="keywordflow">return</span> error;
00532     }
00533     sleep(1);
00534   }
00535   <span class="keywordflow">return</span> 0;
00536 } <span class="comment">/* try_rpc_reinit */</span>
00537 
00538 
<a name="l00539"></a><a class="code" href="commands__NFS__remote_8c.html#a32">00539</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(<span class="keywordtype">int</span> result,
00540                   <span class="keywordtype">int</span> i,
00541                   <span class="keywordtype">char</span> * name,
00542                   <span class="keywordtype">char</span> * func_name,
00543                   <span class="keywordtype">char</span> * func_called_name,
00544                   FILE * output
00545     )
00546 {
00547   <span class="keywordtype">int</span> rc = 0;
00548   
00549   <span class="keywordflow">switch</span> (result) {
00550     <span class="keywordflow">case</span> RPC_SUCCESS:
00551       <span class="keywordflow">break</span>;
00552     <span class="keywordflow">case</span> RPC_CANTRECV:
00553     <span class="keywordflow">case</span> RPC_TIMEDOUT:
00554       <span class="keywordflow">if</span> (i &lt; MAXRETRY) {
00555         rc = <a class="code" href="commands__NFS__remote_8c.html#a31">try_rpc_reinit</a>(name, rc, output);
00556         <span class="keywordflow">if</span> (rc == 0) <span class="keywordflow">return</span> -1;
00557       }
00558       <a class="code" href="commands__NFS__remote_8c.html#a22">setCLIENT</a>(name, <a class="code" href="Getopt_8c.html#a0">NULL</a>);
00559     <span class="keywordflow">default</span>:
00560       fprintf(output,<span class="stringliteral">"Error %s (%d) in %s (%s).\n"</span>,clnt_sperrno(result), result, func_called_name, func_name);
00561       <span class="keywordflow">return</span> result;
00562       <span class="keywordflow">break</span>;
00563   }
00564   <span class="keywordflow">return</span> 0;
00565 }
00566 
00567 
00569 <span class="keyword">static</span> <span class="keywordtype">void</span> getopt_init()
00570 {
00571   <span class="comment">/* disables getopt error message */</span>
00572   <a class="code" href="Getopt_8c.html#a3">Opterr</a> = 0;   
00573   <span class="comment">/* reinits getopt processing */</span>
00574   <a class="code" href="Getopt_8c.html#a4">Optind</a> = 1;  
00575 } <span class="comment">/* getopt_init */</span>
00576 
00577 
<a name="l00579"></a><a class="code" href="commands__NFS__remote_8c.html#a34">00579</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a34">fn_rpc_init</a>(     <span class="keywordtype">int</span> argc ,      <span class="comment">/* IN : number of args in argv */</span>
00580                      <span class="keywordtype">char</span> ** argv ,  <span class="comment">/* IN : arg list               */</span>
00581                      FILE * output   <span class="comment">/* IN : output stream          */</span>
00582     )
00583 {
00584   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"h"</span>;
00585   <span class="keywordtype">int</span> flag_h   = 0;  
00586   <span class="keywordtype">int</span> err_flag = 0 ;
00587   <span class="keywordtype">int</span> option ;
00588   <span class="keywordtype">int</span> rc;
00589 
00590   <span class="keywordtype">char</span> * hostname = <span class="stringliteral">""</span>;
00591   <span class="keywordtype">char</span> * name  = <span class="stringliteral">""</span>;
00592   <span class="keywordtype">char</span> * proto = <span class="stringliteral">""</span>;
00593   <span class="keywordtype">int</span> port = 0;
00594 
00595   <span class="keyword">static</span> <span class="keywordtype">char</span> help_rpc_init[]=
00596   <span class="stringliteral">"usage: rpc_init [options] &lt;hostname&gt; &lt;program_version&gt; &lt;protocol&gt; [&lt;port&gt;]\n"</span>
00597   <span class="stringliteral">"&lt;hostname&gt; : name, localhost, machine.mondomaine.com ...\n"</span>
00598   <span class="stringliteral">"&lt;program&gt; : nfs2 / nfs3 / mount1 / mount3\n"</span>
00599   <span class="stringliteral">"&lt;protocol&gt; : udp / tcp\n"</span>
00600   <span class="stringliteral">"options :\n"</span>
00601   <span class="stringliteral">"\t-h print this help\n"</span>;
00602 
00603   <span class="comment">/* analysing options */</span>
00604   getopt_init();
00605   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 ) {   
00606     <span class="keywordflow">switch</span>( option ) {
00607       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00608         <span class="keywordflow">if</span>( flag_h )
00609           fprintf( output, <span class="stringliteral">"rpc_init: warning: option 'h' has been specified more than once.\n"</span>) ;
00610         <span class="keywordflow">else</span> 
00611           flag_h++;
00612         <span class="keywordflow">break</span>;
00613       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
00614         fprintf( output, <span class="stringliteral">"rpc_init: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a> ) ;
00615         err_flag ++;
00616         <span class="keywordflow">break</span>;
00617     } <span class="comment">/* switch */</span>   
00618   } <span class="comment">/* while */</span>
00619   <span class="keywordflow">if</span>( flag_h ) {
00620     fprintf( output, help_rpc_init );
00621     <span class="keywordflow">return</span> 0;
00622   }
00623   
00624   <span class="comment">/* verifies mandatory argument */</span>
00625   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> &gt; ( argc - 3 ) || <a class="code" href="Getopt_8c.html#a4">Optind</a> &lt; ( argc - 4 ) ) {
00626     <span class="comment">/* too much or not enough arguments */</span>
00627     err_flag ++;
00628   }
00629   <span class="keywordflow">else</span> {
00630     hostname = argv[Optind];
00631     name = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
00632     proto = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+2];
00633     port = (argc==<a class="code" href="Getopt_8c.html#a4">Optind</a>+4) ? atoi(argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+3]) : 0;
00634   }
00635   
00636   <span class="keywordflow">if</span>( err_flag ) {
00637     fprintf(output,help_rpc_init);
00638     <span class="keywordflow">return</span> -1;
00639   }
00640   
00641   <span class="comment">/* getting the hostname */</span>
00642   <span class="keywordflow">if</span> (strlen(localmachine) == 0) {
00643     rc = gethostname( localmachine, <span class="keyword">sizeof</span>( localmachine ) );
00644     <span class="keywordflow">if</span>( rc != 0 ) {
00645       fprintf( output, <span class="stringliteral">"rpc_init: Error %d while getting hostname.\n"</span>, rc );
00646       <span class="keywordflow">return</span> -1 ;
00647     }
00648   }
00649   
00650   rc = <a class="code" href="commands__NFS__remote_8c.html#a29">rpc_init</a>(hostname, name, proto, port, output);
00651 
00652   <span class="keywordflow">return</span> rc;
00653 } <span class="comment">/* fn_rpc_init */</span>
00654 
00655 
00656 <span class="comment">/* nfs_remote_layer_SetLogLevel */</span>
<a name="l00657"></a><a class="code" href="commands__NFS__remote_8c.html#a35">00657</a> <span class="keywordtype">void</span> <a class="code" href="commands__NFS__remote_8c.html#a35">nfs_remote_layer_SetLogLevel</a>( <span class="keywordtype">int</span> log_lvl  ){
00658   
00659   <span class="comment">/* Nothing to do. */</span>
00660   <span class="keywordflow">return</span>;
00661   
00662 } <span class="comment">/* nfs_remote_layer_SetLogLevel */</span>
00663 
00664 
<a name="l00666"></a><a class="code" href="commands__NFS__remote_8c.html#a36">00666</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a36">fn_MNT1_remote_command</a>( <span class="keywordtype">int</span> argc ,     <span class="comment">/* IN : number of args in argv */</span>
00667                             <span class="keywordtype">char</span> ** argv , <span class="comment">/* IN : arg list               */</span>
00668                             FILE * output  <span class="comment">/* IN : output stream          */</span>
00669                     )
00670 {
00671   <a class="code" href="structcmdnfsremote__funcdesc____.html">cmdnfsremote_funcdesc_t</a> * funcdesc = mnt1_remote_funcdesc;
00672   
00673   nfs_arg_t nfs_arg;
00674   nfs_res_t nfs_res;
00675   <span class="keywordtype">int</span> rc;
00676   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00677   CLIENT * clnt;
00678       
00679   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a> != NULL )
00680   {
00681     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00682     {
00683       <span class="keywordflow">do</span> {
00684         clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"mount1"</span>);
00685         <span class="keywordflow">if</span> (clnt == NULL) {
00686           fprintf(output, <span class="stringliteral">"MOUNT1 client not initialized\n"</span>);
00687           <span class="keywordflow">return</span> -1;
00688         }
00689         
00690         <span class="comment">/* encoding args */</span>
00691         
00692         <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00693                                     argc - 1, argv + 1,
00694                                     0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00695                                     (caddr_t)&amp;nfs_arg ) == FALSE )
00696         {
00697           fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00698           fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o5">func_help</a>);
00699           <span class="keywordflow">return</span> -1;
00700         }
00701         
00702         <span class="comment">/* nfs call */</span>
00703         
00704         rc = funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o1">func_call</a>(
00705                                     clnt,
00706                                     &amp;nfs_arg,
00707                                     &amp;nfs_res
00708                                  );
00709         rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"mount1"</span>, argv[0], <span class="stringliteral">"fn_MNT1_remote_command"</span>, output);
00710         <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
00711         i += 1;
00712       } <span class="keywordflow">while</span> (rc == -1);
00713 
00714       <span class="comment">/* freeing args */</span>
00715       
00716       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00717                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00718                              (caddr_t)&amp;nfs_arg );
00719 
00720       <span class="comment">/* decoding output */</span>
00721       
00722 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00723 <span class="preprocessor"></span>      printf(<span class="stringliteral">"MNTv1: RETURNED STRUCTURE:\n"</span>);
00724       print_nfs_res( &amp;nfs_res );
00725 <span class="preprocessor">#endif</span>
00726 <span class="preprocessor"></span>      
00727       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00728                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00729                              (caddr_t)&amp;nfs_res );
00730       
00731       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00732       
00733       <span class="comment">/* returning status */</span>
00734       <span class="keywordflow">return</span> rc;
00735       
00736     }
00737     
00738     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00739     funcdesc ++ ;
00740   }
00741   
00742   fprintf(output,<span class="stringliteral">"%s: command not found in MNT1 protocol.\n"</span>,argv[0]);
00743   <span class="keywordflow">return</span> -1;
00744 } <span class="comment">/* fn_MNT1_remote_command */</span>
00745 
00746 
<a name="l00748"></a><a class="code" href="commands__NFS__remote_8c.html#a37">00748</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a37">fn_MNT3_remote_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00749                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00750                             FILE * output      <span class="comment">/* IN : output stream          */</span>
00751          )
00752 {
00753   <a class="code" href="structcmdnfsremote__funcdesc____.html">cmdnfsremote_funcdesc_t</a> * funcdesc = mnt3_remote_funcdesc;
00754   
00755   nfs_arg_t nfs_arg;
00756   nfs_res_t nfs_res;
00757   <span class="keywordtype">int</span> rc;
00758   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00759   CLIENT * clnt;
00760   
00761   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a> != NULL )
00762   {
00763     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00764     {
00765       <span class="keywordflow">do</span> {
00766         clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"mount3"</span>);
00767         <span class="keywordflow">if</span> (clnt == NULL) {
00768           fprintf(output, <span class="stringliteral">"MOUNT3 client not initialized\n"</span>);
00769           <span class="keywordflow">return</span> -1;
00770         }
00771         
00772         <span class="comment">/* encoding args */</span>
00773         
00774         <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00775                                     argc - 1, argv + 1,
00776                                     0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00777                                     (caddr_t)&amp;nfs_arg ) == FALSE )
00778         {
00779           fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00780           fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o5">func_help</a>);
00781           <span class="keywordflow">return</span> -1;
00782         }
00783         
00784         <span class="comment">/* nfs call */</span>
00785         
00786         rc = funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o1">func_call</a>(
00787                                     clnt,
00788                                     &amp;nfs_arg,
00789                                     &amp;nfs_res
00790                                  );
00791         rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"mount3"</span>, argv[0], <span class="stringliteral">"fn_MNT3_remote_command"</span>, output);
00792         <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
00793         i += 1;
00794       } <span class="keywordflow">while</span> (rc == -1);
00795 
00796       <span class="comment">/* freeing args */</span>
00797       
00798       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00799                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00800                              (caddr_t)&amp;nfs_arg );
00801 
00802       <span class="comment">/* decoding output */</span>
00803 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00804 <span class="preprocessor"></span>      printf(<span class="stringliteral">"MNTv3: RETURNED STRUCTURE:\n"</span>);
00805       print_nfs_res( &amp;nfs_res );
00806 <span class="preprocessor">#endif</span>
00807 <span class="preprocessor"></span>      
00808       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00809                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00810                              (caddr_t)&amp;nfs_res );
00811       
00812       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00813 
00814       <span class="comment">/* returning status */</span>
00815       <span class="keywordflow">return</span> rc;
00816       
00817     }
00818     
00819     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00820     funcdesc ++ ;
00821   }
00822   
00823   fprintf(output,<span class="stringliteral">"%s: command not found in MNT3 protocol.\n"</span>,argv[0]);
00824   <span class="keywordflow">return</span> -1;
00825          
00826 } <span class="comment">/* fn_MNT3_remote_command */</span>
00827 
00828 
<a name="l00830"></a><a class="code" href="commands__NFS__remote_8c.html#a38">00830</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a38">fn_NFS2_remote_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00831                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00832                             FILE * output     <span class="comment">/* IN : output stream          */</span>
00833          )
00834 {
00835   <a class="code" href="structcmdnfsremote__funcdesc____.html">cmdnfsremote_funcdesc_t</a> * funcdesc = nfs2_remote_funcdesc;
00836   
00837   nfs_arg_t nfs_arg;
00838   nfs_res_t nfs_res;
00839   <span class="keywordtype">int</span> rc;
00840   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00841   CLIENT * clnt;
00842   
00843   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a> != NULL )
00844   {
00845     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00846     {
00847       <span class="keywordflow">do</span> {
00848         clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs2"</span>);
00849         <span class="keywordflow">if</span> (clnt == NULL) {
00850           fprintf(output, <span class="stringliteral">"NFS2 client not initialized\n"</span>);
00851           <span class="keywordflow">return</span> -1;
00852         }
00853         
00854         <span class="comment">/* encoding args */</span>
00855         
00856         <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00857                                     argc - 1, argv + 1,
00858                                     0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00859                                     (caddr_t)&amp;nfs_arg ) == FALSE )
00860         {
00861           fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00862           fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o5">func_help</a>);
00863           <span class="keywordflow">return</span> -1;
00864         }
00865         
00866         <span class="comment">/* nfs call */</span>
00867         
00868         rc = funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o1">func_call</a>(
00869                                     clnt,
00870                                     &amp;nfs_arg,
00871                                     &amp;nfs_res
00872                                  );
00873         rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs2"</span>, argv[0], <span class="stringliteral">"fn_NFS2_remote_command"</span>, output);
00874         <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
00875         i += 1;
00876       } <span class="keywordflow">while</span> (rc == -1);
00877 
00878       <span class="comment">/* freeing args */</span>
00879       
00880       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00881                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00882                              (caddr_t)&amp;nfs_arg );
00883       
00884 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00885 <span class="preprocessor"></span>      printf(<span class="stringliteral">"NFSv2: RETURNED STRUCTURE:\n"</span>);
00886       print_nfs_res( &amp;nfs_res );
00887 <span class="preprocessor">#endif</span>
00888 <span class="preprocessor"></span>                
00889       <span class="comment">/* decoding output */</span>
00890       
00891       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00892                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00893                              (caddr_t)&amp;nfs_res );
00894       
00895       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00896 
00897       <span class="comment">/* returning status */</span>
00898       <span class="keywordflow">return</span> rc;
00899       
00900     }
00901     
00902     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00903     funcdesc ++ ;
00904   }
00905   
00906   fprintf(output,<span class="stringliteral">"%s: command not found in NFS2 protocol.\n"</span>,argv[0]);
00907   <span class="keywordflow">return</span> -1;
00908          
00909 } <span class="comment">/* fn_NFS2_remote_command */</span>
00910 
00911 
<a name="l00913"></a><a class="code" href="commands__NFS__remote_8c.html#a39">00913</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a39">fn_NFS3_remote_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00914                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00915                             FILE * output     <span class="comment">/* IN : output stream          */</span>
00916          )
00917 {
00918   <a class="code" href="structcmdnfsremote__funcdesc____.html">cmdnfsremote_funcdesc_t</a> * funcdesc = nfs3_remote_funcdesc;
00919   
00920   nfs_arg_t nfs_arg;
00921   nfs_res_t nfs_res;
00922   <span class="keywordtype">int</span> rc;
00923   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00924   CLIENT * clnt;
00925   
00926   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a> != NULL )
00927   {
00928     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00929     {
00930       <span class="keywordflow">do</span> {
00931         clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
00932         <span class="keywordflow">if</span> (clnt == NULL) {
00933           fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
00934           <span class="keywordflow">return</span> -1;
00935         }
00936         
00937         <span class="comment">/* encoding args */</span>
00938         
00939         <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00940                                     argc - 1, argv + 1,
00941                                     0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00942                                     (caddr_t)&amp;nfs_arg ) == FALSE )
00943         {
00944           fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00945           fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o5">func_help</a>);
00946           <span class="keywordflow">return</span> -1;
00947         }
00948         
00949         <span class="comment">/* nfs call */</span>
00950         
00951         rc = funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o1">func_call</a>(
00952                                     clnt,
00953                                     &amp;nfs_arg,
00954                                     &amp;nfs_res
00955                                  );
00956         rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, argv[0], <span class="stringliteral">"fn_NFS3_remote_command"</span>, output);
00957         <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
00958         i += 1;
00959       } <span class="keywordflow">while</span> (rc == -1);
00960 
00961       <span class="comment">/* freeing args */</span>
00962       
00963       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00964                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00965                              (caddr_t)&amp;nfs_arg );
00966       
00967 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00968 <span class="preprocessor"></span>      printf(<span class="stringliteral">"NFSv3: RETURNED STRUCTURE:\n"</span>);
00969       print_nfs_res( &amp;nfs_res );
00970 <span class="preprocessor">#endif</span>
00971 <span class="preprocessor"></span>                
00972       <span class="comment">/* decoding output */</span>
00973       
00974       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00975                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00976                              (caddr_t)&amp;nfs_res );
00977       
00978       funcdesc-&gt;<a class="code" href="structcmdnfsremote__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00979 
00980       <span class="comment">/* returning status */</span>
00981       <span class="keywordflow">return</span> rc;
00982       
00983     }
00984     
00985     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00986     funcdesc ++ ;
00987   }
00988   
00989   fprintf(output,<span class="stringliteral">"%s: command not found in NFS3 protocol.\n"</span>,argv[0]);
00990   <span class="keywordflow">return</span> -1;
00991          
00992 } <span class="comment">/* fn_NFS3_remote_command */</span>
00993 
00994 
00995 <span class="comment">/*------------------------------------------------------------</span>
00996 <span class="comment"> *     Wrapping of NFS calls (used by high level commands)</span>
00997 <span class="comment"> *-----------------------------------------------------------*/</span>
00998 
00999 
01000 <span class="comment">/* solves a relative or aboslute path */</span>
<a name="l01001"></a><a class="code" href="commands__NFS__remote_8c.html#a40">01001</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>(<a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_mounted_path_hdl, <span class="comment">/* IN - handle of mounted path */</span>
01002                          <span class="keywordtype">char</span> * io_global_path,            <span class="comment">/* IN/OUT - global path */</span>
01003                          <span class="keywordtype">int</span> size_global_path,             <span class="comment">/* IN - max size for global path */</span>
01004                          <span class="keywordtype">char</span> * i_spec_path,               <span class="comment">/* IN - specified path */</span>
01005                          <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_current_hdl,      <span class="comment">/* IN - current directory handle */</span>
01006                          <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * pnew_hdl,           <span class="comment">/* OUT - pointer to solved handle */</span>
01007                          FILE * output                     <span class="comment">/* IN */</span>
01008            )
01009 {
01010   <span class="keywordtype">char</span> str_path[NFS2_MAXPATHLEN];
01011   <span class="keywordtype">char</span> * pstr_path = str_path;
01012   
01013   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN] ;
01014   <span class="keywordtype">char</span> * next_name ;
01015   <span class="keywordtype">char</span> * curr ;
01016   <span class="keywordtype">int</span> last=0;
01017   <span class="keywordtype">int</span> rc;
01018   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
01019   CLIENT * clnt;
01020 
01021   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> hdl_lookup ;
01022   nfs_fh3 hdl_param ;
01023   
01024   diropargs3  dirop_arg;
01025   LOOKUP3res  lookup_res;
01026   
01027   strncpy(str_path, i_spec_path ,NFS2_MAXPATHLEN);  
01028   curr = str_path;
01029   next_name = str_path;
01030 
01031   <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'@'</span>)
01032     {
01033       
01034     rc = <a class="code" href="cmd__nfstools_8h.html#a22">cmdnfs_fhandle3</a>(
01035       <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>, 1, &amp;pstr_path,
01036       0,   <a class="code" href="Getopt_8c.html#a0">NULL</a>,
01037       (caddr_t)&amp;hdl_param );
01038         
01039     <span class="keywordflow">if</span> ( rc != TRUE )
01040     {
01041       fprintf( output, <span class="stringliteral">"Invalid FileHandle: %s\n"</span>,str_path );
01042       <span class="keywordflow">return</span> -1;
01043     }
01044     
01045     strncpy( io_global_path, str_path ,size_global_path);
01046     
01047     set_shell_fh3( pnew_hdl , &amp;hdl_param );
01048 
01049     <a class="code" href="cmd__nfstools_8h.html#a22">cmdnfs_fhandle3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, 0,   <a class="code" href="Getopt_8c.html#a0">NULL</a>,
01050                     (caddr_t)&amp;hdl_param );    
01051     
01052     <span class="keywordflow">return</span> 0;        
01053     
01054     }
01055   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'/'</span>)
01056     {
01057       <span class="comment">/* absolute path, starting from "/", with a relative path */</span>
01058       curr ++;
01059       next_name ++;
01060       hdl_lookup =  *p_mounted_path_hdl ;
01061       strncpy(tmp_path, <span class="stringliteral">"/"</span> ,NFS2_MAXPATHLEN);
01062 
01063       <span class="comment">/* the the directory  is /, return */</span>
01064       <span class="keywordflow">if</span> (str_path[1]==<span class="charliteral">'\0'</span>)
01065         {
01066           strncpy(io_global_path,tmp_path,size_global_path);
01067           *pnew_hdl = hdl_lookup ;
01068           <span class="keywordflow">return</span> 0;
01069         }
01070       
01071     } 
01072   <span class="keywordflow">else</span> 
01073     {
01074       hdl_lookup = *p_current_hdl ;
01075       strncpy(tmp_path, io_global_path ,NFS2_MAXPATHLEN);  
01076     }
01077 
01078   <span class="comment">/* Now, the path is a relative path, proceed a step by step lookup */</span>
01079   <span class="keywordflow">do</span> 
01080     {
01081       i = 0;
01082       <span class="comment">/* tokenize to the next '/' */</span>         
01083       <span class="keywordflow">while</span>( ( curr[0] != <span class="charliteral">'\0'</span> ) &amp;&amp;  
01084              ( curr[0] != <span class="charliteral">'/'</span> ) )
01085         curr++;
01086       
01087       <span class="keywordflow">if</span> (!curr[0]) 
01088         last=1; <span class="comment">/* remembers if it was the last dir */</span>
01089       
01090       curr[0]=<span class="charliteral">'\0'</span>;
01091       
01092       <span class="comment">/* build the arguments */</span>
01093       
01094       set_nfs_fh3( &amp;dirop_arg.dir, &amp;hdl_lookup);
01095       dirop_arg.name = next_name;
01096       
01097       <span class="comment">/* lookup this name */</span>
01098       <span class="keywordflow">do</span> {
01099         clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01100         <span class="keywordflow">if</span> (clnt == NULL) {
01101           fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01102           <span class="keywordflow">return</span> -1;
01103         }
01104         
01105         rc = <a class="code" href="group__NFSprocs.html#ga21">nfs3_remote_Lookup</a>(
01106                           clnt,
01107                           (nfs_arg_t*)&amp;dirop_arg,
01108                           (nfs_res_t*)&amp;lookup_res
01109                        );
01110         rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Lookup"</span>, <span class="stringliteral">"nfs_remote_solvepath"</span>, output);
01111         <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01112         i += 1;
01113       } <span class="keywordflow">while</span> (rc == -1);
01114      
01115        rc = lookup_res.status;
01116        <span class="keywordflow">if</span> ( rc != NFS3_OK )
01117        {
01118          <a class="code" href="group__NFSprocs.html#ga75">nfs3_remote_Lookup_Free</a>( (nfs_res_t*)&amp;lookup_res );
01119          fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01120              rc,nfsstat3_to_str(rc));
01121          <span class="keywordflow">return</span> rc;
01122        }
01123       
01124       <span class="comment">/* updates current handle */</span>
01125       set_shell_fh3( &amp;hdl_lookup, &amp;lookup_res.LOOKUP3res_u.resok.object ) ;
01126 
01127       <a class="code" href="group__NFSprocs.html#ga75">nfs3_remote_Lookup_Free</a>( (nfs_res_t*)&amp;lookup_res );
01128          
01129       <span class="comment">/* adds /name at the end of the path */</span>
01130       strncat(tmp_path,<span class="stringliteral">"/"</span>,FSAL_MAX_PATH_LEN);
01131       strncat(tmp_path,next_name,FSAL_MAX_PATH_LEN);
01132 
01133       <span class="comment">/* updates cursors */</span>
01134       <span class="keywordflow">if</span>( !last )
01135       {
01136         curr ++;
01137         next_name = curr ;
01138         <span class="comment">/* ignore successive slashes */</span>
01139         <span class="keywordflow">while</span>((curr[0]!=<span class="charliteral">'\0'</span>) &amp;&amp; (curr[0]==<span class="charliteral">'/'</span>)){
01140           curr++;
01141           next_name = curr;
01142         }
01143         <span class="keywordflow">if</span> (!curr[0]) last=1; <span class="comment">/* it is the last dir */</span>
01144       }
01145     
01146     } <span class="keywordflow">while</span>( !last );
01147     
01148   <span class="comment">/* everything is OK, apply changes */</span>
01149   <a class="code" href="cmd__tools_8h.html#a16">clean_path</a>(tmp_path,size_global_path);
01150   strncpy(io_global_path,tmp_path,size_global_path);
01151     
01152   *pnew_hdl = hdl_lookup ;
01153   <span class="keywordflow">return</span> 0;
01154  
01155 } <span class="comment">/* nfs_remote_solvepath */</span>
01156 
01157 
<a name="l01159"></a><a class="code" href="commands__NFS__remote_8c.html#a41">01159</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a41">nfs_remote_getattr</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl, <span class="comment">/* IN */</span>
01160                         fattr3 * attrs,      <span class="comment">/* OUT */</span>
01161                         FILE * output        <span class="comment">/* IN */</span>
01162            )
01163 {
01164   GETATTR3res res;
01165   <span class="keywordtype">int</span> rc;
01166   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01167   CLIENT * clnt;
01168   
01169   nfs_fh3 nfshdl;
01170   
01171   set_nfs_fh3( &amp;nfshdl , p_hdl );
01172   
01173   <span class="keywordflow">do</span> {
01174     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01175     <span class="keywordflow">if</span> (clnt == NULL) {
01176       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01177       <span class="keywordflow">return</span> -1;
01178     }
01179     
01180     rc = <a class="code" href="group__NFSprocs.html#ga19">nfs3_remote_Getattr</a>(
01181                       clnt,
01182                       (nfs_arg_t*)&amp;nfshdl,
01183                       (nfs_res_t*)&amp;res
01184                    );
01185     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Getattr"</span>, <span class="stringliteral">"nfs_remote_getattr"</span>, output);
01186     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01187     i += 1;
01188   } <span class="keywordflow">while</span> (rc == -1);
01189 
01190   rc = res.status;
01191   <span class="keywordflow">if</span> ( rc != NFS3_OK ) {
01192     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01193        rc,nfsstat3_to_str(rc));
01194    
01195     <a class="code" href="group__NFSprocs.html#ga73">nfs3_remote_Getattr_Free</a>( (nfs_res_t*)&amp;res );
01196     <span class="keywordflow">return</span> rc;
01197   }
01198 
01199   <span class="comment">/* updates current handle */</span>
01200   *attrs = res.GETATTR3res_u.resok.obj_attributes;
01201 
01202   <a class="code" href="group__NFSprocs.html#ga73">nfs3_remote_Getattr_Free</a>( (nfs_res_t*)&amp;res );
01203   
01204   <span class="keywordflow">return</span> 0;
01205 } <span class="comment">/* nfs_remote_getattr */</span>
01206 
01207 
<a name="l01209"></a><a class="code" href="commands__NFS__remote_8c.html#a42">01209</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a42">nfs_remote_access</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl,       <span class="comment">/* IN */</span>
01210                        nfs3_uint32 * access_mask, <span class="comment">/* IN/OUT */</span>
01211                        FILE * output              <span class="comment">/* IN */</span>
01212            )
01213 {
01214   ACCESS3args arg;
01215   ACCESS3res  res ;
01216   <span class="keywordtype">int</span> rc;
01217   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01218   CLIENT * clnt;
01219   
01220   <span class="comment">/* preparing args */</span>
01221   set_nfs_fh3( &amp;arg.object, p_hdl);
01222   arg.access = *access_mask;
01223   
01224   <span class="keywordflow">do</span> {
01225     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01226     <span class="keywordflow">if</span> (clnt == NULL) {
01227       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01228       <span class="keywordflow">return</span> -1;
01229     }
01230     
01231     rc = <a class="code" href="group__NFSprocs.html#ga34">nfs3_remote_Access</a>(
01232                       clnt,
01233                       (nfs_arg_t*)&amp;arg,
01234                       (nfs_res_t*)&amp;res
01235                    );
01236     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Access"</span>, <span class="stringliteral">"nfs_remote_access"</span>, output);
01237     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01238     i += 1;
01239   } <span class="keywordflow">while</span> (rc == -1);
01240 
01241   rc = res.status;
01242   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01243   {
01244     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01245         rc,nfsstat3_to_str(rc));
01246     <a class="code" href="group__NFSprocs.html#ga76">nfs3_remote_Access_Free</a>( (nfs_res_t*)&amp;res );
01247     <span class="keywordflow">return</span> rc;
01248   }
01249 
01250   <span class="comment">/* updates access mask */</span>
01251   *access_mask = res.ACCESS3res_u.resok.access;
01252 
01253   <a class="code" href="group__NFSprocs.html#ga76">nfs3_remote_Access_Free</a>( (nfs_res_t*)&amp;res );
01254   
01255   <span class="keywordflow">return</span> 0;
01256   
01257 } <span class="comment">/* nfs_remote_access */</span>
01258     
01259 
<a name="l01261"></a><a class="code" href="commands__NFS__remote_8c.html#a43">01261</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a43">nfs_remote_readlink</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl, <span class="comment">/* IN */</span>
01262                          <span class="keywordtype">char</span> * linkcontent,  <span class="comment">/* OUT */</span>
01263                          FILE * output        <span class="comment">/* IN */</span>
01264            )
01265 {
01266   READLINK3res res;
01267   <span class="keywordtype">int</span> rc;
01268   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01269   CLIENT * clnt;
01270   
01271   nfs_fh3 nfshdl;
01272   
01273   set_nfs_fh3( &amp;nfshdl, p_hdl );
01274 
01275   <span class="keywordflow">do</span> {
01276     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01277     <span class="keywordflow">if</span> (clnt == NULL) {
01278       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01279       <span class="keywordflow">return</span> -1;
01280     }
01281     
01282     rc = <a class="code" href="group__NFSprocs.html#ga22">nfs3_remote_Readlink</a>(
01283                       clnt,
01284                       (nfs_arg_t*)&amp;nfshdl,
01285                       (nfs_res_t*)&amp;res
01286                    );
01287     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Readlink"</span>, <span class="stringliteral">"nfs_remote_readlink"</span>, output);
01288     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01289     i += 1;
01290   } <span class="keywordflow">while</span> (rc == -1);
01291 
01292   rc = res.status;
01293   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01294   {
01295     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01296         rc,nfsstat3_to_str(rc));
01297     <a class="code" href="group__NFSprocs.html#ga77">nfs3_remote_Readlink_Free</a>( (nfs_res_t*)&amp;res );
01298     <span class="keywordflow">return</span> rc;
01299   }
01300 
01301   <span class="comment">/* copy link content */</span>
01302   strcpy( linkcontent, res.READLINK3res_u.resok.data );
01303   
01304   <a class="code" href="group__NFSprocs.html#ga77">nfs3_remote_Readlink_Free</a>( (nfs_res_t*)&amp;res );
01305   
01306   <span class="keywordflow">return</span> 0;
01307   
01308 } <span class="comment">/* nfs_remote_readlink */</span>
01309 
01310 
<a name="l01312"></a><a class="code" href="commands__NFS__remote_8c.html#a44">01312</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a44">nfs_remote_readdirplus</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl,    <span class="comment">/* IN */</span>
01313                             cookie3 cookie,             <span class="comment">/* IN */</span> 
01314                             cookieverf3 * p_cookieverf, <span class="comment">/* IN/OUT */</span>
01315                             dirlistplus3 * dirlist,     <span class="comment">/* OUT */</span>
01316                             nfs_res_t ** to_be_freed,   <span class="comment">/* OUT */</span>
01317                             FILE * output               <span class="comment">/* IN */</span>
01318            )
01319 {
01320   READDIRPLUS3args arg;
01321   READDIRPLUS3res * p_res;
01322   <span class="keywordtype">int</span> rc;
01323   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01324   CLIENT * clnt;
01325 
01326   *to_be_freed = NULL;
01327     
01328   <span class="comment">/* args */</span>
01329   set_nfs_fh3( &amp;arg.dir, p_dir_hdl );
01330   arg.cookie = cookie;
01331   memcpy ( &amp;arg.cookieverf, p_cookieverf, <span class="keyword">sizeof</span>( cookieverf3 ) );
01332   arg.dircount = 1024;
01333   arg.maxcount = 4096;
01334   
01335   p_res = ( READDIRPLUS3res * ) Mem_Alloc( <span class="keyword">sizeof</span>( READDIRPLUS3res ) );
01336 
01337   <span class="keywordflow">do</span> {
01338     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01339     <span class="keywordflow">if</span> (clnt == NULL) {
01340       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01341       <span class="keywordflow">return</span> -1;
01342     }
01343       
01344     rc = <a class="code" href="group__NFSprocs.html#ga35">nfs3_remote_Readdirplus</a>(
01345                       clnt,
01346                       (nfs_arg_t*)&amp;arg,
01347                       (nfs_res_t*)p_res
01348                    );
01349     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Readdirplus"</span>, <span class="stringliteral">"nfs_remote_readdirplus"</span>, output);
01350     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01351     i += 1;
01352   } <span class="keywordflow">while</span> (rc == -1);
01353 
01354   rc = p_res-&gt;status;
01355   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01356   {
01357     <a class="code" href="group__NFSprocs.html#ga88">nfs3_remote_Readdirplus_Free</a>( (nfs_res_t*)p_res );
01358     Mem_Free( p_res );
01359     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01360         rc,nfsstat3_to_str(rc));
01361     <span class="keywordflow">return</span> rc;
01362   }
01363  
01364   memcpy( p_cookieverf, p_res-&gt;READDIRPLUS3res_u.resok.cookieverf,
01365       <span class="keyword">sizeof</span>( cookieverf3 ) );
01366   
01367   *dirlist = p_res-&gt;READDIRPLUS3res_u.resok.reply;
01368   *to_be_freed = (nfs_res_t*)p_res;
01369   
01370   <span class="keywordflow">return</span> 0;
01371 } <span class="comment">/* nfs_remote_readdirplus */</span>
01372 
01373 
<a name="l01375"></a><a class="code" href="commands__NFS__remote_8c.html#a45">01375</a> <span class="keywordtype">void</span> <a class="code" href="commands__NFS__remote_8c.html#a45">nfs_remote_readdirplus_free</a>( nfs_res_t * to_free )
01376 {
01377   <span class="keywordflow">if</span> ( to_free == NULL ) <span class="keywordflow">return</span>;
01378   
01379   <a class="code" href="group__NFSprocs.html#ga88">nfs3_remote_Readdirplus_Free</a>( (nfs_res_t*)to_free );
01380   Mem_Free( to_free );  
01381 } <span class="comment">/* nfs_remote_readdirplus_free */</span>
01382 
01383 
<a name="l01385"></a><a class="code" href="commands__NFS__remote_8c.html#a46">01385</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a46">nfs_remote_readdir</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl,    <span class="comment">/* IN */</span>
01386                         cookie3 cookie,             <span class="comment">/* IN */</span> 
01387                         cookieverf3 * p_cookieverf, <span class="comment">/* IN/OUT */</span>
01388                         dirlist3 * dirlist,         <span class="comment">/* OUT */</span>
01389                         nfs_res_t ** to_be_freed,   <span class="comment">/* OUT */</span>
01390                         FILE * output               <span class="comment">/* IN */</span>
01391            )
01392 {
01393   READDIR3args arg;
01394   READDIR3res * p_res;
01395   <span class="keywordtype">int</span> rc;
01396   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01397   CLIENT * clnt;
01398 
01399   *to_be_freed = NULL;
01400     
01401   <span class="comment">/* args */</span>
01402   set_nfs_fh3( &amp;arg.dir, p_dir_hdl );
01403   arg.cookie = cookie;
01404   memcpy ( &amp;arg.cookieverf, p_cookieverf, <span class="keyword">sizeof</span>( cookieverf3 ) );
01405   arg.count = 4096;
01406   
01407   p_res = ( READDIR3res * ) Mem_Alloc( <span class="keyword">sizeof</span>( READDIR3res ) );
01408 
01409   <span class="keywordflow">do</span> {
01410     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01411     <span class="keywordflow">if</span> (clnt == NULL) {
01412       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01413       <span class="keywordflow">return</span> -1;
01414     }
01415       
01416     rc = <a class="code" href="group__NFSprocs.html#ga32">nfs3_remote_Readdir</a>(
01417                       clnt,
01418                       (nfs_arg_t*)&amp;arg,
01419                       (nfs_res_t*)p_res
01420                    );
01421     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Readdir"</span>, <span class="stringliteral">"nfs_remote_readdir"</span>, output);
01422     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01423     i += 1;
01424   } <span class="keywordflow">while</span> (rc == -1);
01425 
01426   rc = p_res-&gt;status;
01427   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01428   {
01429     <a class="code" href="group__NFSprocs.html#ga87">nfs3_remote_Readdir_Free</a>( (nfs_res_t*)p_res );
01430     Mem_Free( p_res );
01431     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01432         rc,nfsstat3_to_str(rc));
01433     <span class="keywordflow">return</span> rc;
01434   }
01435  
01436   memcpy( p_cookieverf, p_res-&gt;READDIR3res_u.resok.cookieverf,
01437       <span class="keyword">sizeof</span>( cookieverf3 ) );
01438   
01439   *dirlist = p_res-&gt;READDIR3res_u.resok.reply;
01440   *to_be_freed = (nfs_res_t*)p_res;
01441   
01442   <span class="keywordflow">return</span> 0;
01443 } <span class="comment">/* nfs_remote_readdirplus */</span>
01444 
01445 
<a name="l01447"></a><a class="code" href="commands__NFS__remote_8c.html#a47">01447</a> <span class="keywordtype">void</span> <a class="code" href="commands__NFS__remote_8c.html#a47">nfs_remote_readdir_free</a>( nfs_res_t * to_free )
01448 {
01449   <span class="keywordflow">if</span> ( to_free == NULL ) <span class="keywordflow">return</span>;
01450   
01451   <a class="code" href="group__NFSprocs.html#ga87">nfs3_remote_Readdir_Free</a>( (nfs_res_t*)to_free );
01452   Mem_Free( to_free );  
01453 } <span class="comment">/* nfs_remote_readdir_free */</span>
01454 
01455 
<a name="l01457"></a><a class="code" href="commands__NFS__remote_8c.html#a48">01457</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a48">nfs_remote_create</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="comment">/* IN */</span> 
01458                        <span class="keywordtype">char</span> * obj_name,         <span class="comment">/* IN */</span>
01459                        mode_t posix_mode,       <span class="comment">/* IN */</span>
01460                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl, <span class="comment">/* OUT */</span>
01461                        FILE * output            <span class="comment">/* IN */</span>
01462            )
01463 {
01464   CREATE3args arg;
01465   CREATE3res res;
01466   <span class="keywordtype">int</span> rc;
01467   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01468   CLIENT * clnt;   
01469       
01470   <span class="comment">/* preparing arguments */</span>
01471   
01472   set_nfs_fh3( &amp;arg.where.dir, p_dir_hdl );  
01473   arg.where.name = obj_name;
01474   arg.how.mode = GUARDED;
01475 
01476   <span class="comment">/* empty sattr3 list */</span>
01477   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
01478                  (caddr_t)&amp;(arg.how.createhow3_u.obj_attributes) ) == FALSE )
01479   {
01480     <span class="comment">/* invalid handle */</span>
01481     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
01482     <span class="keywordflow">return</span> -1 ;
01483   }
01484   
01485   <span class="comment">/* only setting mode */</span>
01486   arg.how.createhow3_u.obj_attributes.mode.set_it = TRUE;
01487   arg.how.createhow3_u.obj_attributes.mode.set_mode3_u.mode = posix_mode;
01488   
01489   <span class="keywordflow">do</span> {
01490     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01491     <span class="keywordflow">if</span> (clnt == NULL) {
01492       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01493       <span class="keywordflow">return</span> -1;
01494     }
01495     
01496     rc = <a class="code" href="group__NFSprocs.html#ga25">nfs3_remote_Create</a>(
01497                       clnt,
01498                       (nfs_arg_t*)&amp;arg,
01499                       (nfs_res_t*)&amp;res
01500                    );
01501     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Create"</span>, <span class="stringliteral">"nfs_remote_create"</span>, output);
01502     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01503     i += 1;
01504   } <span class="keywordflow">while</span> (rc == -1);
01505 
01506   rc = res.status;
01507   <span class="keywordflow">if</span> ( rc != NFS3_OK ) {
01508     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01509         rc,nfsstat3_to_str(rc));
01510     <a class="code" href="group__NFSprocs.html#ga79">nfs3_remote_Create_Free</a>( (nfs_res_t*)&amp;res );
01511     <span class="keywordflow">return</span> rc;
01512   }
01513 
01514   <span class="comment">/* object handle */</span>
01515   <span class="keywordflow">if</span> ( res.CREATE3res_u.resok.obj.handle_follows )
01516     set_shell_fh3( p_obj_hdl, &amp;res.CREATE3res_u.resok.obj.post_op_fh3_u.handle );
01517   <span class="keywordflow">else</span> {
01518     fprintf(output,<span class="stringliteral">"Warning: nfs3_remote_Create did not return file handle.\n"</span>);
01519     <a class="code" href="group__NFSprocs.html#ga79">nfs3_remote_Create_Free</a>( (nfs_res_t*)&amp;res );
01520     <span class="keywordflow">return</span> -1;
01521   }
01522     
01523   <a class="code" href="group__NFSprocs.html#ga79">nfs3_remote_Create_Free</a>( (nfs_res_t*)&amp;res );
01524    
01525   <span class="keywordflow">return</span> 0;
01526   
01527 } <span class="comment">/* nfs_remote_create */</span>
01528 
01529 
<a name="l01531"></a><a class="code" href="commands__NFS__remote_8c.html#a49">01531</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a49">nfs_remote_mkdir</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="comment">/* IN */</span>
01532                       <span class="keywordtype">char</span> * obj_name,         <span class="comment">/* IN */</span>
01533                       mode_t posix_mode,       <span class="comment">/* IN */</span>
01534                       <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl, <span class="comment">/* OUT */</span>
01535                       FILE * output            <span class="comment">/* IN */</span>
01536            )
01537 {
01538   MKDIR3args arg;
01539   MKDIR3res res;
01540   <span class="keywordtype">int</span> rc;
01541   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01542   CLIENT * clnt;
01543   
01544   <span class="comment">/* preparing arguments */</span>
01545   
01546   set_nfs_fh3( &amp;arg.where.dir , p_dir_hdl );
01547   arg.where.name = obj_name;
01548 
01549   <span class="comment">/* empty sattr3 list */</span>
01550   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
01551                  (caddr_t)&amp;(arg.attributes) ) == FALSE )
01552   {
01553     <span class="comment">/* invalid handle */</span>
01554     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
01555     <span class="keywordflow">return</span> -1 ;
01556   }
01557   
01558   <span class="comment">/* only setting mode */</span>
01559   arg.attributes.mode.set_it = TRUE;
01560   arg.attributes.mode.set_mode3_u.mode = posix_mode;
01561   
01562   <span class="keywordflow">do</span> {
01563     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01564     <span class="keywordflow">if</span> (clnt == NULL) {
01565       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01566       <span class="keywordflow">return</span> -1;
01567     }
01568     
01569     rc = <a class="code" href="group__NFSprocs.html#ga30">nfs3_remote_Mkdir</a>(
01570                       clnt,
01571                       (nfs_arg_t*)&amp;arg,
01572                       (nfs_res_t*)&amp;res
01573                    );
01574     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Mkdir"</span>, <span class="stringliteral">"nfs_remote_mkdir"</span>, output);
01575     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01576     i += 1;
01577   } <span class="keywordflow">while</span> (rc == -1);
01578 
01579   rc = res.status;
01580   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01581   {
01582     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01583         rc,nfsstat3_to_str(rc));
01584     <a class="code" href="group__NFSprocs.html#ga80">nfs3_remote_Mkdir_Free</a>( (nfs_res_t*)&amp;res );
01585     <span class="keywordflow">return</span> rc;
01586   }
01587 
01588   <span class="comment">/* object handle */</span>
01589   <span class="keywordflow">if</span> ( res.MKDIR3res_u.resok.obj.handle_follows )
01590     set_shell_fh3( p_obj_hdl, &amp;res.MKDIR3res_u.resok.obj.post_op_fh3_u.handle ) ;
01591   <span class="keywordflow">else</span> {
01592     fprintf(output,<span class="stringliteral">"Warning: nfs3_remote_Mkdir did not return file handle.\n"</span>);
01593     <a class="code" href="group__NFSprocs.html#ga80">nfs3_remote_Mkdir_Free</a>( (nfs_res_t*)&amp;res );   
01594     <span class="keywordflow">return</span> -1;
01595   }
01596 
01597   <a class="code" href="group__NFSprocs.html#ga80">nfs3_remote_Mkdir_Free</a>( (nfs_res_t*)&amp;res );   
01598    
01599   <span class="keywordflow">return</span> 0;
01600 } <span class="comment">/*nfs_remote_mkdir*/</span>
01601 
01602 
<a name="l01604"></a><a class="code" href="commands__NFS__remote_8c.html#a50">01604</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a50">nfs_remote_rmdir</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="comment">/* IN */</span> 
01605                       <span class="keywordtype">char</span> * obj_name,         <span class="comment">/* IN */</span>
01606                       FILE * output            <span class="comment">/* IN */</span>
01607            )
01608 {
01609   diropargs3 arg;
01610   RMDIR3res res;
01611   <span class="keywordtype">int</span> rc;
01612   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01613   CLIENT * clnt;
01614   
01615   <span class="comment">/* preparing arguments */</span>
01616   
01617   set_nfs_fh3( &amp;arg.dir, p_dir_hdl );
01618   arg.name = obj_name;
01619     
01620   <span class="keywordflow">do</span> {
01621     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01622     <span class="keywordflow">if</span> (clnt == NULL) {
01623       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01624       <span class="keywordflow">return</span> -1;
01625     }
01626     
01627     rc = <a class="code" href="group__NFSprocs.html#ga31">nfs3_remote_Rmdir</a>(
01628                       clnt,
01629                       (nfs_arg_t*)&amp;arg,
01630                       (nfs_res_t*)&amp;res
01631                    );
01632     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Rmdir"</span>, <span class="stringliteral">"nfs_remote_rmdir"</span>, output);
01633     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01634     i += 1;
01635   } <span class="keywordflow">while</span> (rc == -1);
01636 
01637   rc = res.status;
01638   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01639   {
01640     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01641         rc,nfsstat3_to_str(rc));
01642     <a class="code" href="group__NFSprocs.html#ga84">nfs3_remote_Rmdir_Free</a>( (nfs_res_t*)&amp;res );   
01643     <span class="keywordflow">return</span> rc;
01644   }
01645    
01646   <a class="code" href="group__NFSprocs.html#ga84">nfs3_remote_Rmdir_Free</a>( (nfs_res_t*)&amp;res );   
01647   <span class="keywordflow">return</span> 0;
01648   
01649 } <span class="comment">/* nfs_remote_rmdir */</span>
01650 
01651 
<a name="l01653"></a><a class="code" href="commands__NFS__remote_8c.html#a51">01653</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a51">nfs_remote_remove</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="comment">/* IN */</span> 
01654                        <span class="keywordtype">char</span> * obj_name,         <span class="comment">/* IN */</span>
01655                        FILE * output            <span class="comment">/* IN */</span>
01656            )
01657 {
01658   diropargs3 arg;
01659   REMOVE3res res;
01660   <span class="keywordtype">int</span> rc;
01661   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01662   CLIENT * clnt;
01663   
01664   <span class="comment">/* preparing arguments */</span>
01665   
01666   set_nfs_fh3( &amp;arg.dir, p_dir_hdl);
01667   arg.name = obj_name;
01668 
01669   <span class="keywordflow">do</span> {
01670     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01671     <span class="keywordflow">if</span> (clnt == NULL) {
01672       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01673       <span class="keywordflow">return</span> -1;
01674     }
01675     
01676     rc = <a class="code" href="group__NFSprocs.html#ga26">nfs3_remote_Remove</a>(
01677                       clnt,
01678                       (nfs_arg_t*)&amp;arg,
01679                       (nfs_res_t*)&amp;res
01680                    );
01681     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Remove"</span>, <span class="stringliteral">"nfs_remote_remove"</span>, output);
01682     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01683     i += 1;
01684   } <span class="keywordflow">while</span> (rc == -1);
01685 
01686   rc = res.status;
01687   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01688   {
01689     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01690         rc,nfsstat3_to_str(rc));
01691     <a class="code" href="group__NFSprocs.html#ga83">nfs3_remote_Remove_Free</a>( (nfs_res_t*)&amp;res );
01692     <span class="keywordflow">return</span> rc;
01693   }
01694    
01695   <a class="code" href="group__NFSprocs.html#ga83">nfs3_remote_Remove_Free</a>( (nfs_res_t*)&amp;res );
01696   <span class="keywordflow">return</span> 0;
01697   
01698 } <span class="comment">/* nfs_remote_remove */</span>
01699 
01700 
<a name="l01702"></a><a class="code" href="commands__NFS__remote_8c.html#a52">01702</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a52">nfs_remote_setattr</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl, <span class="comment">/* IN */</span>
01703                         sattr3 * p_attributes,   <span class="comment">/* IN */</span>
01704                         FILE * output            <span class="comment">/* IN */</span>
01705            )
01706 {
01707   SETATTR3args arg;
01708   SETATTR3res res;
01709   <span class="keywordtype">int</span> rc;
01710   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01711   CLIENT * clnt;
01712   
01713   <span class="comment">/* preparing arguments */</span>
01714   
01715   set_nfs_fh3( &amp;arg.object , p_obj_hdl );
01716   arg.new_attributes = *p_attributes;
01717   arg.guard.check = FALSE;
01718   
01719   <span class="keywordflow">do</span> {
01720     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01721     <span class="keywordflow">if</span> (clnt == NULL) {
01722       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01723       <span class="keywordflow">return</span> -1;
01724     }
01725     
01726     rc = <a class="code" href="group__NFSprocs.html#ga20">nfs3_remote_Setattr</a>(
01727                       clnt,
01728                       (nfs_arg_t*)&amp;arg,
01729                       (nfs_res_t*)&amp;res
01730                    );
01731     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Setattr"</span>, <span class="stringliteral">"nfs_remote_setattr"</span>, output);
01732     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01733     i += 1;
01734   } <span class="keywordflow">while</span> (rc == -1);
01735 
01736   rc = res.status;
01737   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01738   {
01739     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01740         rc,nfsstat3_to_str(rc));
01741     <a class="code" href="group__NFSprocs.html#ga74">nfs3_remote_Setattr_Free</a>( (nfs_res_t*)&amp;res );
01742     <span class="keywordflow">return</span> rc;
01743   }
01744 
01745   <a class="code" href="group__NFSprocs.html#ga74">nfs3_remote_Setattr_Free</a>( (nfs_res_t*)&amp;res );
01746   <span class="keywordflow">return</span> 0;
01747   
01748 } <span class="comment">/*nfs_remote_setattr*/</span>
01749 
01750 
<a name="l01752"></a><a class="code" href="commands__NFS__remote_8c.html#a53">01752</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a53">nfs_remote_rename</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_src_dir_hdl, <span class="comment">/* IN */</span> 
01753                        <span class="keywordtype">char</span> * src_name,             <span class="comment">/* IN */</span>
01754                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_tgt_dir_hdl, <span class="comment">/* IN */</span>
01755                        <span class="keywordtype">char</span> * tgt_name,             <span class="comment">/* IN */</span>
01756                        FILE * output                <span class="comment">/* IN */</span>
01757            )
01758 {
01759   RENAME3args arg;
01760   RENAME3res res;
01761   <span class="keywordtype">int</span> rc;
01762   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01763   CLIENT * clnt;
01764   
01765   <span class="comment">/* preparing arguments */</span>
01766   
01767   set_nfs_fh3( &amp;arg.from.dir, p_src_dir_hdl );
01768   arg.from.name = src_name;
01769   set_nfs_fh3( &amp;arg.to.dir, p_tgt_dir_hdl);
01770   arg.to.name = tgt_name;
01771 
01772   <span class="keywordflow">do</span> {
01773     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01774     <span class="keywordflow">if</span> (clnt == NULL) {
01775       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01776       <span class="keywordflow">return</span> -1;
01777     }
01778     
01779     rc = <a class="code" href="group__NFSprocs.html#ga27">nfs3_remote_Rename</a>(
01780                       clnt,
01781                       (nfs_arg_t*)&amp;arg,
01782                       (nfs_res_t*)&amp;res
01783                    );
01784     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Rename"</span>, <span class="stringliteral">"nfs_remote_rename"</span>, output);
01785     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01786     i += 1;
01787   } <span class="keywordflow">while</span> (rc == -1);
01788 
01789   rc = res.status;
01790   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01791   {
01792     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01793         rc,nfsstat3_to_str(rc));
01794     <a class="code" href="group__NFSprocs.html#ga85">nfs3_remote_Rename_Free</a>( (nfs_res_t*)&amp;res );
01795     <span class="keywordflow">return</span> rc;
01796   }
01797 
01798   <a class="code" href="group__NFSprocs.html#ga85">nfs3_remote_Rename_Free</a>( (nfs_res_t*)&amp;res );
01799   <span class="keywordflow">return</span> 0;
01800   
01801 } <span class="comment">/*nfs_remote_rename*/</span>
01802 
01803 
<a name="l01805"></a><a class="code" href="commands__NFS__remote_8c.html#a54">01805</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a54">nfs_remote_link</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_file_hdl,    <span class="comment">/* IN */</span>
01806                      <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_tgt_dir_hdl, <span class="comment">/* IN */</span>
01807                      <span class="keywordtype">char</span> * tgt_name,             <span class="comment">/* IN */</span>
01808                      FILE * output                <span class="comment">/* IN */</span>
01809            )
01810 {
01811   LINK3args arg;
01812   LINK3res res;
01813   <span class="keywordtype">int</span> rc;
01814   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01815   CLIENT * clnt;
01816   
01817   <span class="comment">/* preparing arguments */</span>
01818   
01819   set_nfs_fh3( &amp;arg.file, p_file_hdl );
01820   set_nfs_fh3( &amp;arg.link.dir, p_tgt_dir_hdl );
01821   arg.link.name = tgt_name;
01822 
01823   <span class="keywordflow">do</span> {
01824     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01825     <span class="keywordflow">if</span> (clnt == NULL) {
01826       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01827       <span class="keywordflow">return</span> -1;
01828     }
01829     
01830     rc = <a class="code" href="group__NFSprocs.html#ga28">nfs3_remote_Link</a>(
01831                       clnt,
01832                       (nfs_arg_t*)&amp;arg,
01833                       (nfs_res_t*)&amp;res
01834                   );
01835     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Link"</span>, <span class="stringliteral">"nfs_remote_link"</span>, output);
01836     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01837     i += 1;
01838   } <span class="keywordflow">while</span> (rc == -1);
01839 
01840   rc = res.status;
01841   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01842   {
01843     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01844         rc,nfsstat3_to_str(rc));
01845     <a class="code" href="group__NFSprocs.html#ga86">nfs3_remote_Link_Free</a>( (nfs_res_t*)&amp;res );
01846     <span class="keywordflow">return</span> rc;
01847   }
01848 
01849   <a class="code" href="group__NFSprocs.html#ga86">nfs3_remote_Link_Free</a>( (nfs_res_t*)&amp;res );
01850   <span class="keywordflow">return</span> 0;
01851   
01852 } <span class="comment">/*nfs_remote_link*/</span>
01853 
01854 
<a name="l01856"></a><a class="code" href="commands__NFS__remote_8c.html#a55">01856</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a55">nfs_remote_symlink</a>( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> path_hdl,     <span class="comment">/* IN */</span> 
01857                         <span class="keywordtype">char</span> * link_name,         <span class="comment">/* IN */</span>
01858                         <span class="keywordtype">char</span> * link_content,      <span class="comment">/* IN */</span> 
01859                         sattr3 * p_setattr,       <span class="comment">/* IN */</span>
01860                         <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_link_hdl, <span class="comment">/* OUT */</span>
01861                         FILE * output             <span class="comment">/* IN */</span>
01862            )
01863 {
01864   SYMLINK3args arg;
01865   SYMLINK3res res;
01866   <span class="keywordtype">int</span> rc;
01867   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01868   CLIENT * clnt;
01869   
01870   <span class="comment">/* preparing arguments */</span>
01871   
01872   set_nfs_fh3( &amp;arg.where.dir, &amp;path_hdl );
01873   arg.where.name = link_name;
01874   arg.symlink.symlink_attributes = *p_setattr;
01875   arg.symlink.symlink_data = link_content;
01876 
01877   <span class="keywordflow">do</span> {
01878     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"nfs3"</span>);
01879     <span class="keywordflow">if</span> (clnt == NULL) {
01880       fprintf(output, <span class="stringliteral">"NFS3 client not initialized\n"</span>);
01881       <span class="keywordflow">return</span> -1;
01882     }
01883     
01884     rc = <a class="code" href="group__NFSprocs.html#ga29">nfs3_remote_Symlink</a>(
01885                       clnt,
01886                       (nfs_arg_t*)&amp;arg,
01887                       (nfs_res_t*)&amp;res
01888                   );
01889     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"nfs3"</span>, <span class="stringliteral">"nfs3_remote_Symlink"</span>, <span class="stringliteral">"nfs_remote_symlink"</span>, output);
01890     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01891     i += 1;
01892   } <span class="keywordflow">while</span> (rc == -1);
01893 
01894   rc = res.status;
01895   <span class="keywordflow">if</span> ( rc != NFS3_OK )
01896   {
01897     fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01898         rc,nfsstat3_to_str(rc));
01899     <span class="comment">/* free nfs call resources */</span>
01900     <a class="code" href="group__NFSprocs.html#ga81">nfs3_remote_Symlink_Free</a>( (nfs_res_t*)&amp;res );
01901     <span class="keywordflow">return</span> rc;
01902   }
01903 
01904   <span class="comment">/* returned handle */</span>
01905   <span class="keywordflow">if</span> ( res.SYMLINK3res_u.resok.obj.handle_follows ) {
01906     set_shell_fh3( p_link_hdl , &amp;res.SYMLINK3res_u.resok.obj.post_op_fh3_u.handle ) ;
01907   } <span class="keywordflow">else</span> {
01908     fprintf(output,<span class="stringliteral">"Warning: nfs3_remote_Symlink did not return file handle.\n"</span>);
01909     <a class="code" href="group__NFSprocs.html#ga81">nfs3_remote_Symlink_Free</a>( (nfs_res_t*)&amp;res );
01910     <span class="keywordflow">return</span> -1;
01911   }
01912   
01913   <span class="comment">/* free nfs call resources */</span>
01914   <a class="code" href="group__NFSprocs.html#ga81">nfs3_remote_Symlink_Free</a>( (nfs_res_t*)&amp;res );
01915   
01916   <span class="keywordflow">return</span> 0;
01917   
01918 } <span class="comment">/*nfs_remote_symlink*/</span>
01919 
01920 
<a name="l01922"></a><a class="code" href="commands__NFS__remote_8c.html#a56">01922</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a56">nfs_remote_mount</a>( <span class="keywordtype">char</span> * str_path,         <span class="comment">/* IN */</span>
01923                       <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_mnt_hdl, <span class="comment">/* OUT */</span>
01924                       FILE * output            <span class="comment">/* IN */</span>
01925     )
01926 {
01927   <span class="keywordtype">int</span> rc;
01928   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
01929   nfs_arg_t nfs_arg;
01930   mountres3 res;
01931   CLIENT * clnt;
01932 
01933   rc = <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
01934                        1, &amp;str_path,
01935                        0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
01936                        (caddr_t)&amp;nfs_arg );
01937   <span class="keywordflow">if</span> (rc == FALSE) {
01938     fprintf(output, <span class="stringliteral">"nfs_remote_mount : Error during encoding args\n"</span>);
01939     <span class="keywordflow">return</span> -1;
01940   }
01941   
01942   <span class="keywordflow">do</span> {
01943     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"mount3"</span>);
01944     <span class="keywordflow">if</span> (clnt == NULL) {
01945       fprintf(output, <span class="stringliteral">"MOUNT3 client not initialized\n"</span>);
01946       <span class="keywordflow">return</span> -1;
01947     }
01948       
01949     <span class="comment">/* nfs call */</span>
01950 
01951     rc = <a class="code" href="group__MNTprocs.html#ga7">mnt3_remote_Mnt</a>(
01952                     clnt,
01953                     &amp;nfs_arg,
01954                     (nfs_res_t*)&amp;res
01955                  );
01956     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"mount3"</span>, <span class="stringliteral">"mnt3_remote_Mnt"</span>, <span class="stringliteral">"nfs_remote_mount"</span>, output);
01957     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
01958     i += 1;
01959   } <span class="keywordflow">while</span> (rc == -1);
01960 
01961   <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
01962                    0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
01963                    (caddr_t)&amp;nfs_arg );
01964   
01965   rc = res.fhs_status;
01966   <span class="keywordflow">if</span> ( rc != MNT3_OK )
01967   {
01968     <a class="code" href="group__NFSprocs.html#ga48">mnt3_remote_Mnt_Free</a>( (nfs_res_t*)&amp;res );
01969     fprintf(output, <span class="stringliteral">"nfs_remote_mount: Error %d in MNT3 protocol.\n"</span>,rc);
01970     <span class="keywordflow">return</span> rc;
01971   }
01972 
01973   set_shell_fh3( p_mnt_hdl , (nfs_fh3*)&amp;res.mountres3_u.mountinfo.fhandle ) ;
01974   
01975   <a class="code" href="group__NFSprocs.html#ga48">mnt3_remote_Mnt_Free</a>( (nfs_res_t*)&amp;res );
01976    
01977   <span class="keywordflow">return</span> 0;
01978 } <span class="comment">/* nfs_remote_mount */</span>
01979 
01980 <span class="comment">/*------------------------------------------------------------</span>
01981 <span class="comment"> *          High level, shell-like commands </span>
01982 <span class="comment"> *-----------------------------------------------------------*/</span>
01983 
<a name="l01985"></a><a class="code" href="commands__NFS__remote_8c.html#a57">01985</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a57">fn_nfs_remote_mount</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
01986                   <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
01987                   FILE * output   )   <span class="comment">/* IN : output stream          */</span>
01988 {
01989   <span class="keywordtype">int</span> rc;
01990   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
01991   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> mnt_hdl;
01992 
01993   <span class="comment">/* check if a path has already been mounted */</span>
01994   
01995   <span class="keywordflow">if</span> ( is_mounted_path != FALSE )
01996   {
01997     fprintf( output, <span class="stringliteral">"%s: a path is already mounted. Use \"umount\" command first.\n"</span>,argv[0] );
01998     <span class="keywordflow">return</span> -1 ;
01999   }
02000 
02001   <span class="keywordflow">if</span> (argc - 1 != 1) {
02002     fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
02003     fprintf(output,<span class="stringliteral">"Usage: mount &lt;path&gt;.\n"</span>);
02004     <span class="keywordflow">return</span> -1;
02005   }
02006 
02007   rc = <a class="code" href="commands__NFS__remote_8c.html#a56">nfs_remote_mount</a>(argv[1], &amp;mnt_hdl, output);
02008   <span class="keywordflow">if</span> (rc != 0) <span class="keywordflow">return</span> -1;
02009    
02010   memcpy( &amp;mounted_path_hdl, &amp;mnt_hdl, <span class="keyword">sizeof</span>(<a class="code" href="structshell__fh3____.html">shell_fh3_t</a>));
02011    
02012   strcpy( mounted_path , argv[1] );
02013       
02014   current_path_hdl = mounted_path_hdl;
02015   strcpy( current_path , <span class="stringliteral">"/"</span> );
02016    
02017   is_mounted_path = TRUE;
02018    
02019   fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, current_path );
02020   snprintmem( buff, 2*NFS3_FHSIZE+1,
02021       (caddr_t)current_path_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02022       current_path_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> );
02023   fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02024   
02025   <span class="keywordflow">return</span> 0;
02026 }
02027 
02028 
02029 
<a name="l02031"></a><a class="code" href="commands__NFS__remote_8c.html#a58">02031</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a58">fn_nfs_remote_umount</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
02032                   <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
02033                   FILE * output   )   <span class="comment">/* IN : output stream          */</span>
02034 {
02035   <span class="keywordtype">int</span> rc;
02036   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02037   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> mnt_hdl;
02038   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
02039   nfs_arg_t nfs_arg;
02040   nfs_res_t res;
02041   CLIENT * clnt;
02042 
02043   <span class="comment">/* check if a path has already been mounted */</span>
02044   
02045   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02046   {
02047     fprintf( output, <span class="stringliteral">"%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02048     <span class="keywordflow">return</span> -1 ;
02049   }
02050   
02051       
02052   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
02053                        argc - 1, argv + 1,
02054                        0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
02055                        (caddr_t)&amp;nfs_arg ) == FALSE )
02056   {
02057     fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
02058     fprintf(output,<span class="stringliteral">"Usage: umount &lt;path&gt;.\n"</span>);
02059     <span class="keywordflow">return</span> -1;
02060   }
02061 
02062   <span class="keywordflow">if</span> (strncmp(argv[1], mounted_path, NFS2_MAXPATHLEN)) {
02063     fprintf(output, <span class="stringliteral">"%s: this path is not mounted.\n"</span>, argv[0]);
02064     fprintf(output, <span class="stringliteral">"Current monted path : %s.\n"</span>, mounted_path);
02065     <span class="keywordflow">return</span> -1;
02066   }
02067 
02068   <span class="keywordflow">do</span> {
02069     clnt = <a class="code" href="commands__NFS__remote_8c.html#a21">getCLIENT</a>(<span class="stringliteral">"mount3"</span>);
02070     <span class="keywordflow">if</span> (clnt == NULL) {
02071       fprintf(output, <span class="stringliteral">"MOUNT3 client not initialized\n"</span>);
02072       <span class="keywordflow">return</span> -1;
02073     }
02074       
02075     <span class="comment">/* nfs call */</span>
02076 
02077     rc = <a class="code" href="group__MNTprocs.html#ga7">mnt3_remote_Mnt</a>(
02078                     clnt,
02079                     &amp;nfs_arg,
02080                     (nfs_res_t*)&amp;res
02081                  );
02082     rc = <a class="code" href="commands__NFS__remote_8c.html#a32">switch_result</a>(rc, i, <span class="stringliteral">"mount3"</span>, <span class="stringliteral">"mnt3_remote_Umnt"</span>, <span class="stringliteral">"fn_nfs_remote_umount"</span>, output);
02083     <span class="keywordflow">if</span> (rc &gt; 0) <span class="keywordflow">return</span> rc;
02084     i += 1;
02085   } <span class="keywordflow">while</span> (rc == -1);
02086 
02087   <span class="comment">/* freeing args */</span>
02088       
02089   <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
02090                   0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
02091                   (caddr_t)&amp;nfs_arg );
02092   
02093   <span class="keywordflow">if</span> ( rc != 0 )
02094   {
02095     fprintf(output,<span class="stringliteral">"%s: Error %d in mnt_Umnt.\n"</span>,argv[0],rc);
02096      <span class="keywordflow">return</span> rc;
02097   }
02098    
02099   <a class="code" href="group__NFSprocs.html#ga52">mnt3_remote_Umnt_Free</a>( &amp;res );
02100 
02101   is_mounted_path = FALSE;
02102    
02103   <span class="keywordflow">return</span> 0;
02104 }
02105 
02106 
02107 
<a name="l02109"></a><a class="code" href="commands__NFS__remote_8c.html#a59">02109</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a59">fn_nfs_remote_pwd</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
02110                 <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
02111                 FILE * output   )   <span class="comment">/* IN : output stream          */</span>
02112 {
02113   <span class="keywordtype">int</span> rc;
02114   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02115   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02116   {
02117     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02118     <span class="keywordflow">return</span> -1 ;
02119   }
02120   
02121   fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, current_path ) ;
02122   snprintmem( buff, 2*NFS3_FHSIZE+1,
02123       (caddr_t)current_path_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02124       current_path_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02125   fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02126   
02127   <span class="keywordflow">return</span> 0;  
02128 }
02129 
02130 
<a name="l02132"></a><a class="code" href="commands__NFS__remote_8c.html#a60">02132</a> <span class="keywordtype">int</span>  <a class="code" href="commands__NFS__remote_8c.html#a60">fn_nfs_remote_ls</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02133                 <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02134                 FILE * output )    <span class="comment">/* IN : output stream          */</span>
02135 {
02136 <span class="preprocessor">#define NFS_READDIR_SIZE 10</span>
02137 <span class="preprocessor"></span>  
02138   <span class="keywordtype">char</span> linkdata[NFS2_MAXPATHLEN];
02139   <span class="keywordtype">char</span> item_path[NFS2_MAXPATHLEN];
02140   <span class="keywordtype">char</span> * str_name = <span class="stringliteral">"."</span> ;
02141   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> handle_tmp;
02142   fattr3 attrs;
02143   cookie3 begin_cookie;
02144   bool_t  eod_met;
02145   cookieverf3 cookieverf;
02146   dirlistplus3 dirlist;
02147   entryplus3 * p_entry;
02148   
02149   fattr3 * p_attrs;
02150   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> hdl;
02151   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl = NULL;
02152 
02153   nfs_res_t * to_free = NULL;
02154       
02155   <span class="keywordtype">int</span> rc = 0 ;
02156   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02157 
02158   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvdlSHz"</span>;
02159   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ls[]=<span class="stringliteral">"usage: ls [options] [name|path]\n"</span>
02160     <span class="stringliteral">"options :\n"</span>
02161     <span class="stringliteral">"\t-h print this help\n"</span>
02162     <span class="stringliteral">"\t-v verbose mode\n"</span>
02163     <span class="stringliteral">"\t-d print directory info instead of listing its content\n"</span>      
02164     <span class="stringliteral">"\t-l print standard UNIX attributes\n"</span>
02165     <span class="stringliteral">"\t-S print all supported attributes\n"</span>
02166     <span class="stringliteral">"\t-H print the NFS handle\n"</span> 
02167     <span class="stringliteral">"\t-z silent mode (print nothing)\n"</span> ;
02168   
02169   <span class="keywordtype">int</span> option;
02170   <span class="keywordtype">int</span> flag_v = 0;
02171   <span class="keywordtype">int</span> flag_h = 0;
02172   <span class="keywordtype">int</span> flag_d = 0;
02173   <span class="keywordtype">int</span> flag_l = 0;
02174   <span class="keywordtype">int</span> flag_S = 0;
02175   <span class="keywordtype">int</span> flag_H = 0 ;
02176   <span class="keywordtype">int</span> flag_z = 0 ;
02177   <span class="keywordtype">int</span> err_flag = 0;
02178 
02179   <span class="comment">/* check if a path has been mounted */</span>
02180   
02181   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02182   {
02183     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02184     <span class="keywordflow">return</span> -1 ;
02185   }
02186   
02187     
02188   <span class="comment">/* analysing options */</span>
02189   getopt_init();
02190 
02191   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
02192     {   
02193       <span class="keywordflow">switch</span>( option )
02194         {
02195         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02196           <span class="keywordflow">if</span> (flag_v)
02197             fprintf(output,
02198                     <span class="stringliteral">"ls: warning: option 'v' has been specified more than once.\n"</span>);
02199           <span class="keywordflow">else</span> 
02200             flag_v++;
02201           <span class="keywordflow">break</span>;
02202           
02203         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02204           <span class="keywordflow">if</span> ( flag_h )
02205             fprintf(output,
02206                     <span class="stringliteral">"ls: warning: option 'h' has been specified more than once.\n"</span>);
02207           <span class="keywordflow">else</span> 
02208             flag_h++;
02209           <span class="keywordflow">break</span>;
02210           
02211         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
02212           <span class="keywordflow">if</span> ( flag_d )
02213             fprintf(output,
02214                     <span class="stringliteral">"ls: warning: option 'd' has been specified more than once.\n"</span>);
02215           <span class="keywordflow">else</span> 
02216             flag_d++;
02217           <span class="keywordflow">break</span>;
02218           
02219         <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
02220           <span class="keywordflow">if</span> ( flag_l )
02221             fprintf(output,
02222                     <span class="stringliteral">"ls: warning: option 'l' has been specified more than once.\n"</span>);
02223           <span class="keywordflow">else</span> 
02224             flag_l++;
02225           <span class="keywordflow">break</span>;
02226           
02227         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02228           <span class="keywordflow">if</span> ( flag_S )
02229             fprintf(output,
02230                     <span class="stringliteral">"ls: warning: option 'S' has been specified more than once.\n"</span>);
02231           <span class="keywordflow">else</span> 
02232             flag_S++;
02233           <span class="keywordflow">break</span>;
02234           
02235         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
02236           <span class="keywordflow">if</span> ( flag_z )
02237             fprintf(output,
02238                     <span class="stringliteral">"ls: warning: option 'z' has been specified more than once.\n"</span>);
02239           <span class="keywordflow">else</span> 
02240             flag_z++;
02241           <span class="keywordflow">break</span>;
02242 
02243         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
02244           <span class="keywordflow">if</span>( flag_H )
02245             fprintf(output,
02246                     <span class="stringliteral">"ls: warning: option 'H' has been specified more than once.\n"</span>);
02247           <span class="keywordflow">else</span> 
02248             flag_H++;
02249           <span class="keywordflow">break</span>;
02250           
02251         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02252           fprintf(output,<span class="stringliteral">"ls: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02253           err_flag ++;
02254           <span class="keywordflow">break</span>;
02255         }
02256     } <span class="comment">/* while */</span>
02257   
02258   <span class="keywordflow">if</span>( flag_l + flag_S + flag_H &gt; 1 )
02259     {
02260       fprintf(output,<span class="stringliteral">"ls: conflict between options l,S,H\n"</span>);
02261       err_flag++;
02262     }
02263 
02264   <span class="keywordflow">if</span>( flag_z + flag_v &gt; 1 )
02265     {
02266       fprintf( output, <span class="stringliteral">"ls: can't use -z and -v at the same time\n"</span> ) ;
02267       err_flag ++ ;
02268     }
02269   
02270   <span class="keywordflow">if</span>( flag_h )
02271     {
02272       fprintf(output,help_ls);
02273       <span class="keywordflow">return</span> 0;
02274     }
02275   
02276   <span class="keywordflow">if</span>( err_flag )
02277     {
02278       fprintf(output,help_ls);
02279       <span class="keywordflow">return</span> -1;
02280     }
02281   
02282   <span class="comment">/* copy current global path */</span>
02283   strncpy(glob_path,current_path,NFS2_MAXPATHLEN);
02284 
02285   <span class="comment">/* first, retrieve the argument (if any) */</span>
02286   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> == argc -1  )
02287     { 
02288       str_name = argv[Optind];
02289       
02290       <span class="comment">/* retrieving handle */</span>  
02291       <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl,
02292                                     glob_path,
02293                                     NFS2_MAXPATHLEN,
02294                                     str_name, 
02295                                     &amp;current_path_hdl, 
02296                                     &amp;handle_tmp,
02297                                     output))
02298         <span class="keywordflow">return</span> rc;
02299     } 
02300   <span class="keywordflow">else</span> 
02301     {
02302       str_name = <span class="stringliteral">"."</span>;
02303       handle_tmp = current_path_hdl ;
02304     }
02305   
02306   <span class="keywordflow">if</span>( flag_v )
02307     fprintf(output,<span class="stringliteral">"proceeding ls (using NFS protocol) on \"%s\"\n"</span>, glob_path );
02308   
02309   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a41">nfs_remote_getattr</a>( &amp;handle_tmp, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
02310   
02311  <span class="comment">/*</span>
02312 <span class="comment">  * if the object is a file or a directoy with the -d option specified,</span>
02313 <span class="comment">  * we only show its info and exit.</span>
02314 <span class="comment">  */</span>  
02315   <span class="keywordflow">if</span> ( ( attrs.type != NF3DIR ) || flag_d )
02316     {
02317       <span class="keywordflow">if</span> ( (attrs.type == NF3LNK) &amp;&amp; flag_l )
02318         {
02319             <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a43">nfs_remote_readlink</a>( &amp;handle_tmp, linkdata, output ) )
02320               <span class="keywordflow">return</span> rc;
02321         }
02322       
02323       <span class="keywordflow">if</span>( flag_l )
02324         {
02325           <span class="keywordflow">if</span>( !flag_z )
02326             <a class="code" href="cmd__nfstools_8h.html#a68">print_nfsitem_line</a>( output, &amp;attrs, str_name, linkdata );
02327         }
02328       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_S )
02329         {
02330           <span class="keywordflow">if</span>( !flag_z )
02331             {
02332               fprintf(output,<span class="stringliteral">"%s :\n"</span>,str_name);
02333               <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( &amp;attrs, output );
02334             }
02335         } 
02336       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_H )
02337         {
02338           <span class="keywordflow">if</span>( !flag_z )
02339             {
02340               <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
02341               
02342               snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)handle_tmp.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02343                           handle_tmp.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02344               fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, str_name, buff ) ;
02345             }
02346         }
02347       <span class="keywordflow">else</span>  <span class="comment">/* only prints the name */</span>
02348         {
02349           <span class="keywordflow">if</span>( !flag_z )
02350             fprintf(output,<span class="stringliteral">"%s\n"</span>,str_name);
02351         }
02352         
02353       <span class="keywordflow">return</span> 0;
02354     }
02355   
02356   <span class="comment">/* If this point is reached, then the current element is a directory */</span>
02357   
02358   begin_cookie = 0LL ;
02359   eod_met = FALSE ;
02360   memset( &amp;cookieverf, 0, <span class="keyword">sizeof</span>(cookieverf3) );
02361   
02362   <span class="keywordflow">while</span>( ! eod_met )
02363     {
02364       
02365       <span class="keywordflow">if</span>( flag_v )
02366          fprintf( output, <span class="stringliteral">"--&gt;nfs3_remote_Readdirplus( path=%s, cookie=%llu )\n"</span>,
02367                   glob_path,
02368                   begin_cookie ) ;
02369 
02370       <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a44">nfs_remote_readdirplus</a>( &amp;handle_tmp,
02371                                         begin_cookie,
02372                                         &amp;cookieverf, <span class="comment">/* IN/OUT */</span>
02373                                         &amp;dirlist,
02374                                         &amp;to_free,
02375                                         output ) )
02376         <span class="keywordflow">return</span> rc;
02377 
02378       p_entry = dirlist.entries;
02379       
02380       
02381       <span class="keywordflow">while</span> ( p_entry )
02382         {
02383         <span class="keywordtype">int</span> len;
02384         
02385           <span class="keywordflow">if</span> (!strcmp(str_name,<span class="stringliteral">"."</span>))
02386             strncpy(item_path,p_entry-&gt;name,NFS2_MAXPATHLEN);          
02387           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_name[strlen(str_name)-1] == <span class="charliteral">'/'</span>)
02388             snprintf(item_path,NFS2_MAXPATHLEN,<span class="stringliteral">"%s%s"</span>,str_name,p_entry-&gt;name);
02389           <span class="keywordflow">else</span>
02390             snprintf(item_path,NFS2_MAXPATHLEN,<span class="stringliteral">"%s/%s"</span>,str_name,p_entry-&gt;name);
02391           
02392           <span class="comment">/* interpreting post-op attributes */</span>
02393           
02394           <span class="keywordflow">if</span> ( p_entry-&gt;name_attributes.attributes_follow )
02395             p_attrs = &amp;p_entry-&gt;name_attributes.post_op_attr_u.attributes;
02396           <span class="keywordflow">else</span>
02397             p_attrs = NULL;
02398 
02399           <span class="comment">/* interpreting post-op handle */</span>
02400           
02401           <span class="keywordflow">if</span> ( p_entry-&gt;name_handle.handle_follows )
02402           {
02403             set_shell_fh3( &amp;hdl, &amp;p_entry-&gt;name_handle.post_op_fh3_u.handle );
02404             p_hdl = &amp;hdl;
02405           }
02406           <span class="keywordflow">else</span>
02407             p_hdl = NULL;
02408 
02409 
02410           <span class="keywordflow">if</span>( (p_attrs != NULL)
02411                 &amp;&amp; (p_hdl != NULL)
02412                 &amp;&amp; (p_attrs-&gt;type == NF3LNK ) )
02413             {
02414               <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a43">nfs_remote_readlink</a>( p_hdl, linkdata, output ))
02415                 <span class="keywordflow">return</span> rc;
02416             }
02417           
02418           <span class="keywordflow">if</span>( (p_attrs != NULL) &amp;&amp; flag_l )
02419             {
02420               <a class="code" href="cmd__nfstools_8h.html#a68">print_nfsitem_line</a>( output, p_attrs, item_path, linkdata);
02421             }
02422           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (p_attrs != NULL) &amp;&amp; flag_S )
02423             {
02424               fprintf(output,<span class="stringliteral">"%s :\n"</span>,item_path);
02425               <span class="keywordflow">if</span>( !flag_z )
02426                 <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( p_attrs, output);
02427             }
02428           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (p_hdl != NULL) &amp;&amp; flag_H )
02429             {
02430               <span class="keywordflow">if</span>( !flag_z )
02431                 {
02432                   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
02433 
02434                   snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)p_hdl-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02435                               p_hdl-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02436                   fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, item_path, buff ) ;                  
02437                 }
02438             }
02439           <span class="keywordflow">else</span>
02440             {
02441               <span class="keywordflow">if</span>( !flag_z )
02442                 fprintf(output,<span class="stringliteral">"%s\n"</span>,item_path);
02443             }
02444             
02445           begin_cookie = p_entry-&gt;cookie ;
02446           p_entry = p_entry-&gt;nextentry;
02447         }
02448         
02449       <span class="comment">/* Ready for next iteration */</span>
02450       eod_met = dirlist.eof;
02451       
02452     }
02453   
02454   <a class="code" href="commands__NFS__remote_8c.html#a45">nfs_remote_readdirplus_free</a>( to_free );
02455 
02456   <span class="keywordflow">return</span> 0;
02457 } <span class="comment">/* fn_nfs_remote_ls */</span>
02458 
02459 
02460 
<a name="l02462"></a><a class="code" href="commands__NFS__remote_8c.html#a61">02462</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a61">fn_nfs_remote_cd</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02463         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02464         FILE * output      <span class="comment">/* IN : output stream          */</span>
02465       ){
02466 
02467   
02468   <span class="keyword">static</span> <span class="keywordtype">char</span> help_cd[]=
02469   <span class="stringliteral">"usage: cd &lt;path&gt;\n"</span>;
02470 
02471   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02472   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl;
02473   <span class="keywordtype">int</span> rc;
02474   fattr3 attrs;
02475   nfs3_uint32 mask;
02476     
02477   <span class="comment">/* check if a path has been mounted */</span>
02478   
02479   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02480   {
02481     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02482     <span class="keywordflow">return</span> -1 ;
02483   }
02484   
02485   <span class="comment">/* Exactly one arg expected */</span>
02486   <span class="keywordflow">if</span> (argc!=2){
02487     fprintf(output,help_cd);
02488     <span class="keywordflow">return</span> -1;
02489   }
02490   
02491   strncpy(glob_path, current_path, NFS2_MAXPATHLEN);
02492   
02493   <span class="keywordflow">if</span> (rc = 
02494       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path, NFS2_MAXPATHLEN,
02495                      argv[1],&amp;current_path_hdl,&amp;new_hdl,output))
02496     <span class="keywordflow">return</span> rc;
02497 
02498   <span class="comment">/* verify if the object is a directory */</span>
02499   
02500   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a41">nfs_remote_getattr</a>( &amp;new_hdl, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
02501   
02502   <span class="keywordflow">if</span> (attrs.type != NF3DIR)
02503   {
02504     fprintf(output,<span class="stringliteral">"Error: %s is not a directory\n"</span>,glob_path);
02505     <span class="keywordflow">return</span> ENOTDIR;
02506   }
02507   
02508   <span class="comment">/* verify lookup permission  */</span>  
02509   mask = ACCESS3_LOOKUP;
02510   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a42">nfs_remote_access</a>( &amp;new_hdl, &amp;mask, output ) ) <span class="keywordflow">return</span> rc;
02511   
02512   <span class="keywordflow">if</span> ( ! ( mask &amp; ACCESS3_LOOKUP ) )
02513   {
02514     fprintf(output,<span class="stringliteral">"Error: %s: permission denied.\n"</span>,glob_path);
02515     <span class="keywordflow">return</span> EACCES;
02516   }
02517   
02518   <span class="comment">/* if so, apply changes */</span>
02519   strncpy( current_path, glob_path, NFS2_MAXPATHLEN );   
02520   current_path_hdl = new_hdl;
02521     
02522   {
02523     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02524     fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, current_path ) ;
02525     snprintmem( buff, 2*NFS3_FHSIZE+1,
02526         (caddr_t)current_path_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02527         current_path_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02528     fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02529   }
02530   
02531   <span class="keywordflow">return</span> 0;
02532       
02533 }
02534 
02535 
02536 
<a name="l02538"></a><a class="code" href="commands__NFS__remote_8c.html#a62">02538</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a62">fn_nfs_remote_create</a>(
02539                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02540                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02541                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02542                   )
02543 {
02544   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02545    
02546   <span class="keyword">static</span> <span class="keywordtype">char</span> help_create[]=
02547   <span class="stringliteral">"usage: create [-h][-v] &lt;path&gt; &lt;mode&gt;\n"</span>
02548   <span class="stringliteral">"       path: path of the file to be created\n"</span>
02549   <span class="stringliteral">"       mode: octal mode for the directory to be created (ex: 644)\n"</span> ;
02550 
02551   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02552   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl ;
02553   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
02554   <span class="keywordtype">int</span> rc,option;
02555   <span class="keywordtype">int</span> flag_v=0;
02556   <span class="keywordtype">int</span> flag_h=0;
02557   <span class="keywordtype">int</span> err_flag=0;
02558   <span class="keywordtype">int</span> mode=0644;
02559   
02560   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
02561   <span class="keywordtype">char</span> * path;
02562   <span class="keywordtype">char</span> * file;
02563   <span class="keywordtype">char</span> * strmode;
02564   
02565   <span class="comment">/* check if a path has been mounted */</span>
02566   
02567   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02568   {
02569     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02570     <span class="keywordflow">return</span> -1 ;
02571   }
02572   
02573   <span class="comment">/* analysing options */</span>
02574   getopt_init();
02575   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02576     <span class="keywordflow">switch</span>( option )
02577       {
02578       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02579         <span class="keywordflow">if</span>( flag_v )
02580           fprintf( output, <span class="stringliteral">"create: warning: option 'v' has been specified more than once.\n"</span>);
02581         <span class="keywordflow">else</span> flag_v++;
02582         <span class="keywordflow">break</span>;
02583         
02584       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02585         <span class="keywordflow">if</span>( flag_h )
02586           fprintf( output, <span class="stringliteral">"create: warning: option 'h' has been specified more than once.\n"</span>);
02587         <span class="keywordflow">else</span> flag_h++;
02588         <span class="keywordflow">break</span>;
02589         
02590       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02591         fprintf( output,<span class="stringliteral">"create: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02592         err_flag ++;
02593         <span class="keywordflow">break</span>;
02594     }    
02595   }
02596   
02597   <span class="keywordflow">if</span>( flag_h )
02598     {
02599       fprintf( output, help_create);
02600       <span class="keywordflow">return</span> 0;
02601     }
02602   
02603   <span class="comment">/* Exactly 2 args expected */</span>
02604   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) ) {
02605       err_flag ++;
02606   } <span class="keywordflow">else</span> {
02607     strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
02608     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02609     
02610     strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
02611   
02612     <span class="comment">/* converting mode string to posix mode */</span>
02613     mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );
02614     <span class="keywordflow">if</span>( mode&lt;0 ) err_flag ++;
02615   }
02616     
02617   <span class="keywordflow">if</span>( err_flag ) {
02618     fprintf( output, help_create );
02619     <span class="keywordflow">return</span> -1;
02620   }
02621   
02622   <span class="comment">/* copy current path. */</span>
02623   strncpy( glob_path, current_path, NFS2_MAXPATHLEN );
02624   
02625   <span class="comment">/* retrieves path handle*/</span>
02626   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path, NFS2_MAXPATHLEN,
02627                           path, &amp;current_path_hdl, &amp;subdir_hdl,output) )
02628     <span class="keywordflow">return</span> rc;
02629 
02630   
02631   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a48">nfs_remote_create</a>( &amp;subdir_hdl, file, mode, &amp;new_hdl,output))
02632     <span class="keywordflow">return</span> rc;
02633 
02634   <span class="keywordflow">if</span>( flag_v ) {
02635     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02636     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)new_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02637                 new_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02638     fprintf(output,<span class="stringliteral">"%s/%s successfully created.\n(handle=@%s)\n"</span>,glob_path,file, buff ) ;
02639   }
02640 
02641   <span class="keywordflow">return</span> 0;  
02642 }
02643 
02644 
02645 
<a name="l02647"></a><a class="code" href="commands__NFS__remote_8c.html#a63">02647</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a63">fn_nfs_remote_mkdir</a>(
02648                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02649                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02650                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02651                   )
02652 {
02653   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02654    
02655   <span class="keyword">static</span> <span class="keywordtype">char</span> help_mkdir[]=
02656   <span class="stringliteral">"usage: mkdir [-h][-v] &lt;path&gt; &lt;mode&gt;\n"</span>
02657   <span class="stringliteral">"       path: path of the directory to be created\n"</span>
02658   <span class="stringliteral">"       mode: octal mode for the dir to be created (ex: 755)\n"</span> ;
02659 
02660   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02661   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl ;
02662   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
02663   <span class="keywordtype">int</span> rc,option;
02664   <span class="keywordtype">int</span> flag_v=0;
02665   <span class="keywordtype">int</span> flag_h=0;
02666   <span class="keywordtype">int</span> err_flag=0;
02667   <span class="keywordtype">int</span> mode=0755;
02668   
02669   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
02670   <span class="keywordtype">char</span> * path;
02671   <span class="keywordtype">char</span> * file;
02672   <span class="keywordtype">char</span> * strmode;
02673   
02674   <span class="comment">/* check if a path has been mounted */</span>
02675   
02676   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02677   {
02678     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02679     <span class="keywordflow">return</span> -1 ;
02680   }
02681   
02682   <span class="comment">/* analysing options */</span>
02683   getopt_init();
02684   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02685     <span class="keywordflow">switch</span>( option )
02686       {
02687       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02688         <span class="keywordflow">if</span>( flag_v )
02689           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'v' has been specified more than once.\n"</span>);
02690         <span class="keywordflow">else</span> flag_v++;
02691         <span class="keywordflow">break</span>;
02692         
02693       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02694         <span class="keywordflow">if</span>( flag_h )
02695           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'h' has been specified more than once.\n"</span>);
02696         <span class="keywordflow">else</span> flag_h++;
02697         <span class="keywordflow">break</span>;
02698         
02699       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02700         fprintf( output,<span class="stringliteral">"mkdir: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02701         err_flag ++;
02702         <span class="keywordflow">break</span>;
02703     }    
02704   }
02705   
02706   <span class="keywordflow">if</span>( flag_h )
02707     {
02708       fprintf( output, help_mkdir);
02709       <span class="keywordflow">return</span> 0;
02710     }
02711   
02712   <span class="comment">/* Exactly 2 args expected */</span>
02713   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) ) {
02714     err_flag ++;
02715   } <span class="keywordflow">else</span> {
02716     strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
02717     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02718       
02719     strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
02720   
02721     <span class="comment">/* converting mode string to posix mode */</span>
02722     mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );
02723     <span class="keywordflow">if</span>( mode&lt;0 ) err_flag ++;
02724   }
02725     
02726   <span class="keywordflow">if</span>( err_flag ) {
02727     fprintf( output, help_mkdir );
02728     <span class="keywordflow">return</span> -1;
02729   }
02730   
02731   <span class="comment">/* copy current path. */</span>
02732   strncpy( glob_path, current_path, NFS2_MAXPATHLEN );
02733   
02734   <span class="comment">/* retrieves path handle*/</span>
02735   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path, NFS2_MAXPATHLEN,
02736                           path, &amp;current_path_hdl, &amp;subdir_hdl,output) )
02737     <span class="keywordflow">return</span> rc;
02738 
02739   
02740   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a49">nfs_remote_mkdir</a>( &amp;subdir_hdl, file, mode, &amp;new_hdl,output))
02741     <span class="keywordflow">return</span> rc;
02742       
02743 
02744   <span class="keywordflow">if</span>( flag_v )
02745   {
02746     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02747     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)new_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02748                 new_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02749     fprintf(output,<span class="stringliteral">"%s/%s successfully created.\n(handle=@%s)\n"</span>,glob_path,file, buff ) ;
02750   }
02751 
02752   <span class="keywordflow">return</span> 0;  
02753 
02754 
02755 }
02756 
02757 
<a name="l02759"></a><a class="code" href="commands__NFS__remote_8c.html#a64">02759</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a64">fn_nfs_remote_unlink</a>(
02760                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02761                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02762                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02763                   )
02764 {
02765   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02766    
02767   <span class="keyword">static</span> <span class="keywordtype">char</span> help_unlink[]=
02768   <span class="stringliteral">"usage: unlink [-h][-v] &lt;path&gt;\n"</span>
02769   <span class="stringliteral">"       path: path of the directory to be unlinkd\n"</span>;
02770   
02771   <span class="keywordtype">char</span> glob_path_parent[NFS2_MAXPATHLEN];
02772   <span class="keywordtype">char</span> glob_path_object[NFS2_MAXPATHLEN];
02773   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
02774   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> obj_hdl ; 
02775   fattr3 attrs; 
02776   <span class="keywordtype">int</span> rc,option;
02777   <span class="keywordtype">int</span> flag_v=0;
02778   <span class="keywordtype">int</span> flag_h=0;
02779   <span class="keywordtype">int</span> err_flag=0;
02780   
02781   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
02782   <span class="keywordtype">char</span> * path;
02783   <span class="keywordtype">char</span> * file;
02784   
02785   <span class="comment">/* check if a path has been mounted */</span>
02786   
02787   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02788   {
02789     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02790     <span class="keywordflow">return</span> -1 ;
02791   }
02792   
02793   <span class="comment">/* analysing options */</span>
02794   getopt_init();
02795   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02796     <span class="keywordflow">switch</span>( option )
02797       {
02798       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02799         <span class="keywordflow">if</span>( flag_v )
02800           fprintf( output, <span class="stringliteral">"unlink: warning: option 'v' has been specified more than once.\n"</span>);
02801         <span class="keywordflow">else</span> flag_v++;
02802         <span class="keywordflow">break</span>;
02803         
02804       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02805         <span class="keywordflow">if</span>( flag_h )
02806           fprintf( output, <span class="stringliteral">"unlink: warning: option 'h' has been specified more than once.\n"</span>);
02807         <span class="keywordflow">else</span> flag_h++;
02808         <span class="keywordflow">break</span>;
02809         
02810       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02811         fprintf( output,<span class="stringliteral">"unlink: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02812         err_flag ++;
02813         <span class="keywordflow">break</span>;
02814     }    
02815   }
02816   
02817   <span class="keywordflow">if</span>( flag_h )
02818     {
02819       fprintf( output, help_unlink);
02820       <span class="keywordflow">return</span> 0;
02821     }
02822   
02823   <span class="comment">/* Exactly 1 args expected */</span>
02824   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) )
02825     {
02826       err_flag ++;
02827     }
02828   <span class="keywordflow">else</span> 
02829     {
02830       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
02831       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);      
02832     }
02833   
02834   <span class="comment">/* copy current path. */</span>
02835   strncpy( glob_path_parent, current_path, NFS2_MAXPATHLEN );
02836   
02837   <span class="comment">/* retrieves parent dir handle*/</span>
02838   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path_parent, NFS2_MAXPATHLEN,
02839                           path, &amp;current_path_hdl, &amp;subdir_hdl,output) )
02840     <span class="keywordflow">return</span> rc;
02841 
02842    <span class="comment">/* copy parent path */</span>
02843    strncpy( glob_path_object, glob_path_parent, NFS2_MAXPATHLEN );
02844    
02845    <span class="comment">/* lookup on child object */</span>
02846    <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path_object, NFS2_MAXPATHLEN,
02847                           file, &amp;subdir_hdl, &amp;obj_hdl, output) )
02848     <span class="keywordflow">return</span> rc;
02849     
02850    <span class="comment">/* get attributes of child object */</span>
02851    <span class="keywordflow">if</span>( flag_v )
02852       fprintf(output,<span class="stringliteral">"Getting attributes for %s...\n"</span>,glob_path_object );
02853 
02854    <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a41">nfs_remote_getattr</a>( &amp;obj_hdl, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
02855 
02856     <span class="keywordflow">if</span> ( attrs.type != NF3DIR )
02857     {
02858       <span class="keywordflow">if</span>( flag_v )
02859         fprintf(output,<span class="stringliteral">"%s is not a directory: calling nfs3_remove...\n"</span>,glob_path_object );
02860       
02861       <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a51">nfs_remote_remove</a>( &amp;subdir_hdl, file, output))
02862         <span class="keywordflow">return</span> rc;
02863     }
02864     <span class="keywordflow">else</span>
02865     {
02866       <span class="keywordflow">if</span>( flag_v )
02867         fprintf(output,<span class="stringliteral">"%s is a directory: calling nfs3_rmdir...\n"</span>,glob_path_object );
02868       
02869       <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a50">nfs_remote_rmdir</a>( &amp;subdir_hdl, file, output))
02870         <span class="keywordflow">return</span> rc;     
02871     }  
02872 
02873   <span class="keywordflow">if</span>( flag_v )
02874     fprintf(output,<span class="stringliteral">"%s successfully removed.\n"</span>,glob_path_object );
02875 
02876   <span class="keywordflow">return</span> 0;
02877 
02878 }
02879 
<a name="l02881"></a><a class="code" href="commands__NFS__remote_8c.html#a65">02881</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a65">fn_nfs_remote_setattr</a>( <span class="keywordtype">int</span>     argc ,     <span class="comment">/* IN : number of args in argv */</span>
02882                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02883                             FILE *  output     <span class="comment">/* IN : output stream          */</span> )
02884 {
02885   
02886   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02887    
02888   <span class="keyword">static</span> <span class="keywordtype">char</span> help_setattr[]=
02889     <span class="stringliteral">"usage: setattr [-h][-v] &lt;path&gt; &lt;attr&gt;=&lt;value&gt;,&lt;attr&gt;=&lt;value&gt;,...\n"</span>
02890     <span class="stringliteral">"       where &lt;attr&gt; can be :\n"</span>
02891     <span class="stringliteral">"          mode(octal value),\n"</span>
02892     <span class="stringliteral">"          uid, gid, (unsigned 32 bits integer)\n"</span>
02893     <span class="stringliteral">"          size, (unsigned  64 bits integer)\n"</span>
02894     <span class="stringliteral">"          atime, mtime (format: YYYYMMDDHHMMSS.nnnnnnnnn)\n"</span>;
02895 
02896   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];  <span class="comment">/* absolute path of the object */</span>
02897 
02898   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> obj_hdl ;        <span class="comment">/* handle of the object    */</span>
02899   sattr3  set_attrs;       <span class="comment">/* attributes to be setted */</span>
02900   <span class="keywordtype">char</span> * attr_string;
02901   
02902   <span class="keywordtype">int</span> rc, option;
02903   <span class="keywordtype">int</span> flag_v=0;
02904   <span class="keywordtype">int</span> flag_h=0;
02905   <span class="keywordtype">int</span> err_flag=0;
02906   
02907   <span class="keywordtype">char</span> file[NFS2_MAXPATHLEN]; <span class="comment">/* the relative path to the object */</span>
02908        
02909   <span class="comment">/* check if a path has been mounted */</span>
02910   
02911   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
02912   {
02913     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02914     <span class="keywordflow">return</span> -1 ;
02915   }
02916     
02917   <span class="comment">/* analysing options */</span>
02918   getopt_init() ;
02919   
02920   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format )) != -1 )
02921   {   
02922     <span class="keywordflow">switch</span>( option )
02923       {
02924       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02925         <span class="keywordflow">if</span>( flag_v )
02926           fprintf( output, <span class="stringliteral">"setattr: warning: option 'v' has been specified more than once.\n"</span>);
02927         <span class="keywordflow">else</span> 
02928           flag_v++;
02929         <span class="keywordflow">break</span>;
02930         
02931       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02932         <span class="keywordflow">if</span>( flag_h )
02933           fprintf(output, <span class="stringliteral">"setattr: warning: option 'h' has been specified more than once.\n"</span>);
02934         <span class="keywordflow">else</span> 
02935           flag_h++;
02936         <span class="keywordflow">break</span>;
02937         
02938       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02939         fprintf(output,<span class="stringliteral">"setattr: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02940         err_flag ++;
02941         <span class="keywordflow">break</span>;
02942     }    
02943   }
02944   
02945   <span class="keywordflow">if</span>( flag_h )
02946     {
02947       <span class="comment">/* print usage */</span>
02948       fprintf(output,help_setattr);
02949       <span class="keywordflow">return</span> 0;
02950     }
02951   
02952   <span class="comment">/* Exactly 2 args expected */</span>
02953   
02954   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02955     {
02956       err_flag ++;
02957     } 
02958   <span class="keywordflow">else</span> 
02959     {
02960       strcpy( file,  argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>] ) ;
02961       attr_string = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1]; 
02962     }
02963   
02964   <span class="keywordflow">if</span>( err_flag )
02965     {
02966       fprintf( output, help_setattr );
02967       <span class="keywordflow">return</span> -1;
02968     }
02969   
02970   <span class="comment">/* copy current absolute path to a local variable. */</span>
02971   strncpy( glob_path, current_path, NFS2_MAXPATHLEN);
02972   
02973   <span class="comment">/* retrieve handle to the file whose attributes are to be changed */</span>
02974   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path, NFS2_MAXPATHLEN, file, &amp;current_path_hdl, &amp;obj_hdl, output ) )
02975     <span class="keywordflow">return</span> rc ;
02976     
02977   <span class="comment">/* Convert the peer (attr_name,attr_val) to an sattr3 structure. */</span>
02978   <span class="keywordflow">if</span> ( (rc = <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
02979                            1, &amp;attr_string, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, (caddr_t)&amp;set_attrs ))
02980       == FALSE )
02981     <span class="keywordflow">return</span> rc;
02982 
02983                               
02984   <span class="comment">/* executes set attrs */</span>
02985   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a52">nfs_remote_setattr</a>( &amp;obj_hdl, &amp;set_attrs, output ) ) <span class="keywordflow">return</span> rc;
02986 
02987   <span class="keywordflow">if</span> (flag_v)
02988     fprintf(output,<span class="stringliteral">"Attributes of \"%s\" successfully changed.\n"</span>,glob_path );
02989         
02990   <span class="keywordflow">return</span> 0;  
02991 } <span class="comment">/* fn_nfs_remote_setattr */</span>
02992 
02993 
02994 
<a name="l02996"></a><a class="code" href="commands__NFS__remote_8c.html#a66">02996</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a66">fn_nfs_remote_rename</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02997         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02998         FILE * output      <span class="comment">/* IN : output stream          */</span>
02999       ){
03000   
03001   
03002   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03003    
03004   <span class="keyword">static</span> <span class="keywordtype">char</span> help_rename[]=
03005   <span class="stringliteral">"usage: rename [-h][-v] &lt;src&gt; &lt;dest&gt;\n"</span>;
03006 
03007   <span class="keywordtype">char</span> src_glob_path[NFS2_MAXPATHLEN];
03008   <span class="keywordtype">char</span> tgt_glob_path[NFS2_MAXPATHLEN];
03009   
03010   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> src_path_handle, tgt_path_handle;
03011   
03012   <span class="keywordtype">int</span> rc,option;
03013   <span class="keywordtype">int</span> flag_v=0;
03014   <span class="keywordtype">int</span> flag_h=0;
03015   <span class="keywordtype">int</span> err_flag=0;
03016   
03017   <span class="keywordtype">char</span> tmp_path1[NFS2_MAXPATHLEN];
03018   <span class="keywordtype">char</span> tmp_path2[NFS2_MAXPATHLEN];
03019   <span class="keywordtype">char</span> * src_path;
03020   <span class="keywordtype">char</span> * src_file;
03021   <span class="keywordtype">char</span> * tgt_path;
03022   <span class="keywordtype">char</span> * tgt_file;
03023       
03024   <span class="comment">/* check if a path has been mounted */</span>
03025   
03026   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
03027   {
03028     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03029     <span class="keywordflow">return</span> -1 ;
03030   }
03031   
03032   <span class="comment">/* analysing options */</span>
03033   getopt_init();
03034   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03035     <span class="keywordflow">switch</span>(option){
03036       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03037         <span class="keywordflow">if</span> (flag_v)
03038           fprintf(output,
03039               <span class="stringliteral">"rename: warning: option 'v' has been specified more than once.\n"</span>);
03040         <span class="keywordflow">else</span> flag_v++;
03041         <span class="keywordflow">break</span>;
03042       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03043         <span class="keywordflow">if</span> ( flag_h )
03044           fprintf(output,
03045               <span class="stringliteral">"rename: warning: option 'h' has been specified more than once.\n"</span>);
03046         <span class="keywordflow">else</span> flag_h++;
03047         <span class="keywordflow">break</span>;
03048       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03049         fprintf(output,<span class="stringliteral">"rename: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03050         err_flag ++;
03051         <span class="keywordflow">break</span>;
03052     }    
03053   }
03054   
03055   <span class="keywordflow">if</span> (flag_h){
03056     fprintf(output,help_rename);
03057     <span class="keywordflow">return</span> 0;
03058   }
03059   
03060   <span class="comment">/* Exactly 2 args expected */</span>
03061   <span class="keywordflow">if</span> (<a class="code" href="Getopt_8c.html#a4">Optind</a> != (argc-2)){
03062     err_flag ++;
03063   } <span class="keywordflow">else</span> {
03064     
03065     strncpy(tmp_path1,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>],NFS2_MAXPATHLEN);
03066     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path1,&amp;src_path,&amp;src_file);
03067 
03068     strncpy(tmp_path2,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03069     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path2,&amp;tgt_path,&amp;tgt_file);
03070     
03071   }
03072   
03073   <span class="keywordflow">if</span> (err_flag){
03074     fprintf(output,help_rename);
03075     <span class="keywordflow">return</span> -1;
03076   }
03077   
03078   <span class="keywordflow">if</span> (flag_v)
03079     fprintf(output,<span class="stringliteral">"Renaming %s (dir %s) to %s (dir %s)\n"</span>,
03080         src_file,src_path,tgt_file,tgt_path);
03081   
03082   <span class="comment">/* copy current path. */</span>
03083   strncpy(src_glob_path,current_path,NFS2_MAXPATHLEN);
03084   strncpy(tgt_glob_path,current_path,NFS2_MAXPATHLEN);
03085   
03086   <span class="comment">/* retrieves paths handles */</span>
03087   <span class="keywordflow">if</span> (rc = 
03088       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>(&amp;mounted_path_hdl, src_glob_path,NFS2_MAXPATHLEN,
03089                 src_path, &amp;current_path_hdl,&amp;src_path_handle,output))
03090     <span class="keywordflow">return</span> rc;
03091 
03092   <span class="keywordflow">if</span> (rc = 
03093       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>(&amp;mounted_path_hdl, tgt_glob_path,NFS2_MAXPATHLEN,
03094                 tgt_path, &amp;current_path_hdl,&amp;tgt_path_handle,output))
03095     <span class="keywordflow">return</span> rc;
03096 
03097   
03098   <span class="comment">/* Rename operation */</span>  
03099   
03100   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a53">nfs_remote_rename</a>(
03101     &amp;src_path_handle,      <span class="comment">/* IN */</span>
03102     src_file,              <span class="comment">/* IN */</span>
03103     &amp;tgt_path_handle,      <span class="comment">/* IN */</span>
03104     tgt_file,              <span class="comment">/* IN */</span>
03105     output ) ) <span class="keywordflow">return</span> rc;
03106   
03107 
03108   <span class="keywordflow">if</span> (flag_v)
03109     fprintf( output,<span class="stringliteral">"%s/%s successfully renamed to %s/%s\n"</span>,
03110           src_glob_path, src_file,
03111           tgt_glob_path, tgt_file
03112         );
03113 
03114   <span class="keywordflow">return</span> 0;
03115   
03116 }
03117 
03118 
03119 
03120 
<a name="l03122"></a><a class="code" href="commands__NFS__remote_8c.html#a67">03122</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a67">fn_nfs_remote_hardlink</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03123         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03124         FILE * output      <span class="comment">/* IN : output stream          */</span>
03125       ){
03126   
03127   
03128   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03129    
03130   <span class="keyword">static</span> <span class="keywordtype">char</span> help_hardlink[]=
03131   <span class="stringliteral">"hardlink: create a hard link.\n"</span>
03132   <span class="stringliteral">"usage: hardlink [-h][-v] &lt;target&gt; &lt;new_path&gt;\n"</span>
03133   <span class="stringliteral">"       target: path of an existing file.\n"</span>
03134   <span class="stringliteral">"       new_path: path of the hardlink to be created\n"</span>;
03135 
03136   <span class="keywordtype">char</span> glob_path_target[NFS2_MAXPATHLEN];
03137   <span class="keywordtype">char</span> glob_path_link[NFS2_MAXPATHLEN];
03138   
03139   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> target_hdl, dir_hdl;
03140   
03141   <span class="keywordtype">int</span> rc,option;
03142   <span class="keywordtype">int</span> flag_v=0;
03143   <span class="keywordtype">int</span> flag_h=0;
03144   <span class="keywordtype">int</span> err_flag=0;
03145   
03146   <span class="keywordtype">char</span> * target = NULL;
03147   
03148   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
03149   <span class="keywordtype">char</span> * path;
03150   <span class="keywordtype">char</span> * name;
03151       
03152   <span class="comment">/* check if a path has been mounted */</span>
03153   
03154   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
03155   {
03156     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03157     <span class="keywordflow">return</span> -1 ;
03158   }
03159   
03160   <span class="comment">/* analysing options */</span>
03161   getopt_init();
03162   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03163     <span class="keywordflow">switch</span>(option){
03164       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03165         <span class="keywordflow">if</span> (flag_v)
03166           fprintf(output,
03167               <span class="stringliteral">"hardlink: warning: option 'v' has been specified more than once.\n"</span>);
03168         <span class="keywordflow">else</span> flag_v++;
03169         <span class="keywordflow">break</span>;
03170       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03171         <span class="keywordflow">if</span> ( flag_h )
03172           fprintf(output,
03173               <span class="stringliteral">"hardlink: warning: option 'h' has been specified more than once.\n"</span>);
03174         <span class="keywordflow">else</span> flag_h++;
03175         <span class="keywordflow">break</span>;
03176       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03177         fprintf(output,<span class="stringliteral">"hardlink: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03178         err_flag ++;
03179         <span class="keywordflow">break</span>;
03180     }    
03181   }
03182   
03183   <span class="keywordflow">if</span> (flag_h){
03184     fprintf(output,help_hardlink);
03185     <span class="keywordflow">return</span> 0;
03186   }
03187   
03188   <span class="comment">/* 2 args expected */</span>
03189   
03190   <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == (argc-2) ){
03191     
03192     target = argv[Optind];
03193     
03194     strncpy(tmp_path,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03195     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path,&amp;path,&amp;name);
03196 
03197   } <span class="keywordflow">else</span> {    
03198     err_flag ++;    
03199   }
03200   
03201   
03202   <span class="keywordflow">if</span> (err_flag){
03203     fprintf(output,help_hardlink);
03204     <span class="keywordflow">return</span> -1;
03205   }
03206     
03207   <span class="comment">/* copy current path. */</span>
03208   strncpy(glob_path_target,current_path,NFS2_MAXPATHLEN);
03209   strncpy(glob_path_link,current_path,NFS2_MAXPATHLEN);
03210   
03211   <span class="comment">/* retrieves path handle for target */</span>
03212   <span class="keywordflow">if</span> (rc = 
03213       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>(&amp;mounted_path_hdl, glob_path_target,NFS2_MAXPATHLEN,
03214                 target,&amp;current_path_hdl,&amp;target_hdl,output))
03215     <span class="keywordflow">return</span> rc;
03216 
03217   <span class="comment">/* retrieves path handle for parent dir */</span>
03218   <span class="keywordflow">if</span> (rc = 
03219       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>(&amp;mounted_path_hdl, glob_path_link,NFS2_MAXPATHLEN,
03220                 path,&amp;current_path_hdl,&amp;dir_hdl,output))
03221     <span class="keywordflow">return</span> rc;
03222   
03223   
03224 
03225   rc = <a class="code" href="commands__NFS__remote_8c.html#a54">nfs_remote_link</a>(
03226                  &amp;target_hdl,   <span class="comment">/* IN - target file */</span>
03227                  &amp;dir_hdl,      <span class="comment">/* IN - parent dir handle */</span>
03228                  name,          <span class="comment">/* IN - link name */</span>
03229                  output );      <span class="comment">/* IN */</span>
03230   
03231   <span class="keywordflow">if</span> ( rc ) <span class="keywordflow">return</span> rc;
03232 
03233   <span class="keywordflow">if</span> (flag_v)
03234     fprintf(output,<span class="stringliteral">"%s/%s &lt;=&gt; %s successfully created\n"</span>,path,name,glob_path_target);
03235       
03236   <span class="keywordflow">return</span> 0;
03237   
03238 }
03239 
03240 
03241 
<a name="l03244"></a><a class="code" href="commands__NFS__remote_8c.html#a68">03244</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a68">fn_nfs_remote_ln</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03245         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03246         FILE * output      <span class="comment">/* IN : output stream          */</span>
03247       ){
03248   
03249   
03250   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03251    
03252   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ln[]=
03253   <span class="stringliteral">"ln: create a symbolic link.\n"</span>
03254   <span class="stringliteral">"usage: ln [-h][-v] &lt;link_content&gt; &lt;link_path&gt;\n"</span>
03255   <span class="stringliteral">"       link_content: content of the symbolic link to be created\n"</span>
03256   <span class="stringliteral">"       link_path: path of the symbolic link to be created\n"</span>;
03257 
03258   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
03259   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> path_hdl,link_hdl;
03260   sattr3 set_attrs;
03261   <span class="keywordtype">int</span> rc,option;
03262   <span class="keywordtype">int</span> flag_v=0;
03263   <span class="keywordtype">int</span> flag_h=0;
03264   <span class="keywordtype">int</span> err_flag=0;
03265   
03266   <span class="keywordtype">char</span> * content = NULL;
03267   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
03268   <span class="keywordtype">char</span> * path;
03269   <span class="keywordtype">char</span> * name;
03270     
03271   <span class="comment">/* check if a path has been mounted */</span>
03272   
03273   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
03274   {
03275     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03276     <span class="keywordflow">return</span> -1 ;
03277   }
03278   
03279   <span class="comment">/* analysing options */</span>
03280   getopt_init();
03281   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03282     <span class="keywordflow">switch</span>(option){
03283       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03284         <span class="keywordflow">if</span> (flag_v)
03285           fprintf(output,
03286               <span class="stringliteral">"ln: warning: option 'v' has been specified more than once.\n"</span>);
03287         <span class="keywordflow">else</span> flag_v++;
03288         <span class="keywordflow">break</span>;
03289       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03290         <span class="keywordflow">if</span> ( flag_h )
03291           fprintf(output,
03292               <span class="stringliteral">"ln: warning: option 'h' has been specified more than once.\n"</span>);
03293         <span class="keywordflow">else</span> flag_h++;
03294         <span class="keywordflow">break</span>;
03295       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03296         fprintf(output,<span class="stringliteral">"ln: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03297         err_flag ++;
03298         <span class="keywordflow">break</span>;
03299     }    
03300   }
03301   
03302   <span class="keywordflow">if</span> (flag_h){
03303     fprintf(output,help_ln);
03304     <span class="keywordflow">return</span> 0;
03305   }
03306   
03307   <span class="comment">/* 2 args expected */</span>
03308   
03309   <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == (argc-2) ){
03310     
03311     content = argv[Optind];
03312     
03313     strncpy(tmp_path,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03314     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path,&amp;path,&amp;name);
03315 
03316   } <span class="keywordflow">else</span> {
03317     err_flag ++;
03318   }
03319   
03320   
03321   <span class="keywordflow">if</span> (err_flag){
03322     fprintf(output,help_ln);
03323     <span class="keywordflow">return</span> -1;
03324   }
03325     
03326   <span class="comment">/* copy current path. */</span>
03327   strncpy(glob_path,current_path,NFS2_MAXPATHLEN);
03328   
03329   <span class="comment">/* retrieves path handle*/</span>
03330   <span class="keywordflow">if</span> (rc = 
03331       <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl, glob_path,NFS2_MAXPATHLEN,
03332                      path,&amp;current_path_hdl,&amp;path_hdl,output))
03333     <span class="keywordflow">return</span> rc;
03334 
03335   
03336   <span class="comment">/* Prepare link attributes : empty sattr3 list */</span>
03337   
03338   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
03339                  (caddr_t)&amp;set_attrs ) == FALSE )
03340   {
03341     <span class="comment">/* invalid handle */</span>
03342     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
03343     <span class="keywordflow">return</span> -1 ;
03344   }
03345   
03346   
03347 
03348   rc = <a class="code" href="commands__NFS__remote_8c.html#a55">nfs_remote_symlink</a>(
03349                  path_hdl,   <span class="comment">/* IN - parent dir handle */</span>
03350                  name,       <span class="comment">/* IN - link name */</span>
03351                  content,    <span class="comment">/* IN - link content */</span>
03352                  &amp;set_attrs, <span class="comment">/* Link attributes */</span>
03353                  &amp;link_hdl,  <span class="comment">/* OUT - link handle*/</span>
03354                  output );
03355   
03356   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> rc;
03357   
03358   <span class="keywordflow">if</span> (flag_v)
03359   {
03360     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
03361     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)link_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
03362                 link_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> );
03363   
03364     fprintf(output,<span class="stringliteral">"%s/%s -&gt; %s successfully created (@%s) \n"</span>,path,name,content,buff);
03365   }
03366       
03367   <span class="keywordflow">return</span> 0;  
03368 }
03369 
03370 
03371 
03372 
<a name="l03374"></a><a class="code" href="commands__NFS__remote_8c.html#a69">03374</a> <span class="keywordtype">int</span>  <a class="code" href="commands__NFS__remote_8c.html#a69">fn_nfs_remote_stat</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03375                 <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03376                 FILE * output )    <span class="comment">/* IN : output stream          */</span>
03377 {
03378   
03379   <span class="keywordtype">char</span> item_path[NFS2_MAXPATHLEN];
03380   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> handle_tmp;
03381   fattr3 attrs;
03382   cookie3 begin_cookie;
03383   bool_t  eod_met;
03384   cookieverf3 cookieverf;
03385   dirlistplus3 dirlist;
03386   entryplus3 * p_entry;
03387   
03388   fattr3 * p_attrs;
03389   nfs_fh3 * p_hdl;
03390 
03391       
03392   <span class="keywordtype">int</span> rc = 0 ;
03393   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
03394 
03395   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvHz"</span>;
03396   <span class="keyword">static</span> <span class="keywordtype">char</span> help_stat[]=<span class="stringliteral">"usage: stat [options] &lt;path&gt;\n"</span>
03397     <span class="stringliteral">"options :\n"</span>
03398     <span class="stringliteral">"\t-h print this help\n"</span>
03399     <span class="stringliteral">"\t-v verbose mode\n"</span>
03400     <span class="stringliteral">"\t-H print the NFS handle\n"</span> 
03401     <span class="stringliteral">"\t-z silent mode (print nothing)\n"</span> ;
03402   
03403   <span class="keywordtype">int</span> option;
03404   <span class="keywordtype">char</span> * str_name = NULL;
03405   <span class="keywordtype">int</span> flag_v = 0;
03406   <span class="keywordtype">int</span> flag_h = 0;
03407   <span class="keywordtype">int</span> flag_H = 0 ;
03408   <span class="keywordtype">int</span> flag_z = 0 ;
03409   <span class="keywordtype">int</span> err_flag = 0;
03410 
03411   <span class="comment">/* check if a path has been mounted */</span>
03412   
03413   <span class="keywordflow">if</span> ( is_mounted_path != TRUE )
03414   {
03415     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03416     <span class="keywordflow">return</span> -1 ;
03417   }
03418   
03419     
03420   <span class="comment">/* analysing options */</span>
03421   getopt_init();
03422 
03423   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
03424     {   
03425       <span class="keywordflow">switch</span>( option )
03426         {
03427         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03428           <span class="keywordflow">if</span> (flag_v)
03429             fprintf(output,
03430                     <span class="stringliteral">"stat: warning: option 'v' has been specified more than once.\n"</span>);
03431           <span class="keywordflow">else</span> 
03432             flag_v++;
03433           <span class="keywordflow">break</span>;
03434           
03435         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03436           <span class="keywordflow">if</span> ( flag_h )
03437             fprintf(output,
03438                     <span class="stringliteral">"stat: warning: option 'h' has been specified more than once.\n"</span>);
03439           <span class="keywordflow">else</span> 
03440             flag_h++;
03441           <span class="keywordflow">break</span>;
03442           
03443         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
03444           <span class="keywordflow">if</span> ( flag_z )
03445             fprintf(output,
03446                     <span class="stringliteral">"stat: warning: option 'z' has been specified more than once.\n"</span>);
03447           <span class="keywordflow">else</span> 
03448             flag_z++;
03449           <span class="keywordflow">break</span>;
03450 
03451         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
03452           <span class="keywordflow">if</span>( flag_H )
03453             fprintf(output,
03454                     <span class="stringliteral">"stat: warning: option 'H' has been specified more than once.\n"</span>);
03455           <span class="keywordflow">else</span> 
03456             flag_H++;
03457           <span class="keywordflow">break</span>;
03458           
03459         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03460           fprintf(output,<span class="stringliteral">"stat: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03461           err_flag ++;
03462           <span class="keywordflow">break</span>;
03463         }
03464     } <span class="comment">/* while */</span>
03465   
03466   <span class="keywordflow">if</span>( flag_z + flag_v &gt; 1 )
03467     {
03468       fprintf( output, <span class="stringliteral">"stat: can't use -z and -v at the same time\n"</span> ) ;
03469       err_flag ++ ;
03470     }
03471   
03472   <span class="keywordflow">if</span>( flag_h )
03473     {
03474       fprintf(output,help_stat);
03475       <span class="keywordflow">return</span> 0;
03476     }
03477     
03478   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != argc -1 )
03479     {
03480       fprintf( output, <span class="stringliteral">"stat: Missing argument: &lt;path&gt;\n"</span> ) ;
03481       err_flag ++;
03482     }
03483   <span class="keywordflow">else</span>
03484    {
03485      str_name = argv[Optind];
03486    }
03487   
03488   <span class="keywordflow">if</span>( err_flag )
03489     {
03490       fprintf(output,help_stat);
03491       <span class="keywordflow">return</span> -1;
03492     }
03493   
03494   <span class="comment">/* copy current global path */</span>
03495   strncpy(glob_path,current_path,NFS2_MAXPATHLEN);
03496 
03497   <span class="comment">/* retrieving handle */</span>
03498   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__NFS__remote_8c.html#a40">nfs_remote_solvepath</a>( &amp;mounted_path_hdl,
03499                                  glob_path,
03500                                  NFS2_MAXPATHLEN,
03501                                  str_name, 
03502                                  &amp;current_path_hdl, 
03503                                  &amp;handle_tmp,
03504                                  output))
03505   
03506   <span class="keywordflow">if</span>( flag_v )
03507     fprintf(output,<span class="stringliteral">"proceeding stat (using NFS protocol) on \"%s\"\n"</span>, glob_path );
03508   
03509   <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS__remote_8c.html#a41">nfs_remote_getattr</a>( &amp;handle_tmp, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
03510   
03511   <span class="keywordflow">if</span> ( flag_H )
03512   {
03513     <span class="keywordflow">if</span>( !flag_z )
03514       {
03515         <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
03516 
03517         snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)handle_tmp.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
03518                     handle_tmp.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
03519         fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, str_name, buff ) ;
03520       }
03521   }
03522   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !flag_z )
03523   {
03524     fprintf(output,<span class="stringliteral">"%s :\n"</span>,str_name);
03525     <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( &amp;attrs, output );
03526   }
03527   
03528   <span class="keywordflow">return</span> 0;
03529 } <span class="comment">/* fn_nfs_remote_stat */</span>
03530 
03531 
03532 
03533 
<a name="l03535"></a><a class="code" href="commands__NFS__remote_8c.html#a70">03535</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a70">fn_nfs_remote_su</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03536                <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03537                FILE * output )    <span class="comment">/* IN : output stream          */</span>
03538 {
03539   <span class="keywordtype">int</span> rc, i;
03540   <span class="keywordtype">char</span> * str_uid;
03541   uid_t uid;
03542   fsal_status_t st;
03543   <span class="keyword">struct </span>passwd * pw_struct;
03544   
03545 <span class="preprocessor">#define MAX_GRPS  128</span>
03546 <span class="preprocessor"></span>  gid_t   groups_tab[MAX_GRPS];
03547   <span class="keywordtype">int</span>     nb_grp;
03548 
03549   <span class="keyword">static</span> <span class="keywordtype">char</span> help_su[]=
03550   <span class="stringliteral">"usage: su &lt;uid&gt;\n"</span>;
03551 
03552   <a class="code" href="structprog__vers__client__def____.html">prog_vers_client_def_t</a> * clnts = progvers_clnts;
03553   AUTH * auth;
03554       
03555   <span class="comment">/* UID arg expected */</span>
03556   <span class="keywordflow">if</span> ( argc != 2 )
03557   {
03558     fprintf(output,help_su);
03559     <span class="keywordflow">return</span> -1;
03560   }
03561   <span class="keywordflow">else</span>
03562   {
03563     str_uid = argv[1];
03564   }
03565 
03566   
03567   <span class="keywordflow">if</span> ( isdigit( str_uid[0] ) )
03568   {
03569     <span class="keywordflow">if</span> ( (uid = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>(str_uid)) == (uid_t)-1 )
03570     {
03571       fprintf(output,<span class="stringliteral">"Error: invalid uid \"%s\"\n"</span>,str_uid);
03572       <span class="keywordflow">return</span> -1;
03573     }
03574     pw_struct = getpwuid(uid); 
03575   }
03576   <span class="keywordflow">else</span>
03577   {
03578     pw_struct = getpwnam( str_uid );
03579   }
03580   
03581   <span class="keywordflow">if</span> ( pw_struct == NULL )
03582   {
03583     fprintf( output, <span class="stringliteral">"Unknown user %s\n"</span>, str_uid );
03584     <span class="keywordflow">return</span> errno;
03585   }
03586   
03587   nb_grp = <a class="code" href="cmd__tools_8h.html#a25">getugroups</a>( <a class="code" href="commands__Cache__inode_8c.html#a3">MAX_GRPS</a>, groups_tab, pw_struct-&gt;pw_name, pw_struct-&gt;pw_gid );
03588   
03589   fprintf( output, <span class="stringliteral">"Changing user to : %s ( uid = %d, gid = %d )\n"</span>,
03590        pw_struct-&gt;pw_name , pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid );
03591   
03592   <span class="keywordflow">if</span> ( nb_grp &gt; 1 )
03593   {
03594     fprintf( output, <span class="stringliteral">"altgroups = "</span>);
03595     <span class="keywordflow">for</span> ( i = 1; i &lt; nb_grp; i++ )
03596     {      
03597       <span class="keywordflow">if</span> ( i == 1 )
03598         fprintf( output, <span class="stringliteral">"%d"</span>, groups_tab[i]);
03599       <span class="keywordflow">else</span>
03600         fprintf( output, <span class="stringliteral">", %d"</span>, groups_tab[i]);      
03601     }
03602     fprintf( output, <span class="stringliteral">"\n"</span>);
03603   }
03604 
03605   auth = authunix_create(localmachine, pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid, nb_grp, groups_tab);
03606   <span class="keywordflow">if</span> (auth == NULL) {
03607     fprintf(stdout, <span class="stringliteral">"su %s : error during creating Auth\n"</span>, pw_struct-&gt;pw_name);
03608   }
03609   <span class="keywordflow">while</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o0">name</a> != NULL) {
03610     <span class="keywordflow">if</span> (clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o1">clnt</a> != NULL) {
03611       clnts-&gt;<a class="code" href="structprog__vers__client__def____.html#o1">clnt</a>-&gt;cl_auth = auth;
03612     }
03613     clnts ++;
03614   }
03615   memcpy(<a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>, pw_struct, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> passwd));
03616   
03617   fprintf(output,<span class="stringliteral">"Done.\n"</span>);
03618   
03619   <span class="keywordflow">return</span> 0;
03620   
03621 }
03622 
<a name="l03623"></a><a class="code" href="commands__NFS__remote_8c.html#a71">03623</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS__remote_8c.html#a71">fn_nfs_remote_id</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03624                       <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03625                       FILE * output )    <span class="comment">/* IN : output stream          */</span>
03626 {
03627   fprintf(output, <span class="stringliteral">"Current user : %s ( uid = %d, gid = %d )\n"</span>,
03628        <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_name , <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_uid, <a class="code" href="commands__NFS__remote_8c.html#a12">current_pw</a>-&gt;pw_gid );
03629 
03630   <span class="keywordflow">return</span> 0;
03631 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:35 2008 for ganeshell by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
