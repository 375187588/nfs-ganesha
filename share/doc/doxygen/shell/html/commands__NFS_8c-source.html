<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ganeshell: commands_NFS.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>commands_NFS.c</h1><a href="commands__NFS_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00189 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00191 <span class="preprocessor">#endif</span>
00192 <span class="preprocessor"></span>
00193 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00195 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00196 <span class="preprocessor">#include &lt;gssrpc/svc.h&gt;</span>
00197 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00198 <span class="preprocessor">#else</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00200 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00201 <span class="preprocessor">#include &lt;rpc/svc.h&gt;</span>
00202 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#include "fsal.h"</span>
00205 <span class="preprocessor">#include "cache_inode.h"</span>
00206 <span class="preprocessor">#include "cache_content.h"</span>
00207 <span class="preprocessor">#include "<a class="code" href="commands_8h.html">commands.h</a>"</span>
00208 <span class="preprocessor">#include "stuff_alloc.h"</span>
00209 <span class="preprocessor">#include "<a class="code" href="Getopt_8h.html">Getopt.h</a>"</span>
00210 <span class="preprocessor">#include "<a class="code" href="cmd__nfstools_8h.html">cmd_nfstools.h</a>"</span>
00211 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00212 <span class="preprocessor">#include "nfs_file_handle.h"</span>
00213 <span class="preprocessor">#include "nfs_core.h"</span>
00214 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00215 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00216 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00217 <span class="preprocessor">#include &lt;string.h&gt;</span>
00218 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00219 
<a name="l00220"></a><a class="code" href="commands__NFS_8c.html#a2">00220</a> nfs_parameter_t      nfs_param ;
00221 
00222 <span class="comment">/* Function used for debugging */</span>
00223 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00224 <span class="preprocessor"></span><span class="keywordtype">void</span> print_nfs_res( nfs_res_t * p_res )
00225 {
00226   <span class="keywordtype">int</span> index;
00227   <span class="keywordflow">for</span> ( index = 0; index &lt; <span class="keyword">sizeof</span>(nfs_res_t); index++ )
00228   {
00229     <span class="keywordflow">if</span> ( (index+1)%32 == 0 )
00230       printf(<span class="stringliteral">"%02X\n"</span>,((<span class="keywordtype">char</span>*)p_res)[index]);
00231     <span class="keywordflow">else</span>
00232       printf(<span class="stringliteral">"%02X."</span>,((<span class="keywordtype">char</span>*)p_res)[index]);
00233   }
00234   printf(<span class="stringliteral">"\n"</span>);
00235 }
00236 <span class="preprocessor">#endif</span>
00237 <span class="preprocessor"></span>
00238 <span class="comment">/* --------------- INTERNAL FH3 REPRESENTATION ---------------- */</span>
00239 <span class="comment">/* used for keeping handle value after</span>
00240 <span class="comment"> * freeing nfs res.</span>
00241 <span class="comment"> */</span>
<a name="l00242"></a><a class="code" href="structshell__fh3____.html">00242</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structshell__fh3____.html">shell_fh3__</a>
00243 {
00244   u_int data_len;
00245   <span class="keywordtype">char</span>  data_val[NFS3_FHSIZE];
00246 } <a class="code" href="structshell__fh3____.html">shell_fh3_t</a>;
00247 
00248 <span class="keyword">static</span> <span class="keywordtype">void</span> set_shell_fh3( <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_int_fh3, nfs_fh3 * p_nfshdl)
00249 {
00250   p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> = p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a>;
00251   memcpy( p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a>, p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o1">data_val</a>, p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a> );
00252 } 
00253 
00254 <span class="keyword">static</span> <span class="keywordtype">void</span> set_nfs_fh3( nfs_fh3 * p_nfshdl, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_int_fh3 )
00255 {
00256   p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o0">data_len</a> = p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> ;
00257   p_nfshdl-&gt;data.<a class="code" href="structshell__fh3____.html#o1">data_val</a> = p_int_fh3-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a>;
00258 } 
00259 <span class="comment">/* ------------------------- END ------------------------------ */</span>
00260 
00261 
00262 
00263 <span class="comment">/* The cache hash table (defined in "commands_Cache_inode.c") */</span>
00264 <span class="keyword">extern</span>  hash_table_t * ht ;
00265 
00266 <span class="keyword">extern</span> cache_inode_client_parameter_t cache_client_param;
00267 <span class="keyword">extern</span> cache_content_client_parameter_t datacache_client_param;
00268 
00269 <span class="comment">/* NFS layer initialization status*/</span>
00270 <span class="keyword">static</span> <span class="keywordtype">int</span> is_nfs_layer_initialized = FALSE;
00271 
00272 <span class="comment">/* Global variable: export list */</span>
<a name="l00273"></a><a class="code" href="commands__NFS_8c.html#a8">00273</a> exportlist_t  <a class="code" href="commands__NFS_8c.html#a8">exportlist</a>[128];
<a name="l00274"></a><a class="code" href="commands__NFS_8c.html#a9">00274</a> exportlist_t  * <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a> = exportlist ;
00275 
00276 <span class="comment">/* Global variable: local host name */</span>
00277 <span class="keyword">static</span> <span class="keywordtype">char</span> localmachine[256];
00278 
00279 <span class="comment">/* thread specific variables */</span>
00280 
<a name="l00281"></a><a class="code" href="structcmdnfs__thr__info____.html">00281</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info__</a>
00282 {
00283 
<a name="l00284"></a><a class="code" href="structcmdnfs__thr__info____.html#o0">00284</a>   <span class="keywordtype">int</span> is_thread_init;
00285 
00286   <span class="comment">/* export context : on for each thread,</span>
00287 <span class="comment">   * on order to make it possible for them</span>
00288 <span class="comment">   * to access different filesets.</span>
00289 <span class="comment">   */</span>
<a name="l00290"></a><a class="code" href="structcmdnfs__thr__info____.html#o1">00290</a>   fsal_export_context_t exp_context;
00291 
<a name="l00293"></a><a class="code" href="structcmdnfs__thr__info____.html#o2">00293</a>   fsal_op_context_t context ;
00294 
00295   <span class="comment">/* AuthUnix_params for this thread */</span>
<a name="l00296"></a><a class="code" href="structcmdnfs__thr__info____.html#o3">00296</a>   <span class="keyword">struct </span>authunix_parms authunix_struct;
00297 
<a name="l00299"></a><a class="code" href="structcmdnfs__thr__info____.html#o4">00299</a>   cache_inode_client_t client ;
<a name="l00300"></a><a class="code" href="structcmdnfs__thr__info____.html#o5">00300</a>   cache_content_client_t dc_client ;
00301   
00302   
00303   <span class="comment">/* info for advanced commands (pwd, ls, cd, ...) */</span>
<a name="l00304"></a><a class="code" href="structcmdnfs__thr__info____.html#o6">00304</a>   <span class="keywordtype">int</span> is_mounted_path;
00305   
<a name="l00306"></a><a class="code" href="structcmdnfs__thr__info____.html#o7">00306</a>   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> mounted_path_hdl;
<a name="l00307"></a><a class="code" href="structcmdnfs__thr__info____.html#o8">00307</a>   <span class="keywordtype">char</span> mounted_path[NFS2_MAXPATHLEN];
00308       
<a name="l00309"></a><a class="code" href="structcmdnfs__thr__info____.html#o9">00309</a>   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> current_path_hdl;
<a name="l00310"></a><a class="code" href="structcmdnfs__thr__info____.html#o10">00310</a>   <span class="keywordtype">char</span> current_path[NFS2_MAXPATHLEN];
00311   
00312 } <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a>;
00313 
00314 
00315 <span class="comment">/* pthread key to manage thread specific configuration */</span>
00316 
00317 <span class="keyword">static</span> pthread_key_t  thread_key ;
00318 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00319 
00320 
00321 <span class="comment">/* init pthtread_key for current thread */</span>
00322 
00323 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00324 {
00325   <span class="keywordflow">if</span>( pthread_key_create( &amp;thread_key, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) == -1 )
00326     printf( <span class="stringliteral">"Error %d creating pthread key for thread %p : %s\n"</span>,
00327         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00328   
00329   return ;
00330 } <span class="comment">/* init_keys */</span>
00331 
00332 
00333 
00334 
00335 
00336 
<a name="l00337"></a><a class="code" href="commands__NFS_8c.html#a17">00337</a> <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>()
00338 {
00339   
00340   
00341   <span class="keywordtype">int</span> i;
00342   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info ;
00343   
00344   <span class="comment">/* first, we init the keys if this is the first time */</span>
00345   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00346     printf( <span class="stringliteral">"Error %d calling pthread_once for thread %p : %s\n"</span>,
00347         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00348     <span class="keywordflow">return</span> NULL;
00349   }
00350   
00351   p_thr_info = (<a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> *)pthread_getspecific( thread_key );
00352   
00353   <span class="comment">/* we allocate the thread context if this is the first time */</span>
00354   <span class="keywordflow">if</span> (p_thr_info==NULL){
00355       
00356     <span class="comment">/* allocates thread structure */</span>
00357     p_thr_info = (<a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> *)Mem_Alloc(<span class="keyword">sizeof</span>(<a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a>));
00358     
00359     <span class="comment">/* panic !!! */</span>
00360     <span class="keywordflow">if</span> (p_thr_info == NULL) {
00361       printf( <span class="stringliteral">"%p:commands_NFS: Not enough memory\n"</span>,(caddr_t)pthread_self());
00362       <span class="keywordflow">return</span> NULL;
00363     }
00364     
00365     <span class="comment">/* Clean thread context */</span>
00366         
00367     memset(  p_thr_info, 0, <span class="keyword">sizeof</span>( <a class="code" href="commands__NFS_8c.html#a11">cmdnfs_thr_info_t</a> ) );
00368     
00369     p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> = FALSE;
00370     p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> = FALSE;
00371 
00372     <span class="comment">/* set the specific value */</span>
00373     pthread_setspecific( thread_key , (<span class="keywordtype">void</span> *)p_thr_info ) ;
00374     
00375   }
00376  
00377   <span class="keywordflow">return</span> p_thr_info ;
00378   
00379   
00380 } <span class="comment">/* GetNFSClient */</span>
00381 
00382 
<a name="l00383"></a><a class="code" href="commands__NFS_8c.html#a18">00383</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info )
00384 {
00385   uid_t uid;
00386   fsal_status_t st;
00387   <span class="keyword">struct </span>passwd * pw_struct;
00388   
00389   <span class="keywordflow">if</span> ( p_thr_info == NULL ) <span class="keywordflow">return</span> -1;
00390   
00391   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> == TRUE ) <span class="keywordflow">return</span> 0;
00392   
00393   <span class="comment">/* for the moment, create export context for root fileset */</span>
00394   st = FSAL_BuildExportContext( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o1">exp_context</a>,<a class="code" href="Getopt_8c.html#a0">NULL</a>, <a class="code" href="Getopt_8c.html#a0">NULL</a> );
00395     
00396   <span class="comment">/* initialize FSAL credential for this thread */</span>
00397 
00398   st = FSAL_InitClientContext( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a> );
00399     
00400   <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00401   {    
00402     printf( <span class="stringliteral">"%p:commands_NFS: Error %d initing credentials for thread (FSAL_InitThreadCred)\n"</span>,
00403         (caddr_t)pthread_self(),st.major);
00404     <span class="keywordflow">return</span> st.major;
00405   }
00406 
00407   uid = getuid();
00408   pw_struct = getpwuid(uid);
00409   
00410   <span class="keywordflow">if</span> ( pw_struct == NULL )
00411   {
00412     printf( <span class="stringliteral">"commands_NFS: Unknown user %u\n"</span>, uid );
00413     <span class="keywordflow">return</span> errno;
00414   }
00415   
00416   st = FSAL_GetClientContext( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o1">exp_context</a>,
00417                               uid, pw_struct-&gt;pw_gid, <a class="code" href="Getopt_8c.html#a0">NULL</a> , 0 );
00418 
00419   <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00420     {
00421       printf( <span class="stringliteral">"%p:commands_NFS: Error %d getting contexte for uid %d (FSAL_GetUserCred)\n"</span>,
00422         (caddr_t)pthread_self(),st.major,uid);
00423       <span class="keywordflow">return</span> st.major;
00424     }
00425   
00426   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a>.aup_machname = localmachine;
00427   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a>.aup_uid = uid;
00428   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a>.aup_gid = getgid();
00429   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a>.aup_len = 0; 
00431   <span class="comment">/* Init the cache_inode client */</span>
00432   <span class="keywordflow">if</span>( cache_inode_client_init( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>, <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) != 0 )
00433     <span class="keywordflow">return</span> 1 ;
00434   
00435   <span class="comment">/* Init the cache content client */</span>
00436   <span class="keywordflow">if</span>( cache_content_client_init( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o5">dc_client</a>, <a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a> ) != 0 )
00437     <span class="keywordflow">return</span> 1  ;
00438 
00439   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>.pcontent_client = (caddr_t)&amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o5">dc_client</a> ;
00440     
00441   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> = TRUE;
00442   
00443   <span class="keywordflow">return</span> 0;
00444   
00445 } <span class="comment">/* InitNFSClient */</span>
00446 
00447 
00448 
00449 
<a name="l00450"></a><a class="code" href="commands__NFS_8c.html#a19">00450</a> <span class="keywordtype">void</span> <a class="code" href="commands__NFS_8c.html#a19">nfs_layer_SetLogLevel</a>( <span class="keywordtype">int</span> log_lvl  ){
00451   
00452   <span class="comment">/* Nothing to do. */</span>
00453   <span class="keywordflow">return</span>;
00454   
00455 }
00456 
00457 
00458 <span class="keyword">static</span> <span class="keywordtype">void</span> getopt_init()
00459 {
00460   <span class="comment">/* disables getopt error message */</span>
00461   <a class="code" href="Getopt_8c.html#a3">Opterr</a> = 0;   
00462   <span class="comment">/* reinits getopt processing */</span>
00463   <a class="code" href="Getopt_8c.html#a4">Optind</a> = 1;  
00464 }
00465 
<a name="l00466"></a><a class="code" href="commands__NFS_8c.html#a21">00466</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a21">nfs_init</a>(<span class="keywordtype">char</span> * filename,
00467              <span class="keywordtype">int</span> flag_v,
00468              FILE * output
00469     )
00470 {
00471   config_file_t config_file;
00472   <span class="keywordtype">int</span> rc;
00473   
00474   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.lru_param.nb_entry_prealloc = 5000 ;
00475   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.lru_param.entry_to_str      = NULL ;
00476   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.lru_param.clean_entry       = NULL ;
00477   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.nb_prealloc_entry           = 100 ;
00478   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.flush_force_fsal            = 1 ;
00479   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.max_fd_per_thread           = 20 ;
00480   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.use_cache                   = 0 ;
00481   <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.retention                   = 60 ;
00482   strcpy( <a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param.cache_dir, <span class="stringliteral">"/tmp/ganesha.datacache"</span> ) ;
00483         
00484   <span class="comment">/* Parse config file */</span>
00485       
00486   config_file = config_ParseFile( filename );
00487   
00488   <span class="keywordflow">if</span> ( !config_file ){
00489     fprintf(output, <span class="stringliteral">"nfs_init: Error parsing %s: %s\n"</span>, filename,  config_GetErrorMsg());
00490     <span class="keywordflow">return</span> -1;
00491   }
00492 
00493   <span class="keywordflow">if</span>( ( rc = cache_content_read_conf_client_parameter( config_file, &amp;<a class="code" href="commands__NFS_8c.html#a2">nfs_param</a>.cache_layers_param.cache_content_client_param ) )!= CACHE_CONTENT_SUCCESS )
00494   {
00495     fprintf( output, <span class="stringliteral">"nfs_init: Error %d reading cache content parameters.\n"</span>, -rc );
00496     <span class="keywordflow">return</span> -1 ;
00497   }
00498   
00499           
00500   <span class="comment">/* Read export list from file */</span>
00501     
00502   rc = ReadExports( config_file, &amp;<a class="code" href="commands__NFS_8c.html#a9">pexportlist</a> );
00503     
00504   <span class="keywordflow">if</span> ( rc &lt; 0 )
00505   {
00506     fprintf( output, <span class="stringliteral">"nfs_init: Error %d while parsing exports file.\n"</span>, -rc );
00507     <span class="keywordflow">return</span> -1 ;
00508   }
00509   
00510   <span class="comment">/* initalize export entries */</span>
00511   <span class="keywordflow">if</span>( rc = nfs_export_create_root_entry( <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>, <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> ) != TRUE )
00512   {
00513       fprintf( output, <span class="stringliteral">"nfs_init: Error %d while initing root entries, exiting..."</span>, -rc );
00514       <span class="keywordflow">return</span> -1 ;
00515   }  
00516   
00517   <span class="comment">/* geting the hostname */</span>
00518   rc = gethostname( localmachine, <span class="keyword">sizeof</span>( localmachine ) );
00519   <span class="keywordflow">if</span>( rc != 0 )
00520   {
00521     fprintf( output, <span class="stringliteral">"nfs_init: Error %d while getting hostname.\n"</span>, rc );
00522     <span class="keywordflow">return</span> -1 ;
00523   }
00524 
00525     
00528   is_nfs_layer_initialized = TRUE;
00529   
00530   <span class="keywordflow">if</span> (flag_v) fprintf( output, <span class="stringliteral">"\tNFS layer successfully initialized.\n"</span> );
00531 
00532   <span class="keywordflow">return</span> 0;
00533 }
00534 
<a name="l00536"></a><a class="code" href="commands__NFS_8c.html#a22">00536</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a22">fn_nfs_init</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
00537                      <span class="keywordtype">char</span> ** argv ,  <span class="comment">/* IN : arg list               */</span>
00538                      FILE * output   <span class="comment">/* IN : output stream          */</span>
00539          )
00540 {
00541   <span class="keywordtype">int</span> flag_v   = 0;
00542   <span class="keywordtype">int</span> flag_h   = 0;  
00543   <span class="keywordtype">int</span> err_flag = 0 ;
00544   <span class="keywordtype">int</span> option ;
00545   <span class="keywordtype">char</span> * filename = NULL;
00546   <span class="keywordtype">int</span> rc;
00547 
00548   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
00549 
00550   
00551   <span class="keyword">static</span> <span class="keywordtype">char</span> help_nfs_init[]=
00552 <span class="comment">/*  "usage: nfs_init [options] &lt;ganesha_config_file&gt;\n"*/</span>
00553   <span class="stringliteral">"usage: nfs_init [options] &lt;ganesha_config_file&gt;\n"</span>
00554   <span class="stringliteral">"options :\n"</span>
00555   <span class="stringliteral">"\t-h print this help\n"</span>
00556   <span class="stringliteral">"\t-v verbose mode\n"</span>;
00557 
00558   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != FALSE )
00559   {
00560     fprintf( output, <span class="stringliteral">"\tNFS layer is already initialized.\n"</span> ) ;
00561     <span class="keywordflow">return</span> 0 ;
00562   }
00563   
00564   <span class="comment">/* analysing options */</span>
00565   getopt_init();
00566   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
00567     {   
00568       <span class="keywordflow">switch</span>( option )
00569         {
00570         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
00571           <span class="keywordflow">if</span>( flag_v )
00572             fprintf( output,
00573                     <span class="stringliteral">"nfs_init: warning: option 'v' has been specified more than once.\n"</span>); 
00574           <span class="keywordflow">else</span> 
00575             flag_v++;
00576           <span class="keywordflow">break</span>;
00577           
00578         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00579           <span class="keywordflow">if</span>( flag_h )
00580             fprintf( output,
00581                      <span class="stringliteral">"nfs_init: warning: option 'h' has been specified more than once.\n"</span>) ;
00582           <span class="keywordflow">else</span> 
00583             flag_h++;
00584           <span class="keywordflow">break</span>;
00585           
00586       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
00587         fprintf( output, <span class="stringliteral">"nfs_init: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a> ) ;
00588         err_flag ++;
00589         <span class="keywordflow">break</span>;
00590         } <span class="comment">/* switch */</span>   
00591     } <span class="comment">/* while */</span>
00592   
00593   <span class="keywordflow">if</span>( flag_h )
00594     {
00595       fprintf( output, help_nfs_init );
00596       <span class="keywordflow">return</span> 0;
00597     }
00598 
00599   <span class="comment">/* verifies mandatory argument */</span>
00600   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc -1 ) )
00601     {
00602       <span class="comment">/* too much or not enough arguments */</span>
00603       err_flag ++;
00604     }
00605   <span class="keywordflow">else</span> 
00606     filename = argv[Optind];
00607   
00608   <span class="keywordflow">if</span>( err_flag )
00609     {
00610       fprintf(output,help_nfs_init);
00611       <span class="keywordflow">return</span> -1;
00612     }
00613 
00614   rc = <a class="code" href="commands__NFS_8c.html#a21">nfs_init</a>(filename, flag_v, output);
00615   
00616   <span class="keywordflow">return</span> rc;  
00617   
00618 } <span class="comment">/* fn_nfs_init */</span>
00619 
00620 
00621 
<a name="l00623"></a><a class="code" href="commands__NFS_8c.html#a23">00623</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a23">fn_MNT1_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00624                      <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00625                      FILE * output     <span class="comment">/* IN : output stream          */</span>
00626                     )
00627 {
00628 
00629   <a class="code" href="structcmdnfs__funcdesc____.html">cmdnfs_funcdesc_t</a> * funcdesc = mnt1_funcdesc;
00630   
00631   nfs_arg_t nfs_arg;
00632   nfs_res_t nfs_res;
00633   <span class="keyword">struct </span>svc_req req;
00634   <span class="keywordtype">int</span> rc;
00635   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
00636       
00637   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
00638   {
00639     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
00640     <span class="keywordflow">return</span> -1 ;    
00641   }
00642   
00643   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
00644   
00645   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
00646   {
00647     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
00648     {
00649       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
00650       <span class="keywordflow">return</span> -1 ;
00651     }
00652   }
00653   
00654   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a> != NULL )
00655   {
00656     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00657     {
00658       
00659       <span class="comment">/* encoding args */</span>
00660       
00661       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00662                                   argc - 1, argv + 1,
00663                                   0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00664                                   (caddr_t)&amp;nfs_arg ) == FALSE )
00665       {
00666         fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00667         fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o5">func_help</a>);
00668         <span class="keywordflow">return</span> -1;
00669       }
00670       
00671       <span class="comment">/* preparing request identifier */</span>
00672       req.rq_prog = MOUNTPROG;
00673       req.rq_vers = MOUNT_V1;
00674       
00675       req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
00676       
00677       <span class="comment">/* nfs call */</span>
00678       
00679       rc = funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a>(
00680                                   &amp;nfs_arg,
00681                                   <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>,
00682                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
00683                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
00684                                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
00685                                   &amp;req,
00686                                   &amp;nfs_res
00687                                );
00688       
00689       <span class="comment">/* freeing args */</span>
00690       
00691       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00692                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00693                              (caddr_t)&amp;nfs_arg );
00694 
00695       <span class="comment">/* decoding output */</span>
00696       
00697 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00698 <span class="preprocessor"></span>      printf(<span class="stringliteral">"MNTv1: RETURNED STRUCTURE:\n"</span>);
00699       print_nfs_res( &amp;nfs_res );
00700 <span class="preprocessor">#endif</span>
00701 <span class="preprocessor"></span>      
00702       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00703                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00704                              (caddr_t)&amp;nfs_res );
00705       
00706       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00707       
00708       <span class="comment">/* returning status */</span>
00709       <span class="keywordflow">return</span> rc;
00710       
00711     }
00712     
00713     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00714     funcdesc ++ ;
00715   }
00716   
00717   fprintf(output,<span class="stringliteral">"%s: command not found in MNT1 protocol.\n"</span>,argv[0]);
00718   <span class="keywordflow">return</span> -1;
00719            
00720 } <span class="comment">/* fn_MNT1_command */</span>
00721 
00722 
00723 
00724 
00725 
<a name="l00727"></a><a class="code" href="commands__NFS_8c.html#a24">00727</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a24">fn_MNT3_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00728                      <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00729                      FILE * output     <span class="comment">/* IN : output stream          */</span>
00730          ){
00731          
00732   <a class="code" href="structcmdnfs__funcdesc____.html">cmdnfs_funcdesc_t</a> * funcdesc = mnt3_funcdesc;
00733   
00734   nfs_arg_t nfs_arg;
00735   nfs_res_t nfs_res;
00736   <span class="keyword">struct </span>svc_req req;
00737   <span class="keywordtype">int</span> rc;
00738   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
00739       
00740   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
00741   {
00742     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
00743     <span class="keywordflow">return</span> -1 ;    
00744   }
00745   
00746   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
00747   
00748   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
00749   {
00750     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
00751     {
00752       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
00753       <span class="keywordflow">return</span> -1 ;
00754     }
00755   }
00756   
00757   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a> != NULL )
00758   {
00759     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00760     {
00761       
00762       <span class="comment">/* encoding args */</span>
00763       
00764       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00765                                   argc - 1, argv + 1,
00766                                   0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00767                                   (caddr_t)&amp;nfs_arg ) == FALSE )
00768       {
00769         fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00770         fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o5">func_help</a>);
00771         <span class="keywordflow">return</span> -1;
00772       }
00773       
00774       <span class="comment">/* preparing request identifier */</span>
00775       req.rq_prog = MOUNTPROG;
00776       req.rq_vers = MOUNT_V3;
00777       
00778       req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
00779       
00780       <span class="comment">/* nfs call */</span>
00781       
00782       rc = funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a>(
00783                                   &amp;nfs_arg,
00784                                   <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>,
00785                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
00786                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
00787                                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
00788                                   &amp;req,
00789                                   &amp;nfs_res
00790                                );
00791       
00792       <span class="comment">/* freeing args */</span>
00793       
00794       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00795                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00796                              (caddr_t)&amp;nfs_arg );
00797 
00798       <span class="comment">/* decoding output */</span>
00799 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00800 <span class="preprocessor"></span>      printf(<span class="stringliteral">"MNTv3: RETURNED STRUCTURE:\n"</span>);
00801       print_nfs_res( &amp;nfs_res );
00802 <span class="preprocessor">#endif</span>
00803 <span class="preprocessor"></span>      
00804       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00805                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00806                              (caddr_t)&amp;nfs_res );
00807       
00808       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00809 
00810       <span class="comment">/* returning status */</span>
00811       <span class="keywordflow">return</span> rc;
00812       
00813     }
00814     
00815     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00816     funcdesc ++ ;
00817   }
00818   
00819   fprintf(output,<span class="stringliteral">"%s: command not found in MNT3 protocol.\n"</span>,argv[0]);
00820   <span class="keywordflow">return</span> -1;
00821          
00822 }
00823 
00824 
00825 
00826 
<a name="l00828"></a><a class="code" href="commands__NFS_8c.html#a25">00828</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a25">fn_NFS2_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00829                      <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00830                      FILE * output     <span class="comment">/* IN : output stream          */</span>
00831          )
00832 {
00833   
00834   <a class="code" href="structcmdnfs__funcdesc____.html">cmdnfs_funcdesc_t</a> * funcdesc = nfs2_funcdesc;
00835   
00836   nfs_arg_t nfs_arg;
00837   nfs_res_t nfs_res;
00838   <span class="keyword">struct </span>svc_req req;
00839   <span class="keywordtype">int</span> rc;
00840   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
00841 
00842   <span class="keywordtype">short</span>           exportid;
00843   exportlist_t  * pexport;
00844       
00845   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
00846   {
00847     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
00848     <span class="keywordflow">return</span> -1 ;    
00849   }
00850   
00851   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
00852   
00853   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
00854   {
00855     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
00856     {
00857       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
00858       <span class="keywordflow">return</span> -1 ;
00859     }
00860   }
00861   
00862   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a> != NULL )
00863   {
00864     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00865     {
00866       
00867       <span class="comment">/* encoding args */</span>
00868       
00869       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00870                                   argc - 1, argv + 1,
00871                                   0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00872                                   (caddr_t)&amp;nfs_arg ) == FALSE )
00873       {
00874         fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00875         fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o5">func_help</a>);
00876         <span class="keywordflow">return</span> -1;
00877       }
00878       
00879       <span class="comment">/* preparing request identifier */</span>
00880       
00881       req.rq_prog = NFS_PROGRAM;
00882       req.rq_vers = NFS_V2;      
00883       req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
00884       
00885       <span class="comment">/* the only function that doesn't take a filehandle */</span>
00886       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a> != nfs_Null )
00887       {
00888         exportid = nfs2_FhandleToExportId( ( fhandle2 *)&amp;nfs_arg ) ;
00889         <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>, exportid ) ) == NULL )
00890         {
00891           <span class="comment">/* invalid handle */</span>
00892           fprintf( output, <span class="stringliteral">"\t%s: Bad arguments: Invalid file handle.\n"</span>,argv[0] );
00893           <span class="keywordflow">return</span> -1 ;
00894         }
00895       }
00896       <span class="keywordflow">else</span>
00897         pexport = NULL;
00898       
00899       
00900       <span class="comment">/* nfs call */</span>
00901       
00902       rc = funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a>(
00903                                   &amp;nfs_arg,
00904                                   pexport,
00905                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
00906                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
00907                                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
00908                                   &amp;req,
00909                                   &amp;nfs_res
00910                                );
00911       
00912       <span class="comment">/* freeing args */</span>
00913       
00914       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
00915                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
00916                              (caddr_t)&amp;nfs_arg );
00917       
00918 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
00919 <span class="preprocessor"></span>      printf(<span class="stringliteral">"NFSv2: RETURNED STRUCTURE:\n"</span>);
00920       print_nfs_res( &amp;nfs_res );
00921 <span class="preprocessor">#endif</span>
00922 <span class="preprocessor"></span>                
00923       <span class="comment">/* decoding output */</span>
00924       
00925       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
00926                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
00927                              (caddr_t)&amp;nfs_res );
00928       
00929       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
00930 
00931       <span class="comment">/* returning status */</span>
00932       <span class="keywordflow">return</span> rc;
00933       
00934     }
00935     
00936     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
00937     funcdesc ++ ;
00938   }
00939   
00940   fprintf(output,<span class="stringliteral">"%s: command not found in NFS2 protocol.\n"</span>,argv[0]);
00941   <span class="keywordflow">return</span> -1;
00942          
00943 }
00944 
00945 
<a name="l00947"></a><a class="code" href="commands__NFS_8c.html#a26">00947</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a26">fn_NFS3_command</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
00948                      <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
00949                      FILE * output     <span class="comment">/* IN : output stream          */</span>
00950          )
00951 {
00952   
00953   <a class="code" href="structcmdnfs__funcdesc____.html">cmdnfs_funcdesc_t</a> * funcdesc = nfs3_funcdesc;
00954   
00955   nfs_arg_t nfs_arg;
00956   nfs_res_t nfs_res;
00957   <span class="keyword">struct </span>svc_req req;
00958   <span class="keywordtype">int</span> rc;
00959   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
00960 
00961   <span class="keywordtype">short</span>           exportid;
00962   exportlist_t  * pexport;
00963       
00964   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
00965   {
00966     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
00967     <span class="keywordflow">return</span> -1 ;    
00968   }
00969   
00970   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
00971   
00972   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
00973   {
00974     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
00975     {
00976       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
00977       <span class="keywordflow">return</span> -1 ;
00978     }
00979   }
00980   
00981   <span class="keywordflow">while</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a> != NULL )
00982   {
00983     <span class="keywordflow">if</span> ( !strcmp(  funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o0">func_name</a>, argv[0] ) )
00984     {
00985       
00986       <span class="comment">/* encoding args */</span>
00987       
00988       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
00989                                   argc - 1, argv + 1,
00990                                   0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
00991                                   (caddr_t)&amp;nfs_arg ) == FALSE )
00992       {
00993         fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
00994         fprintf(output,<span class="stringliteral">"Usage: %s\n"</span>,funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o5">func_help</a>);
00995         <span class="keywordflow">return</span> -1;
00996       }
00997       
00998       <span class="comment">/* preparing request identifier */</span>
00999       
01000       req.rq_prog = NFS_PROGRAM;
01001       req.rq_vers = NFS_V3;      
01002       req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01003       
01004       <span class="comment">/* the only function that doesn't take a filehandle */</span>
01005       <span class="keywordflow">if</span> ( funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a> != nfs_Null )
01006       {
01007         exportid = nfs3_FhandleToExportId( ( nfs_fh3 *)&amp;nfs_arg ) ;
01008         <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>, exportid ) ) == NULL )
01009         {
01010           <span class="comment">/* invalid handle */</span>
01011           fprintf( output, <span class="stringliteral">"\t%s: Bad arguments: Invalid file handle.\n"</span>,argv[0] );
01012           <span class="keywordflow">return</span> -1 ;
01013         }
01014       }
01015       <span class="keywordflow">else</span>
01016         pexport = NULL;
01017       
01018       
01019       <span class="comment">/* nfs call */</span>
01020       
01021       rc = funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o1">func_call</a>(
01022                                   &amp;nfs_arg,
01023                                   pexport,
01024                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01025                                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01026                                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
01027                                   &amp;req,
01028                                   &amp;nfs_res
01029                                );
01030       
01031       <span class="comment">/* freeing args */</span>
01032       
01033       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o3">func_encode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
01034                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
01035                              (caddr_t)&amp;nfs_arg );
01036       
01037 <span class="preprocessor">#ifdef _DEBUG_NFS_SHELL</span>
01038 <span class="preprocessor"></span>      printf(<span class="stringliteral">"NFSv3: RETURNED STRUCTURE:\n"</span>);
01039       print_nfs_res( &amp;nfs_res );
01040 <span class="preprocessor">#endif</span>
01041 <span class="preprocessor"></span>                
01042       <span class="comment">/* decoding output */</span>
01043       
01044       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o4">func_decode</a>( <a class="code" href="cmd__nfstools_8h.html#a70a13">CMDNFS_DECODE</a>,
01045                              0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,output,
01046                              (caddr_t)&amp;nfs_res );
01047       
01048       funcdesc-&gt;<a class="code" href="structcmdnfs__funcdesc____.html#o2">func_free</a>( &amp;nfs_res );
01049 
01050       <span class="comment">/* returning status */</span>
01051       <span class="keywordflow">return</span> rc;
01052       
01053     }
01054     
01055     <span class="comment">/* pointer to the next cmdnfs_funcdesc_t */</span>
01056     funcdesc ++ ;
01057   }
01058   
01059   fprintf(output,<span class="stringliteral">"%s: command not found in NFS3 protocol.\n"</span>,argv[0]);
01060   <span class="keywordflow">return</span> -1;
01061          
01062 } <span class="comment">/* fn_NFS3_command */</span>
01063 
01064 
01065 <span class="comment">/*------------------------------------------------------------</span>
01066 <span class="comment"> *     Wrapping of NFS calls (used by high level commands)</span>
01067 <span class="comment"> *-----------------------------------------------------------*/</span>
01068 
01069 
01070 <span class="comment">/* solves a relative or aboslute path */</span>
01071 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_solvepath(<a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01072                          <span class="keywordtype">char</span> * io_global_path,    <span class="comment">/* global path */</span>
01073                          <span class="keywordtype">int</span> size_global_path,<span class="comment">/* max size for global path */</span>
01074                          <span class="keywordtype">char</span> * i_spec_path,  <span class="comment">/* specified path */</span>
01075                          <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_current_hdl, <span class="comment">/* current directory handle */</span>
01076                          <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * pnew_hdl,  <span class="comment">/* pointer to solved handle */</span>
01077                          FILE * output)
01078 {
01079   <span class="keywordtype">char</span> str_path[NFS2_MAXPATHLEN];
01080   <span class="keywordtype">char</span> * pstr_path = str_path;
01081   
01082   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN] ;
01083   <span class="keywordtype">char</span> * next_name ;
01084   <span class="keywordtype">char</span> * curr ;
01085   <span class="keywordtype">int</span> last=0;
01086   <span class="keywordtype">int</span> rc;
01087 
01088   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> hdl_lookup ;
01089   nfs_fh3 hdl_param ;
01090   
01091   diropargs3  dirop_arg;
01092   LOOKUP3res  lookup_res;
01093   <span class="keyword">struct </span>svc_req req;
01094   <span class="keywordtype">short</span>           exportid;
01095   exportlist_t  * pexport;
01096   
01097   strncpy(str_path, i_spec_path ,NFS2_MAXPATHLEN);  
01098   curr = str_path;
01099   next_name = str_path;
01100 
01101   <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'@'</span>)
01102     {
01103       
01104     rc = <a class="code" href="cmd__nfstools_8h.html#a22">cmdnfs_fhandle3</a>(
01105       CMDNFS_ENCODE, 1, &amp;pstr_path,
01106       0,   NULL,
01107       (caddr_t)&amp;hdl_param );
01108         
01109     <span class="keywordflow">if</span> ( rc != TRUE )
01110     {
01111       fprintf( output, <span class="stringliteral">"Invalid FileHandle: %s\n"</span>,str_path );
01112       <span class="keywordflow">return</span> -1;
01113     }
01114     
01115     strncpy( io_global_path, str_path ,size_global_path);
01116     
01117     set_shell_fh3( pnew_hdl , &amp;hdl_param );
01118 
01119     <a class="code" href="cmd__nfstools_8h.html#a22">cmdnfs_fhandle3</a>( CMDNFS_FREE, 0, NULL, 0,   NULL,
01120                     (caddr_t)&amp;hdl_param );    
01121     
01122     <span class="keywordflow">return</span> 0;        
01123     
01124     }
01125   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'/'</span>)
01126     {
01127       <span class="comment">/* absolute path, starting from "/", with a relative path */</span>
01128       curr ++;
01129       next_name ++;
01130       hdl_lookup =  p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o7">mounted_path_hdl</a> ;
01131       strncpy(tmp_path, <span class="stringliteral">"/"</span> ,NFS2_MAXPATHLEN);
01132 
01133       <span class="comment">/* the the directory  is /, return */</span>
01134       <span class="keywordflow">if</span> (str_path[1]==<span class="charliteral">'\0'</span>)
01135         {
01136           strncpy(io_global_path,tmp_path,size_global_path);
01137           *pnew_hdl = hdl_lookup ;
01138           <span class="keywordflow">return</span> 0;
01139         }
01140       
01141     } 
01142   <span class="keywordflow">else</span> 
01143     {
01144       hdl_lookup = *p_current_hdl ;
01145       strncpy(tmp_path, io_global_path ,NFS2_MAXPATHLEN);  
01146     }
01147 
01148   <span class="comment">/* Now, the path is a relative path, proceed a step by step lookup */</span>
01149   <span class="keywordflow">do</span> 
01150     {
01151       <span class="comment">/* tokenize to the next '/' */</span>         
01152       <span class="keywordflow">while</span>( ( curr[0] != <span class="charliteral">'\0'</span> ) &amp;&amp;  
01153              ( curr[0] != <span class="charliteral">'/'</span> ) )
01154         curr++;
01155       
01156       <span class="keywordflow">if</span> (!curr[0]) 
01157         last=1; <span class="comment">/* remembers if it was the last dir */</span>
01158       
01159       curr[0]=<span class="charliteral">'\0'</span>;
01160       
01161       <span class="comment">/* build the arguments */</span>
01162       
01163       set_nfs_fh3( &amp;dirop_arg.dir, &amp;hdl_lookup);
01164       dirop_arg.name = next_name;
01165       
01166       <span class="comment">/* preparing request identifier */</span>
01167       
01168       req.rq_prog = NFS_PROGRAM;
01169       req.rq_vers = NFS_V3;      
01170       req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;                  
01171       
01172       exportid = nfs3_FhandleToExportId(  &amp;dirop_arg.dir ) ;
01173       <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01174       {
01175         <span class="comment">/* invalid handle */</span>
01176         fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01177         <span class="keywordflow">return</span> -1 ;
01178       }
01179         
01180       <span class="comment">/* lookup this name */</span>
01181       
01182       rc = nfs_Lookup(
01183                         (nfs_arg_t*)&amp;dirop_arg,
01184                         pexport,
01185                         &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01186                         &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01187                         ht,
01188                         &amp;req,
01189                         (nfs_res_t*)&amp;lookup_res
01190                      );
01191      
01192        <span class="keywordflow">if</span> ( rc != 0 )
01193        {
01194          fprintf(output,<span class="stringliteral">"Error %d in nfs_Lookup.\n"</span>,rc);
01195          <span class="keywordflow">return</span> rc;
01196        }
01197 
01198        rc = lookup_res.status;
01199        <span class="keywordflow">if</span> ( rc != NFS3_OK )
01200        {
01201          nfs3_Lookup_Free( (nfs_res_t*)&amp;lookup_res );
01202          fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01203              rc,nfsstat3_to_str(rc));
01204          <span class="keywordflow">return</span> rc;
01205        }
01206       
01207       <span class="comment">/* updates current handle */</span>
01208       set_shell_fh3( &amp;hdl_lookup, &amp;lookup_res.LOOKUP3res_u.resok.object ) ;
01209 
01210       nfs3_Lookup_Free( (nfs_res_t*)&amp;lookup_res );
01211          
01212       <span class="comment">/* adds /name at the end of the path */</span>
01213       strncat(tmp_path,<span class="stringliteral">"/"</span>,FSAL_MAX_PATH_LEN);
01214       strncat(tmp_path,next_name,FSAL_MAX_PATH_LEN);
01215 
01216       <span class="comment">/* updates cursors */</span>
01217       <span class="keywordflow">if</span>( !last )
01218       {
01219         curr ++;
01220         next_name = curr ;
01221         <span class="comment">/* ignore successive slashes */</span>
01222         <span class="keywordflow">while</span>((curr[0]!=<span class="charliteral">'\0'</span>) &amp;&amp; (curr[0]==<span class="charliteral">'/'</span>)){
01223           curr++;
01224           next_name = curr;
01225         }
01226         <span class="keywordflow">if</span> (!curr[0]) last=1; <span class="comment">/* it is the last dir */</span>
01227       }
01228     
01229     } <span class="keywordflow">while</span>( !last );
01230     
01231   <span class="comment">/* everything is OK, apply changes */</span>
01232   <a class="code" href="cmd__tools_8h.html#a16">clean_path</a>(tmp_path,size_global_path);
01233   strncpy(io_global_path,tmp_path,size_global_path);
01234     
01235   *pnew_hdl = hdl_lookup ;
01236   <span class="keywordflow">return</span> 0;
01237  
01238 } <span class="comment">/* nfs_solvepath */</span>
01239 
01240 
01241 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_getattr( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl,
01242                         fattr3 * attrs, FILE * output )
01243 {
01244   GETATTR3res res;
01245   <span class="keyword">struct </span>svc_req req;
01246   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01247   exportlist_t  * pexport;
01248   <span class="keywordtype">int</span> rc;
01249   
01250   nfs_fh3 nfshdl;
01251   
01252   <span class="comment">/* preparing request identifier */</span>
01253 
01254   req.rq_prog = NFS_PROGRAM;
01255   req.rq_vers = NFS_V3;      
01256   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01257 
01258   set_nfs_fh3( &amp;nfshdl , p_hdl );
01259   
01260   exportid = nfs3_FhandleToExportId( &amp;nfshdl ) ;
01261   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01262   {
01263     <span class="comment">/* invalid handle */</span>
01264     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01265     <span class="keywordflow">return</span> -1 ;
01266   }
01267   
01268   rc = nfs_Getattr(
01269                     (nfs_arg_t*)&amp;nfshdl,
01270                     pexport,
01271                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01272                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01273                     ht,
01274                     &amp;req,
01275                     (nfs_res_t*)&amp;res
01276                  );
01277 
01278    <span class="keywordflow">if</span> ( rc != 0 )
01279    {
01280      fprintf(output,<span class="stringliteral">"Error %d in nfs_Getattr.\n"</span>,rc);
01281      <span class="keywordflow">return</span> rc;
01282    }
01283 
01284    rc = res.status;
01285    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01286    {
01287      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01288          rc,nfsstat3_to_str(rc));
01289      
01290      nfs_Getattr_Free( (nfs_res_t*)&amp;res );
01291      <span class="keywordflow">return</span> rc;
01292    }
01293 
01294   <span class="comment">/* updates current handle */</span>
01295   *attrs = res.GETATTR3res_u.resok.obj_attributes;
01296 
01297   nfs_Getattr_Free( (nfs_res_t*)&amp;res );
01298   
01299   <span class="keywordflow">return</span> 0;
01300   
01301 }
01302 
01303 
01304 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_access( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl,
01305                        nfs3_uint32 * access_mask, <span class="comment">/* IN/OUT */</span>
01306                        FILE * output )
01307 {
01308   ACCESS3args arg;
01309   ACCESS3res  res ;
01310   <span class="keyword">struct </span>svc_req req;
01311   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01312   exportlist_t  * pexport;
01313   <span class="keywordtype">int</span> rc;
01314   
01315   <span class="comment">/* preparing args */</span>
01316   set_nfs_fh3( &amp;arg.object, p_hdl);
01317   arg.access = *access_mask;
01318   
01319   <span class="comment">/* preparing request identifier */</span>
01320 
01321   req.rq_prog = NFS_PROGRAM;
01322   req.rq_vers = NFS_V3;      
01323   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01324 
01325   exportid = nfs3_FhandleToExportId( &amp;arg.object ) ;
01326   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01327   {
01328     <span class="comment">/* invalid handle */</span>
01329     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01330     <span class="keywordflow">return</span> -1 ;
01331   }
01332   
01333   rc = nfs3_Access(
01334                     (nfs_arg_t*)&amp;arg,
01335                     pexport,
01336                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01337                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01338                     ht,
01339                     &amp;req,
01340                     (nfs_res_t*)&amp;res
01341                  );
01342 
01343    <span class="keywordflow">if</span> ( rc != 0 )
01344    {
01345      fprintf(output,<span class="stringliteral">"Error %d in nfs_Access.\n"</span>,rc);
01346      <span class="keywordflow">return</span> rc;
01347    }
01348 
01349    rc = res.status;
01350    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01351    {
01352      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01353          rc,nfsstat3_to_str(rc));
01354      nfs3_Access_Free( (nfs_res_t*)&amp;res );
01355      <span class="keywordflow">return</span> rc;
01356    }
01357 
01358   <span class="comment">/* updates access mask */</span>
01359   *access_mask = res.ACCESS3res_u.resok.access;
01360 
01361   nfs3_Access_Free( (nfs_res_t*)&amp;res );
01362   
01363   <span class="keywordflow">return</span> 0;
01364   
01365 }
01366     
01367 
01368 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_readlink( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl,
01369                          <span class="keywordtype">char</span> * linkcontent, FILE * output )
01370 {
01371   READLINK3res res;
01372   <span class="keyword">struct </span>svc_req req;
01373   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01374   exportlist_t  * pexport;
01375   <span class="keywordtype">int</span> rc;
01376   
01377   nfs_fh3 nfshdl;
01378   
01379   set_nfs_fh3( &amp;nfshdl, p_hdl );
01380   
01381   <span class="comment">/* preparing request identifier */</span>
01382 
01383   req.rq_prog = NFS_PROGRAM;
01384   req.rq_vers = NFS_V3;      
01385   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01386 
01387   exportid = nfs3_FhandleToExportId( &amp;nfshdl ) ;
01388   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01389   {
01390     <span class="comment">/* invalid handle */</span>
01391     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01392     <span class="keywordflow">return</span> -1 ;
01393   }
01394   
01395   rc = nfs_Readlink(
01396                     (nfs_arg_t*)&amp;nfshdl,
01397                     pexport,
01398                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01399                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01400                     ht,
01401                     &amp;req,
01402                     (nfs_res_t*)&amp;res
01403                  );
01404 
01405    <span class="keywordflow">if</span> ( rc != 0 )
01406    {
01407      fprintf(output,<span class="stringliteral">"Error %d in nfs_Readlink.\n"</span>,rc);
01408      <span class="keywordflow">return</span> rc;
01409    }
01410 
01411    rc = res.status;
01412    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01413    {
01414      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01415          rc,nfsstat3_to_str(rc));
01416      nfs3_Readlink_Free( (nfs_res_t*)&amp;res );
01417      <span class="keywordflow">return</span> rc;
01418    }
01419 
01420   <span class="comment">/* copy link content */</span>
01421   strcpy( linkcontent, res.READLINK3res_u.resok.data );
01422   
01423   nfs3_Readlink_Free( (nfs_res_t*)&amp;res );
01424   
01425   <span class="keywordflow">return</span> 0;
01426   
01427 } <span class="comment">/* nfs_readlink */</span>
01428 
01429 
01430 
01431 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_readdirplus( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01432                          <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl,
01433                          cookie3 cookie,    
01434                          cookieverf3 * p_cookieverf, <span class="comment">/* IN/OUT */</span>
01435                          dirlistplus3 * dirlist,
01436                          nfs_res_t ** to_be_freed,
01437                          FILE * output )
01438 {
01439   READDIRPLUS3args arg;
01440   READDIRPLUS3res * p_res;
01441   <span class="keyword">struct </span>svc_req req;
01442   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01443   exportlist_t  * pexport;
01444   <span class="keywordtype">int</span> rc;
01445 
01446   *to_be_freed = NULL;
01447     
01448   <span class="comment">/* args */</span>
01449   set_nfs_fh3( &amp;arg.dir, p_dir_hdl );
01450   arg.cookie = cookie;
01451   memcpy ( &amp;arg.cookieverf, p_cookieverf, <span class="keyword">sizeof</span>( cookieverf3 ) );
01452   arg.dircount = 1024;
01453   arg.maxcount = 4096;
01454   
01455   <span class="comment">/* preparing request identifier */</span>
01456 
01457   req.rq_prog = NFS_PROGRAM;
01458   req.rq_vers = NFS_V3;      
01459   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01460 
01461   exportid = nfs3_FhandleToExportId( &amp;arg.dir ) ;
01462   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01463   {
01464     <span class="comment">/* invalid handle */</span>
01465     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01466     <span class="keywordflow">return</span> -1 ;
01467   }
01468 
01469   p_res = ( READDIRPLUS3res * ) Mem_Alloc( <span class="keyword">sizeof</span>( READDIRPLUS3res ) );
01470 
01471     
01472   rc = nfs3_Readdirplus(
01473                     (nfs_arg_t*)&amp;arg,
01474                     pexport,
01475                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01476                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01477                     ht,
01478                     &amp;req,
01479                     (nfs_res_t*)p_res
01480                  );
01481 
01482    <span class="keywordflow">if</span> ( rc != 0 )
01483    {
01484      Mem_Free( p_res );
01485      fprintf(output,<span class="stringliteral">"Error %d in nfs3_Readdirplus.\n"</span>,rc);
01486      <span class="keywordflow">return</span> rc;
01487    }
01488 
01489    rc = p_res-&gt;status;
01490    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01491    {
01492      nfs3_Readdirplus_Free( (nfs_res_t*)p_res );
01493      Mem_Free( p_res );
01494      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01495          rc,nfsstat3_to_str(rc));
01496      <span class="keywordflow">return</span> rc;
01497    }
01498   
01499    memcpy( p_cookieverf, p_res-&gt;READDIRPLUS3res_u.resok.cookieverf,
01500        <span class="keyword">sizeof</span>( cookieverf3 ) );
01501    
01502    *dirlist = p_res-&gt;READDIRPLUS3res_u.resok.reply;
01503    *to_be_freed = (nfs_res_t*)p_res;
01504    
01505   <span class="keywordflow">return</span> 0;
01506   
01507 } <span class="comment">/* nfs_readdirplus */</span>
01508 
01509 
<a name="l01510"></a><a class="code" href="commands__NFS_8c.html#a32">01510</a> <span class="keywordtype">void</span> <a class="code" href="commands__NFS_8c.html#a32">nfs_readdirplus_free</a>( nfs_res_t * to_free )
01511 {
01512   <span class="keywordflow">if</span> ( to_free == NULL ) <span class="keywordflow">return</span>;
01513   
01514   nfs3_Readdirplus_Free( (nfs_res_t*)to_free );
01515   Mem_Free( to_free );  
01516 }
01517 
01518 
01519 
01520 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_create( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01521                         <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="keywordtype">char</span> * obj_name,
01522                         mode_t posix_mode, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl,
01523                         FILE * output )
01524 {
01525   CREATE3args arg;
01526   CREATE3res res;
01527   <span class="keyword">struct </span>svc_req req;
01528   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01529   exportlist_t  * pexport;
01530   <span class="keywordtype">int</span> rc;
01531       
01532       
01533   <span class="comment">/* preparing arguments */</span>
01534   
01535   set_nfs_fh3( &amp;arg.where.dir, p_dir_hdl );  
01536   arg.where.name = obj_name;
01537   arg.how.mode = GUARDED;
01538 
01539   <span class="comment">/* preparing request identifier */</span>
01540 
01541   req.rq_prog = NFS_PROGRAM;
01542   req.rq_vers = NFS_V3;      
01543   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01544 
01545   exportid = nfs3_FhandleToExportId( &amp;arg.where.dir ) ;
01546   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01547   {
01548     <span class="comment">/* invalid handle */</span>
01549     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01550     <span class="keywordflow">return</span> -1 ;
01551   }
01552 
01553     
01554   <span class="comment">/* empty sattr3 list */</span>
01555   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( CMDNFS_ENCODE, 0, NULL, 0, NULL,
01556                  (caddr_t)&amp;(arg.how.createhow3_u.obj_attributes) ) == FALSE )
01557   {
01558     <span class="comment">/* invalid handle */</span>
01559     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
01560     <span class="keywordflow">return</span> -1 ;
01561   }
01562   
01563   <span class="comment">/* only setting mode */</span>
01564   arg.how.createhow3_u.obj_attributes.mode.set_it = TRUE;
01565   arg.how.createhow3_u.obj_attributes.mode.set_mode3_u.mode = posix_mode;
01566   
01567   rc = nfs_Create(
01568                     (nfs_arg_t*)&amp;arg,
01569                     pexport,
01570                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01571                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01572                     ht,
01573                     &amp;req,
01574                     (nfs_res_t*)&amp;res
01575                  );
01576 
01577    <span class="keywordflow">if</span> ( rc != 0 )
01578    {
01579      fprintf(output,<span class="stringliteral">"Error %d in nfs_Create.\n"</span>,rc);
01580      <span class="keywordflow">return</span> rc;
01581    }
01582 
01583    rc = res.status;
01584    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01585    {
01586      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01587          rc,nfsstat3_to_str(rc));
01588      nfs_Create_Free( (nfs_res_t*)&amp;res );
01589      <span class="keywordflow">return</span> rc;
01590    }
01591 
01592   <span class="comment">/* object handle */</span>
01593   <span class="keywordflow">if</span> ( res.CREATE3res_u.resok.obj.handle_follows )
01594     set_shell_fh3( p_obj_hdl, &amp;res.CREATE3res_u.resok.obj.post_op_fh3_u.handle );
01595   <span class="keywordflow">else</span>
01596     fprintf(output,<span class="stringliteral">"Warning: nfs_Create did not return file handle.\n"</span>);
01597     
01598   nfs_Create_Free( (nfs_res_t*)&amp;res );
01599    
01600   <span class="keywordflow">return</span> 0;
01601   
01602 }
01603 
01604 
01605 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_mkdir( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01606                         <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="keywordtype">char</span> * obj_name,
01607                         mode_t posix_mode, <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl,
01608                         FILE * output )
01609 {
01610   MKDIR3args arg;
01611   MKDIR3res res;
01612   <span class="keyword">struct </span>svc_req req;
01613   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01614   exportlist_t  * pexport;
01615   <span class="keywordtype">int</span> rc;
01616   
01617   <span class="comment">/* preparing request identifier */</span>
01618 
01619   req.rq_prog = NFS_PROGRAM;
01620   req.rq_vers = NFS_V3;      
01621   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01622 
01623   <span class="comment">/* preparing arguments */</span>
01624   
01625   set_nfs_fh3( &amp;arg.where.dir , p_dir_hdl );
01626   arg.where.name = obj_name;
01627 
01628   exportid = nfs3_FhandleToExportId( &amp;arg.where.dir ) ;
01629   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01630   {
01631     <span class="comment">/* invalid handle */</span>
01632     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01633     <span class="keywordflow">return</span> -1 ;
01634   }
01635 
01636     
01637   <span class="comment">/* empty sattr3 list */</span>
01638   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( CMDNFS_ENCODE, 0, NULL, 0, NULL,
01639                  (caddr_t)&amp;(arg.attributes) ) == FALSE )
01640   {
01641     <span class="comment">/* invalid handle */</span>
01642     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
01643     <span class="keywordflow">return</span> -1 ;
01644   }
01645   
01646   <span class="comment">/* only setting mode */</span>
01647   arg.attributes.mode.set_it = TRUE;
01648   arg.attributes.mode.set_mode3_u.mode = posix_mode;
01649   
01650   rc = nfs_Mkdir(
01651                     (nfs_arg_t*)&amp;arg,
01652                     pexport,
01653                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01654                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01655                     ht,
01656                     &amp;req,
01657                     (nfs_res_t*)&amp;res
01658                  );
01659 
01660    <span class="keywordflow">if</span> ( rc != 0 )
01661    {
01662      fprintf(output,<span class="stringliteral">"Error %d in nfs_Mkdir.\n"</span>,rc);
01663      <span class="keywordflow">return</span> rc;
01664    }
01665 
01666    rc = res.status;
01667    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01668    {
01669      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01670          rc,nfsstat3_to_str(rc));
01671      nfs_Mkdir_Free( (nfs_res_t*)&amp;res );
01672      <span class="keywordflow">return</span> rc;
01673    }
01674 
01675   <span class="comment">/* object handle */</span>
01676   <span class="keywordflow">if</span> ( res.MKDIR3res_u.resok.obj.handle_follows )
01677     set_shell_fh3( p_obj_hdl, &amp;res.MKDIR3res_u.resok.obj.post_op_fh3_u.handle ) ;
01678   <span class="keywordflow">else</span>
01679     fprintf(output,<span class="stringliteral">"Warning: nfs_Mkdir did not return file handle.\n"</span>);
01680 
01681   nfs_Mkdir_Free( (nfs_res_t*)&amp;res );   
01682    
01683   <span class="keywordflow">return</span> 0;
01684   
01685 } <span class="comment">/*nfs_mkdir*/</span>
01686 
01687 
01688 
01689 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_rmdir( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01690                       <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="keywordtype">char</span> * obj_name,
01691                        FILE * output )
01692 {
01693   diropargs3 arg;
01694   RMDIR3res res;
01695   <span class="keyword">struct </span>svc_req req;
01696   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01697   exportlist_t  * pexport;
01698   <span class="keywordtype">int</span> rc;
01699   
01700   <span class="comment">/* preparing request identifier */</span>
01701 
01702   req.rq_prog = NFS_PROGRAM;
01703   req.rq_vers = NFS_V3;      
01704   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01705   
01706   <span class="comment">/* preparing arguments */</span>
01707   
01708   set_nfs_fh3( &amp;arg.dir, p_dir_hdl );
01709   arg.name = obj_name;
01710 
01711   <span class="comment">/* extract expoort id */</span>  
01712   exportid = nfs3_FhandleToExportId( &amp;arg.dir ) ;
01713   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01714   {
01715     <span class="comment">/* invalid handle */</span>
01716     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01717     <span class="keywordflow">return</span> -1 ;
01718   }
01719 
01720     
01721   rc = nfs_Rmdir(
01722                     (nfs_arg_t*)&amp;arg,
01723                     pexport,
01724                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01725                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01726                     ht,
01727                     &amp;req,
01728                     (nfs_res_t*)&amp;res
01729                  );
01730 
01731    <span class="keywordflow">if</span> ( rc != 0 )
01732    {
01733      fprintf(output,<span class="stringliteral">"Error %d in nfs_Rmdir.\n"</span>,rc);
01734      <span class="keywordflow">return</span> rc;
01735    }
01736 
01737    rc = res.status;
01738    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01739    {
01740      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01741          rc,nfsstat3_to_str(rc));
01742      nfs_Rmdir_Free( (nfs_res_t*)&amp;res );   
01743      <span class="keywordflow">return</span> rc;
01744    }
01745    
01746   nfs_Rmdir_Free( (nfs_res_t*)&amp;res );   
01747   <span class="keywordflow">return</span> 0;
01748   
01749 } <span class="comment">/* nfs_rmdir */</span>
01750 
01751 
01752 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_remove( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01753                       <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_dir_hdl, <span class="keywordtype">char</span> * obj_name,
01754                        FILE * output )
01755 {
01756   diropargs3 arg;
01757   REMOVE3res res;
01758   <span class="keyword">struct </span>svc_req req;
01759   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01760   exportlist_t  * pexport;
01761   <span class="keywordtype">int</span> rc;
01762   
01763   <span class="comment">/* preparing request identifier */</span>
01764 
01765   req.rq_prog = NFS_PROGRAM;
01766   req.rq_vers = NFS_V3;      
01767   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01768 
01769   <span class="comment">/* preparing arguments */</span>
01770   
01771   set_nfs_fh3( &amp;arg.dir, p_dir_hdl);
01772   arg.name = obj_name;
01773 
01774   <span class="comment">/* extract export id */</span>
01775   
01776   exportid = nfs3_FhandleToExportId( &amp;arg.dir ) ;
01777   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01778   {
01779     <span class="comment">/* invalid handle */</span>
01780     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01781     <span class="keywordflow">return</span> -1 ;
01782   }
01783   
01784   
01785   rc = nfs_Remove(
01786                     (nfs_arg_t*)&amp;arg,
01787                     pexport,
01788                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01789                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01790                     ht,
01791                     &amp;req,
01792                     (nfs_res_t*)&amp;res
01793                  );
01794 
01795    <span class="keywordflow">if</span> ( rc != 0 )
01796    {
01797      fprintf(output,<span class="stringliteral">"Error %d in nfs_Remove.\n"</span>,rc);
01798      <span class="keywordflow">return</span> rc;
01799    }
01800 
01801    rc = res.status;
01802    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01803    {
01804      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01805          rc,nfsstat3_to_str(rc));
01806      nfs_Remove_Free( (nfs_res_t*)&amp;res );
01807      <span class="keywordflow">return</span> rc;
01808    }
01809    
01810   nfs_Remove_Free( (nfs_res_t*)&amp;res );
01811   <span class="keywordflow">return</span> 0;
01812   
01813 } <span class="comment">/* nfs_remove */</span>
01814 
01815 
01816 
01817 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_setattr( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01818                         <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_obj_hdl, sattr3 * p_attributes,                        
01819                         FILE * output )
01820 {
01821   SETATTR3args arg;
01822   SETATTR3res res;
01823   <span class="keyword">struct </span>svc_req req;
01824   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01825   exportlist_t  * pexport;
01826   <span class="keywordtype">int</span> rc;
01827   
01828   <span class="comment">/* preparing request identifier */</span>
01829 
01830   req.rq_prog = NFS_PROGRAM;
01831   req.rq_vers = NFS_V3;      
01832   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01833 
01834   <span class="comment">/* preparing arguments */</span>
01835   
01836   set_nfs_fh3( &amp;arg.object , p_obj_hdl );
01837   arg.new_attributes = *p_attributes;
01838   arg.guard.check = FALSE;
01839   
01840   <span class="comment">/* extract export id */</span>
01841   exportid = nfs3_FhandleToExportId( &amp;arg.object ) ;
01842   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01843   {
01844     <span class="comment">/* invalid handle */</span>
01845     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01846     <span class="keywordflow">return</span> -1 ;
01847   }
01848   
01849   
01850   rc = nfs_Setattr(
01851                     (nfs_arg_t*)&amp;arg,
01852                     pexport,
01853                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01854                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01855                     ht,
01856                     &amp;req,
01857                     (nfs_res_t*)&amp;res
01858                  );
01859 
01860    <span class="keywordflow">if</span> ( rc != 0 )
01861    {
01862      fprintf(output,<span class="stringliteral">"Error %d in nfs_Setattr.\n"</span>,rc);
01863      <span class="keywordflow">return</span> rc;
01864    }
01865 
01866    rc = res.status;
01867    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01868    {
01869      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01870          rc,nfsstat3_to_str(rc));
01871      nfs_Setattr_Free( (nfs_res_t*)&amp;res );
01872      <span class="keywordflow">return</span> rc;
01873    }
01874 
01875   nfs_Setattr_Free( (nfs_res_t*)&amp;res );
01876   <span class="keywordflow">return</span> 0;
01877   
01878 } <span class="comment">/*nfs_setattr*/</span>
01879 
01880 
01881 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_rename( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01882                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_src_dir_hdl, <span class="keywordtype">char</span> * src_name,
01883                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_tgt_dir_hdl, <span class="keywordtype">char</span> * tgt_name,
01884                        FILE * output )
01885 {
01886   RENAME3args arg;
01887   RENAME3res res;
01888   <span class="keyword">struct </span>svc_req req;
01889   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01890   exportlist_t  * pexport;
01891   <span class="keywordtype">int</span> rc;
01892   
01893   <span class="comment">/* preparing request identifier */</span>
01894 
01895   req.rq_prog = NFS_PROGRAM;
01896   req.rq_vers = NFS_V3;      
01897   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01898 
01899  
01900   <span class="comment">/* preparing arguments */</span>
01901   
01902   set_nfs_fh3( &amp;arg.from.dir, p_src_dir_hdl );
01903   arg.from.name = src_name;
01904   set_nfs_fh3( &amp;arg.to.dir, p_tgt_dir_hdl);
01905   arg.to.name = tgt_name;
01906 
01907   <span class="comment">/* extract export id */</span>
01908   exportid = nfs3_FhandleToExportId( &amp;arg.from.dir ) ;
01909   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01910   {
01911     <span class="comment">/* invalid handle */</span>
01912     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01913     <span class="keywordflow">return</span> -1 ;
01914   }
01915 
01916     
01917   rc = nfs_Rename(
01918                     (nfs_arg_t*)&amp;arg,
01919                     pexport,
01920                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01921                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01922                     ht,
01923                     &amp;req,
01924                     (nfs_res_t*)&amp;res
01925                  );
01926 
01927    <span class="keywordflow">if</span> ( rc != 0 )
01928    {
01929      fprintf(output,<span class="stringliteral">"Error %d in nfs_Rename.\n"</span>,rc);
01930      <span class="keywordflow">return</span> rc;
01931    }
01932 
01933    rc = res.status;
01934    <span class="keywordflow">if</span> ( rc != NFS3_OK )
01935    {
01936      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
01937          rc,nfsstat3_to_str(rc));
01938      nfs_Rename_Free( (nfs_res_t*)&amp;res );
01939      <span class="keywordflow">return</span> rc;
01940    }
01941 
01942   nfs_Rename_Free( (nfs_res_t*)&amp;res );
01943   <span class="keywordflow">return</span> 0;
01944   
01945 } <span class="comment">/*nfs_rename*/</span>
01946 
01947 
01948 
01949 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_link( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
01950                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_file_hdl,
01951                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_tgt_dir_hdl, <span class="keywordtype">char</span> * tgt_name,
01952                        FILE * output )
01953 {
01954   LINK3args arg;
01955   LINK3res res;
01956   <span class="keyword">struct </span>svc_req req;
01957   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
01958   exportlist_t  * pexport;
01959   <span class="keywordtype">int</span> rc;
01960   
01961   <span class="comment">/* preparing request identifier */</span>
01962 
01963   req.rq_prog = NFS_PROGRAM;
01964   req.rq_vers = NFS_V3;      
01965   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
01966 
01967   <span class="comment">/* preparing arguments */</span>
01968   
01969   set_nfs_fh3( &amp;arg.file, p_file_hdl );
01970   set_nfs_fh3( &amp;arg.link.dir, p_tgt_dir_hdl );
01971   arg.link.name = tgt_name;
01972 
01973   <span class="comment">/* extract export id */</span>  
01974   exportid = nfs3_FhandleToExportId( &amp;arg.file ) ;
01975   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
01976   {
01977     <span class="comment">/* invalid handle */</span>
01978     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
01979     <span class="keywordflow">return</span> -1 ;
01980   }
01981   
01982   rc = nfs_Link(
01983                     (nfs_arg_t*)&amp;arg,
01984                     pexport,
01985                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
01986                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
01987                     ht,
01988                     &amp;req,
01989                     (nfs_res_t*)&amp;res
01990                 );
01991 
01992    <span class="keywordflow">if</span> ( rc != 0 )
01993    {
01994      fprintf(output,<span class="stringliteral">"Error %d in nfs_Link.\n"</span>,rc);
01995      <span class="keywordflow">return</span> rc;
01996    }
01997 
01998    rc = res.status;
01999    <span class="keywordflow">if</span> ( rc != NFS3_OK )
02000    {
02001      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
02002          rc,nfsstat3_to_str(rc));
02003      nfs_Link_Free( (nfs_res_t*)&amp;res );
02004      <span class="keywordflow">return</span> rc;
02005    }
02006 
02007   nfs_Link_Free( (nfs_res_t*)&amp;res );
02008   <span class="keywordflow">return</span> 0;
02009   
02010 } <span class="comment">/*nfs_link*/</span>
02011 
02012 
02013 
02014 
02015 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_symlink( <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info,
02016                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> path_hdl, <span class="keywordtype">char</span> * link_name,
02017                        <span class="keywordtype">char</span> * link_content, sattr3 * p_setattr,
02018                        <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_link_hdl,
02019                        FILE * output )
02020 {
02021   SYMLINK3args arg;
02022   SYMLINK3res res;
02023   <span class="keyword">struct </span>svc_req req;
02024   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> exportid;
02025   exportlist_t  * pexport;
02026   <span class="keywordtype">int</span> rc;
02027   
02028   <span class="comment">/* preparing request identifier */</span>
02029 
02030   req.rq_prog = NFS_PROGRAM;
02031   req.rq_vers = NFS_V3;      
02032   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
02033 
02034   
02035   <span class="comment">/* preparing arguments */</span>
02036   
02037   set_nfs_fh3( &amp;arg.where.dir, &amp;path_hdl );
02038   arg.where.name = link_name;
02039   arg.symlink.symlink_attributes = *p_setattr;
02040   arg.symlink.symlink_data = link_content;
02041 
02042   exportid = nfs3_FhandleToExportId( &amp;arg.where.dir ) ;
02043   <span class="keywordflow">if</span>( ( pexport = nfs_Get_export_by_id( pexportlist, exportid ) ) == NULL )
02044   {
02045     <span class="comment">/* invalid handle */</span>
02046     fprintf( output, <span class="stringliteral">"\tBad arguments: Invalid file handle.\n"</span> );
02047     <span class="keywordflow">return</span> -1 ;
02048   }
02049 
02050     
02051   rc = nfs_Symlink(
02052                     (nfs_arg_t*)&amp;arg,
02053                     pexport,
02054                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
02055                     &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
02056                     ht,
02057                     &amp;req,
02058                     (nfs_res_t*)&amp;res
02059                 );
02060 
02061    <span class="keywordflow">if</span> ( rc != 0 )
02062    {
02063      fprintf(output,<span class="stringliteral">"Error %d in nfs_Symlink.\n"</span>,rc);
02064      <span class="keywordflow">return</span> rc;
02065    }
02066 
02067    rc = res.status;
02068    <span class="keywordflow">if</span> ( rc != NFS3_OK )
02069    {
02070      fprintf(output, <span class="stringliteral">"Error %d in NFSv3 protocol: %s\n"</span>,
02071          rc,nfsstat3_to_str(rc));
02072      <span class="comment">/* free nfs call resources */</span>
02073      nfs_Symlink_Free( (nfs_res_t*)&amp;res );
02074      <span class="keywordflow">return</span> rc;
02075    }
02076 
02077   <span class="comment">/* returned handle */</span>
02078   <span class="keywordflow">if</span> ( res.SYMLINK3res_u.resok.obj.handle_follows )
02079   {
02080     set_shell_fh3( p_link_hdl , &amp;res.SYMLINK3res_u.resok.obj.post_op_fh3_u.handle ) ;
02081   }
02082   <span class="keywordflow">else</span>
02083   {
02084     fprintf(output,<span class="stringliteral">"Warning: nfs_Symlink did not return file handle.\n"</span>);
02085   }
02086   
02087   <span class="comment">/* free nfs call resources */</span>
02088   nfs_Symlink_Free( (nfs_res_t*)&amp;res );
02089   
02090   <span class="keywordflow">return</span> 0;
02091   
02092 } <span class="comment">/*nfs_symlink*/</span>
02093 
02094 
02095 <span class="comment">/*------------------------------------------------------------</span>
02096 <span class="comment"> *          High level, shell-like commands </span>
02097 <span class="comment"> *-----------------------------------------------------------*/</span>
02098 
<a name="l02100"></a><a class="code" href="commands__NFS_8c.html#a41">02100</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a41">fn_nfs_mount</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
02101                   <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
02102                   FILE * output   )   <span class="comment">/* IN : output stream          */</span>
02103 {
02104   nfs_arg_t nfs_arg;
02105   nfs_res_t nfs_res;
02106   <span class="keyword">struct </span>svc_req req;
02107   <span class="keywordtype">int</span> rc;
02108   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02109   mountres3 * p_mountres = ( mountres3 *) &amp;nfs_res ;
02110 
02111   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02112       
02113   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02114   {
02115     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02116     <span class="keywordflow">return</span> -1 ;
02117   }
02118   
02119   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02120   
02121   <span class="comment">/* We only need to init thread in mount command. */</span>
02122   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
02123   {
02124     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
02125     {
02126       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
02127       <span class="keywordflow">return</span> -1 ;
02128     }
02129   }
02130 
02131   <span class="comment">/* check if a path has already been mounted */</span>
02132   
02133   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != FALSE )
02134   {
02135     fprintf( output, <span class="stringliteral">"%s: a path is already mounted. Use \"umount\" command first.\n"</span>,argv[0] );
02136     <span class="keywordflow">return</span> -1 ;
02137   }
02138   
02139       
02140   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
02141                        argc - 1, argv + 1,
02142                        0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
02143                        (caddr_t)&amp;nfs_arg ) == FALSE )
02144   {
02145     fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
02146     fprintf(output,<span class="stringliteral">"Usage: mount &lt;path&gt;.\n"</span>);
02147     <span class="keywordflow">return</span> -1;
02148   }
02149     
02150   <span class="comment">/* preparing request identifier */</span>
02151   req.rq_prog = MOUNTPROG;
02152   req.rq_vers = MOUNT_V3;  
02153   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
02154 
02155   <span class="comment">/* nfs call */</span>
02156 
02157   rc = mnt_Mnt(
02158                   &amp;nfs_arg,
02159                   <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>,
02160                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
02161                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
02162                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
02163                   &amp;req,
02164                   &amp;nfs_res
02165                );
02166   
02167    <span class="comment">/* freeing args */</span>
02168       
02169    <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
02170                    0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
02171                    (caddr_t)&amp;nfs_arg );
02172   
02173    <span class="keywordflow">if</span> ( rc != 0 )
02174    {
02175      fprintf(output,<span class="stringliteral">"%s: Error %d in mnt_Mnt.\n"</span>,argv[0],rc);
02176      <span class="keywordflow">return</span> rc;
02177    }
02178    
02179    rc = p_mountres-&gt;fhs_status;
02180    <span class="keywordflow">if</span> ( rc != MNT3_OK )
02181    {
02182      mnt3_Mnt_Free( &amp;nfs_res );
02183      fprintf(output, <span class="stringliteral">"%s: Error %d in MNT3 protocol.\n"</span>,argv[0],rc);
02184      <span class="keywordflow">return</span> rc;
02185    }
02186    
02187    set_shell_fh3( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o7">mounted_path_hdl</a>,
02188                   (nfs_fh3*)&amp;p_mountres-&gt;mountres3_u.mountinfo.fhandle );
02189    
02190    mnt3_Mnt_Free( &amp;nfs_res );
02191 
02192    strcpy( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o8">mounted_path</a> , argv[1] );
02193       
02194    p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a> = p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o7">mounted_path_hdl</a>;
02195    strcpy( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a> , <span class="stringliteral">"/"</span> );
02196    
02197    p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> = TRUE;
02198    
02199    fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a> ) ;
02200    snprintmem( buff, 2*NFS3_FHSIZE+1,
02201       (caddr_t)p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02202       p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02203    fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02204   
02205   <span class="keywordflow">return</span> 0;
02206 }
02207 
02208 
02209 
<a name="l02211"></a><a class="code" href="commands__NFS_8c.html#a42">02211</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a42">fn_nfs_umount</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
02212                    <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
02213                    FILE * output   )   <span class="comment">/* IN : output stream          */</span>
02214 {
02215   nfs_arg_t nfs_arg;
02216   nfs_res_t nfs_res;
02217   <span class="keyword">struct </span>svc_req req;
02218   <span class="keywordtype">int</span> rc;
02219   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02220   mountres3 * p_mountres = ( mountres3 *) &amp;nfs_res ;
02221 
02222   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02223       
02224   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02225   {
02226     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02227     <span class="keywordflow">return</span> -1 ;
02228   }
02229   
02230   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02231   
02232   <span class="comment">/* We only need to init thread in mount command. */</span>
02233   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
02234   {
02235     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
02236     {
02237       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
02238       <span class="keywordflow">return</span> -1 ;
02239     }
02240   }
02241 
02242   <span class="comment">/* check if a path has already been mounted */</span>
02243   
02244   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02245   {
02246     fprintf( output, <span class="stringliteral">"%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02247     <span class="keywordflow">return</span> -1 ;
02248   }
02249   
02250       
02251   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
02252                        argc - 1, argv + 1,
02253                        0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
02254                        (caddr_t)&amp;nfs_arg ) == FALSE )
02255   {
02256     fprintf(output,<span class="stringliteral">"%s: bad arguments.\n"</span>,argv[0]);
02257     fprintf(output,<span class="stringliteral">"Usage: umount &lt;path&gt;.\n"</span>);
02258     <span class="keywordflow">return</span> -1;
02259   }
02260 
02261   <span class="keywordflow">if</span> (strncmp(argv[1], p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o8">mounted_path</a>, NFS2_MAXPATHLEN)) {
02262     fprintf(output, <span class="stringliteral">"%s: this path is not mounted.\n"</span>, argv[0]);
02263     fprintf(output, <span class="stringliteral">"Current monted path : %s.\n"</span>, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o8">mounted_path</a>);
02264     <span class="keywordflow">return</span> -1;
02265   }
02266     
02267   <span class="comment">/* preparing request identifier */</span>
02268   req.rq_prog = MOUNTPROG;
02269   req.rq_vers = MOUNT_V3;  
02270   req.rq_clntcred = (caddr_t) &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o3">authunix_struct</a> ;
02271 
02272   <span class="comment">/* nfs call */</span>
02273 
02274   rc = mnt_Umnt(
02275                   &amp;nfs_arg,
02276                   <a class="code" href="commands__NFS_8c.html#a9">pexportlist</a>,
02277                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>),
02278                   &amp;(p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o4">client</a>),
02279                   <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
02280                   &amp;req,
02281                   &amp;nfs_res
02282                );
02283   
02284    <span class="comment">/* freeing args */</span>
02285       
02286    <a class="code" href="cmd__nfstools_8h.html#a16">cmdnfs_dirpath</a>( <a class="code" href="cmd__nfstools_8h.html#a70a14">CMDNFS_FREE</a>,
02287                    0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,0,<a class="code" href="Getopt_8c.html#a0">NULL</a>,
02288                    (caddr_t)&amp;nfs_arg );
02289   
02290    <span class="keywordflow">if</span> ( rc != 0 )
02291    {
02292     fprintf(output,<span class="stringliteral">"%s: Error %d in mnt_Umnt.\n"</span>,argv[0],rc);
02293      <span class="keywordflow">return</span> rc;
02294    }
02295    
02296    mnt_Umnt_Free( &amp;nfs_res );
02297 
02298    p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> = FALSE;
02299    
02300   <span class="keywordflow">return</span> 0;
02301 }
02302 
02303 
02304 
<a name="l02306"></a><a class="code" href="commands__NFS_8c.html#a43">02306</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a43">fn_nfs_pwd</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
02307                 <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
02308                 FILE * output   )   <span class="comment">/* IN : output stream          */</span>
02309 {
02310   <span class="keywordtype">int</span> rc;
02311   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02312   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02313       
02314   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02315   {
02316     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02317     <span class="keywordflow">return</span> -1 ;
02318   }
02319   
02320   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02321   
02322   <span class="comment">/* check if a path has been mounted */</span>
02323   
02324   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02325   {
02326     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02327     <span class="keywordflow">return</span> -1 ;
02328   }
02329   
02330   fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a> ) ;
02331   snprintmem( buff, 2*NFS3_FHSIZE+1,
02332       (caddr_t)p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02333       p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02334   fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02335   
02336   <span class="keywordflow">return</span> 0;  
02337 }
02338 
02339 
<a name="l02341"></a><a class="code" href="commands__NFS_8c.html#a44">02341</a> <span class="keywordtype">int</span>  <a class="code" href="commands__NFS_8c.html#a44">fn_nfs_ls</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02342                 <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02343                 FILE * output )    <span class="comment">/* IN : output stream          */</span>
02344 {
02345 <span class="preprocessor">#define NFS_READDIR_SIZE 10</span>
02346 <span class="preprocessor"></span>  
02347   <span class="keywordtype">char</span> linkdata[NFS2_MAXPATHLEN];
02348   <span class="keywordtype">char</span> item_path[NFS2_MAXPATHLEN];
02349   <span class="keywordtype">char</span> * str_name = <span class="stringliteral">"."</span> ;
02350   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> handle_tmp;
02351   fattr3 attrs;
02352   cookie3 begin_cookie;
02353   bool_t  eod_met;
02354   cookieverf3 cookieverf;
02355   dirlistplus3 dirlist;
02356   entryplus3 * p_entry;
02357   
02358   fattr3 * p_attrs;
02359   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> hdl;
02360   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> * p_hdl = NULL;
02361 
02362   nfs_res_t * to_free = NULL;
02363       
02364   <span class="keywordtype">int</span> rc = 0 ;
02365   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02366 
02367   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvdlSHz"</span>;
02368   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ls[]=<span class="stringliteral">"usage: ls [options] [name|path]\n"</span>
02369     <span class="stringliteral">"options :\n"</span>
02370     <span class="stringliteral">"\t-h print this help\n"</span>
02371     <span class="stringliteral">"\t-v verbose mode\n"</span>
02372     <span class="stringliteral">"\t-d print directory info instead of listing its content\n"</span>      
02373     <span class="stringliteral">"\t-l print standard UNIX attributes\n"</span>
02374     <span class="stringliteral">"\t-S print all supported attributes\n"</span>
02375     <span class="stringliteral">"\t-H print the NFS handle\n"</span> 
02376     <span class="stringliteral">"\t-z silent mode (print nothing)\n"</span> ;
02377   
02378   <span class="keywordtype">int</span> option;
02379   <span class="keywordtype">int</span> flag_v = 0;
02380   <span class="keywordtype">int</span> flag_h = 0;
02381   <span class="keywordtype">int</span> flag_d = 0;
02382   <span class="keywordtype">int</span> flag_l = 0;
02383   <span class="keywordtype">int</span> flag_S = 0;
02384   <span class="keywordtype">int</span> flag_H = 0 ;
02385   <span class="keywordtype">int</span> flag_z = 0 ;
02386   <span class="keywordtype">int</span> err_flag = 0;
02387 
02388   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02389       
02390   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02391   {
02392     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02393     <span class="keywordflow">return</span> -1 ;
02394   }
02395   
02396   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02397   
02398   <span class="comment">/* check if a path has been mounted */</span>
02399   
02400   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02401   {
02402     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02403     <span class="keywordflow">return</span> -1 ;
02404   }
02405   
02406     
02407   <span class="comment">/* analysing options */</span>
02408   getopt_init();
02409 
02410   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
02411     {   
02412       <span class="keywordflow">switch</span>( option )
02413         {
02414         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02415           <span class="keywordflow">if</span> (flag_v)
02416             fprintf(output,
02417                     <span class="stringliteral">"ls: warning: option 'v' has been specified more than once.\n"</span>);
02418           <span class="keywordflow">else</span> 
02419             flag_v++;
02420           <span class="keywordflow">break</span>;
02421           
02422         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02423           <span class="keywordflow">if</span> ( flag_h )
02424             fprintf(output,
02425                     <span class="stringliteral">"ls: warning: option 'h' has been specified more than once.\n"</span>);
02426           <span class="keywordflow">else</span> 
02427             flag_h++;
02428           <span class="keywordflow">break</span>;
02429           
02430         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
02431           <span class="keywordflow">if</span> ( flag_d )
02432             fprintf(output,
02433                     <span class="stringliteral">"ls: warning: option 'd' has been specified more than once.\n"</span>);
02434           <span class="keywordflow">else</span> 
02435             flag_d++;
02436           <span class="keywordflow">break</span>;
02437           
02438         <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
02439           <span class="keywordflow">if</span> ( flag_l )
02440             fprintf(output,
02441                     <span class="stringliteral">"ls: warning: option 'l' has been specified more than once.\n"</span>);
02442           <span class="keywordflow">else</span> 
02443             flag_l++;
02444           <span class="keywordflow">break</span>;
02445           
02446         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02447           <span class="keywordflow">if</span> ( flag_S )
02448             fprintf(output,
02449                     <span class="stringliteral">"ls: warning: option 'S' has been specified more than once.\n"</span>);
02450           <span class="keywordflow">else</span> 
02451             flag_S++;
02452           <span class="keywordflow">break</span>;
02453           
02454         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
02455           <span class="keywordflow">if</span> ( flag_z )
02456             fprintf(output,
02457                     <span class="stringliteral">"ls: warning: option 'z' has been specified more than once.\n"</span>);
02458           <span class="keywordflow">else</span> 
02459             flag_z++;
02460           <span class="keywordflow">break</span>;
02461 
02462         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
02463           <span class="keywordflow">if</span>( flag_H )
02464             fprintf(output,
02465                     <span class="stringliteral">"ls: warning: option 'H' has been specified more than once.\n"</span>);
02466           <span class="keywordflow">else</span> 
02467             flag_H++;
02468           <span class="keywordflow">break</span>;
02469           
02470         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02471           fprintf(output,<span class="stringliteral">"ls: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02472           err_flag ++;
02473           <span class="keywordflow">break</span>;
02474         }
02475     } <span class="comment">/* while */</span>
02476   
02477   <span class="keywordflow">if</span>( flag_l + flag_S + flag_H &gt; 1 )
02478     {
02479       fprintf(output,<span class="stringliteral">"ls: conflict between options l,S,H\n"</span>);
02480       err_flag++;
02481     }
02482 
02483   <span class="keywordflow">if</span>( flag_z + flag_v &gt; 1 )
02484     {
02485       fprintf( output, <span class="stringliteral">"ls: can't use -z and -v at the same time\n"</span> ) ;
02486       err_flag ++ ;
02487     }
02488   
02489   <span class="keywordflow">if</span>( flag_h )
02490     {
02491       fprintf(output,help_ls);
02492       <span class="keywordflow">return</span> 0;
02493     }
02494   
02495   <span class="keywordflow">if</span>( err_flag )
02496     {
02497       fprintf(output,help_ls);
02498       <span class="keywordflow">return</span> -1;
02499     }
02500   
02501   <span class="comment">/* copy current global path */</span>
02502   strncpy(glob_path,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
02503 
02504   <span class="comment">/* first, retrieve the argument (if any) */</span>
02505   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> == argc -1  )
02506     { 
02507       str_name = argv[Optind];
02508       
02509       <span class="comment">/* retrieving handle */</span>  
02510       <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info,
02511                              glob_path,
02512                              NFS2_MAXPATHLEN,
02513                              str_name, 
02514                              &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, 
02515                              &amp;handle_tmp,
02516                              output))
02517         <span class="keywordflow">return</span> rc;
02518     } 
02519   <span class="keywordflow">else</span> 
02520     {
02521       str_name = <span class="stringliteral">"."</span>;
02522       handle_tmp = p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a> ;
02523     }
02524   
02525   <span class="keywordflow">if</span>( flag_v )
02526     fprintf(output,<span class="stringliteral">"proceeding ls (using NFS protocol) on \"%s\"\n"</span>, glob_path );
02527   
02528   <span class="keywordflow">if</span> ( rc = nfs_getattr( p_thr_info, &amp;handle_tmp, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
02529   
02530  <span class="comment">/*</span>
02531 <span class="comment">  * if the object is a file or a directoy with the -d option specified,</span>
02532 <span class="comment">  * we only show its info and exit.</span>
02533 <span class="comment">  */</span>  
02534   <span class="keywordflow">if</span> ( ( attrs.type != NF3DIR ) || flag_d )
02535     {
02536       <span class="keywordflow">if</span> ( (attrs.type == NF3LNK) &amp;&amp; flag_l )
02537         {
02538             <span class="keywordflow">if</span> ( rc = nfs_readlink( p_thr_info, &amp;handle_tmp, linkdata, output ) )
02539               <span class="keywordflow">return</span> rc;
02540         }
02541       
02542       <span class="keywordflow">if</span>( flag_l )
02543         {
02544           <span class="keywordflow">if</span>( !flag_z )
02545             <a class="code" href="cmd__nfstools_8h.html#a68">print_nfsitem_line</a>( output, &amp;attrs, str_name, linkdata );
02546         }
02547       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_S )
02548         {
02549           <span class="keywordflow">if</span>( !flag_z )
02550             {
02551               fprintf(output,<span class="stringliteral">"%s :\n"</span>,str_name);
02552               <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( &amp;attrs, output );
02553             }
02554         } 
02555       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_H )
02556         {
02557           <span class="keywordflow">if</span>( !flag_z )
02558             {
02559               <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
02560               
02561               snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)handle_tmp.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02562                           handle_tmp.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02563               fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, str_name, buff ) ;
02564             }
02565         }
02566       <span class="keywordflow">else</span>  <span class="comment">/* only prints the name */</span>
02567         {
02568           <span class="keywordflow">if</span>( !flag_z )
02569             fprintf(output,<span class="stringliteral">"%s\n"</span>,str_name);
02570         }
02571         
02572       <span class="keywordflow">return</span> 0;
02573     }
02574   
02575   <span class="comment">/* If this point is reached, then the current element is a directory */</span>
02576   
02577   begin_cookie = 0LL ;
02578   eod_met = FALSE ;
02579   memset( &amp;cookieverf, 0, <span class="keyword">sizeof</span>(cookieverf3) );
02580   
02581   <span class="keywordflow">while</span>( ! eod_met )
02582     {
02583       
02584       <span class="keywordflow">if</span>( flag_v )
02585          fprintf( output, <span class="stringliteral">"--&gt;nfs3_Readdirplus( path=%s, cookie=%llu )\n"</span>,
02586                   glob_path,
02587                   begin_cookie ) ;
02588 
02589       <span class="keywordflow">if</span> ( rc = nfs_readdirplus( p_thr_info,
02590                                  &amp;handle_tmp,
02591                                  begin_cookie,
02592                                  &amp;cookieverf, <span class="comment">/* IN/OUT */</span>
02593                                  &amp;dirlist,
02594                                  &amp;to_free,
02595                                  output ) )
02596         <span class="keywordflow">return</span> rc;
02597 
02598       p_entry = dirlist.entries;
02599       
02600       
02601       <span class="keywordflow">while</span> ( p_entry )
02602         {
02603         <span class="keywordtype">int</span> len;
02604         
02605           <span class="keywordflow">if</span> (!strcmp(str_name,<span class="stringliteral">"."</span>))
02606             strncpy(item_path,p_entry-&gt;name,NFS2_MAXPATHLEN);          
02607           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_name[strlen(str_name)-1] == <span class="charliteral">'/'</span>)
02608             snprintf(item_path,NFS2_MAXPATHLEN,<span class="stringliteral">"%s%s"</span>,str_name,p_entry-&gt;name);
02609           <span class="keywordflow">else</span>
02610             snprintf(item_path,NFS2_MAXPATHLEN,<span class="stringliteral">"%s/%s"</span>,str_name,p_entry-&gt;name);
02611           
02612           <span class="comment">/* interpreting post-op attributes */</span>
02613           
02614           <span class="keywordflow">if</span> ( p_entry-&gt;name_attributes.attributes_follow )
02615             p_attrs = &amp;p_entry-&gt;name_attributes.post_op_attr_u.attributes;
02616           <span class="keywordflow">else</span>
02617             p_attrs = NULL;
02618 
02619           <span class="comment">/* interpreting post-op handle */</span>
02620           
02621           <span class="keywordflow">if</span> ( p_entry-&gt;name_handle.handle_follows )
02622           {
02623             set_shell_fh3( &amp;hdl, &amp;p_entry-&gt;name_handle.post_op_fh3_u.handle );
02624             p_hdl = &amp;hdl;
02625           }
02626           <span class="keywordflow">else</span>
02627             p_hdl = NULL;
02628 
02629 
02630           <span class="keywordflow">if</span>( (p_attrs != NULL)
02631                 &amp;&amp; (p_hdl != NULL)
02632                 &amp;&amp; (p_attrs-&gt;type == NF3LNK ) )
02633             {
02634               <span class="keywordflow">if</span> ( rc = nfs_readlink( p_thr_info, p_hdl, linkdata, output ))
02635                 <span class="keywordflow">return</span> rc;
02636             }
02637           
02638           <span class="keywordflow">if</span>( (p_attrs != NULL) &amp;&amp; flag_l )
02639             {
02640               <a class="code" href="cmd__nfstools_8h.html#a68">print_nfsitem_line</a>( output, p_attrs, item_path, linkdata);
02641             }
02642           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (p_attrs != NULL) &amp;&amp; flag_S )
02643             {
02644               fprintf(output,<span class="stringliteral">"%s :\n"</span>,item_path);
02645               <span class="keywordflow">if</span>( !flag_z )
02646                 <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( p_attrs, output);
02647             }
02648           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (p_hdl != NULL) &amp;&amp; flag_H )
02649             {
02650               <span class="keywordflow">if</span>( !flag_z )
02651                 {
02652                   <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
02653 
02654                   snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)p_hdl-&gt;<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02655                               p_hdl-&gt;<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02656                   fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, item_path, buff ) ;                  
02657                 }
02658             }
02659           <span class="keywordflow">else</span>
02660             {
02661               <span class="keywordflow">if</span>( !flag_z )
02662                 fprintf(output,<span class="stringliteral">"%s\n"</span>,item_path);
02663             }
02664             
02665           begin_cookie = p_entry-&gt;cookie ;
02666           p_entry = p_entry-&gt;nextentry;
02667         }
02668         
02669       <span class="comment">/* Ready for next iteration */</span>
02670       eod_met = dirlist.eof;
02671       
02672     }
02673   
02674   <a class="code" href="commands__NFS_8c.html#a32">nfs_readdirplus_free</a>( to_free );
02675 
02676   <span class="keywordflow">return</span> 0;
02677 } <span class="comment">/* fn_nfs_ls */</span>
02678 
02679 
02680 
<a name="l02682"></a><a class="code" href="commands__NFS_8c.html#a45">02682</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a45">fn_nfs_cd</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02683         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02684         FILE * output      <span class="comment">/* IN : output stream          */</span>
02685       ){
02686 
02687   
02688   <span class="keyword">static</span> <span class="keywordtype">char</span> help_cd[]=
02689   <span class="stringliteral">"usage: cd &lt;path&gt;\n"</span>;
02690 
02691   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02692   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl;
02693   <span class="keywordtype">int</span> rc;
02694   fattr3 attrs;
02695   nfs3_uint32 mask;
02696     
02697   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02698       
02699   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02700   {
02701     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02702     <span class="keywordflow">return</span> -1 ;
02703   }
02704   
02705   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02706   
02707   <span class="comment">/* check if a path has been mounted */</span>
02708   
02709   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02710   {
02711     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02712     <span class="keywordflow">return</span> -1 ;
02713   }
02714   
02715   <span class="comment">/* Exactly one arg expected */</span>
02716   <span class="keywordflow">if</span> (argc!=2){
02717     fprintf(output,help_cd);
02718     <span class="keywordflow">return</span> -1;
02719   }
02720   
02721   strncpy(glob_path, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, NFS2_MAXPATHLEN);
02722   
02723   <span class="keywordflow">if</span> (rc = 
02724       nfs_solvepath( p_thr_info, glob_path, NFS2_MAXPATHLEN,
02725                      argv[1],&amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;new_hdl,output))
02726     <span class="keywordflow">return</span> rc;
02727 
02728   <span class="comment">/* verify if the object is a directory */</span>
02729   
02730   <span class="keywordflow">if</span> ( rc = nfs_getattr( p_thr_info, &amp;new_hdl, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
02731   
02732   <span class="keywordflow">if</span> (attrs.type != NF3DIR)
02733   {
02734     fprintf(output,<span class="stringliteral">"Error: %s is not a directory\n"</span>,glob_path);
02735     <span class="keywordflow">return</span> ENOTDIR;
02736   }
02737   
02738   <span class="comment">/* verify lookup permission  */</span>  
02739   mask = ACCESS3_LOOKUP;
02740   <span class="keywordflow">if</span> ( rc = nfs_access( p_thr_info, &amp;new_hdl, &amp;mask, output ) ) <span class="keywordflow">return</span> rc;
02741   
02742   <span class="keywordflow">if</span> ( ! ( mask &amp; ACCESS3_LOOKUP ) )
02743   {
02744     fprintf(output,<span class="stringliteral">"Error: %s: permission denied.\n"</span>,glob_path);
02745     <span class="keywordflow">return</span> EACCES;
02746   }
02747   
02748   <span class="comment">/* if so, apply changes */</span>
02749   strncpy( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, glob_path, NFS2_MAXPATHLEN );   
02750   p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a> = new_hdl;
02751     
02752   {
02753     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02754     fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a> ) ;
02755     snprintmem( buff, 2*NFS3_FHSIZE+1,
02756         (caddr_t)p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02757         p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02758     fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ); 
02759   }
02760   
02761   <span class="keywordflow">return</span> 0;
02762       
02763 }
02764 
02765 
02766 
<a name="l02768"></a><a class="code" href="commands__NFS_8c.html#a46">02768</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a46">fn_nfs_create</a>(
02769                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02770                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02771                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02772                   )
02773 {
02774   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02775    
02776   <span class="keyword">static</span> <span class="keywordtype">char</span> help_create[]=
02777   <span class="stringliteral">"usage: create [-h][-v] &lt;path&gt; &lt;mode&gt;\n"</span>
02778   <span class="stringliteral">"       path: path of the file to be created\n"</span>
02779   <span class="stringliteral">"       mode: octal mode for the directory to be created (ex: 644)\n"</span> ;
02780 
02781   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02782   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl ;
02783   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
02784   <span class="keywordtype">int</span> rc,option;
02785   <span class="keywordtype">int</span> flag_v=0;
02786   <span class="keywordtype">int</span> flag_h=0;
02787   <span class="keywordtype">int</span> err_flag=0;
02788   <span class="keywordtype">int</span> mode = 0644;
02789   
02790   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
02791   <span class="keywordtype">char</span> * path;
02792   <span class="keywordtype">char</span> * file;
02793   <span class="keywordtype">char</span> * strmode;
02794   
02795   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02796       
02797   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02798   {
02799     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02800     <span class="keywordflow">return</span> -1 ;
02801   }
02802   
02803   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02804   
02805   <span class="comment">/* check if a path has been mounted */</span>
02806   
02807   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02808   {
02809     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02810     <span class="keywordflow">return</span> -1 ;
02811   }
02812   
02813   <span class="comment">/* analysing options */</span>
02814   getopt_init();
02815   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02816     <span class="keywordflow">switch</span>( option )
02817       {
02818       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02819         <span class="keywordflow">if</span>( flag_v )
02820           fprintf( output, <span class="stringliteral">"create: warning: option 'v' has been specified more than once.\n"</span>);
02821         <span class="keywordflow">else</span> flag_v++;
02822         <span class="keywordflow">break</span>;
02823         
02824       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02825         <span class="keywordflow">if</span>( flag_h )
02826           fprintf( output, <span class="stringliteral">"create: warning: option 'h' has been specified more than once.\n"</span>);
02827         <span class="keywordflow">else</span> flag_h++;
02828         <span class="keywordflow">break</span>;
02829         
02830       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02831         fprintf( output,<span class="stringliteral">"create: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02832         err_flag ++;
02833         <span class="keywordflow">break</span>;
02834     }    
02835   }
02836   
02837   <span class="keywordflow">if</span>( flag_h )
02838     {
02839       fprintf( output, help_create);
02840       <span class="keywordflow">return</span> 0;
02841     }
02842   
02843   <span class="comment">/* Exactly 2 args expected */</span>
02844   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02845     {
02846       err_flag ++;
02847     }
02848   <span class="keywordflow">else</span> 
02849     {
02850       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
02851       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02852       
02853       strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
02854   
02855       <span class="comment">/* converting mode string to posix mode */</span>
02856       mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );
02857       <span class="keywordflow">if</span>( mode&lt;0 ) err_flag ++;
02858     }
02859     
02860   <span class="keywordflow">if</span>( err_flag )
02861     {
02862       fprintf( output, help_create );
02863       <span class="keywordflow">return</span> -1;
02864     }
02865   
02866   <span class="comment">/* copy current path. */</span>
02867   strncpy( glob_path, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, NFS2_MAXPATHLEN );
02868   
02869   <span class="comment">/* retrieves path handle*/</span>
02870   <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info, glob_path, NFS2_MAXPATHLEN,
02871                           path, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, &amp;subdir_hdl,output) )
02872     <span class="keywordflow">return</span> rc;
02873 
02874   
02875   <span class="keywordflow">if</span> ( rc = nfs_create( p_thr_info, &amp;subdir_hdl, file, mode, &amp;new_hdl,output))
02876     <span class="keywordflow">return</span> rc;
02877       
02878 
02879   <span class="keywordflow">if</span>( flag_v )
02880   {
02881     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
02882     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)new_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
02883                 new_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
02884     fprintf(output,<span class="stringliteral">"%s/%s successfully created.\n(handle=@%s)\n"</span>,glob_path,file, buff ) ;
02885   }
02886 
02887   <span class="keywordflow">return</span> 0;  
02888 
02889 
02890 }
02891 
02892 
02893 
<a name="l02895"></a><a class="code" href="commands__NFS_8c.html#a47">02895</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a47">fn_nfs_mkdir</a>(
02896                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02897                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02898                    FILE * output      <span class="comment">/* IN : output stream          */</span>
02899                   )
02900 {
02901   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02902    
02903   <span class="keyword">static</span> <span class="keywordtype">char</span> help_mkdir[]=
02904   <span class="stringliteral">"usage: mkdir [-h][-v] &lt;path&gt; &lt;mode&gt;\n"</span>
02905   <span class="stringliteral">"       path: path of the directory to be created\n"</span>
02906   <span class="stringliteral">"       mode: octal mode for the dir to be created (ex: 755)\n"</span> ;
02907 
02908   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
02909   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> new_hdl ;
02910   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
02911   <span class="keywordtype">int</span> rc,option;
02912   <span class="keywordtype">int</span> flag_v=0;
02913   <span class="keywordtype">int</span> flag_h=0;
02914   <span class="keywordtype">int</span> err_flag=0;
02915   <span class="keywordtype">int</span> mode = 0755;
02916   
02917   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
02918   <span class="keywordtype">char</span> * path;
02919   <span class="keywordtype">char</span> * file;
02920   <span class="keywordtype">char</span> * strmode;
02921   
02922   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
02923       
02924   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
02925   {
02926     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
02927     <span class="keywordflow">return</span> -1 ;
02928   }
02929   
02930   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
02931   
02932   <span class="comment">/* check if a path has been mounted */</span>
02933   
02934   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
02935   {
02936     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
02937     <span class="keywordflow">return</span> -1 ;
02938   }
02939   
02940   <span class="comment">/* analysing options */</span>
02941   getopt_init();
02942   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02943     <span class="keywordflow">switch</span>( option )
02944       {
02945       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02946         <span class="keywordflow">if</span>( flag_v )
02947           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'v' has been specified more than once.\n"</span>);
02948         <span class="keywordflow">else</span> flag_v++;
02949         <span class="keywordflow">break</span>;
02950         
02951       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02952         <span class="keywordflow">if</span>( flag_h )
02953           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'h' has been specified more than once.\n"</span>);
02954         <span class="keywordflow">else</span> flag_h++;
02955         <span class="keywordflow">break</span>;
02956         
02957       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02958         fprintf( output,<span class="stringliteral">"mkdir: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02959         err_flag ++;
02960         <span class="keywordflow">break</span>;
02961     }    
02962   }
02963   
02964   <span class="keywordflow">if</span>( flag_h )
02965     {
02966       fprintf( output, help_mkdir);
02967       <span class="keywordflow">return</span> 0;
02968     }
02969   
02970   <span class="comment">/* Exactly 2 args expected */</span>
02971   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02972     {
02973       err_flag ++;
02974     }
02975   <span class="keywordflow">else</span> 
02976     {
02977       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
02978       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02979       
02980       strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
02981   
02982       <span class="comment">/* converting mode string to posix mode */</span>
02983       mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );
02984       <span class="keywordflow">if</span>( mode&lt;0 ) err_flag ++;
02985     }
02986     
02987   <span class="keywordflow">if</span>( err_flag )
02988     {
02989       fprintf( output, help_mkdir );
02990       <span class="keywordflow">return</span> -1;
02991     }
02992   
02993   <span class="comment">/* copy current path. */</span>
02994   strncpy( glob_path, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, NFS2_MAXPATHLEN );
02995   
02996   <span class="comment">/* retrieves path handle*/</span>
02997   <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info, glob_path, NFS2_MAXPATHLEN,
02998                           path, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, &amp;subdir_hdl,output) )
02999     <span class="keywordflow">return</span> rc;
03000 
03001   
03002   <span class="keywordflow">if</span> ( rc = nfs_mkdir( p_thr_info, &amp;subdir_hdl, file, mode, &amp;new_hdl,output))
03003     <span class="keywordflow">return</span> rc;
03004       
03005 
03006   <span class="keywordflow">if</span>( flag_v )
03007   {
03008     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
03009     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)new_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
03010                 new_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
03011     fprintf(output,<span class="stringliteral">"%s/%s successfully created.\n(handle=@%s)\n"</span>,glob_path,file, buff ) ;
03012   }
03013 
03014   <span class="keywordflow">return</span> 0;  
03015 
03016 
03017 }
03018 
03019 
<a name="l03021"></a><a class="code" href="commands__NFS_8c.html#a48">03021</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a48">fn_nfs_unlink</a>(
03022                    <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03023                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03024                    FILE * output      <span class="comment">/* IN : output stream          */</span>
03025                   )
03026 {
03027   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03028    
03029   <span class="keyword">static</span> <span class="keywordtype">char</span> help_unlink[]=
03030   <span class="stringliteral">"usage: unlink [-h][-v] &lt;path&gt;\n"</span>
03031   <span class="stringliteral">"       path: path of the directory to be unlinkd\n"</span>;
03032   
03033   <span class="keywordtype">char</span> glob_path_parent[NFS2_MAXPATHLEN];
03034   <span class="keywordtype">char</span> glob_path_object[NFS2_MAXPATHLEN];
03035   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> subdir_hdl ;
03036   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> obj_hdl ; 
03037   fattr3 attrs; 
03038   <span class="keywordtype">int</span> rc,option;
03039   <span class="keywordtype">int</span> flag_v=0;
03040   <span class="keywordtype">int</span> flag_h=0;
03041   <span class="keywordtype">int</span> err_flag=0;
03042   
03043   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
03044   <span class="keywordtype">char</span> * path;
03045   <span class="keywordtype">char</span> * file;
03046   
03047   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03048       
03049   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03050   {
03051     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03052     <span class="keywordflow">return</span> -1 ;
03053   }
03054   
03055   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03056   
03057   <span class="comment">/* check if a path has been mounted */</span>
03058   
03059   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03060   {
03061     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03062     <span class="keywordflow">return</span> -1 ;
03063   }
03064   
03065   <span class="comment">/* analysing options */</span>
03066   getopt_init();
03067   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
03068     <span class="keywordflow">switch</span>( option )
03069       {
03070       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03071         <span class="keywordflow">if</span>( flag_v )
03072           fprintf( output, <span class="stringliteral">"unlink: warning: option 'v' has been specified more than once.\n"</span>);
03073         <span class="keywordflow">else</span> flag_v++;
03074         <span class="keywordflow">break</span>;
03075         
03076       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03077         <span class="keywordflow">if</span>( flag_h )
03078           fprintf( output, <span class="stringliteral">"unlink: warning: option 'h' has been specified more than once.\n"</span>);
03079         <span class="keywordflow">else</span> flag_h++;
03080         <span class="keywordflow">break</span>;
03081         
03082       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03083         fprintf( output,<span class="stringliteral">"unlink: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03084         err_flag ++;
03085         <span class="keywordflow">break</span>;
03086     }    
03087   }
03088   
03089   <span class="keywordflow">if</span>( flag_h )
03090     {
03091       fprintf( output, help_unlink);
03092       <span class="keywordflow">return</span> 0;
03093     }
03094   
03095   <span class="comment">/* Exactly 1 args expected */</span>
03096   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) )
03097     {
03098       err_flag ++;
03099     }
03100   <span class="keywordflow">else</span> 
03101     {
03102       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], NFS2_MAXPATHLEN );
03103       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);      
03104     }
03105   
03106   <span class="comment">/* copy current path. */</span>
03107   strncpy( glob_path_parent, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, NFS2_MAXPATHLEN );
03108   
03109   <span class="comment">/* retrieves parent dir handle*/</span>
03110   <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info, glob_path_parent, NFS2_MAXPATHLEN,
03111                           path, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, &amp;subdir_hdl,output) )
03112     <span class="keywordflow">return</span> rc;
03113 
03114    <span class="comment">/* copy parent path */</span>
03115    strncpy( glob_path_object, glob_path_parent, NFS2_MAXPATHLEN );
03116    
03117    <span class="comment">/* lookup on child object */</span>
03118    <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info, glob_path_object, NFS2_MAXPATHLEN,
03119                           file, &amp;subdir_hdl, &amp;obj_hdl, output) )
03120     <span class="keywordflow">return</span> rc;
03121     
03122    <span class="comment">/* get attributes of child object */</span>
03123    <span class="keywordflow">if</span>( flag_v )
03124       fprintf(output,<span class="stringliteral">"Getting attributes for %s...\n"</span>,glob_path_object );
03125 
03126    <span class="keywordflow">if</span> ( rc = nfs_getattr( p_thr_info, &amp;obj_hdl, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
03127 
03128     <span class="keywordflow">if</span> ( attrs.type != NF3DIR )
03129     {
03130       <span class="keywordflow">if</span>( flag_v )
03131         fprintf(output,<span class="stringliteral">"%s is not a directory: calling nfs3_remove...\n"</span>,glob_path_object );
03132       
03133       <span class="keywordflow">if</span> ( rc = nfs_remove( p_thr_info, &amp;subdir_hdl, file, output))
03134         <span class="keywordflow">return</span> rc;
03135     }
03136     <span class="keywordflow">else</span>
03137     {
03138       <span class="keywordflow">if</span>( flag_v )
03139         fprintf(output,<span class="stringliteral">"%s is a directory: calling nfs3_rmdir...\n"</span>,glob_path_object );
03140       
03141       <span class="keywordflow">if</span> ( rc = nfs_rmdir( p_thr_info, &amp;subdir_hdl, file, output))
03142         <span class="keywordflow">return</span> rc;     
03143     }  
03144 
03145   <span class="keywordflow">if</span>( flag_v )
03146     fprintf(output,<span class="stringliteral">"%s successfully removed.\n"</span>,glob_path_object );
03147 
03148   <span class="keywordflow">return</span> 0;
03149 
03150 }
03151 
<a name="l03153"></a><a class="code" href="commands__NFS_8c.html#a49">03153</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a49">fn_nfs_setattr</a>( <span class="keywordtype">int</span>     argc ,     <span class="comment">/* IN : number of args in argv */</span>
03154                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03155                             FILE *  output     <span class="comment">/* IN : output stream          */</span> )
03156 {
03157   
03158   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03159    
03160   <span class="keyword">static</span> <span class="keywordtype">char</span> help_setattr[]=
03161     <span class="stringliteral">"usage: setattr [-h][-v] &lt;path&gt; &lt;attr&gt;=&lt;value&gt;,&lt;attr&gt;=&lt;value&gt;,...\n"</span>
03162     <span class="stringliteral">"       where &lt;attr&gt; can be :\n"</span>
03163     <span class="stringliteral">"          mode(octal value),\n"</span>
03164     <span class="stringliteral">"          uid, gid, (unsigned 32 bits integer)\n"</span>
03165     <span class="stringliteral">"          size, (unsigned  64 bits integer)\n"</span>
03166     <span class="stringliteral">"          atime, mtime (format: YYYYMMDDHHMMSS.nnnnnnnnn)\n"</span>;
03167 
03168   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];  <span class="comment">/* absolute path of the object */</span>
03169 
03170   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> obj_hdl ;        <span class="comment">/* handle of the object    */</span>
03171   sattr3  set_attrs;       <span class="comment">/* attributes to be setted */</span>
03172   <span class="keywordtype">char</span> * attr_string;
03173   
03174   <span class="keywordtype">int</span> rc, option;
03175   <span class="keywordtype">int</span> flag_v=0;
03176   <span class="keywordtype">int</span> flag_h=0;
03177   <span class="keywordtype">int</span> err_flag=0;
03178   
03179   <span class="keywordtype">char</span> file[NFS2_MAXPATHLEN]; <span class="comment">/* the relative path to the object */</span>
03180        
03181   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03182       
03183   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03184   {
03185     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03186     <span class="keywordflow">return</span> -1 ;
03187   }
03188   
03189   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03190   
03191   <span class="comment">/* check if a path has been mounted */</span>
03192   
03193   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03194   {
03195     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03196     <span class="keywordflow">return</span> -1 ;
03197   }
03198     
03199   <span class="comment">/* analysing options */</span>
03200   getopt_init() ;
03201   
03202   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format )) != -1 )
03203   {   
03204     <span class="keywordflow">switch</span>( option )
03205       {
03206       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03207         <span class="keywordflow">if</span>( flag_v )
03208           fprintf( output, <span class="stringliteral">"setattr: warning: option 'v' has been specified more than once.\n"</span>);
03209         <span class="keywordflow">else</span> 
03210           flag_v++;
03211         <span class="keywordflow">break</span>;
03212         
03213       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03214         <span class="keywordflow">if</span>( flag_h )
03215           fprintf(output, <span class="stringliteral">"setattr: warning: option 'h' has been specified more than once.\n"</span>);
03216         <span class="keywordflow">else</span> 
03217           flag_h++;
03218         <span class="keywordflow">break</span>;
03219         
03220       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03221         fprintf(output,<span class="stringliteral">"setattr: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03222         err_flag ++;
03223         <span class="keywordflow">break</span>;
03224     }    
03225   }
03226   
03227   <span class="keywordflow">if</span>( flag_h )
03228     {
03229       <span class="comment">/* print usage */</span>
03230       fprintf(output,help_setattr);
03231       <span class="keywordflow">return</span> 0;
03232     }
03233   
03234   <span class="comment">/* Exactly 2 args expected */</span>
03235   
03236   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
03237     {
03238       err_flag ++;
03239     } 
03240   <span class="keywordflow">else</span> 
03241     {
03242       strcpy( file,  argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>] ) ;
03243       attr_string = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1]; 
03244     }
03245   
03246   <span class="keywordflow">if</span>( err_flag )
03247     {
03248       fprintf( output, help_setattr );
03249       <span class="keywordflow">return</span> -1;
03250     }
03251   
03252   <span class="comment">/* copy current absolute path to a local variable. */</span>
03253   strncpy( glob_path, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>, NFS2_MAXPATHLEN);
03254   
03255   <span class="comment">/* retrieve handle to the file whose attributes are to be changed */</span>
03256   <span class="keywordflow">if</span>( rc = nfs_solvepath( p_thr_info, glob_path, NFS2_MAXPATHLEN, file, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, &amp;obj_hdl, output ) )
03257     <span class="keywordflow">return</span> rc ;
03258     
03259   <span class="comment">/* Convert the peer (attr_name,attr_val) to an sattr3 structure. */</span>
03260   <span class="keywordflow">if</span> ( (rc = <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>,
03261                            1, &amp;attr_string, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, (caddr_t)&amp;set_attrs ))
03262       == FALSE )
03263     <span class="keywordflow">return</span> rc;
03264 
03265                               
03266   <span class="comment">/* executes set attrs */</span>
03267   <span class="keywordflow">if</span> ( rc = nfs_setattr( p_thr_info, &amp;obj_hdl, &amp;set_attrs, output ) ) <span class="keywordflow">return</span> rc;
03268 
03269   <span class="keywordflow">if</span> (flag_v)
03270     fprintf(output,<span class="stringliteral">"Attributes of \"%s\" successfully changed.\n"</span>,glob_path );
03271         
03272   <span class="keywordflow">return</span> 0;  
03273 } <span class="comment">/* fn_nfs_setattr */</span>
03274 
03275 
03276 
<a name="l03278"></a><a class="code" href="commands__NFS_8c.html#a50">03278</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a50">fn_nfs_rename</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03279         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03280         FILE * output      <span class="comment">/* IN : output stream          */</span>
03281       ){
03282   
03283   
03284   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03285    
03286   <span class="keyword">static</span> <span class="keywordtype">char</span> help_rename[]=
03287   <span class="stringliteral">"usage: rename [-h][-v] &lt;src&gt; &lt;dest&gt;\n"</span>;
03288 
03289   <span class="keywordtype">char</span> src_glob_path[NFS2_MAXPATHLEN];
03290   <span class="keywordtype">char</span> tgt_glob_path[NFS2_MAXPATHLEN];
03291   
03292   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> src_path_handle, tgt_path_handle;
03293   
03294   <span class="keywordtype">int</span> rc,option;
03295   <span class="keywordtype">int</span> flag_v=0;
03296   <span class="keywordtype">int</span> flag_h=0;
03297   <span class="keywordtype">int</span> err_flag=0;
03298   
03299   <span class="keywordtype">char</span> tmp_path1[NFS2_MAXPATHLEN];
03300   <span class="keywordtype">char</span> tmp_path2[NFS2_MAXPATHLEN];
03301   <span class="keywordtype">char</span> * src_path;
03302   <span class="keywordtype">char</span> * src_file;
03303   <span class="keywordtype">char</span> * tgt_path;
03304   <span class="keywordtype">char</span> * tgt_file;
03305       
03306   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03307       
03308   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03309   {
03310     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03311     <span class="keywordflow">return</span> -1 ;
03312   }
03313   
03314   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03315   
03316   <span class="comment">/* check if a path has been mounted */</span>
03317   
03318   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03319   {
03320     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03321     <span class="keywordflow">return</span> -1 ;
03322   }
03323   
03324   <span class="comment">/* analysing options */</span>
03325   getopt_init();
03326   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03327     <span class="keywordflow">switch</span>(option){
03328       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03329         <span class="keywordflow">if</span> (flag_v)
03330           fprintf(output,
03331               <span class="stringliteral">"rename: warning: option 'v' has been specified more than once.\n"</span>);
03332         <span class="keywordflow">else</span> flag_v++;
03333         <span class="keywordflow">break</span>;
03334       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03335         <span class="keywordflow">if</span> ( flag_h )
03336           fprintf(output,
03337               <span class="stringliteral">"rename: warning: option 'h' has been specified more than once.\n"</span>);
03338         <span class="keywordflow">else</span> flag_h++;
03339         <span class="keywordflow">break</span>;
03340       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03341         fprintf(output,<span class="stringliteral">"rename: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03342         err_flag ++;
03343         <span class="keywordflow">break</span>;
03344     }    
03345   }
03346   
03347   <span class="keywordflow">if</span> (flag_h){
03348     fprintf(output,help_rename);
03349     <span class="keywordflow">return</span> 0;
03350   }
03351   
03352   <span class="comment">/* Exactly 2 args expected */</span>
03353   <span class="keywordflow">if</span> (<a class="code" href="Getopt_8c.html#a4">Optind</a> != (argc-2)){
03354     err_flag ++;
03355   } <span class="keywordflow">else</span> {
03356     
03357     strncpy(tmp_path1,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>],NFS2_MAXPATHLEN);
03358     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path1,&amp;src_path,&amp;src_file);
03359 
03360     strncpy(tmp_path2,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03361     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path2,&amp;tgt_path,&amp;tgt_file);
03362     
03363   }
03364   
03365   <span class="keywordflow">if</span> (err_flag){
03366     fprintf(output,help_rename);
03367     <span class="keywordflow">return</span> -1;
03368   }
03369   
03370   <span class="keywordflow">if</span> (flag_v)
03371     fprintf(output,<span class="stringliteral">"Renaming %s (dir %s) to %s (dir %s)\n"</span>,
03372         src_file,src_path,tgt_file,tgt_path);
03373   
03374   <span class="comment">/* copy current path. */</span>
03375   strncpy(src_glob_path,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03376   strncpy(tgt_glob_path,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03377   
03378   <span class="comment">/* retrieves paths handles */</span>
03379   <span class="keywordflow">if</span> (rc = 
03380       nfs_solvepath(p_thr_info, src_glob_path,NFS2_MAXPATHLEN,
03381                 src_path, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;src_path_handle,output))
03382     <span class="keywordflow">return</span> rc;
03383 
03384   <span class="keywordflow">if</span> (rc = 
03385       nfs_solvepath(p_thr_info, tgt_glob_path,NFS2_MAXPATHLEN,
03386                 tgt_path, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;tgt_path_handle,output))
03387     <span class="keywordflow">return</span> rc;
03388 
03389   
03390   <span class="comment">/* Rename operation */</span>  
03391   
03392   <span class="keywordflow">if</span> ( rc = nfs_rename(
03393     p_thr_info,
03394     &amp;src_path_handle,      <span class="comment">/* IN */</span>
03395     src_file,             <span class="comment">/* IN */</span>
03396     &amp;tgt_path_handle,      <span class="comment">/* IN */</span>
03397     tgt_file,             <span class="comment">/* IN */</span>
03398     output ) ) <span class="keywordflow">return</span> rc;
03399   
03400 
03401   <span class="keywordflow">if</span> (flag_v)
03402     fprintf( output,<span class="stringliteral">"%s/%s successfully renamed to %s/%s\n"</span>,
03403           src_glob_path, src_file,
03404           tgt_glob_path, tgt_file
03405         );
03406 
03407   <span class="keywordflow">return</span> 0;
03408   
03409 }
03410 
03411 
03412 
03413 
<a name="l03415"></a><a class="code" href="commands__NFS_8c.html#a51">03415</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a51">fn_nfs_hardlink</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03416         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03417         FILE * output      <span class="comment">/* IN : output stream          */</span>
03418       ){
03419   
03420   
03421   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03422    
03423   <span class="keyword">static</span> <span class="keywordtype">char</span> help_hardlink[]=
03424   <span class="stringliteral">"hardlink: create a hard link.\n"</span>
03425   <span class="stringliteral">"usage: hardlink [-h][-v] &lt;target&gt; &lt;new_path&gt;\n"</span>
03426   <span class="stringliteral">"       target: path of an existing file.\n"</span>
03427   <span class="stringliteral">"       new_path: path of the hardlink to be created\n"</span>;
03428 
03429   <span class="keywordtype">char</span> glob_path_target[NFS2_MAXPATHLEN];
03430   <span class="keywordtype">char</span> glob_path_link[NFS2_MAXPATHLEN];
03431   
03432   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> target_hdl, dir_hdl;
03433   
03434   <span class="keywordtype">int</span> rc,option;
03435   <span class="keywordtype">int</span> flag_v=0;
03436   <span class="keywordtype">int</span> flag_h=0;
03437   <span class="keywordtype">int</span> err_flag=0;
03438   
03439   <span class="keywordtype">char</span> * target = NULL;
03440   
03441   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
03442   <span class="keywordtype">char</span> * path;
03443   <span class="keywordtype">char</span> * name;
03444       
03445   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03446       
03447   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03448   {
03449     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03450     <span class="keywordflow">return</span> -1 ;
03451   }
03452   
03453   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03454   
03455   <span class="comment">/* check if a path has been mounted */</span>
03456   
03457   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03458   {
03459     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03460     <span class="keywordflow">return</span> -1 ;
03461   }
03462   
03463   <span class="comment">/* analysing options */</span>
03464   getopt_init();
03465   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03466     <span class="keywordflow">switch</span>(option){
03467       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03468         <span class="keywordflow">if</span> (flag_v)
03469           fprintf(output,
03470               <span class="stringliteral">"hardlink: warning: option 'v' has been specified more than once.\n"</span>);
03471         <span class="keywordflow">else</span> flag_v++;
03472         <span class="keywordflow">break</span>;
03473       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03474         <span class="keywordflow">if</span> ( flag_h )
03475           fprintf(output,
03476               <span class="stringliteral">"hardlink: warning: option 'h' has been specified more than once.\n"</span>);
03477         <span class="keywordflow">else</span> flag_h++;
03478         <span class="keywordflow">break</span>;
03479       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03480         fprintf(output,<span class="stringliteral">"hardlink: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03481         err_flag ++;
03482         <span class="keywordflow">break</span>;
03483     }    
03484   }
03485   
03486   <span class="keywordflow">if</span> (flag_h){
03487     fprintf(output,help_hardlink);
03488     <span class="keywordflow">return</span> 0;
03489   }
03490   
03491   <span class="comment">/* 2 args expected */</span>
03492   
03493   <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == (argc-2) ){
03494     
03495     target = argv[Optind];
03496     
03497     strncpy(tmp_path,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03498     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path,&amp;path,&amp;name);
03499 
03500   } <span class="keywordflow">else</span> {    
03501     err_flag ++;    
03502   }
03503   
03504   
03505   <span class="keywordflow">if</span> (err_flag){
03506     fprintf(output,help_hardlink);
03507     <span class="keywordflow">return</span> -1;
03508   }
03509     
03510   <span class="comment">/* copy current path. */</span>
03511   strncpy(glob_path_target,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03512   strncpy(glob_path_link,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03513   
03514   <span class="comment">/* retrieves path handle for target */</span>
03515   <span class="keywordflow">if</span> (rc = 
03516       nfs_solvepath(p_thr_info, glob_path_target,NFS2_MAXPATHLEN,
03517                 target,&amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;target_hdl,output))
03518     <span class="keywordflow">return</span> rc;
03519 
03520   <span class="comment">/* retrieves path handle for parent dir */</span>
03521   <span class="keywordflow">if</span> (rc = 
03522       nfs_solvepath(p_thr_info, glob_path_link,NFS2_MAXPATHLEN,
03523                 path,&amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;dir_hdl,output))
03524     <span class="keywordflow">return</span> rc;
03525   
03526   
03527 
03528   rc = nfs_link(
03529           p_thr_info,
03530           &amp;target_hdl,   <span class="comment">/* IN - target file */</span>
03531           &amp;dir_hdl,      <span class="comment">/* IN - parent dir handle */</span>
03532           name,         <span class="comment">/* IN - link name */</span>
03533           output );     <span class="comment">/* OUT - new attributes */</span>
03534   
03535   <span class="keywordflow">if</span> ( rc ) <span class="keywordflow">return</span> rc;
03536 
03537   <span class="keywordflow">if</span> (flag_v)
03538     fprintf(output,<span class="stringliteral">"%s/%s &lt;=&gt; %s successfully created\n"</span>,path,name,glob_path_target);
03539       
03540   <span class="keywordflow">return</span> 0;
03541   
03542 }
03543 
03544 
03545 
<a name="l03548"></a><a class="code" href="commands__NFS_8c.html#a52">03548</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a52">fn_nfs_ln</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03549         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03550         FILE * output      <span class="comment">/* IN : output stream          */</span>
03551       ){
03552   
03553   
03554   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03555    
03556   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ln[]=
03557   <span class="stringliteral">"ln: create a symbolic link.\n"</span>
03558   <span class="stringliteral">"usage: ln [-h][-v] &lt;link_content&gt; &lt;link_path&gt;\n"</span>
03559   <span class="stringliteral">"       link_content: content of the symbolic link to be created\n"</span>
03560   <span class="stringliteral">"       link_path: path of the symbolic link to be created\n"</span>;
03561 
03562   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
03563   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> path_hdl,link_hdl;
03564   sattr3 set_attrs;
03565   <span class="keywordtype">int</span> rc,option;
03566   <span class="keywordtype">int</span> flag_v=0;
03567   <span class="keywordtype">int</span> flag_h=0;
03568   <span class="keywordtype">int</span> err_flag=0;
03569   
03570   <span class="keywordtype">char</span> * content = NULL;
03571   <span class="keywordtype">char</span> tmp_path[NFS2_MAXPATHLEN];
03572   <span class="keywordtype">char</span> * path;
03573   <span class="keywordtype">char</span> * name;
03574     
03575   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03576       
03577   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03578   {
03579     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03580     <span class="keywordflow">return</span> -1 ;
03581   }
03582   
03583   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03584   
03585   <span class="comment">/* check if a path has been mounted */</span>
03586   
03587   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03588   {
03589     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03590     <span class="keywordflow">return</span> -1 ;
03591   }
03592   
03593   <span class="comment">/* analysing options */</span>
03594   getopt_init();
03595   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){   
03596     <span class="keywordflow">switch</span>(option){
03597       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03598         <span class="keywordflow">if</span> (flag_v)
03599           fprintf(output,
03600               <span class="stringliteral">"ln: warning: option 'v' has been specified more than once.\n"</span>);
03601         <span class="keywordflow">else</span> flag_v++;
03602         <span class="keywordflow">break</span>;
03603       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03604         <span class="keywordflow">if</span> ( flag_h )
03605           fprintf(output,
03606               <span class="stringliteral">"ln: warning: option 'h' has been specified more than once.\n"</span>);
03607         <span class="keywordflow">else</span> flag_h++;
03608         <span class="keywordflow">break</span>;
03609       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03610         fprintf(output,<span class="stringliteral">"ln: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03611         err_flag ++;
03612         <span class="keywordflow">break</span>;
03613     }    
03614   }
03615   
03616   <span class="keywordflow">if</span> (flag_h){
03617     fprintf(output,help_ln);
03618     <span class="keywordflow">return</span> 0;
03619   }
03620   
03621   <span class="comment">/* 2 args expected */</span>
03622   
03623   <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == (argc-2) ){
03624     
03625     content = argv[Optind];
03626     
03627     strncpy(tmp_path,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1],NFS2_MAXPATHLEN);
03628     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path,&amp;path,&amp;name);
03629 
03630   } <span class="keywordflow">else</span> {
03631     err_flag ++;
03632   }
03633   
03634   
03635   <span class="keywordflow">if</span> (err_flag){
03636     fprintf(output,help_ln);
03637     <span class="keywordflow">return</span> -1;
03638   }
03639     
03640   <span class="comment">/* copy current path. */</span>
03641   strncpy(glob_path,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03642   
03643   <span class="comment">/* retrieves path handle*/</span>
03644   <span class="keywordflow">if</span> (rc = 
03645       nfs_solvepath( p_thr_info, glob_path,NFS2_MAXPATHLEN,
03646                      path,&amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>,&amp;path_hdl,output))
03647     <span class="keywordflow">return</span> rc;
03648 
03649   
03650   <span class="comment">/* Prepare link attributes : empty sattr3 list */</span>
03651   
03652   <span class="keywordflow">if</span> ( <a class="code" href="cmd__nfstools_8h.html#a36">cmdnfs_sattr3</a>( <a class="code" href="cmd__nfstools_8h.html#a70a12">CMDNFS_ENCODE</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a>,
03653                  (caddr_t)&amp;set_attrs ) == FALSE )
03654   {
03655     <span class="comment">/* invalid handle */</span>
03656     fprintf( output, <span class="stringliteral">"\tError encoding nfs arguments.\n"</span> );
03657     <span class="keywordflow">return</span> -1 ;
03658   }
03659   
03660   
03661 
03662   rc = nfs_symlink(
03663           p_thr_info,
03664           path_hdl,  <span class="comment">/* IN - parent dir handle */</span>
03665           name,      <span class="comment">/* IN - link name */</span>
03666           content,   <span class="comment">/* IN - link content */</span>
03667           &amp;set_attrs, <span class="comment">/* Link attributes */</span>
03668           &amp;link_hdl,  <span class="comment">/* OUT - link handle*/</span>
03669           output );
03670   
03671   <span class="keywordflow">if</span> (rc) <span class="keywordflow">return</span> rc;
03672   
03673   <span class="keywordflow">if</span> (flag_v)
03674   {
03675     <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1];
03676     snprintmem( buff, 2*NFS3_FHSIZE+1,(caddr_t)link_hdl.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
03677                 link_hdl.<a class="code" href="structshell__fh3____.html#o0">data_len</a> );
03678   
03679     fprintf(output,<span class="stringliteral">"%s/%s -&gt; %s successfully created (@%s) \n"</span>,path,name,content,buff);
03680   }
03681       
03682   <span class="keywordflow">return</span> 0;  
03683 }
03684 
03685 
03686 
03687 
<a name="l03689"></a><a class="code" href="commands__NFS_8c.html#a53">03689</a> <span class="keywordtype">int</span>  <a class="code" href="commands__NFS_8c.html#a53">fn_nfs_stat</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03690                 <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03691                 FILE * output )    <span class="comment">/* IN : output stream          */</span>
03692 {
03693   
03694   <span class="keywordtype">char</span> item_path[NFS2_MAXPATHLEN];
03695   <a class="code" href="structshell__fh3____.html">shell_fh3_t</a> handle_tmp;
03696   fattr3 attrs;
03697   cookie3 begin_cookie;
03698   bool_t  eod_met;
03699   cookieverf3 cookieverf;
03700   dirlistplus3 dirlist;
03701   entryplus3 * p_entry;
03702   
03703   fattr3 * p_attrs;
03704   nfs_fh3 * p_hdl;
03705 
03706       
03707   <span class="keywordtype">int</span> rc = 0 ;
03708   <span class="keywordtype">char</span> glob_path[NFS2_MAXPATHLEN];
03709 
03710   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvHz"</span>;
03711   <span class="keyword">static</span> <span class="keywordtype">char</span> help_stat[]=<span class="stringliteral">"usage: stat [options] &lt;path&gt;\n"</span>
03712     <span class="stringliteral">"options :\n"</span>
03713     <span class="stringliteral">"\t-h print this help\n"</span>
03714     <span class="stringliteral">"\t-v verbose mode\n"</span>
03715     <span class="stringliteral">"\t-H print the NFS handle\n"</span> 
03716     <span class="stringliteral">"\t-z silent mode (print nothing)\n"</span> ;
03717   
03718   <span class="keywordtype">int</span> option;
03719   <span class="keywordtype">char</span> * str_name = NULL;
03720   <span class="keywordtype">int</span> flag_v = 0;
03721   <span class="keywordtype">int</span> flag_h = 0;
03722   <span class="keywordtype">int</span> flag_H = 0 ;
03723   <span class="keywordtype">int</span> flag_z = 0 ;
03724   <span class="keywordtype">int</span> err_flag = 0;
03725 
03726   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03727       
03728   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03729   {
03730     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03731     <span class="keywordflow">return</span> -1 ;
03732   }
03733   
03734   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03735   
03736   <span class="comment">/* check if a path has been mounted */</span>
03737   
03738   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o6">is_mounted_path</a> != TRUE )
03739   {
03740     fprintf( output, <span class="stringliteral">"\t%s: no mounted path. Use \"mount\" command first.\n"</span>,argv[0] );
03741     <span class="keywordflow">return</span> -1 ;
03742   }
03743   
03744     
03745   <span class="comment">/* analysing options */</span>
03746   getopt_init();
03747 
03748   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
03749     {   
03750       <span class="keywordflow">switch</span>( option )
03751         {
03752         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03753           <span class="keywordflow">if</span> (flag_v)
03754             fprintf(output,
03755                     <span class="stringliteral">"stat: warning: option 'v' has been specified more than once.\n"</span>);
03756           <span class="keywordflow">else</span> 
03757             flag_v++;
03758           <span class="keywordflow">break</span>;
03759           
03760         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03761           <span class="keywordflow">if</span> ( flag_h )
03762             fprintf(output,
03763                     <span class="stringliteral">"stat: warning: option 'h' has been specified more than once.\n"</span>);
03764           <span class="keywordflow">else</span> 
03765             flag_h++;
03766           <span class="keywordflow">break</span>;
03767           
03768         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
03769           <span class="keywordflow">if</span> ( flag_z )
03770             fprintf(output,
03771                     <span class="stringliteral">"stat: warning: option 'z' has been specified more than once.\n"</span>);
03772           <span class="keywordflow">else</span> 
03773             flag_z++;
03774           <span class="keywordflow">break</span>;
03775 
03776         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
03777           <span class="keywordflow">if</span>( flag_H )
03778             fprintf(output,
03779                     <span class="stringliteral">"stat: warning: option 'H' has been specified more than once.\n"</span>);
03780           <span class="keywordflow">else</span> 
03781             flag_H++;
03782           <span class="keywordflow">break</span>;
03783           
03784         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03785           fprintf(output,<span class="stringliteral">"stat: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03786           err_flag ++;
03787           <span class="keywordflow">break</span>;
03788         }
03789     } <span class="comment">/* while */</span>
03790   
03791   <span class="keywordflow">if</span>( flag_z + flag_v &gt; 1 )
03792     {
03793       fprintf( output, <span class="stringliteral">"stat: can't use -z and -v at the same time\n"</span> ) ;
03794       err_flag ++ ;
03795     }
03796   
03797   <span class="keywordflow">if</span>( flag_h )
03798     {
03799       fprintf(output,help_stat);
03800       <span class="keywordflow">return</span> 0;
03801     }
03802     
03803   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != argc -1 )
03804     {
03805       fprintf( output, <span class="stringliteral">"stat: Missing argument: &lt;path&gt;\n"</span> ) ;
03806       err_flag ++;
03807     }
03808   <span class="keywordflow">else</span>
03809    {
03810      str_name = argv[Optind];
03811    }
03812   
03813   <span class="keywordflow">if</span>( err_flag )
03814     {
03815       fprintf(output,help_stat);
03816       <span class="keywordflow">return</span> -1;
03817     }
03818   
03819   <span class="comment">/* copy current global path */</span>
03820   strncpy(glob_path,p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o10">current_path</a>,NFS2_MAXPATHLEN);
03821 
03822   <span class="comment">/* retrieving handle */</span>
03823   <span class="keywordflow">if</span> (rc = nfs_solvepath( p_thr_info,
03824                          glob_path,
03825                          NFS2_MAXPATHLEN,
03826                          str_name, 
03827                          &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o9">current_path_hdl</a>, 
03828                          &amp;handle_tmp,
03829                          output))
03830     <span class="keywordflow">return</span> rc;
03831   
03832   <span class="keywordflow">if</span>( flag_v )
03833     fprintf(output,<span class="stringliteral">"proceeding stat (using NFS protocol) on \"%s\"\n"</span>, glob_path );
03834   
03835   <span class="keywordflow">if</span> ( rc = nfs_getattr( p_thr_info, &amp;handle_tmp, &amp;attrs, output ) ) <span class="keywordflow">return</span> rc;
03836   
03837   <span class="keywordflow">if</span> ( flag_H )
03838   {
03839     <span class="keywordflow">if</span>( !flag_z )
03840       {
03841         <span class="keywordtype">char</span> buff[2*NFS3_FHSIZE+1] ;
03842 
03843         snprintmem( buff, 2*NFS3_FHSIZE+1, (caddr_t)handle_tmp.<a class="code" href="structshell__fh3____.html#o1">data_val</a> ,
03844                     handle_tmp.<a class="code" href="structshell__fh3____.html#o0">data_len</a> ) ;
03845         fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, str_name, buff ) ;
03846       }
03847   }
03848   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !flag_z )
03849   {
03850     fprintf(output,<span class="stringliteral">"%s :\n"</span>,str_name);
03851     <a class="code" href="cmd__nfstools_8h.html#a69">print_nfs_attributes</a>( &amp;attrs, output );
03852   }
03853   
03854   <span class="keywordflow">return</span> 0;
03855 } <span class="comment">/* fn_nfs_stat */</span>
03856 
03857 
03858 
03859 
<a name="l03861"></a><a class="code" href="commands__NFS_8c.html#a54">03861</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a54">fn_nfs_su</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03862                <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03863                FILE * output )    <span class="comment">/* IN : output stream          */</span>
03864 {
03865   <span class="keywordtype">int</span> rc, i;
03866   <span class="keywordtype">char</span> * str_uid;
03867   uid_t uid;
03868   fsal_status_t st;
03869   <span class="keyword">struct </span>passwd * pw_struct;
03870   
03871 <span class="preprocessor">#define MAX_GRPS  128</span>
03872 <span class="preprocessor"></span>  gid_t   groups_tab[MAX_GRPS];
03873   <span class="keywordtype">int</span>     nb_grp;
03874 
03875   <span class="keyword">static</span> <span class="keywordtype">char</span> help_su[]=
03876   <span class="stringliteral">"usage: su &lt;uid&gt;\n"</span>;
03877 
03878   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03879       
03880   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03881   {
03882     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03883     <span class="keywordflow">return</span> -1 ;
03884   }
03885   
03886   <span class="comment">/* UID arg expected */</span>
03887   <span class="keywordflow">if</span> ( argc != 2 )
03888   {
03889     fprintf(output,help_su);
03890     <span class="keywordflow">return</span> -1;
03891   }
03892   <span class="keywordflow">else</span>
03893   {
03894     str_uid = argv[1];
03895   }
03896 
03897   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03898   
03899   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
03900   {
03901     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
03902     {
03903       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
03904       <span class="keywordflow">return</span> -1 ;
03905     }
03906   }
03907   
03908   
03909   <span class="keywordflow">if</span> ( isdigit( str_uid[0] ) )
03910   {
03911     <span class="keywordflow">if</span> ( (uid = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>(str_uid) ) == (uid_t)-1 )
03912     {
03913       fprintf(output,<span class="stringliteral">"Error: invalid uid \"%s\"\n"</span>,str_uid);
03914       <span class="keywordflow">return</span> -1;
03915     }
03916     pw_struct = getpwuid(uid); 
03917   }
03918   <span class="keywordflow">else</span>
03919   {
03920     pw_struct = getpwnam( str_uid );
03921   }
03922   
03923   <span class="keywordflow">if</span> ( pw_struct == NULL )
03924   {
03925     fprintf( output, <span class="stringliteral">"Unknown user %s\n"</span>, str_uid );
03926     <span class="keywordflow">return</span> errno;
03927   }
03928   
03929   nb_grp = <a class="code" href="cmd__tools_8h.html#a25">getugroups</a>( <a class="code" href="commands__Cache__inode_8c.html#a3">MAX_GRPS</a>, groups_tab, pw_struct-&gt;pw_name, pw_struct-&gt;pw_gid );
03930   
03931   fprintf( output, <span class="stringliteral">"Changing user to : %s ( uid = %d, gid = %d )\n"</span>,
03932        pw_struct-&gt;pw_name , pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid );
03933   
03934   <span class="keywordflow">if</span> ( nb_grp &gt; 1 )
03935   {
03936     fprintf( output, <span class="stringliteral">"altgroups = "</span>);
03937     <span class="keywordflow">for</span> ( i = 1; i &lt; nb_grp; i++ )
03938     {      
03939       <span class="keywordflow">if</span> ( i == 1 )
03940         fprintf( output, <span class="stringliteral">"%d"</span>, groups_tab[i]);
03941       <span class="keywordflow">else</span>
03942         fprintf( output, <span class="stringliteral">", %d"</span>, groups_tab[i]);      
03943     }
03944     fprintf( output, <span class="stringliteral">"\n"</span>);
03945   }
03946 
03947   st = FSAL_GetClientContext( &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>, &amp;p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o1">exp_context</a>,
03948                               pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid, groups_tab, nb_grp );
03949       
03950   <span class="keywordflow">if</span> ( FSAL_IS_ERROR(st) )
03951   {
03952     fprintf(output,<span class="stringliteral">"Error executing FSAL_GetUserCred:"</span>);
03953     <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>(output,st);
03954     fprintf(output,<span class="stringliteral">"\n"</span>);
03955     <span class="keywordflow">return</span> st.major;
03956   }
03957   
03958   fprintf(output,<span class="stringliteral">"Done.\n"</span>);
03959   
03960   <span class="keywordflow">return</span> 0;
03961   
03962 }
03963 
03964 
<a name="l03965"></a><a class="code" href="commands__NFS_8c.html#a55">03965</a> <span class="keywordtype">int</span> <a class="code" href="commands__NFS_8c.html#a55">fn_nfs_id</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03966                       <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03967                       FILE * output )    <span class="comment">/* IN : output stream          */</span>
03968 {
03969   <span class="keywordtype">int</span> rc;
03970   <a class="code" href="structcmdnfs__thr__info____.html">cmdnfs_thr_info_t</a> * p_thr_info = NULL;
03971       
03972   <span class="keywordflow">if</span> ( is_nfs_layer_initialized != TRUE )
03973   {
03974     fprintf( output, <span class="stringliteral">"\tNFS layer not initialized.\n"</span> );
03975     <span class="keywordflow">return</span> -1 ;
03976   }
03977   
03978   p_thr_info = <a class="code" href="commands__NFS_8c.html#a17">GetNFSClient</a>();
03979   
03980   <span class="keywordflow">if</span> ( p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o0">is_thread_init</a> != TRUE )
03981   {
03982     <span class="keywordflow">if</span> ( rc = <a class="code" href="commands__NFS_8c.html#a18">InitNFSClient</a>( p_thr_info ) )
03983     {
03984       fprintf( output, <span class="stringliteral">"\t%s: Error %d during thread initialization.\n"</span>,argv[0],rc );
03985       <span class="keywordflow">return</span> -1 ;
03986     }
03987   }
03988   
03989 <span class="preprocessor">#ifdef _USE_POSIX</span>
03990 <span class="preprocessor"></span>  fprintf(output, <span class="stringliteral">"Current user : uid = %d, gid = %d\n"</span>,
03991        p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>.credential.user, p_thr_info-&gt;<a class="code" href="structcmdnfs__thr__info____.html#o2">context</a>.credential.group);
03992 <span class="preprocessor">#endif</span>
03993 <span class="preprocessor"></span>
03994   <span class="keywordflow">return</span> 0;
03995 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:35 2008 for ganeshell by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
