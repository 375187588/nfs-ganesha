<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ganeshell: commands_Cache_inode.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>commands_Cache_inode.c</h1><a href="commands__Cache__inode_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00295 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00297 <span class="preprocessor">#endif</span>
00298 <span class="preprocessor"></span>
00299 <span class="preprocessor">#include "fsal.h"</span>
00300 <span class="preprocessor">#include "cache_inode.h"</span>
00301 <span class="preprocessor">#include "cache_content.h"</span>
00302 <span class="preprocessor">#include "LRU_List.h"</span>
00303 <span class="preprocessor">#include "err_fsal.h"</span>
00304 <span class="preprocessor">#include "err_cache_inode.h"</span>
00305 <span class="preprocessor">#include "err_cache_content.h"</span>
00306 <span class="preprocessor">#include "stuff_alloc.h"</span>
00307 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00308 <span class="preprocessor">#include "<a class="code" href="commands_8h.html">commands.h</a>"</span>
00309 <span class="preprocessor">#include "<a class="code" href="Getopt_8h.html">Getopt.h</a>"</span>
00310 
00311 
00312 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00313 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00314 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00315 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00316 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00317 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00318 <span class="preprocessor">#include &lt;string.h&gt;</span>
00319 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00320 <span class="preprocessor">#include &lt;time.h&gt;</span> 
00321 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00322 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00323 
<a name="l00324"></a><a class="code" href="commands__Cache__inode_8c.html#a0">00324</a> <span class="preprocessor">#define EXPORT_ID 1 </span>
<a name="l00325"></a><a class="code" href="commands__Cache__inode_8c.html#a1">00325</a> <span class="preprocessor"></span><span class="preprocessor">#define ATTR_LEN  100 </span>
00326 <span class="preprocessor"></span>
00328 <span class="keyword">static</span> pthread_mutex_t mutex_log = PTHREAD_MUTEX_INITIALIZER;
00329 
00331 <span class="keyword">static</span> <span class="keywordtype">int</span>  log_level = -1;
00332 <span class="keyword">static</span> <span class="keywordtype">char</span> localmachine[256] ;
00333 <span class="keyword">static</span> desc_log_stream_t  voie_cache;
00334 <span class="keyword">static</span> log_t log_desc_cache = LOG_INITIALIZER;
00335 
00337 <span class="keyword">static</span> cache_entry_t * pentry_root ;
00338 
<a name="l00340"></a><a class="code" href="commands__NFS_8c.html#a4">00340</a> hash_table_t * ht ;
00341 
00343 <span class="keyword">static</span> cache_inode_gc_policy_t gcpol ;
00344 
<a name="l00346"></a><a class="code" href="commands__NFS_8c.html#a5">00346</a> cache_inode_client_parameter_t cache_client_param ;
<a name="l00347"></a><a class="code" href="commands__NFS_8c.html#a6">00347</a> cache_content_client_parameter_t datacache_client_param ;
00348 
00349 
<a name="l00350"></a><a class="code" href="structcmdCacheInode__thr__info____.html">00350</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info__</a>
00351 {
00352 
<a name="l00353"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o0">00353</a>   <span class="keywordtype">int</span> is_thread_init;
00354 
00355   <span class="comment">/* export context : on for each thread,</span>
00356 <span class="comment">   * on order to make it possible for them</span>
00357 <span class="comment">   * to access different filesets.</span>
00358 <span class="comment">   */</span>
<a name="l00359"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o1">00359</a>   fsal_export_context_t exp_context;
00360 
<a name="l00362"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o2">00362</a>   fsal_op_context_t context ;
00363   
<a name="l00365"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o3">00365</a>   cache_inode_status_t cache_status ;
00366   
<a name="l00367"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o4">00367</a>   <span class="keywordtype">int</span> is_client_init;
00368 
<a name="l00370"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o5">00370</a>   cache_entry_t * pentry  ;
00371 
<a name="l00373"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o6">00373</a>   <span class="keywordtype">char</span> current_path[FSAL_MAX_PATH_LEN]; <span class="comment">/* current path */</span>
00374 
00375   
<a name="l00377"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o7">00377</a>   cache_inode_client_t client ;
<a name="l00378"></a><a class="code" href="structcmdCacheInode__thr__info____.html#o8">00378</a>   cache_content_client_t dc_client ;
00379 
00380 } <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>;
00381 
00382 
00383 <span class="comment">/* pthread key to manage thread specific configuration */</span>
00384 
00385 <span class="keyword">static</span> pthread_key_t  thread_key ;
00386 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00387 
00388 
00389 <span class="comment">/* init pthtread_key for current thread */</span>
00390 
00391 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00392 {
00393   <span class="keywordflow">if</span>( pthread_key_create( &amp;thread_key, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) == -1 )
00394     printf( <span class="stringliteral">"Error %d creating pthread key for thread %p : %s\n"</span>,
00395         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00396   
00397   return ;
00398 } <span class="comment">/* init_keys */</span>
00399 
00400 
00405 <span class="keyword">static</span> <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>  * GetCacheInodeContext(){
00406   
00407   <span class="keywordtype">int</span> i;
00408   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * p_current_thread_vars ;
00409   
00410   <span class="comment">/* first, we init the keys if this is the first time */</span>
00411   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00412     printf( <span class="stringliteral">"Error %d calling pthread_once for thread %p : %s\n"</span>,
00413         errno,(caddr_t)pthread_self(),strerror(errno) ) ;
00414     <span class="keywordflow">return</span> NULL;
00415   }
00416   
00417   p_current_thread_vars = (<a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> *)pthread_getspecific( thread_key );
00418   
00419   <span class="comment">/* we allocate the thread context if this is the first time */</span>
00420   <span class="keywordflow">if</span> (p_current_thread_vars==NULL){
00421       
00422     <span class="comment">/* allocates thread structure */</span>
00423     p_current_thread_vars = (<a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> *)Mem_Alloc(<span class="keyword">sizeof</span>(<a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>));
00424     
00425     <span class="comment">/* panic !!! */</span>
00426     <span class="keywordflow">if</span> (p_current_thread_vars == NULL) {
00427       printf( <span class="stringliteral">"%p:commands_Cache_inode: Not enough memory\n"</span>,(caddr_t)pthread_self());
00428       <span class="keywordflow">return</span> NULL;
00429     }
00430     
00431     <span class="comment">/* Clean thread context */</span>
00432         
00433     memset(  p_current_thread_vars, 0, <span class="keyword">sizeof</span>( <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> ) );
00434     
00435     p_current_thread_vars-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o0">is_thread_init</a> = FALSE;
00436     p_current_thread_vars-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o4">is_client_init</a> = FALSE;
00437     strcpy( p_current_thread_vars-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, <span class="stringliteral">""</span>);
00438     p_current_thread_vars-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> = NULL; 
00439     p_current_thread_vars-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> = CACHE_INODE_SUCCESS;
00440     
00441     <span class="comment">/* set the specific value */</span>
00442     pthread_setspecific( thread_key , (<span class="keywordtype">void</span> *)p_current_thread_vars ) ;
00443     
00444   }
00445  
00446   <span class="keywordflow">return</span> p_current_thread_vars ;
00447   
00448 }<span class="comment">/* GetCacheInodeContext */</span>
00449 
00450 
00451 <span class="keyword">static</span> <span class="keywordtype">int</span> InitThread( <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>  * thr_info )
00452 {
00453   
00454   uid_t uid;
00455   fsal_status_t st;
00456   <span class="keyword">struct </span>passwd * pw_struct;
00457 
00458   <span class="comment">/* for the moment, create export context for root fileset */</span>
00459   st = FSAL_BuildExportContext( &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o1">exp_context</a>,NULL, NULL );
00460     
00461   <span class="comment">/* initialize FSAL credential for this thread */</span>
00462 
00463   st = FSAL_InitClientContext( &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a> );
00464     
00465   <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00466   {    
00467     printf( <span class="stringliteral">"%p:commands_Cache_inode: Error %d initing contexte for thread (FSAL_InitThreadCred)\n"</span>,
00468         (caddr_t)pthread_self(),st.major);
00469     <span class="keywordflow">return</span> 1;
00470   }
00471   
00472   uid = getuid();
00473   
00474   pw_struct = getpwuid(uid); 
00475   
00476   <span class="keywordflow">if</span> ( pw_struct == NULL )
00477   {
00478     printf( <span class="stringliteral">"commands_Cache_inode: Unknown user %u\n"</span>, uid );
00479     <span class="keywordflow">return</span> 1;
00480   }
00481   
00482   st = FSAL_GetClientContext( &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o1">exp_context</a>,
00483                               uid, pw_struct-&gt;pw_gid, NULL , 0 );
00484 
00485   <span class="keywordflow">if</span> ( FSAL_IS_ERROR( st ) )
00486     {
00487       printf( <span class="stringliteral">"%p:commands_Cache_inode: Error %d getting contexte for uid %d (FSAL_GetUserCred)\n"</span>,
00488         (caddr_t)pthread_self(),st.major,uid);
00489       <span class="keywordflow">return</span> 1;
00490     }
00491   
00492   thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o0">is_thread_init</a> = TRUE;
00493     
00494   <span class="keywordflow">return</span> 0;
00495   
00496 }
00497 
00498 
00499 <span class="keyword">static</span> <span class="keywordtype">int</span> InitClient( <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>  * thr_info )
00500 {
00501   thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> = pentry_root ;
00502 
00503   strcpy( thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, <span class="stringliteral">"/"</span> ); 
00504     
00505   <span class="comment">/* Init the cache_inode client */</span>
00506   <span class="keywordflow">if</span>( cache_inode_client_init( &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, cache_client_param, 0, NULL ) != 0 )
00507     <span class="keywordflow">return</span> 1 ;
00508   
00509   <span class="comment">/* Init the cache content client */</span>
00510   <span class="keywordflow">if</span>( cache_content_client_init( &amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o8">dc_client</a>, datacache_client_param ) != 0 )
00511     <span class="keywordflow">return</span> 1  ;
00512 
00513   thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.pcontent_client = (caddr_t)&amp;thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o8">dc_client</a> ;
00514 
00515   thr_info-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o4">is_client_init</a> = TRUE;
00516     
00517   <span class="keywordflow">return</span> 0;
00518   
00519 }
00520 
<a name="l00521"></a><a class="code" href="commands__Cache__inode_8c.html#a21">00521</a> <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>()    
00522 {
00523   
00524   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;
00525   
00526   context = GetCacheInodeContext();
00527   
00528   <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o0">is_thread_init</a> != TRUE )
00529     <span class="keywordflow">if</span> ( InitThread( context ) )
00530     {
00531       printf( <span class="stringliteral">"Error occured during thread initialization.\n"</span> ) ;
00532       <span class="keywordflow">return</span> NULL;
00533     }
00534   
00535   <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o4">is_client_init</a> != TRUE )
00536     <span class="keywordflow">if</span> ( InitClient( context ) )
00537     {
00538       printf( <span class="stringliteral">"Error occured during client initialization.\n"</span> ) ;
00539       <span class="keywordflow">return</span> NULL;
00540     }
00541   
00542   <span class="keywordflow">return</span> context;
00543     
00544 }
00545 
00546 
<a name="l00547"></a><a class="code" href="commands__Cache__inode_8c.html#a22">00547</a> <span class="keywordtype">void</span> <a class="code" href="commands__Cache__inode_8c.html#a22">Cache_inode_layer_SetLogLevel</a>(<span class="keywordtype">int</span> log_lvl  ){
00548   
00549   log_stream_t * curr;
00550 
00551   <span class="comment">/* mutex pour proteger le descriptor de log */</span>
00552   pthread_mutex_lock( &amp;mutex_log );
00553       
00554   <span class="comment">/* first time */</span>
00555   <span class="keywordflow">if</span> ( log_level == -1){
00556     log_level = log_lvl;
00557     voie_cache.fd = fileno( stderr ) ;
00558     AddLogStreamJd( &amp;log_desc_cache, V_FD,voie_cache,log_level,SUP);
00559   } 
00560   <span class="keywordflow">else</span> 
00561     {
00562       log_level = log_lvl;
00563       <span class="comment">/* changing log level */</span>
00564       curr = log_desc_cache.liste_voies;
00565       <span class="keywordflow">while</span> (curr){
00566         curr-&gt;niveau = log_level;
00567         curr = curr-&gt;suivante;
00568       }
00569     }
00570    
00571   <span class="comment">/* mutex pour proteger le descriptor de log */</span>
00572   pthread_mutex_unlock( &amp;mutex_log );
00573 
00574 }
00575 
00576 
00577 
<a name="l00578"></a><a class="code" href="commands__Cache__inode_8c.html#a23">00578</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a23">lru_entry_to_str</a>( LRU_data_t data, <span class="keywordtype">char</span> * str)
00579 {
00580   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"%p (len=%u)"</span>, data.pdata, data.len ) ;
00581 } <span class="comment">/* lru_entry_to_str */</span>
00582 
<a name="l00583"></a><a class="code" href="commands__Cache__inode_8c.html#a24">00583</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a24">lru_clean_entry</a>( LRU_entry_t * entry, <span class="keywordtype">void</span> * adddata)
00584 {
00585   <span class="keywordflow">return</span> 0 ;
00586 } <span class="comment">/* lru_clean_entry */</span>
00587 
00588 <span class="keyword">static</span> <span class="keywordtype">void</span> getopt_init()
00589 {
00590   <span class="comment">/* disables getopt error message */</span>
00591   <a class="code" href="Getopt_8c.html#a3">Opterr</a> = 0; 
00592   
00593   <span class="comment">/* reinits getopt processing */</span>
00594   <a class="code" href="Getopt_8c.html#a4">Optind</a> = 1;
00595   
00596 }
00597 
00598 <span class="comment">/* solves a relative or aboslute path */</span>
<a name="l00599"></a><a class="code" href="commands__Cache__inode_8c.html#a26">00599</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>(<span class="keywordtype">char</span> * io_global_path, <span class="keywordtype">int</span> size_global_path,    <span class="comment">/* global path */</span>
00600                     <span class="keywordtype">char</span> * i_spec_path,                          <span class="comment">/* specified path */</span>
00601                     cache_entry_t *  current_pentry,    <span class="comment">/* current directory handle */</span>
00602                     cache_entry_t ** pnew_pentry, 
00603                     FILE * output)
00604 {
00605   <span class="keywordtype">char</span> str_path[FSAL_MAX_PATH_LEN];
00606 
00607   fsal_name_t name;
00608   fsal_status_t st;
00609   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN] ;
00610   <span class="keywordtype">char</span> * next_name ;
00611   <span class="keywordtype">char</span> * curr ;
00612   <span class="keywordtype">int</span> last=0;
00613 
00614   cache_inode_fsal_data_t fsdata ;
00615   
00616   cache_entry_t * pentry_lookup = NULL ;
00617   cache_entry_t * pentry_tmp    = NULL ;
00618   fsal_attrib_list_t attrlookup ;
00619   
00620   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
00621   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
00622   
00623   <span class="comment">/* is it a relative or an absolute path ? */</span>
00624   strncpy(str_path, i_spec_path ,FSAL_MAX_PATH_LEN);
00625   
00626   curr = str_path;
00627   next_name = str_path;
00628 
00629   <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'@'</span>)
00630     {
00631       <span class="comment">/* It is a file handle */</span>
00632     <span class="keywordtype">int</span> rc;
00633     
00634     rc = sscanHandle( &amp;(fsdata.handle), str_path+1 );
00635     
00636     <span class="keywordflow">if</span> ( rc&lt;=0 ){
00637       fprintf( output, <span class="stringliteral">"Invalid FileHandle: %s\n"</span>,str_path );
00638       <span class="keywordflow">return</span> -1;
00639     }
00640     
00641     <span class="keywordflow">if</span> ( str_path[rc+1] != <span class="charliteral">'\0'</span> )
00642     {
00643       fprintf( output, <span class="stringliteral">"Invalid FileHandle: %s\n"</span>,str_path );
00644       <span class="keywordflow">return</span> -1;
00645     }
00646     
00647     <span class="comment">/* Get the corresponding pentry */</span>
00648     fsdata.cookie = 0 ;
00649     <span class="keywordflow">if</span>( ( pentry_tmp =  cache_inode_get( &amp;fsdata, 
00650                                          &amp;attrlookup, 
00651                                          <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
00652                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
00653                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
00654                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
00655       {
00656         log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_get( \"%s\" ) : %J%r\n"</span>,
00657                str_path, ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
00658         
00659         <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
00660       }
00661     
00662     strncpy( io_global_path, str_path ,size_global_path);
00663     *pnew_pentry = pentry_tmp ;
00664     
00665     <span class="keywordflow">return</span> 0;        
00666     
00667     }
00668   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_path[0] == <span class="charliteral">'/'</span>)
00669     {
00670       <span class="comment">/* absolute path, starting from "/", with a relative path */</span>
00671       curr ++;
00672       next_name ++;
00673       pentry_lookup = pentry_root ;
00674       strncpy(tmp_path, <span class="stringliteral">"/"</span> ,FSAL_MAX_PATH_LEN);
00675       
00676       <span class="comment">/* the the directory  is /, return */</span>
00677       <span class="keywordflow">if</span> (str_path[1]==<span class="charliteral">'\0'</span>)
00678         {
00679           strncpy(io_global_path,tmp_path,size_global_path);       
00680           *pnew_pentry = pentry_lookup ;
00681           <span class="keywordflow">return</span> 0;
00682         }
00683       
00684     } 
00685   <span class="keywordflow">else</span> 
00686     {
00687       pentry_lookup = current_pentry ;
00688       strncpy(tmp_path, io_global_path ,FSAL_MAX_PATH_LEN);  
00689     }
00690 
00691   <span class="comment">/* Now, the path is a relative path, proceed a step by step lookup */</span>
00692   <span class="keywordflow">do</span> 
00693     {
00694       
00695       <span class="comment">/* tokenize to the next '/' */</span>         
00696       <span class="keywordflow">while</span>( ( curr[0] != <span class="charliteral">'\0'</span> ) &amp;&amp;  
00697              ( curr[0] != <span class="charliteral">'/'</span> ) )
00698         curr++;
00699       
00700       
00701       <span class="keywordflow">if</span> (!curr[0]) 
00702         last=1; <span class="comment">/* remembers if it was the last dir */</span>
00703 
00704       curr[0]=<span class="charliteral">'\0'</span>;
00705       
00706       <span class="comment">/* build the name */</span>
00707       <span class="keywordflow">if</span>( FSAL_IS_ERROR( st = FSAL_str2name( next_name, FSAL_MAX_PATH_LEN, &amp;name ) ) )
00708         {
00709           fprintf(output,<span class="stringliteral">"Error executing FSAL_str2name:"</span>);
00710           <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>(output,st);
00711           fprintf(output,<span class="stringliteral">"\n"</span>);
00712           <span class="keywordflow">return</span> st.major;
00713         }
00714       
00715       <span class="comment">/* lookup this name */</span>
00716       
00717       <span class="keywordflow">if</span>( ( pentry_tmp = cache_inode_lookup( pentry_lookup,
00718                                              &amp;name, 
00719                                              &amp;attrlookup, 
00720                                              <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
00721                                              &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
00722                                              &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>,
00723                                              &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
00724         {
00725          log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_lookup( \"%s\", \"%s\" ) : %J%r\n"</span>,
00726                tmp_path,name.name, ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
00727           
00728           <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
00729         }
00730     
00731     <span class="comment">/* updates current handle */</span>
00732     pentry_lookup = pentry_tmp ;
00733     
00734     
00735     <span class="comment">/* adds /name at the end of the path */</span>
00736     strncat(tmp_path,<span class="stringliteral">"/"</span>,FSAL_MAX_PATH_LEN);
00737     strncat(tmp_path,next_name,FSAL_MAX_PATH_LEN);
00738     
00739     <span class="comment">/* updates cursors */</span>
00740     <span class="keywordflow">if</span>( !last )
00741       {
00742         curr ++;
00743         next_name = curr ;
00744         <span class="comment">/* ignore successive slashes */</span>
00745         <span class="keywordflow">while</span>((curr[0]!=<span class="charliteral">'\0'</span>) &amp;&amp; (curr[0]==<span class="charliteral">'/'</span>)){
00746           curr++;
00747           next_name = curr;
00748         }
00749         <span class="keywordflow">if</span> (!curr[0]) last=1; <span class="comment">/* it is the last dir */</span>
00750       }
00751     
00752     } <span class="keywordflow">while</span>( !last );
00753   
00754   <span class="comment">/* everything is OK, apply changes */</span>
00755   <a class="code" href="cmd__tools_8h.html#a16">clean_path</a>(tmp_path,size_global_path);
00756   strncpy(io_global_path,tmp_path,size_global_path);   
00757     
00758   *pnew_pentry = pentry_lookup ;
00759   <span class="keywordflow">return</span> 0;
00760   
00761 }
00762 
<a name="l00763"></a><a class="code" href="commands__Cache__inode_8c.html#a27">00763</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a27">cacheinode_init</a>(<span class="keywordtype">char</span> * filename,
00764                      <span class="keywordtype">int</span> flag_v,
00765                      FILE * output
00766     )
00767 {
00768   <span class="keywordtype">int</span> rc;
00769 
00770   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
00771 
00772   fsal_status_t   status;
00773   fsal_path_t pathroot ;
00774   fsal_handle_t root_handle ;
00775   fsal_attrib_list_t attribs;
00776   fsal_attrib_list_t attrs ;
00777 
00778   cache_inode_fsal_data_t fsdata ;
00779   cache_inode_parameter_t cache_param ;
00780   LRU_parameter_t lru_param ;
00781   LRU_status_t lru_status ;
00782   config_file_t config_file;
00783   
00784   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a>  * context;
00785 
00786   <span class="comment">/* geting the hostname */</span>
00787   <span class="keywordflow">if</span>( gethostname( localmachine, <span class="keyword">sizeof</span>( localmachine ) ) != 0 )
00788     {
00789       DisplayErrorLog( ERR_SYS, ERR_GETHOSTNAME, errno ) ;
00790       exit( 1 ) ;
00791     }
00792   <span class="keywordflow">else</span>
00793     SetNameHost( localmachine ) ;
00794 
00795   <span class="comment">/* Parse config file */</span>
00796   <span class="keywordflow">if</span>( ( config_file = config_ParseFile( filename ) ) == NULL )
00797     {
00798       fprintf( output, <span class="stringliteral">"init_cache: Error parsing %s: %s\n"</span>, filename,  config_GetErrorMsg() );
00799       <span class="keywordflow">return</span> -1;
00800     }
00801   
00802   <span class="comment">/* creating log */</span>
00803   AddFamilyError( ERR_CACHE_INODE, <span class="stringliteral">"Cache_inode related Errors"</span>, tab_errstatus_cache_inode ) ;
00804   
00805   
00806   <span class="comment">/* creates thread context */</span>  
00807   
00808   context = GetCacheInodeContext();
00809   
00810   <span class="keywordflow">if</span> ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o0">is_thread_init</a> != TRUE )
00811     <span class="keywordflow">if</span> ( InitThread( context ) )
00812     {
00813       fprintf( output, <span class="stringliteral">"Error ossured during thread initialization.\n"</span> ) ;
00814       <span class="keywordflow">return</span> 1;
00815     }
00816     
00817   <span class="comment">/* Reading the hash parameter */</span>
00818   rc = cache_inode_read_conf_hash_parameter( config_file, &amp;cache_param );
00819   <span class="keywordflow">if</span>( rc != CACHE_INODE_SUCCESS )
00820     {
00821       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_read_conf_hash_parameter : %J%r\n"</span>,
00822                    ERR_CACHE_INODE, rc );
00823 
00824       <span class="keywordflow">return</span> 1 ;
00825     }
00826 
00827   cache_param.hparam.hash_func_key    = cache_inode_fsal_hash_func ;
00828   cache_param.hparam.hash_func_rbt    = cache_inode_fsal_rbt_func ;
00829   cache_param.hparam.compare_key      = cache_inode_compare_key_fsal ;
00830   cache_param.hparam.key_to_str       = NULL ;
00831   cache_param.hparam.val_to_str       = NULL ;
00832 
00833   <span class="keywordflow">if</span>( flag_v )
00834     cache_inode_print_conf_hash_parameter( output, cache_param ) ;
00835   
00836   <span class="keywordflow">if</span>( ( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> = cache_inode_init( cache_param, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
00837     {
00838       fprintf( output, <span class="stringliteral">"Error %d while init hash\n "</span>, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ;
00839       <span class="keywordflow">return</span> 1 ;
00840     }
00841   <span class="keywordflow">else</span>
00842    <span class="keywordflow">if</span> (flag_v) fprintf( output, <span class="stringliteral">"\tHash Table address = %p\n"</span>, <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> ) ;
00843 
00844    <span class="comment">/* Get the gc policy */</span>
00845   rc = cache_inode_read_conf_gc_policy( config_file, &amp;gcpol );
00846   <span class="keywordflow">if</span>( rc != CACHE_INODE_SUCCESS )
00847     {
00848       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_read_conf_gc_policy : %J%r\n"</span>,
00849                    ERR_CACHE_INODE, rc );
00850       <span class="keywordflow">return</span> 1 ;
00851     }
00852 
00853   <span class="keywordflow">if</span>( flag_v )
00854     cache_inode_print_conf_gc_policy( output, gcpol ) ;
00855 
00856 
00857   <span class="comment">/* retrieve lower layer info */</span>
00858 
00859   <span class="comment">/* Getting the root of the FS */</span>
00860 <span class="preprocessor">#ifdef _USE_PROXY</span>
00861 <span class="preprocessor"></span>  <span class="comment">/*if( FSAL_IS_ERROR( status = FSAL_str2path( "/users/thomas/./", FSAL_MAX_PATH_LEN, &amp;pathroot ) ) ) */</span>
00862   <span class="keywordflow">if</span>( FSAL_IS_ERROR( status = FSAL_str2path( <span class="stringliteral">"/"</span>, FSAL_MAX_PATH_LEN, &amp;pathroot ) ) )
00863     {
00864       DisplayErrorFlux( output, ERR_FSAL, status.major, status.minor);
00865       <span class="keywordflow">return</span> 1 ;
00866     }
00867 
00868   <span class="keywordflow">if</span>( FSAL_IS_ERROR( status = FSAL_lookupPath( &amp;pathroot, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;root_handle, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) ) )
00869     {
00870       DisplayErrorFlux( output, ERR_FSAL, status.major, status.minor);
00871       <span class="keywordflow">return</span> 1 ;
00872     }
00873 <span class="preprocessor">#else</span>
00874 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( FSAL_IS_ERROR( status = FSAL_lookup( <a class="code" href="Getopt_8c.html#a0">NULL</a>, <a class="code" href="Getopt_8c.html#a0">NULL</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;root_handle, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) ) )
00875     {
00876       DisplayErrorFlux( output, ERR_FSAL, status.major, status.minor);
00877       <span class="keywordflow">return</span> 1 ;
00878     }
00879 <span class="preprocessor">#endif</span>
00880 <span class="preprocessor"></span>
00881   <span class="comment">/* retrieve supported attributes */</span>
00882     
00883   FSAL_CLEAR_MASK( attrs.asked_attributes );
00884   FSAL_SET_MASK( attrs.asked_attributes, FSAL_ATTR_SUPPATTR );
00885   <span class="keywordflow">if</span>( FSAL_IS_ERROR( status = FSAL_getattrs( &amp;root_handle, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;attrs ) ) )
00886     {
00887       fprintf( output, <span class="stringliteral">"Error executing FSAL_getattrs:"</span> );
00888       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, status );
00889       fprintf(output,<span class="stringliteral">"\n"</span>);
00890       <span class="keywordflow">return</span> status.major;
00891     }
00892 
00893 
00894   
00895   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.log_outputs = log_desc_cache;
00896   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.attrmask = attrs.supported_attributes;
00897   
00898   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.lru_param.entry_to_str = lru_entry_to_str ;
00899   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.lru_param.clean_entry = lru_clean_entry ;
00900 <span class="preprocessor">#ifdef _USE_ASYNC_CACHE_INODE</span>
00901 <span class="preprocessor"></span>  <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.atd_sleeptime       = CACHE_INODE_ASYNC_DEFAULT_SLEEP_TIME ;
00902   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.nb_synclet          = CACHE_INODE_ASYNC_DEFAULT_NB_SYNCLETS ;
00903   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.nb_pre_create_dirs  = CACHE_INODE_ASYNC_DEFAULT_NB_PREALLOCATED_DIRS ;
00904   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.nb_pre_create_files = CACHE_INODE_ASYNC_DEFAULT_NB_PREALLOCATED_FILES ;
00905 
00906   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.lru_async_param.nb_entry_prealloc = 512 ;
00907   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.lru_async_param.entry_to_str      = lru_entry_to_str ;
00908   <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.lru_async_param.clean_entry       = lru_clean_entry ;
00909 <span class="preprocessor">#endif</span>
00910 <span class="preprocessor"></span>
00911   <span class="comment">/* We need a cache_client to acces the cache */</span>
00912   rc = cache_inode_read_conf_client_parameter( config_file, &amp;<a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a> );
00913   <span class="keywordflow">if</span>( rc != CACHE_INODE_SUCCESS )
00914     {
00915       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_read_conf_client_parameter : %J%r\n"</span>,
00916                    ERR_CACHE_INODE, rc );
00917       <span class="keywordflow">return</span> 1 ;
00918     }
00919 
00920   <span class="comment">/* We need a cache_client to acces the datacache */</span>
00921   rc = cache_content_read_conf_client_parameter( config_file, &amp;<a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a> );
00922   <span class="keywordflow">if</span>( rc != CACHE_CONTENT_SUCCESS )
00923     {
00924       log_fprintf( output, <span class="stringliteral">"Error executing cache_content_read_conf_client_parameter : %J%r\n"</span>,
00925                    ERR_CACHE_INODE, rc );
00926       <span class="keywordflow">return</span> 1 ;
00927     }
00928   <a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a>.log_outputs = log_desc_cache;
00929 <span class="comment">/*</span>
00930 <span class="comment">  DEPRECATED :</span>
00931 <span class="comment">  datacache_client_param.lru_param.entry_to_str = lru_entry_to_str ;</span>
00932 <span class="comment">  datacache_client_param.lru_param.clean_entry = lru_clean_entry ;</span>
00933 <span class="comment">*/</span>
00934   <span class="keywordflow">if</span>( flag_v )
00935     {
00936       
00937       cache_inode_print_conf_client_parameter( output, <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a> ) ;
00938       cache_content_print_conf_client_parameter( output, <a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a> ) ;
00939     }
00940 
00941   
00942   <span class="comment">/* Reading the datacache core parameter */</span>
00943   <span class="keywordflow">if</span>( rc != CACHE_INODE_SUCCESS )
00944     {
00945       log_fprintf( output, <span class="stringliteral">"Error executing cache_content_read_conf_core_parameter : %J%r\n"</span>,
00946                    ERR_CACHE_INODE, rc );
00947       <span class="keywordflow">return</span> 1 ;
00948     }
00949   
00950   
00951   <span class="comment">/* Init the cache_inode client */</span>
00952   <span class="keywordflow">if</span>( cache_inode_client_init( &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>, 0, <a class="code" href="Getopt_8c.html#a0">NULL</a> ) != 0 )
00953     <span class="keywordflow">return</span> 1 ;
00954   
00955 <span class="preprocessor">#ifdef _USE_ASYNC_CACHE_INODE</span>
00956 <span class="preprocessor"></span>  <span class="comment">/* Start the TAD and synclets for writeback cache inode */</span>
00957   cache_inode_async_init( <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a> ) ;
00958 
00959   
00960   DisplayLog( <span class="stringliteral">"NFS INIT: preallocating directory pool (writeback-md)"</span> ) ;
00961   <span class="keywordflow">for</span>( i = 0 ; i &lt; <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.nb_synclet ; i++ )
00962     <span class="keywordflow">if</span>( cache_inode_async_precreate_object_by_index( i,
00963                                                      FSAL_TYPE_DIR,
00964                                                      &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o1">exp_context</a> ) == -1 )
00965      {
00966         DisplayLog( <span class="stringliteral">"NFS INIT: /!\\ Impossible to pre-create asynchronous directory pool"</span> ) ;
00967         exit( 1 ) ;
00968      }
00969 
00970   DisplayLog( <span class="stringliteral">"NFS INIT: preallocating file pool (writeback-md)"</span> ) ;
00971   <span class="keywordflow">for</span>( i = 0 ; i &lt; <a class="code" href="commands__Cache__inode_8c.html#a12">cache_client_param</a>.nb_synclet ; i++ )
00972     <span class="keywordflow">if</span>( cache_inode_async_precreate_object_by_index( i,
00973                                                      FSAL_TYPE_FILE,
00974                                                      &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o1">exp_context</a> ) == -1 )
00975      { 
00976         DisplayLog( <span class="stringliteral">"NFS INIT: /!\\ Impossible to pre-create asynchronous file pool"</span> ) ;
00977         exit( 1 ) ;
00978      }
00979 
00980 <span class="preprocessor">#endif </span>
00981 <span class="preprocessor"></span>
00982   <span class="comment">/* Init the cache content client */</span>
00983   <span class="keywordflow">if</span>( cache_content_client_init( &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o8">dc_client</a>, <a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a> ) != 0 )
00984     <span class="keywordflow">return</span> 1  ;
00985 
00986   context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.pcontent_client = (caddr_t)&amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o8">dc_client</a> ;
00987 
00988   fsdata.cookie = 0 ;
00989   fsdata.handle = root_handle ; 
00990 
00991   <span class="keywordflow">if</span>( ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> = cache_inode_make_root( &amp;fsdata, <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
00992                                                  &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
00993     {
00994       DisplayLogFlux( output, <span class="stringliteral">"Error: can't init fs's root"</span> ) ;
00995       <span class="keywordflow">return</span> 1 ;
00996     }
00997 
00998   <span class="keywordflow">if</span>( cache_content_init_dir( <a class="code" href="commands__Cache__inode_8c.html#a13">datacache_client_param</a>, <a class="code" href="commands__Cache__inode_8c.html#a0">EXPORT_ID</a> ) != 0  )
00999     {
01000       DisplayLogFlux( output, <span class="stringliteral">"Error: can't init datacache directory"</span> ) ;
01001       <span class="keywordflow">return</span> 1 ;
01002     }
01003  
01004   strcpy( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, <span class="stringliteral">"/"</span> ) ;
01005   
01006   context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o4">is_client_init</a> = TRUE;
01007   
01008   pentry_root = context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> ;
01009   
01010   <span class="keywordflow">if</span> (flag_v) fprintf( output, <span class="stringliteral">"\tCache_inode successfully initialized.\n"</span> ) ;
01011   
01012   <span class="comment">/* Free config struct */</span>  
01013   config_Free( config_file );
01014   
01015   <span class="keywordflow">return</span> 0;
01016 }
01017 
<a name="l01019"></a><a class="code" href="commands__Cache__inode_8c.html#a28">01019</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a28">fn_Cache_inode_cache_init</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01020                                <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01021                                FILE * output )    <span class="comment">/* IN : output stream          */</span>
01022 {
01023   <span class="keywordtype">int</span> rc;
01024     
01025   <span class="keywordtype">int</span> flag_v   = 0;
01026   <span class="keywordtype">int</span> flag_h   = 0;  
01027   <span class="keywordtype">int</span> err_flag = 0 ;
01028   <span class="keywordtype">int</span> option ;
01029   <span class="keywordtype">char</span> * filename = NULL;
01030 
01031   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
01032   
01033   <span class="keyword">static</span> <span class="keywordtype">char</span> help_init[]=
01034     <span class="stringliteral">"usage: init_cache [options] &lt;ganesha_config_file&gt;\n"</span>
01035     <span class="stringliteral">"options :\n"</span>
01036     <span class="stringliteral">"\t-h print this help\n"</span>
01037     <span class="stringliteral">"\t-v verbose mode\n"</span>;
01038 
01039   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> != NULL )
01040     {
01041       fprintf( output, <span class="stringliteral">"\tCache_inode is already initialized\n"</span> ) ;
01042       <span class="keywordflow">return</span> 0 ;
01043     }
01044   
01045   <span class="comment">/* analysing options */</span>
01046   getopt_init();
01047   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
01048     {   
01049       <span class="keywordflow">switch</span>( option )
01050         {
01051         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01052           <span class="keywordflow">if</span>( flag_v )
01053             fprintf( output,
01054                     <span class="stringliteral">"init_cache: warning: option 'v' has been specified more than once.\n"</span>); 
01055           <span class="keywordflow">else</span> 
01056             flag_v++;
01057           <span class="keywordflow">break</span>;
01058           
01059         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01060           <span class="keywordflow">if</span>( flag_h )
01061             fprintf( output,
01062                      <span class="stringliteral">"init_cache: warning: option 'h' has been specified more than once.\n"</span>) ;
01063           <span class="keywordflow">else</span> 
01064             flag_h++;
01065           <span class="keywordflow">break</span>;
01066           
01067       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01068         fprintf( output, <span class="stringliteral">"init_fs: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a> ) ;
01069         err_flag ++;
01070         <span class="keywordflow">break</span>;
01071         } <span class="comment">/* switch */</span>   
01072     } <span class="comment">/* while */</span>
01073   
01074   <span class="keywordflow">if</span>( flag_h )
01075     {
01076       fprintf( output, help_init );
01077       <span class="keywordflow">return</span> 0;
01078     }
01079 
01080   <span class="comment">/* verifies mandatory argument */</span>
01081   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc -1 ) )
01082     {
01083       <span class="comment">/* too much or not enough arguments */</span>
01084       err_flag ++;
01085     } 
01086   <span class="keywordflow">else</span> 
01087     filename = argv[Optind];
01088   
01089   <span class="keywordflow">if</span>( err_flag )
01090     {
01091       fprintf(output,help_init);
01092       <span class="keywordflow">return</span> -1;
01093     }
01094 
01095   rc = <a class="code" href="commands__Cache__inode_8c.html#a27">cacheinode_init</a>(filename, flag_v, output);
01096 
01097   <span class="keywordflow">return</span> rc;
01098 }
01099 
01100 
01101 
<a name="l01103"></a><a class="code" href="commands__Cache__inode_8c.html#a29">01103</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a29">fn_Cache_inode_pwd</a>( <span class="keywordtype">int</span> argc ,          <span class="comment">/* IN : number of args in argv */</span>
01104                         <span class="keywordtype">char</span> ** argv ,      <span class="comment">/* IN : arg list               */</span>
01105                         FILE * output   )   <span class="comment">/* IN : output stream          */</span>
01106 {
01107    fsal_handle_t        * pfsal_handle = NULL ;
01108    cache_inode_status_t   cache_status ;
01109    <span class="keywordtype">char</span> buff[128];
01110    
01111   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01112   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01113   
01114   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL )
01115     {
01116       fprintf( output, <span class="stringliteral">"Error: Cache is not initialized\n"</span> ) ;
01117       <span class="keywordflow">return</span> -1 ;
01118     }
01119 
01120   <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a>) ) == NULL )
01121     {
01122       <span class="keywordflow">return</span> 1 ;
01123     }
01124   
01125   fprintf( output, <span class="stringliteral">"Current directory is \"%s\" \n"</span>, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a> ) ;
01126   snprintmem( buff, 128, (caddr_t)pfsal_handle, <span class="keyword">sizeof</span>( fsal_handle_t ) ) ;
01127   fprintf( output, <span class="stringliteral">"Current File handle is \"@%s\" \n"</span>, buff ) ; 
01128 
01129   <span class="keywordflow">return</span> 0;
01130     
01131 }
01132 
<a name="l01134"></a><a class="code" href="commands__Cache__inode_8c.html#a30">01134</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a30">fn_Cache_inode_cd</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01135         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01136         FILE * output )    <span class="comment">/* IN : output stream          */</span>
01137 {
01138   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
01139   
01140   cache_entry_t *  new_pentry;
01141   fsal_attrib_list_t attrs;
01142   fsal_status_t st;
01143   <span class="keywordtype">int</span> rc ;
01144   
01145   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01146   
01147   <span class="keyword">static</span> <span class="keywordtype">char</span> help_cd[]=
01148     <span class="stringliteral">"usage: cd &lt;path&gt;\n"</span>;
01149     
01150   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL )
01151     {
01152       fprintf( output, <span class="stringliteral">"\tCache is not initialized\n"</span> ) ;
01153       <span class="keywordflow">return</span> -1 ;
01154     }
01155   
01156   <span class="comment">/* Exactly one arg expected */</span>
01157   <span class="keywordflow">if</span> (argc!=2){
01158     fprintf(output,help_cd);
01159     <span class="keywordflow">return</span> -1;
01160   }
01161   
01162   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01163   
01164   strncpy(glob_path,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
01165   
01166   <span class="keywordflow">if</span>(  ( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, argv[1], context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> , &amp;new_pentry, output ) ) != 0 )
01167     <span class="keywordflow">return</span> rc ;
01168   
01169   <span class="keywordflow">if</span>( new_pentry-&gt;internal_md.type != DIR_BEGINNING )
01170     {
01171       fprintf(output,<span class="stringliteral">"Error: %s is not a directory\n"</span>,glob_path);  
01172       <span class="keywordflow">return</span> ENOTDIR;
01173     }
01174 
01175   <span class="keywordflow">if</span>( ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> = cache_inode_access( new_pentry, 
01176                                                     FSAL_X_OK, 
01177                                                     <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01178                                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01179                                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01180                                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) != CACHE_INODE_SUCCESS )
01181     {
01182       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_access : %J%r\n"</span>,
01183                    ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
01184       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01185     }    
01186     
01187     
01188   <span class="comment">/* if so, apply changes */</span>  
01189   strncpy(context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,glob_path,FSAL_MAX_PATH_LEN);   
01190   context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> = new_pentry;
01191   
01192   fprintf(output,<span class="stringliteral">"Current directory is \"%s\"\n"</span>, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a> ); 
01193 
01194   <span class="keywordflow">return</span> 0;      
01195 }
01196 
01197 
<a name="l01199"></a><a class="code" href="commands__Cache__inode_8c.html#a31">01199</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a31">fn_Cache_inode_stat</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01200         <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01201         FILE * output   )  <span class="comment">/* IN : output stream          */</span>
01202 {
01203   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
01204    
01205   <span class="keyword">static</span> <span class="keywordtype">char</span> help_stat[]=<span class="stringliteral">"usage: stat [-h][-v] &lt;file&gt;\n"</span>;
01206 
01207   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
01208   cache_entry_t * pentry_stat = NULL ;
01209   fsal_attrib_list_t attrs;
01210 
01211   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01212 
01213   <span class="keywordtype">int</span> rc,option;
01214   <span class="keywordtype">int</span> flag_v=0;
01215   <span class="keywordtype">int</span> flag_h=0;
01216   <span class="keywordtype">int</span> err_flag=0;
01217   <span class="keywordtype">char</span> * file = NULL;
01218   
01219   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL )
01220     {
01221       fprintf( output, <span class="stringliteral">"\tCache_inode is not initialized\n"</span> ) ;
01222       <span class="keywordflow">return</span> -1 ;
01223     }
01224  
01225   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01226 
01227   <span class="comment">/* analysing options */</span>
01228   getopt_init();  
01229     
01230   <span class="keywordflow">while</span> ((option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format)) != -1){ 
01231     
01232     <span class="keywordflow">switch</span>(option){
01233       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01234         <span class="keywordflow">if</span> (flag_v)
01235           fprintf(output,
01236               <span class="stringliteral">"stat: warning: option 'v' has been specified more than once.\n"</span>);
01237         <span class="keywordflow">else</span> flag_v++;
01238         <span class="keywordflow">break</span>;
01239       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01240         <span class="keywordflow">if</span> ( flag_h )
01241           fprintf(output,
01242               <span class="stringliteral">"stat: warning: option 'h' has been specified more than once.\n"</span>);
01243         <span class="keywordflow">else</span> flag_h++;
01244         <span class="keywordflow">break</span>;
01245       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01246         fprintf(output,<span class="stringliteral">"stat: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
01247         err_flag ++;
01248         <span class="keywordflow">break</span>;
01249     }    
01250   }
01251   
01252   <span class="comment">/* Exactly one arg expected */</span>
01253   <span class="keywordflow">if</span> (<a class="code" href="Getopt_8c.html#a4">Optind</a> != (argc-1)){
01254     err_flag ++;
01255   } <span class="keywordflow">else</span> {
01256     file = argv[Optind];
01257   }
01258   
01259   <span class="keywordflow">if</span> (err_flag){
01260     fprintf(output,help_stat);
01261     <span class="keywordflow">return</span> -1;
01262   }
01263     
01264   <span class="comment">/* copy current path. */</span>
01265   strncpy(glob_path,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
01266   
01267   <span class="comment">/* retrieves object handle*/</span>
01268   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>(glob_path,
01269                            FSAL_MAX_PATH_LEN,
01270                            file, 
01271                            context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, 
01272                            &amp;pentry_stat,
01273                            output ) )
01274     <span class="keywordflow">return</span> rc;
01275 
01276   <span class="comment">/* Get the attributes */</span>
01277   <span class="keywordflow">if</span>( cache_inode_getattr( pentry_stat,
01278                            &amp;attrs,
01279                            <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01280                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01281                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01282                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01283     {
01284      log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_getattr( \"%s\" ) : %J%r\n"</span>,
01285                   file, ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
01286 
01287       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01288     }
01289 
01290   <span class="comment">/* print file attributes */</span>
01291   <a class="code" href="cmd__tools_8h.html#a21">print_fsal_attributes</a>( attrs, output);
01292 
01293   <span class="keywordflow">return</span> 0 ;
01294 }
01295 
01296 
<a name="l01298"></a><a class="code" href="commands__Cache__inode_8c.html#a32">01298</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a32">fn_Cache_inode_gc</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01299                        <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01300                        FILE * output  )   <span class="comment">/* IN : output stream          */</span>
01301 {
01302   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span> ;
01303   
01304   <span class="keyword">static</span> <span class="keywordtype">char</span> help_gc[]=<span class="stringliteral">"usage: gc \n"</span>
01305     <span class="stringliteral">"options :\n"</span>
01306     <span class="stringliteral">"\t-h print this help\n"</span>
01307     <span class="stringliteral">"   The gc policy used is defined in the configuration file\n"</span> ;
01308   
01309    <span class="keywordtype">int</span> option;
01310    <span class="keywordtype">int</span> flag_v = 0;
01311    <span class="keywordtype">int</span> flag_h = 0;
01312    <span class="keywordtype">int</span> err_flag = 0;
01313 
01314   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01315    
01316    <span class="comment">/* is the fs initialized ? */</span>
01317    <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
01318     {
01319       fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
01320       <span class="keywordflow">return</span> -1;
01321     }
01322 
01323   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01324   
01325   <span class="comment">/* analysing options */</span>
01326   getopt_init();
01327   
01328   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
01329     {   
01330       <span class="keywordflow">switch</span>( option )
01331         {
01332         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01333           <span class="keywordflow">if</span>( flag_v )
01334             fprintf(output,
01335                     <span class="stringliteral">"ls: warning: option 'v' has been specified more than once.\n"</span>);
01336           <span class="keywordflow">else</span>
01337             flag_v++;
01338           <span class="keywordflow">break</span>;
01339 
01340         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01341           <span class="keywordflow">if</span>( flag_h )
01342             fprintf(output,
01343                     <span class="stringliteral">"ls: warning: option 'h' has been specified more than once.\n"</span>);
01344           <span class="keywordflow">else</span> 
01345             flag_h++;
01346           <span class="keywordflow">break</span>;
01347 
01348         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01349           fprintf(output,<span class="stringliteral">"ls: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
01350           err_flag ++;
01351           <span class="keywordflow">break</span>;
01352         }
01353     } <span class="comment">/* while */</span>
01354   
01355   <span class="keywordflow">if</span>( flag_h )
01356     {
01357       fprintf(output,help_gc);
01358       <span class="keywordflow">return</span> 0;
01359     }
01360   
01361   <span class="keywordflow">if</span>( err_flag )
01362     {
01363       fprintf(output,help_gc);
01364       <span class="keywordflow">return</span> -1;
01365     }
01366   
01367   
01368   cache_inode_set_gc_policy( gcpol ) ;
01369 
01370   <span class="keywordflow">if</span>( cache_inode_gc( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01371     {
01372       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_gc : %J%r\n"</span>,
01373                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01374       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01375     }
01376 
01377   <span class="keywordflow">return</span> 0 ;
01378 } <span class="comment">/* fn_Cache_inode_gc */</span>
01379 
01380 
<a name="l01382"></a><a class="code" href="commands__Cache__inode_8c.html#a33">01382</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a33">fn_Cache_inode_ls</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01383                        <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01384                        FILE * output  )   <span class="comment">/* IN : output stream          */</span>
01385 {
01386 <span class="preprocessor">#define CACHE_INODE_SHELL_READDIR_SIZE 10</span>
01387 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> begin_cookie = 0 ;
01388   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end_cookie = 0 ;
01389   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbfound ;
01390   cache_inode_dir_entry_t dirent_array[CACHE_INODE_SHELL_READDIR_SIZE] ;
01391   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  cookie_array[CACHE_INODE_SHELL_READDIR_SIZE] ;
01392   cache_inode_endofdir_t eod_met ;
01393   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i ;
01394   fsal_path_t symlink_path;
01395   fsal_attrib_list_t attrs;
01396   <span class="keywordtype">char</span> * str_name = <span class="stringliteral">"."</span> ;
01397   <span class="keywordtype">char</span> item_path[FSAL_MAX_PATH_LEN];
01398   cache_entry_t * pentry_tmp = NULL ;
01399 
01400   <span class="keywordtype">int</span> rc = 0 ;
01401   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
01402   fsal_handle_t        * pfsal_handle = NULL ;
01403 
01404   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvdlLSHz"</span>;
01405   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ls[]=<span class="stringliteral">"usage: ls [options]\n"</span>
01406     <span class="stringliteral">"options :\n"</span>
01407     <span class="stringliteral">"\t-h print this help\n"</span>
01408     <span class="stringliteral">"\t-v verbose mode\n"</span>  
01409     <span class="stringliteral">"\t-d print directory info instead of listing its content\n"</span>      
01410     <span class="stringliteral">"\t-l print standard UNIX attributes\n"</span>
01411     <span class="stringliteral">"\t-L print the cache_inode entry addresses\n"</span> 
01412     <span class="stringliteral">"\t-S print all supported attributes\n"</span>
01413     <span class="stringliteral">"\t-H print the fsal handle\n"</span> 
01414     <span class="stringliteral">"\t-z silent mode (print nothing)\n"</span> ;
01415   
01416   <span class="keywordtype">int</span> option;
01417   <span class="keywordtype">int</span> flag_v = 0;
01418   <span class="keywordtype">int</span> flag_h = 0;
01419   <span class="keywordtype">int</span> flag_d = 0;
01420   <span class="keywordtype">int</span> flag_l = 0;
01421   <span class="keywordtype">int</span> flag_S = 0;
01422   <span class="keywordtype">int</span> flag_L = 0 ;
01423   <span class="keywordtype">int</span> flag_H = 0 ;
01424   <span class="keywordtype">int</span> flag_z = 0 ;
01425   <span class="keywordtype">int</span> err_flag = 0;
01426   
01427   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01428    
01429    <span class="comment">/* is the fs initialized ? */</span>
01430    <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
01431     {
01432       fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
01433       <span class="keywordflow">return</span> -1;
01434     }
01435 
01436   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01437 
01438   <span class="comment">/* analysing options */</span>
01439   getopt_init();
01440 
01441   <span class="keywordflow">while</span> ( (option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>(argc, argv, format) ) != -1)
01442     {   
01443       <span class="keywordflow">switch</span>( option )
01444         {
01445         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01446           <span class="keywordflow">if</span> (flag_v)
01447             fprintf(output,
01448                     <span class="stringliteral">"ls: warning: option 'v' has been specified more than once.\n"</span>);
01449           <span class="keywordflow">else</span> 
01450             flag_v++;
01451           <span class="keywordflow">break</span>;
01452           
01453         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01454           <span class="keywordflow">if</span> ( flag_h )
01455             fprintf(output,
01456                     <span class="stringliteral">"ls: warning: option 'h' has been specified more than once.\n"</span>);
01457           <span class="keywordflow">else</span> 
01458             flag_h++;
01459           <span class="keywordflow">break</span>;
01460           
01461         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
01462           <span class="keywordflow">if</span> ( flag_d )
01463             fprintf(output,
01464                     <span class="stringliteral">"ls: warning: option 'd' has been specified more than once.\n"</span>);
01465           <span class="keywordflow">else</span> 
01466             flag_d++;
01467           <span class="keywordflow">break</span>;
01468           
01469         <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
01470           <span class="keywordflow">if</span> ( flag_l )
01471             fprintf(output,
01472                     <span class="stringliteral">"ls: warning: option 'l' has been specified more than once.\n"</span>);
01473           <span class="keywordflow">else</span> 
01474             flag_l++;
01475           <span class="keywordflow">break</span>;
01476           
01477         <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
01478           <span class="keywordflow">if</span> ( flag_L )
01479             fprintf(output,
01480                     <span class="stringliteral">"ls: warning: option 'L' has been specified more than once.\n"</span>);
01481           <span class="keywordflow">else</span> 
01482             flag_L++;
01483           <span class="keywordflow">break</span>;
01484           
01485         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
01486           <span class="keywordflow">if</span> ( flag_S )
01487             fprintf(output,
01488                     <span class="stringliteral">"ls: warning: option 'S' has been specified more than once.\n"</span>);
01489           <span class="keywordflow">else</span> 
01490             flag_S++;
01491           <span class="keywordflow">break</span>;
01492           
01493         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
01494           <span class="keywordflow">if</span> ( flag_z )
01495             fprintf(output,
01496                     <span class="stringliteral">"ls: warning: option 'z' has been specified more than once.\n"</span>);
01497           <span class="keywordflow">else</span> 
01498             flag_z++;
01499           <span class="keywordflow">break</span>;
01500 
01501         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
01502           <span class="keywordflow">if</span>( flag_H )
01503             fprintf(output,
01504                     <span class="stringliteral">"ls: warning: option 'H' has been specified more than once.\n"</span>);
01505           <span class="keywordflow">else</span> 
01506             flag_H++;
01507           <span class="keywordflow">break</span>;
01508           
01509         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01510           fprintf(output,<span class="stringliteral">"ls: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
01511           err_flag ++;
01512           <span class="keywordflow">break</span>;
01513         }
01514     } <span class="comment">/* while */</span>
01515   
01516   <span class="keywordflow">if</span>( flag_l + flag_S + flag_L + flag_H &gt; 1 )
01517     {
01518       fprintf(output,<span class="stringliteral">"ls: conflict between options l,S,L\n"</span>);
01519       err_flag++;
01520     }
01521 
01522   <span class="keywordflow">if</span>( flag_z + flag_v &gt; 1 )
01523     {
01524       fprintf( output, <span class="stringliteral">"ls: can't use -z and -v at the same time\n"</span> ) ;
01525       err_flag ++ ;
01526     }
01527   
01528   <span class="keywordflow">if</span>( flag_h )
01529     {
01530       fprintf(output,help_ls);
01531       <span class="keywordflow">return</span> 0;
01532     }
01533   
01534   <span class="keywordflow">if</span>( err_flag )
01535     {
01536       fprintf(output,help_ls);
01537       <span class="keywordflow">return</span> -1;
01538     }
01539   
01540   strncpy(glob_path,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
01541 
01542   <span class="comment">/* first, retrieve the argument (if any) */</span>
01543   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> == argc -1  )
01544     { 
01545       str_name = argv[Optind];
01546       
01547       <span class="comment">/* retrieving handle */</span>  
01548       <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>(glob_path,
01549                                FSAL_MAX_PATH_LEN,
01550                                str_name, 
01551                                context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, 
01552                                &amp;pentry_tmp, 
01553                                output))
01554         <span class="keywordflow">return</span> rc;
01555       
01556     } 
01557   <span class="keywordflow">else</span> 
01558     {
01559       str_name = <span class="stringliteral">"."</span>;
01560       pentry_tmp = context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a> ;
01561     }
01562   
01563   <span class="keywordflow">if</span>( flag_v )
01564     fprintf(output,<span class="stringliteral">"proceeding ls (via Cache_inode) on \"%s\"\n"</span>, glob_path ) ;
01565 
01566   
01567 
01568   <span class="comment">/*</span>
01569 <span class="comment">  * if the object is a file or a directoy with the -d option specified,</span>
01570 <span class="comment">  * we only show its info and exit.</span>
01571 <span class="comment">  */</span>  
01572   <span class="keywordflow">if</span> ( (pentry_tmp-&gt;internal_md.type != DIR_BEGINNING ) || flag_d )
01573     {
01574       <span class="keywordflow">if</span> ( pentry_tmp-&gt;internal_md.type == SYMBOLIC_LINK )
01575         {
01576           <span class="keywordflow">if</span>( cache_inode_readlink( pentry_tmp, 
01577                                     &amp;symlink_path, 
01578                                     <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01579                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01580                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01581                                     &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01582             {
01583               <span class="keywordflow">if</span>( !flag_z) 
01584                 log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_readlink : %J%r\n"</span>,
01585                              ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01586               
01587               <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01588             }
01589         }
01590       
01591       <span class="keywordflow">if</span>( cache_inode_getattr( pentry_tmp, 
01592                                &amp;attrs,
01593                                <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01594                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01595                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01596                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01597         {
01598           <span class="keywordflow">if</span>( !flag_z) 
01599                 log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_getattr : %J%r\n"</span>,
01600                              ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01601                       
01602           <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01603         }
01604 
01605       <span class="keywordflow">if</span>( flag_l )
01606         {
01607           <span class="keywordflow">if</span>( !flag_z )
01608             <a class="code" href="cmd__tools_8h.html#a22">print_item_line</a>( output, &amp;attrs, str_name, symlink_path.path);
01609         }
01610       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_S )
01611         {
01612           <span class="keywordflow">if</span>( !flag_z )
01613             {
01614               fprintf(output,<span class="stringliteral">"%s :\n"</span>,str_name);
01615               <a class="code" href="cmd__tools_8h.html#a21">print_fsal_attributes</a>( attrs, output);
01616             }
01617         } 
01618       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_H )
01619         {
01620           <span class="keywordflow">if</span>( !flag_z )
01621             {
01622               <span class="keywordtype">char</span> buff[128] ;
01623               
01624               <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( pentry_tmp, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a>) ) == NULL )
01625                 {
01626                   <span class="keywordflow">return</span> 1 ;
01627                 }
01628               snprintmem( buff, 128, (caddr_t)pfsal_handle, <span class="keyword">sizeof</span>( fsal_handle_t ) ) ;
01629               fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, str_name, buff ) ;
01630             }
01631         }
01632       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_L ) 
01633         {
01634           <span class="keywordflow">if</span>( !flag_z )
01635             {
01636               <span class="keywordflow">if</span>( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>-&gt;internal_md.type != REGULAR_FILE )
01637                 fprintf(output,<span class="stringliteral">"%p N/A  \t\t%s\n"</span>, pentry_tmp, str_name);
01638               <span class="keywordflow">else</span>
01639                 {
01640                   <span class="keywordflow">if</span>( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>-&gt;object.file.pentry_content == NULL )
01641                     fprintf(output,<span class="stringliteral">"%p (not cached) \t%s\n"</span>, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, str_name ) ;
01642                   <span class="keywordflow">else</span>
01643                     fprintf(output,<span class="stringliteral">"%p %p \t%s\n"</span>, 
01644                             context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, 
01645                             context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>-&gt;object.file.pentry_content, 
01646                             str_name ) ;
01647                 }
01648             }
01649         }
01650       <span class="keywordflow">else</span>  <span class="comment">/* only prints the name */</span>
01651         {
01652           <span class="keywordflow">if</span>( !flag_z )
01653             fprintf(output,<span class="stringliteral">"%s\n"</span>,str_name);
01654         }
01655       
01656       <span class="keywordflow">return</span> 0;
01657     }
01658   
01659   <span class="comment">/* If this point is reached, then the pentry is a directory */</span>
01660   
01661   begin_cookie = 0 ;
01662   eod_met = UNASSIGNED_EOD ;
01663   <span class="keywordflow">while</span>( eod_met != END_OF_DIR )
01664     {
01665       
01666       <span class="keywordflow">if</span>( flag_v )
01667          fprintf( output, <span class="stringliteral">"--&gt;cache_inode_readdir(path=%s,cookie=%d)\n"</span>,
01668                   glob_path,
01669                   begin_cookie  ) ;
01670        
01671       
01672       <span class="keywordflow">if</span>( cache_inode_readdir( pentry_tmp, 
01673                                begin_cookie, 
01674                                <a class="code" href="commands__Cache__inode_8c.html#a2">CACHE_INODE_SHELL_READDIR_SIZE</a>, 
01675                                &amp;nbfound,
01676                                &amp;end_cookie,
01677                                &amp;eod_met, 
01678                                dirent_array, 
01679                                cookie_array,
01680                                <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01681                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01682                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01683                                &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01684         {
01685           fprintf( output, <span class="stringliteral">"Error %d in cache_inode_readdir\n"</span>, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ;
01686           <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01687         }
01688     
01689 
01690       <span class="keywordflow">for</span>( i = 0 ; i &lt; nbfound ; i++ )
01691         {
01692         <span class="keywordtype">int</span> len;
01693         
01694 <span class="comment">/*          if( flag_v )</span>
01695 <span class="comment">            fprintf( output, "dirent_array[%d] ==&gt; %s\n", begin_cookie+i,  dirent_array[i].name.name ) ;</span>
01696 <span class="comment">*/</span>
01697           <span class="keywordflow">if</span> (!strcmp(str_name,<span class="stringliteral">"."</span>))
01698             strncpy(item_path,dirent_array[i].name.name,FSAL_MAX_PATH_LEN);
01699           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str_name[strlen(str_name)-1] == <span class="charliteral">'/'</span>)
01700             snprintf(item_path,FSAL_MAX_PATH_LEN,<span class="stringliteral">"%s%s"</span>,str_name,dirent_array[i].name.name);
01701           <span class="keywordflow">else</span>
01702             snprintf(item_path,FSAL_MAX_PATH_LEN,<span class="stringliteral">"%s/%s"</span>,str_name,dirent_array[i].name.name);
01703           
01704 
01705           <span class="keywordflow">if</span>( dirent_array[i].pentry-&gt;internal_md.type == SYMBOLIC_LINK )
01706             {
01707               <span class="keywordflow">if</span>( cache_inode_readlink(  dirent_array[i].pentry,
01708                                          &amp;symlink_path, 
01709                                          <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01710                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01711                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01712                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01713                 {
01714                   log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_readlink : %J%r\n"</span>,
01715                              ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01716                   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01717                 }
01718             }
01719           
01720           <span class="keywordflow">if</span>( flag_l )
01721             {
01722               <span class="keywordflow">if</span>( cache_inode_getattr( dirent_array[i].pentry,
01723                                        &amp;attrs,
01724                                        <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01725                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01726                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01727                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01728                 {
01729                   log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_getattr : %J%r\n"</span>,
01730                              ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01731                   
01732                   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01733                 }
01734               
01735               <a class="code" href="cmd__tools_8h.html#a22">print_item_line</a>( output, &amp;attrs, item_path, symlink_path.path);
01736             }
01737           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_S )
01738             {
01739               fprintf(output,<span class="stringliteral">"%s :\n"</span>,item_path);
01740               <span class="keywordflow">if</span>( cache_inode_getattr( dirent_array[i].pentry,
01741                                        &amp;attrs,
01742                                        <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
01743                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
01744                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
01745                                        &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
01746                 {
01747                   log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_getattr : %J%r\n"</span>,
01748                              ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
01749                   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
01750                 }
01751               <span class="keywordflow">if</span>( !flag_z )
01752                 <a class="code" href="cmd__tools_8h.html#a21">print_fsal_attributes</a>( attrs, output);
01753             }
01754           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_L )
01755             {
01756               <span class="keywordflow">if</span>( !flag_z )
01757                 {
01758                   <span class="keywordflow">if</span>( dirent_array[i].pentry-&gt;internal_md.type != REGULAR_FILE )
01759                     fprintf(output,<span class="stringliteral">"%p N/A \t\t%s\n"</span>, dirent_array[i].pentry, item_path);
01760                   <span class="keywordflow">else</span>
01761                     {
01762                       <span class="keywordflow">if</span>( dirent_array[i].pentry-&gt;object.file.pentry_content == NULL )
01763                         fprintf(output,<span class="stringliteral">"%p (not cached) \t%s\n"</span>, dirent_array[i].pentry, item_path);
01764                       <span class="keywordflow">else</span>
01765                         fprintf(output,<span class="stringliteral">"%p %p \t%s\n"</span>, 
01766                                 dirent_array[i].pentry, 
01767                                 dirent_array[i].pentry-&gt;object.file.pentry_content, 
01768                                 item_path);
01769                     }
01770                 }
01771             }
01772           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_H )
01773             {
01774               <span class="keywordflow">if</span>( !flag_z )
01775                 {
01776                   <span class="keywordtype">char</span> buff[128] ;
01777                   
01778                   <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle(  dirent_array[i].pentry, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a>) ) == NULL )
01779                     {
01780                       <span class="keywordflow">return</span> 1 ;
01781                     }
01782                   snprintmem( buff, 128, (caddr_t)pfsal_handle, <span class="keyword">sizeof</span>( fsal_handle_t ) ) ;
01783                   fprintf( output, <span class="stringliteral">"%s (@%s)\n"</span>, item_path, buff ) ;
01784                 }
01785             }
01786           <span class="keywordflow">else</span>
01787             {
01788               <span class="keywordflow">if</span>( !flag_z )
01789                 fprintf(output,<span class="stringliteral">"%s\n"</span>,item_path);
01790             }
01791         }
01792       
01793       <span class="comment">/* Ready for next iteration */</span>
01794 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
01795 <span class="preprocessor"></span>      printf( <span class="stringliteral">"--------------&gt; begin_cookie = %d, nbfound=%d, last cookie=%d, end_cookie=%d, begin_cookie + nbfound =%d\n"</span>, 
01796               begin_cookie, nbfound,  cookie_array[nbfound-1] , end_cookie, begin_cookie + nbfound ) ;
01797 <span class="preprocessor">#endif</span>
01798 <span class="preprocessor"></span>      begin_cookie = end_cookie ;
01799     }
01800   
01801   <span class="keywordflow">return</span> 0;
01802 } <span class="comment">/* fn_Cache_inode_ls */</span>
01803 
01804   
01805 
<a name="l01807"></a><a class="code" href="commands__Cache__inode_8c.html#a34">01807</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a34">fn_Cache_inode_callstat</a>( <span class="keywordtype">int</span> argc ,<span class="comment">/* IN : number of args in argv */</span>
01808                              <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01809                              FILE * output   )  <span class="comment">/* IN : output stream          */</span>
01810 {
01811   <span class="keywordtype">int</span> i;
01812   hash_stat_t hstat  ;
01813   
01814   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01815    
01816    <span class="comment">/* is the fs initialized ? */</span>
01817    <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
01818     {
01819       fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
01820       <span class="keywordflow">return</span> -1;
01821     }
01822 
01823   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01824   
01825   <span class="comment">/* displaying stats */</span>
01826   <span class="comment">/* header: */</span>
01827   fprintf( output, <span class="stringliteral">"Function             | Nb_Calls    | Success     | Retryable   | Unrecoverable\n"</span> );
01828   <span class="comment">/* content */</span>
01829   <span class="keywordflow">for</span> (i=0;i&lt;CACHE_INODE_NB_COMMAND;i++)
01830     fprintf(output,<span class="stringliteral">"%-20s | %11u | %11u | %11u | %11u\n"</span>,
01831           cache_inode_function_names[i],
01832           context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.stat.func_stats.nb_call[i],
01833           context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.stat.func_stats.nb_success[i],
01834           context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.stat.func_stats.nb_err_retryable[i],
01835           context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.stat.func_stats.nb_err_unrecover[i]
01836           );
01837   fprintf( output, <span class="stringliteral">"------------------------------------------------------------------------------\n"</span> ) ;
01838   
01839   <span class="comment">/* Statistics for the HashTable */</span>
01840   HashTable_GetStats( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, &amp;hstat ) ;
01841   fprintf( output, <span class="stringliteral">"Operation            |     ok      |    err      |   notfound  \n"</span> ) ;
01842   fprintf( output, <span class="stringliteral">"Set                  | %11u | %11u | %11u \n"</span>, 
01843            hstat.dynamic.ok.nb_set, hstat.dynamic.err.nb_set, hstat.dynamic.notfound.nb_set ) ;
01844   fprintf( output, <span class="stringliteral">"Test                 | %11u | %11u | %11u \n"</span>, 
01845            hstat.dynamic.ok.nb_test, hstat.dynamic.err.nb_test, hstat.dynamic.notfound.nb_test ) ;
01846   fprintf( output, <span class="stringliteral">"Get                  | %11u | %11u | %11u \n"</span>, 
01847            hstat.dynamic.ok.nb_get, hstat.dynamic.err.nb_get, hstat.dynamic.notfound.nb_get ) ;
01848   fprintf( output, <span class="stringliteral">"Del                  | %11u | %11u | %11u \n"</span>, 
01849            hstat.dynamic.ok.nb_del, hstat.dynamic.err.nb_del, hstat.dynamic.notfound.nb_del ) ;
01850   fprintf( output, <span class="stringliteral">"------------------------------------------------------------------------------\n"</span> ) ;
01851   fprintf( output, <span class="stringliteral">"There are %d entries in the Cache inode HashTable\n"</span>, hstat.dynamic.nb_entries ) ;
01852   fprintf( output, <span class="stringliteral">"index_size=%d  min_rbt_num_node=%d  max_rbt_num_node=%d average_rbt_num_node=%d\n"</span>, 
01853            <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>-&gt;parameter.index_size, 
01854            hstat.computed.min_rbt_num_node, hstat.computed.max_rbt_num_node, hstat.computed.average_rbt_num_node ) ;
01855   fprintf( output, <span class="stringliteral">"------------------------------------------------------------------------------\n"</span> ) ;
01856   fprintf( output, <span class="stringliteral">"Client LRU_GC: nb_entry=%d, nb_invalid=%d, nb_call_gc=%d, param.nb_call_gc_invalid=%d\n"</span>, 
01857            context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.lru_gc-&gt;nb_entry, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.lru_gc-&gt;nb_invalid, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.lru_gc-&gt;nb_call_gc, 
01858            context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.lru_gc-&gt;parameter.nb_call_gc_invalid ) ;
01859   fprintf( output, <span class="stringliteral">"------------------------------------------------------------------------------\n"</span> ) ;
01860 
01861   <span class="keywordflow">return</span> 0;  
01862 }
01863 
01864 
<a name="l01866"></a><a class="code" href="commands__Cache__inode_8c.html#a35">01866</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a35">fn_Cache_inode_mkdir</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
01867                    <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
01868                    FILE * output      <span class="comment">/* IN : output stream          */</span> )
01869 {
01870   
01871   
01872   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
01873    
01874   <span class="keyword">static</span> <span class="keywordtype">char</span> help_mkdir[]=
01875   <span class="stringliteral">"usage: mkdir [-h][-v] &lt;path&gt; [mode]\n"</span>
01876   <span class="stringliteral">"       path: parent directory where the directory is to be created\n"</span>
01877   <span class="stringliteral">"       name: name of the directory is to be created\n"</span>
01878   <span class="stringliteral">"       mode: octal mode for the directory is to be created (ex: 755)\n"</span> ;
01879 
01880   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
01881   cache_entry_t * new_hdl ;
01882   cache_entry_t * subdir_hdl ;
01883   fsal_attrib_list_t attrs;
01884   fsal_status_t st;
01885   <span class="keywordtype">int</span> rc,option;
01886   <span class="keywordtype">int</span> flag_v=0;
01887   <span class="keywordtype">int</span> flag_h=0;
01888   <span class="keywordtype">int</span> err_flag=0;
01889   <span class="keywordtype">int</span> mode;
01890   fsal_accessmode_t fsalmode = 0755;
01891   fsal_attrib_list_t attrmkdir ;
01892   
01893   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN];
01894   <span class="keywordtype">char</span> * path;
01895   <span class="keywordtype">char</span> * file;
01896   <span class="keywordtype">char</span> * strmode;
01897   
01898   fsal_name_t objname;
01899 
01900   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
01901    
01902   <span class="comment">/* is the fs initialized ? */</span>
01903   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
01904    {
01905      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
01906      <span class="keywordflow">return</span> -1;
01907    }
01908   
01909   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
01910   
01911   <span class="comment">/* analysing options */</span>
01912   getopt_init();
01913   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
01914     <span class="keywordflow">switch</span>( option )
01915       {
01916       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01917         <span class="keywordflow">if</span>( flag_v )
01918           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'v' has been specified more than once.\n"</span>);
01919         <span class="keywordflow">else</span> flag_v++;
01920         <span class="keywordflow">break</span>;
01921         
01922       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01923         <span class="keywordflow">if</span>( flag_h )
01924           fprintf( output, <span class="stringliteral">"mkdir: warning: option 'h' has been specified more than once.\n"</span>);
01925         <span class="keywordflow">else</span> flag_h++;
01926         <span class="keywordflow">break</span>;
01927         
01928       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01929         fprintf( output,<span class="stringliteral">"mkdir: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
01930         err_flag ++;
01931         <span class="keywordflow">break</span>;
01932     }    
01933   }
01934   
01935   <span class="keywordflow">if</span>( flag_h )
01936     {
01937       fprintf( output, help_mkdir);
01938       <span class="keywordflow">return</span> 0;
01939     }
01940   
01941   <span class="comment">/* Exactly 1 or 2 args expected */</span>
01942     
01943   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) &amp;&amp; <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) )
01944     {
01945       err_flag ++;
01946     } 
01947   <span class="keywordflow">else</span> 
01948     {
01949       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], FSAL_MAX_PATH_LEN );
01950       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
01951       
01952       <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == ( argc - 1 ) )
01953       {
01954         mode = 0755;
01955       }
01956       <span class="keywordflow">else</span>
01957       {
01958         strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
01959         <span class="comment">/* converting mode string to FSAL mode string */</span>
01960         mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );  
01961       }
01962 
01963   <span class="keywordflow">if</span>( mode&lt;0 ) 
01964     err_flag ++;
01965   <span class="keywordflow">else</span> 
01966     {
01967       fsalmode = 0;
01968       
01969       <span class="keywordflow">if</span> ( mode &amp; S_ISUID ) fsalmode |= FSAL_MODE_SUID;
01970       <span class="keywordflow">if</span> ( mode &amp; S_ISGID ) fsalmode |= FSAL_MODE_SGID;
01971       
01972       <span class="keywordflow">if</span> ( mode &amp; S_IRUSR ) fsalmode |= FSAL_MODE_RUSR;
01973       <span class="keywordflow">if</span> ( mode &amp; S_IWUSR ) fsalmode |= FSAL_MODE_WUSR;
01974       <span class="keywordflow">if</span> ( mode &amp; S_IXUSR ) fsalmode |= FSAL_MODE_XUSR;
01975       
01976       <span class="keywordflow">if</span> ( mode &amp; S_IRGRP ) fsalmode |= FSAL_MODE_RGRP;
01977       <span class="keywordflow">if</span> ( mode &amp; S_IWGRP ) fsalmode |= FSAL_MODE_WGRP;
01978       <span class="keywordflow">if</span> ( mode &amp; S_IXGRP ) fsalmode |= FSAL_MODE_XGRP;
01979       
01980       <span class="keywordflow">if</span> ( mode &amp; S_IROTH ) fsalmode |= FSAL_MODE_ROTH;
01981       <span class="keywordflow">if</span> ( mode &amp; S_IWOTH ) fsalmode |= FSAL_MODE_WOTH;
01982       <span class="keywordflow">if</span> ( mode &amp; S_IXOTH ) fsalmode |= FSAL_MODE_XOTH;
01983       
01984     }
01985   }
01986   
01987   <span class="keywordflow">if</span>( err_flag )
01988     {
01989       fprintf( output, help_mkdir );
01990       <span class="keywordflow">return</span> -1;
01991     }
01992   
01993   <span class="comment">/* copy current path. */</span>
01994   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
01995   
01996   <span class="comment">/* retrieves path handle*/</span>
01997   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;new_hdl,output) )
01998     <span class="keywordflow">return</span> rc;
01999   
02000 
02001   <span class="comment">/* create fsal_name_t */</span>
02002   st = FSAL_str2name( file, 256,&amp;objname ) ;
02003   
02004   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02005     {
02006       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span>);
02007       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02008       fprintf( output, <span class="stringliteral">"\n"</span> );
02009       <span class="keywordflow">return</span> st.major;
02010     }
02011   
02012   subdir_hdl = cache_inode_create( new_hdl, 
02013                                    &amp;objname, 
02014                                    DIR_BEGINNING, 
02015                                    fsalmode, 
02016                                    <a class="code" href="Getopt_8c.html#a0">NULL</a>, 
02017                                    &amp;attrmkdir, 
02018                                    <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02019                                    &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
02020                                    &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02021                                    &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02022     
02023   <span class="keywordflow">if</span>( ( subdir_hdl == NULL ) || ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> != 0 )  )
02024   {
02025     log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_create(DIR_BEGINNING) : %J%r\n"</span>,
02026                  ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
02027 
02028     <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
02029   }
02030 
02031   <span class="keywordflow">if</span>( flag_v )
02032   {
02033     fprintf(output,<span class="stringliteral">"%s/%s successfully created (handle=%p) \n"</span>,glob_path,file, subdir_hdl ) ;
02034   }
02035 
02036   <span class="keywordflow">return</span> 0;  
02037 }
02038 
<a name="l02040"></a><a class="code" href="commands__Cache__inode_8c.html#a36">02040</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a36">fn_Cache_inode_link</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02041                          <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02042                          FILE * output      <span class="comment">/* IN : output stream          */</span> )
02043 {
02044   
02045   
02046   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02047   
02048   <span class="keyword">static</span> <span class="keywordtype">char</span> help_hardlink[]=
02049     <span class="stringliteral">"hardlink: create a hard link.\n"</span>
02050     <span class="stringliteral">"usage: hardlink [-h][-v] &lt;target&gt; &lt;new_path&gt;\n"</span>
02051     <span class="stringliteral">"       target: path of an existing file.\n"</span>
02052     <span class="stringliteral">"       new_path: path of the hardlink to be created\n"</span>;
02053   
02054   <span class="keywordtype">char</span> glob_path_target[FSAL_MAX_PATH_LEN];
02055   <span class="keywordtype">char</span> glob_path_link[FSAL_MAX_PATH_LEN];
02056 
02057   cache_entry_t * target_hdl;
02058   cache_entry_t * dir_hdl;
02059   fsal_name_t   link_name;
02060 
02061   fsal_attrib_list_t attrs;
02062   fsal_status_t st;
02063   <span class="keywordtype">int</span> rc,option;
02064   <span class="keywordtype">int</span> flag_v=0;
02065   <span class="keywordtype">int</span> flag_h=0;
02066   <span class="keywordtype">int</span> err_flag=0;
02067   fsal_attrib_list_t attrlink ;
02068 
02069   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN];
02070   <span class="keywordtype">char</span> * target = NULL;
02071   <span class="keywordtype">char</span> * path;
02072   <span class="keywordtype">char</span> * name;
02073   
02074   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02075    
02076   <span class="comment">/* is the fs initialized ? */</span>
02077   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02078    {
02079      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02080      <span class="keywordflow">return</span> -1;
02081    }
02082 
02083   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02084   
02085   <span class="comment">/* analysing options */</span>
02086   getopt_init();
02087   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
02088     {   
02089       <span class="keywordflow">switch</span>( option )
02090         {
02091         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02092           <span class="keywordflow">if</span>( flag_v )
02093             fprintf( output,
02094                      <span class="stringliteral">"hardlink: warning: option 'v' has been specified more than once.\n"</span> );
02095           <span class="keywordflow">else</span> 
02096             flag_v++;
02097           <span class="keywordflow">break</span>;
02098 
02099         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02100           <span class="keywordflow">if</span>( flag_h )
02101             fprintf( output, <span class="stringliteral">"hardlink: warning: option 'h' has been specified more than once.\n"</span>);
02102           <span class="keywordflow">else</span> 
02103             flag_h++;
02104           <span class="keywordflow">break</span>;
02105           
02106       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02107         fprintf( output,<span class="stringliteral">"hardlink: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02108         err_flag ++;
02109         <span class="keywordflow">break</span>;
02110         }    
02111     }
02112   
02113   <span class="keywordflow">if</span>( flag_h )
02114     {
02115       fprintf( output, help_hardlink );
02116       <span class="keywordflow">return</span> 0;
02117     }
02118 
02119   <span class="comment">/* There should be exactly 2 arguments */</span>
02120   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> == ( argc -2 ) )
02121     {
02122       target = argv[Optind];
02123       
02124       strncpy( tmp_path, argv[ <a class="code" href="Getopt_8c.html#a4">Optind</a> + 1 ], FSAL_MAX_PATH_LEN );
02125       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;name );
02126     }
02127   <span class="keywordflow">else</span> 
02128     {    
02129       err_flag ++;    
02130     }
02131   
02132   
02133   <span class="keywordflow">if</span>( err_flag )
02134     {
02135       fprintf( output, help_hardlink );
02136       <span class="keywordflow">return</span> -1;
02137     }
02138 
02139   <span class="comment">/* copy current path. */</span>
02140   strncpy(glob_path_target,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
02141   strncpy(glob_path_link,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
02142   
02143   <span class="comment">/* retrieves path handle*/</span>
02144   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path_target, FSAL_MAX_PATH_LEN, target, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;target_hdl, output) )
02145     <span class="keywordflow">return</span> rc;
02146 
02147   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path_link, FSAL_MAX_PATH_LEN, path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;dir_hdl, output) )
02148     <span class="keywordflow">return</span> rc;
02149 
02150   <span class="comment">/* create fsal_name_t */</span>
02151   st = FSAL_str2name( name, 256,&amp;link_name ) ;
02152   
02153   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02154     {
02155       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span>);
02156       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02157       fprintf( output, <span class="stringliteral">"\n"</span> );
02158       <span class="keywordflow">return</span> st.major;
02159     }
02160 
02161   <span class="keywordflow">if</span>( cache_inode_link( target_hdl,
02162                         dir_hdl,
02163                         &amp;link_name, 
02164                         &amp;attrlink, 
02165                         <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02166                         &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
02167                         &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02168                         &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
02169     {
02170      log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_link : %J%r\n"</span>,
02171                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02172       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a>;
02173     }
02174 
02175   <span class="keywordflow">if</span>( flag_v )
02176     {
02177       fprintf(output,<span class="stringliteral">"hardlink successfully created \n"</span> ) ;
02178     }
02179 
02180   <span class="keywordflow">return</span> 0;  
02181 }
02182 
02183 
02184 
<a name="l02186"></a><a class="code" href="commands__Cache__inode_8c.html#a37">02186</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a37">fn_Cache_inode_ln</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02187                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02188                             FILE * output      <span class="comment">/* IN : output stream          */</span> )
02189 {
02190   
02191   
02192   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02193    
02194   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ln[]=
02195   <span class="stringliteral">"usage: ln [-h][-v] &lt;link_content&gt; &lt;link_path&gt;\n"</span>
02196   <span class="stringliteral">"       link_content: content of the symbolic link to be created\n"</span>
02197   <span class="stringliteral">"       link_path: path of the symbolic link to be created\n"</span>;
02198 
02199   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
02200   cache_entry_t * new_hdl ;
02201   cache_entry_t * subdir_hdl ;
02202   fsal_attrib_list_t attrs;
02203   fsal_status_t st;
02204   <span class="keywordtype">int</span> rc,option;
02205   <span class="keywordtype">int</span> flag_v=0;
02206   <span class="keywordtype">int</span> flag_h=0;
02207   <span class="keywordtype">int</span> err_flag=0;
02208   <span class="keywordtype">int</span> mode;
02209   fsal_accessmode_t fsalmode = 0777;
02210   fsal_attrib_list_t attrsymlink ;
02211   
02212   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN];
02213   <span class="keywordtype">char</span> * path;
02214   <span class="keywordtype">char</span> * file;
02215   <span class="keywordtype">char</span> * strmode;
02216   <span class="keywordtype">char</span> * content = NULL;
02217   
02218   fsal_name_t objname;
02219   
02220   cache_inode_create_arg_t create_arg;
02221   
02222   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02223    
02224   <span class="comment">/* is the fs initialized ? */</span>
02225   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02226    {
02227      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02228      <span class="keywordflow">return</span> -1;
02229    }
02230 
02231   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02232   
02233   <span class="comment">/* analysing options */</span>
02234   getopt_init();
02235   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02236     <span class="keywordflow">switch</span>( option )
02237       {
02238       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02239         <span class="keywordflow">if</span>( flag_v )
02240           fprintf( output, <span class="stringliteral">"ln: warning: option 'v' has been specified more than once.\n"</span>);
02241         <span class="keywordflow">else</span> flag_v++;
02242         <span class="keywordflow">break</span>;
02243         
02244       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02245         <span class="keywordflow">if</span>( flag_h )
02246           fprintf( output, <span class="stringliteral">"ln: warning: option 'h' has been specified more than once.\n"</span>);
02247         <span class="keywordflow">else</span> flag_h++;
02248         <span class="keywordflow">break</span>;
02249         
02250       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02251         fprintf( output,<span class="stringliteral">"ln: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02252         err_flag ++;
02253         <span class="keywordflow">break</span>;
02254     }    
02255   }
02256   
02257   <span class="keywordflow">if</span>( flag_h )
02258     {
02259       fprintf( output, help_ln);
02260       <span class="keywordflow">return</span> 0;
02261     }
02262   
02263   <span class="comment">/* Exactly 2 args expected */</span>
02264   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02265     {
02266       err_flag ++;
02267     } 
02268   <span class="keywordflow">else</span> 
02269     {
02270       content = argv[Optind];
02271       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1], FSAL_MAX_PATH_LEN );
02272       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02273       
02274     }
02275   
02276   <span class="keywordflow">if</span>( err_flag )
02277     {
02278       fprintf( output, help_ln );
02279       <span class="keywordflow">return</span> -1;
02280     }
02281   
02282   <span class="comment">/* copy current path. */</span>
02283   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
02284   
02285   <span class="comment">/* retrieves path handle*/</span>
02286   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;new_hdl,output) )
02287     <span class="keywordflow">return</span> rc;
02288 
02289   <span class="comment">/* create fsal_name_t */</span>
02290   st = FSAL_str2name( file, 256,&amp;objname ) ;
02291   
02292   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02293     {
02294       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span>);
02295       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02296       fprintf( output, <span class="stringliteral">"\n"</span> );
02297       <span class="keywordflow">return</span> st.major;
02298     }
02299 
02300   <span class="comment">/* create fsal_path_t */</span>  
02301   st = FSAL_str2path( content, 256, &amp;create_arg.link_content );
02302   
02303   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02304     {
02305       fprintf(output,<span class="stringliteral">"Error executing FSAL_str2path:"</span>);
02306       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02307       fprintf( output, <span class="stringliteral">"\n"</span> );
02308       <span class="keywordflow">return</span> st.major;
02309     }
02310     
02311     
02312   <span class="keywordflow">if</span>( ( subdir_hdl = cache_inode_create( new_hdl, 
02313                                          &amp;objname, 
02314                                          SYMBOLIC_LINK,
02315                                          fsalmode, 
02316                                          &amp;create_arg,
02317                                          &amp;attrsymlink, 
02318                                          <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02319                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
02320                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02321                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
02322     {
02323       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_create(SYMBOLIC_LINK) : %J%r\n"</span>,
02324                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02325       
02326       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
02327     }
02328 
02329   <span class="keywordflow">if</span>( flag_v )
02330   {
02331     fprintf(output,<span class="stringliteral">"%s/%s successfully created (handle=%p) \n"</span>,glob_path,file, subdir_hdl ) ;
02332   }
02333 
02334   <span class="keywordflow">return</span> 0;  
02335 }
02336 
02337 
<a name="l02339"></a><a class="code" href="commands__Cache__inode_8c.html#a38">02339</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a38">fn_Cache_inode_create</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02340                            <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02341                            FILE * output      <span class="comment">/* IN : output stream          */</span> )
02342 {
02343   
02344   
02345   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02346    
02347   <span class="keyword">static</span> <span class="keywordtype">char</span> help_create[]=
02348   <span class="stringliteral">"usage: create [-h][-v] &lt;path&gt; [mode]\n"</span>
02349   <span class="stringliteral">"       path: path of the file to be created\n"</span>
02350   <span class="stringliteral">"       mode: octal mode for the directory to be created (ex: 644)\n"</span> ;
02351 
02352   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
02353   cache_entry_t * new_hdl ;
02354   cache_entry_t * subdir_hdl ;
02355   fsal_attrib_list_t attrs;
02356   fsal_status_t st;
02357   <span class="keywordtype">int</span> rc,option;
02358   <span class="keywordtype">int</span> flag_v=0;
02359   <span class="keywordtype">int</span> flag_h=0;
02360   <span class="keywordtype">int</span> err_flag=0;
02361   <span class="keywordtype">int</span> mode;
02362   fsal_accessmode_t fsalmode = 0644;
02363   fsal_attrib_list_t attrcreate ;
02364   
02365   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN];
02366   <span class="keywordtype">char</span> * path;
02367   <span class="keywordtype">char</span> * file;
02368   <span class="keywordtype">char</span> * strmode;
02369   
02370   fsal_name_t objname;
02371   
02372   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02373    
02374   <span class="comment">/* is the fs initialized ? */</span>
02375   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02376    {
02377      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02378      <span class="keywordflow">return</span> -1;
02379    }
02380 
02381   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02382   
02383   <span class="comment">/* analysing options */</span>
02384   getopt_init();
02385   <span class="keywordflow">while</span> ( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1){   
02386     <span class="keywordflow">switch</span>( option )
02387       {
02388       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02389         <span class="keywordflow">if</span>( flag_v )
02390           fprintf( output, <span class="stringliteral">"create: warning: option 'v' has been specified more than once.\n"</span>);
02391         <span class="keywordflow">else</span> flag_v++;
02392         <span class="keywordflow">break</span>;
02393         
02394       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02395         <span class="keywordflow">if</span>( flag_h )
02396           fprintf( output, <span class="stringliteral">"create: warning: option 'h' has been specified more than once.\n"</span>);
02397         <span class="keywordflow">else</span> flag_h++;
02398         <span class="keywordflow">break</span>;
02399         
02400       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02401         fprintf( output,<span class="stringliteral">"create: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02402         err_flag ++;
02403         <span class="keywordflow">break</span>;
02404     }    
02405   }
02406   
02407   <span class="keywordflow">if</span>( flag_h )
02408     {
02409       fprintf( output, help_create);
02410       <span class="keywordflow">return</span> 0;
02411     }
02412   
02413   <span class="comment">/* 1 or 2 args expected */</span>
02414   <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> != (argc-2) &amp;&amp; <a class="code" href="Getopt_8c.html#a4">Optind</a> != (argc-1) )
02415   {
02416     err_flag ++;
02417   }
02418   <span class="keywordflow">else</span>
02419   {
02420     
02421     strncpy(tmp_path,argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>],FSAL_MAX_PATH_LEN);
02422     <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(tmp_path,&amp;path,&amp;file);
02423     
02424       <span class="keywordflow">if</span> ( <a class="code" href="Getopt_8c.html#a4">Optind</a> == ( argc - 1 ) )
02425       {
02426         mode = 0755;
02427       }
02428       <span class="keywordflow">else</span>
02429       {
02430         strmode = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
02431         <span class="comment">/* converting mode string to FSAL mode string */</span>
02432         mode = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( strmode );  
02433       }
02434           
02435     <span class="keywordflow">if</span> (mode&lt;0) err_flag ++;
02436     <span class="keywordflow">else</span> {
02437 
02438       fsalmode = 0;
02439 
02440       <span class="keywordflow">if</span> ( mode &amp; S_ISUID ) fsalmode|= FSAL_MODE_SUID;
02441       <span class="keywordflow">if</span> ( mode &amp; S_ISGID ) fsalmode|= FSAL_MODE_SGID;
02442 
02443       <span class="keywordflow">if</span> ( mode &amp; S_IRUSR ) fsalmode|= FSAL_MODE_RUSR;
02444       <span class="keywordflow">if</span> ( mode &amp; S_IWUSR ) fsalmode|= FSAL_MODE_WUSR;
02445       <span class="keywordflow">if</span> ( mode &amp; S_IXUSR ) fsalmode|= FSAL_MODE_XUSR;
02446 
02447       <span class="keywordflow">if</span> ( mode &amp; S_IRGRP ) fsalmode|= FSAL_MODE_RGRP;
02448       <span class="keywordflow">if</span> ( mode &amp; S_IWGRP ) fsalmode|= FSAL_MODE_WGRP;
02449       <span class="keywordflow">if</span> ( mode &amp; S_IXGRP ) fsalmode|= FSAL_MODE_XGRP;
02450 
02451       <span class="keywordflow">if</span> ( mode &amp; S_IROTH ) fsalmode|= FSAL_MODE_ROTH;
02452       <span class="keywordflow">if</span> ( mode &amp; S_IWOTH ) fsalmode|= FSAL_MODE_WOTH;
02453       <span class="keywordflow">if</span> ( mode &amp; S_IXOTH ) fsalmode|= FSAL_MODE_XOTH;
02454 
02455     }
02456     
02457   }
02458   
02459   <span class="keywordflow">if</span>( err_flag )
02460     {
02461       fprintf( output, help_create );
02462       <span class="keywordflow">return</span> -1;
02463     }
02464   
02465   <span class="comment">/* copy current path. */</span>
02466   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
02467   
02468   <span class="comment">/* retrieves path handle*/</span>
02469   <span class="keywordflow">if</span> (rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;new_hdl,output) )
02470     <span class="keywordflow">return</span> rc;
02471 
02472   <span class="comment">/* create fsal_name_t */</span>
02473   st = FSAL_str2name( file, 256,&amp;objname ) ;
02474   
02475   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02476     {
02477       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span>);
02478       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02479       fprintf( output, <span class="stringliteral">"\n"</span> );
02480       <span class="keywordflow">return</span> st.major;
02481     }
02482 
02483   <span class="keywordflow">if</span>( ( subdir_hdl = cache_inode_create( new_hdl, 
02484                                          &amp;objname, 
02485                                          REGULAR_FILE,
02486                                          fsalmode, 
02487                                          <a class="code" href="Getopt_8c.html#a0">NULL</a>, 
02488                                          &amp;attrcreate, 
02489                                          <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02490                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
02491                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02492                                          &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) == NULL )
02493     {
02494       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_create(DIR_BEGINNING) : %J%r\n"</span>,
02495                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02496       
02497       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
02498     }
02499 
02500   <span class="keywordflow">if</span>( flag_v )
02501   {
02502     fprintf(output,<span class="stringliteral">"%s/%s successfully created (handle=%p) \n"</span>,glob_path,file, subdir_hdl ) ;
02503   }
02504 
02505   <span class="keywordflow">return</span> 0;  
02506 }
02507 
02508 
02509 
<a name="l02511"></a><a class="code" href="commands__Cache__inode_8c.html#a39">02511</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a39">fn_Cache_inode_rename</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02512                            <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02513                            FILE * output      <span class="comment">/* IN : output stream          */</span>)
02514 { 
02515   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02516   
02517   <span class="keyword">static</span> <span class="keywordtype">char</span> help_rename[]=
02518     <span class="stringliteral">"usage: rename [-h][-v] &lt;src&gt; &lt;dest&gt;\n"</span>;
02519   
02520   <span class="keywordtype">char</span> src_glob_path[FSAL_MAX_PATH_LEN];
02521   <span class="keywordtype">char</span> tgt_glob_path[FSAL_MAX_PATH_LEN];
02522   
02523   cache_entry_t * src_path_pentry ;
02524   cache_entry_t * tgt_path_pentry ;
02525   fsal_name_t     src_name ;
02526   fsal_name_t     tgt_name ;
02527   
02528   fsal_status_t  st;
02529   cache_inode_status_t cache_status ;
02530   <span class="keywordtype">int</span> rc,option;
02531   <span class="keywordtype">int</span> flag_v=0;
02532   <span class="keywordtype">int</span> flag_h=0;
02533   <span class="keywordtype">int</span> err_flag=0;
02534   
02535   <span class="keywordtype">char</span> tmp_path1[FSAL_MAX_PATH_LEN];
02536   <span class="keywordtype">char</span> tmp_path2[FSAL_MAX_PATH_LEN];
02537   <span class="keywordtype">char</span> * src_path;
02538   <span class="keywordtype">char</span> * src_file;
02539   <span class="keywordtype">char</span> * tgt_path;
02540   <span class="keywordtype">char</span> * tgt_file;
02541   
02542   fsal_attrib_list_t attrsrc ;
02543   fsal_attrib_list_t attrdest ;
02544   
02545     
02546   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02547    
02548   <span class="comment">/* is the fs initialized ? */</span>
02549   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02550    {
02551      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02552      <span class="keywordflow">return</span> -1;
02553    }
02554 
02555   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02556   
02557   <span class="comment">/* analysing options */</span>
02558   getopt_init();
02559   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
02560     {   
02561       <span class="keywordflow">switch</span>( option )
02562         {
02563         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02564           <span class="keywordflow">if</span>( flag_v )
02565             fprintf( output, <span class="stringliteral">"rename: warning: option 'v' has been specified more than once.\n"</span> ) ;
02566           <span class="keywordflow">else</span> 
02567             flag_v++ ;
02568         break ;
02569         
02570         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02571           <span class="keywordflow">if</span>( flag_h )
02572             fprintf( output, <span class="stringliteral">"rename: warning: option 'h' has been specified more than once.\n"</span> ) ;
02573           <span class="keywordflow">else</span> 
02574             flag_h++;
02575           break ;
02576           
02577         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02578           fprintf(output,<span class="stringliteral">"rename: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02579           err_flag ++ ;
02580           <span class="keywordflow">break</span>;
02581         }    
02582     }
02583   
02584   <span class="keywordflow">if</span>( flag_h )
02585     {
02586       fprintf(output,help_rename);
02587       <span class="keywordflow">return</span> 0;
02588     }
02589   
02590   <span class="comment">/* Exactly 2 args expected */</span>
02591   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02592     {
02593       err_flag ++;
02594     } 
02595   <span class="keywordflow">else</span> 
02596     {
02597       strncpy( tmp_path1, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], FSAL_MAX_PATH_LEN );
02598       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path1, &amp;src_path, &amp;src_file );
02599       
02600       strncpy( tmp_path2, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1], FSAL_MAX_PATH_LEN );
02601       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path2, &amp;tgt_path, &amp;tgt_file );
02602     }
02603   
02604   <span class="keywordflow">if</span>( err_flag )
02605     {
02606       fprintf(output,help_rename);
02607       <span class="keywordflow">return</span> -1;
02608     }
02609   
02610   <span class="keywordflow">if</span>( flag_v )
02611     fprintf( output,<span class="stringliteral">"Renaming %s (dir %s) to %s (dir %s)\n"</span>, src_file, src_path, tgt_file, tgt_path );
02612   
02613   <span class="comment">/* copy current path. */</span>
02614   strncpy( src_glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
02615   strncpy( tgt_glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
02616   
02617   <span class="comment">/* retrieves paths handles */</span>
02618   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( src_glob_path,
02619                       FSAL_MAX_PATH_LEN,
02620                       src_path,
02621                       context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>,
02622                       &amp;src_path_pentry,
02623                       output ) )
02624     <span class="keywordflow">return</span> rc;
02625 
02626   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>(tgt_glob_path,
02627                            FSAL_MAX_PATH_LEN,
02628                            tgt_path,
02629                            context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>,
02630                            &amp;tgt_path_pentry,
02631                            output ) )
02632     <span class="keywordflow">return</span> rc;
02633   
02634   
02635   <span class="comment">/* create fsal_name_t */</span>
02636   
02637   st = FSAL_str2name( src_file, 256,  &amp;src_name );
02638   
02639   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02640     {
02641       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span> );
02642       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02643       fprintf( output, <span class="stringliteral">"\n"</span> );
02644       <span class="keywordflow">return</span> st.major;
02645     }
02646 
02647   st = FSAL_str2name( tgt_file, 256,  &amp;tgt_name );
02648   
02649   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02650     {
02651       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span> );
02652       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02653       fprintf( output, <span class="stringliteral">"\n"</span> );
02654       <span class="keywordflow">return</span> st.major;
02655     }
02656 
02657   <span class="comment">/* Rename operation */</span>  
02658   <span class="keywordflow">if</span>( cache_inode_rename( src_path_pentry, 
02659                           &amp;src_name,      
02660                           tgt_path_pentry,
02661                           &amp;tgt_name,  
02662                           &amp;attrsrc, 
02663                           &amp;attrdest, 
02664                           <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02665                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
02666                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02667                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
02668     {
02669       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_rename : %J%r\n"</span>,
02670                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02671       
02672       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ; 
02673     }
02674 
02675   <span class="keywordflow">if</span>( flag_v )
02676     fprintf( output,<span class="stringliteral">"%s/%s successfully renamed to %s/%s\n"</span>,
02677              src_glob_path, src_file,
02678              tgt_glob_path, tgt_file );
02679       
02680   <span class="keywordflow">return</span> 0;
02681 }
02682 
02683 
<a name="l02685"></a><a class="code" href="commands__Cache__inode_8c.html#a40">02685</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a40">fn_Cache_inode_unlink</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
02686                            <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02687                            FILE * output      <span class="comment">/* IN : output stream          */</span> )
02688 {
02689   
02690   
02691   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02692    
02693   <span class="keyword">static</span> <span class="keywordtype">char</span> help_ln[]= <span class="stringliteral">"usage: ln [-h][-v] &lt;path&gt;\n"</span> ;
02694 
02695   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];
02696   cache_entry_t * new_hdl ;
02697   cache_entry_t * subdir_hdl ;
02698   fsal_attrib_list_t attrs;
02699   fsal_status_t st;
02700   <span class="keywordtype">int</span> rc,option;
02701   <span class="keywordtype">int</span> flag_v=0;
02702   <span class="keywordtype">int</span> flag_h=0;
02703   <span class="keywordtype">int</span> err_flag=0;
02704   
02705   <span class="keywordtype">char</span> tmp_path[FSAL_MAX_PATH_LEN];
02706   <span class="keywordtype">char</span> * path;
02707   <span class="keywordtype">char</span> * file;
02708   <span class="keywordtype">char</span> * strmode;
02709   
02710   fsal_name_t objname;
02711   fsal_attrib_list_t attrparent ;
02712 
02713   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02714    
02715   <span class="comment">/* is the fs initialized ? */</span>
02716   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02717    {
02718      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02719      <span class="keywordflow">return</span> -1;
02720    }
02721 
02722   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02723   
02724   <span class="comment">/* analysing options */</span>
02725   getopt_init();
02726   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
02727     {   
02728       <span class="keywordflow">switch</span>( option )
02729         {
02730         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02731           <span class="keywordflow">if</span>( flag_v )
02732             fprintf( output, <span class="stringliteral">"unlink: warning: option 'v' has been specified more than once.\n"</span>);
02733           <span class="keywordflow">else</span> flag_v++;
02734           <span class="keywordflow">break</span>;
02735           
02736         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02737           <span class="keywordflow">if</span>( flag_h )
02738             fprintf( output, <span class="stringliteral">"unlink: warning: option 'h' has been specified more than once.\n"</span>);
02739           <span class="keywordflow">else</span> flag_h++;
02740           <span class="keywordflow">break</span>;
02741           
02742         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02743           fprintf( output,<span class="stringliteral">"unlink: unknown option : %c\n"</span>, <a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02744           err_flag ++;
02745         <span class="keywordflow">break</span>;
02746         }    
02747     }
02748   
02749   <span class="keywordflow">if</span>( flag_h )
02750     {
02751       fprintf( output, help_ln);
02752       <span class="keywordflow">return</span> 0;
02753     }
02754   
02755   <span class="comment">/* Exactly 2 args expected */</span>
02756   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) )
02757     {
02758       err_flag ++;
02759     } 
02760   <span class="keywordflow">else</span> 
02761     {
02762       strncpy( tmp_path, argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>], FSAL_MAX_PATH_LEN );
02763       <a class="code" href="cmd__tools_8h.html#a15">split_path</a>( tmp_path, &amp;path, &amp;file);
02764       
02765     }
02766   
02767   <span class="keywordflow">if</span>( err_flag )
02768     {
02769       fprintf( output, help_ln );
02770       <span class="keywordflow">return</span> -1;
02771     }
02772   
02773   <span class="comment">/* copy current path. */</span>
02774   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN );
02775   
02776   <span class="comment">/* retrieves path handle*/</span>
02777   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;new_hdl,output) )
02778     <span class="keywordflow">return</span> rc;
02779 
02780   <span class="comment">/* create fsal_name_t */</span>
02781   st = FSAL_str2name( file, 256,&amp;objname ) ;
02782   
02783   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02784     {
02785       fprintf( output, <span class="stringliteral">"Error executing FSAL_str2name:"</span>);
02786       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02787       fprintf( output, <span class="stringliteral">"\n"</span> );
02788       <span class="keywordflow">return</span> st.major;
02789     }
02790 
02791   <span class="keywordflow">if</span>( FSAL_IS_ERROR( st ) )
02792     {
02793       fprintf(output,<span class="stringliteral">"Error executing FSAL_str2path:"</span>);
02794       <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>( output, st );
02795       fprintf( output, <span class="stringliteral">"\n"</span> );
02796       <span class="keywordflow">return</span> st.major;
02797     }
02798 
02799   cache_inode_remove( new_hdl, 
02800                       &amp;objname, 
02801                       &amp;attrparent, 
02802                       <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
02803                       &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
02804                       &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02805                       &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ;
02806   <span class="keywordflow">if</span>( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> != CACHE_INODE_SUCCESS )
02807     {
02808       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_remove : %J%r\n"</span>,
02809                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );      
02810       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
02811     }
02812   
02813   <span class="keywordflow">if</span>( flag_v )
02814   {
02815     fprintf(output,<span class="stringliteral">"%s/%s successfully unlinked\n"</span>,glob_path,file ) ;
02816   }
02817 
02818   <span class="keywordflow">return</span> 0;
02819 }
02820 
02821 
<a name="l02828"></a><a class="code" href="commands__Cache__inode_8c.html#a41">02828</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a41">fn_Cache_inode_setattr</a>( <span class="keywordtype">int</span>     argc ,     <span class="comment">/* IN : number of args in argv */</span>
02829                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
02830                             FILE *  output     <span class="comment">/* IN : output stream          */</span> )
02831 {
02832   
02833   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
02834    
02835   <span class="keyword">static</span> <span class="keywordtype">char</span> help_setattr[]=
02836     <span class="stringliteral">"usage: setattr [-h][-v] &lt;path&gt; &lt;attr&gt;=&lt;value&gt;,&lt;attr&gt;=&lt;value&gt;,...\n"</span>;
02837 
02838   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
02839 
02840   cache_entry_t        * obj_hdl ;        <span class="comment">/* handle of the object    */</span>
02841   fsal_attrib_list_t     set_attrs;       <span class="comment">/* attributes to be setted */</span>
02842   cache_inode_status_t   cache_status;    <span class="comment">/* FSAL return status      */</span>
02843   
02844   <span class="keywordtype">int</span> rc, option;
02845   <span class="keywordtype">int</span> flag_v=0;
02846   <span class="keywordtype">int</span> flag_h=0;
02847   <span class="keywordtype">int</span> err_flag=0;
02848   
02849   <span class="keywordtype">char</span> file[FSAL_MAX_NAME_LEN];        <span class="comment">/* the relative path to the object */</span>
02850   <span class="keywordtype">char</span> * attr_list  = NULL;               <span class="comment">/* attribute name */</span>
02851        
02852   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
02853    
02854   <span class="comment">/* is the fs initialized ? */</span>
02855   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
02856    {
02857      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
02858      <span class="keywordflow">return</span> -1;
02859    }
02860 
02861   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
02862     
02863   <span class="comment">/* analysing options */</span>
02864   getopt_init() ;
02865   
02866   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format )) != -1 )
02867   {   
02868     <span class="keywordflow">switch</span>( option )
02869       {
02870       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02871         <span class="keywordflow">if</span>( flag_v )
02872           fprintf( output, <span class="stringliteral">"setattr: warning: option 'v' has been specified more than once.\n"</span>);
02873         <span class="keywordflow">else</span> 
02874           flag_v++;
02875         <span class="keywordflow">break</span>;
02876         
02877       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02878         <span class="keywordflow">if</span>( flag_h )
02879           fprintf(output, <span class="stringliteral">"setattr: warning: option 'h' has been specified more than once.\n"</span>);
02880         <span class="keywordflow">else</span> 
02881           flag_h++;
02882         <span class="keywordflow">break</span>;
02883         
02884       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02885         fprintf(output,<span class="stringliteral">"setattr: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
02886         err_flag ++;
02887         <span class="keywordflow">break</span>;
02888     }    
02889   }
02890   
02891   <span class="keywordflow">if</span>( flag_h )
02892     {
02893     
02894       <a class="code" href="structshell__attribute____.html">shell_attribute_t</a> * curr_attr;
02895       
02896       <span class="comment">/* print usage */</span>
02897       fprintf(output,help_setattr);
02898       
02899       fprintf(output,<span class="stringliteral">"\n&lt;attr&gt; can be one of the following values:\n"</span>);
02900       
02901       <span class="comment">/* print attribute list */</span>
02902       
02903       <span class="keywordflow">for</span>( curr_attr = shell_attr_list; curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o1">attr_type</a> != ATTR_NONE; curr_attr++ )
02904         {
02905           <span class="keywordflow">switch</span>( curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o1">attr_type</a>)
02906             {              
02907             <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a5">ATTR_32</a>:        
02908               fprintf( output, <span class="stringliteral">"\t %s \t:\t 32 bits integer\n"</span>,curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o0">attr_name</a> );
02909               <span class="keywordflow">break</span>;
02910               
02911             <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a6">ATTR_64</a>:
02912               fprintf( output, <span class="stringliteral">"\t %s \t:\t 64 bits integer\n"</span>,curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o0">attr_name</a> );
02913               <span class="keywordflow">break</span>;
02914               
02915             <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a7">ATTR_OCTAL</a>:
02916               fprintf( output, <span class="stringliteral">"\t %s \t:\t octal\n"</span>,curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o0">attr_name</a> );
02917               <span class="keywordflow">break</span>;
02918               
02919             <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a8">ATTR_TIME</a>:
02920               fprintf( output, <span class="stringliteral">"\t %s \t:\t time (format: YYYYMMDDhhmmss)\n"</span>,curr_attr-&gt;<a class="code" href="structshell__attribute____.html#o0">attr_name</a> );
02921               <span class="keywordflow">break</span>;
02922             }
02923         }    
02924       
02925       <span class="keywordflow">return</span> 0;
02926     }
02927   
02928   <span class="comment">/* Exactly 2 args expected (path and attributes list)*/</span>
02929   
02930   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) )
02931     {
02932       err_flag ++;
02933     } 
02934   <span class="keywordflow">else</span> 
02935     {
02936       strcpy( file,  argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>] ) ;
02937       attr_list = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1] ;
02938     }
02939   
02940   <span class="keywordflow">if</span>( err_flag )
02941     {
02942       fprintf( output, help_setattr );
02943       <span class="keywordflow">return</span> -1;
02944     }
02945   
02946   <span class="comment">/* copy current absolute path to a local variable. */</span>
02947   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
02948   
02949   <span class="comment">/* retrieve handle to the file whose attributes are to be changed */</span>
02950   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
02951     <span class="keywordflow">return</span> rc ;
02952     
02953   <span class="comment">/* Convert the peer (attr_name,attr_val) to an FSAL attribute structure. */</span>
02954   rc = <a class="code" href="cmd__tools_8h.html#a23">MkFSALSetAttrStruct</a>( attr_list, &amp;set_attrs );
02955   
02956   <span class="comment">/* interprets output code */</span>
02957   <span class="keywordflow">switch</span>( rc )
02958     {
02959     <span class="keywordflow">case</span> 0:
02960       <span class="comment">/* OK */</span>
02961       <span class="keywordflow">break</span>;
02962       
02963     <span class="keywordflow">case</span> EFAULT:
02964       fprintf(output,<span class="stringliteral">"setattr: Internal error.\n"</span>);
02965       <span class="keywordflow">return</span> rc;
02966       
02967     <span class="keywordflow">case</span> ENOENT:
02968       fprintf(output,<span class="stringliteral">"setattr: Unknown attribute in list %s\n"</span>, attr_list);
02969       <span class="keywordflow">return</span> rc;
02970       
02971     <span class="keywordflow">case</span> EINVAL:
02972       fprintf(output,<span class="stringliteral">"setattr: Invalid value for attribute in list %s\n"</span>, attr_list );
02973       <span class="keywordflow">return</span> rc;
02974       
02975     <span class="keywordflow">default</span>:
02976       fprintf(output,<span class="stringliteral">"setattr: Error %d converting attributes.\n"</span>,rc );
02977       <span class="keywordflow">return</span> rc;
02978     }
02979   
02980   <span class="comment">/* if verbose mode is on, we print the attributes to be set */</span>    
02981   <span class="keywordflow">if</span>( flag_v )
02982     {
02983       <a class="code" href="cmd__tools_8h.html#a21">print_fsal_attributes</a>( set_attrs, output );
02984     }
02985   
02986   
02987   <span class="comment">/* executes set attrs */</span>
02988   <span class="keywordflow">if</span>( ( cache_status = cache_inode_setattr( obj_hdl, 
02989                                             &amp;set_attrs,
02990                                             <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
02991                                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
02992                                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
02993                                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) != CACHE_INODE_SUCCESS )
02994                                             
02995     {
02996       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_setattr : %J%r\n"</span>,
02997                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
02998       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
02999     }
03000   
03001   <span class="keywordflow">return</span> 0;  
03002 }
03003 
03004 
03005 
<a name="l03012"></a><a class="code" href="commands__Cache__inode_8c.html#a42">03012</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a42">fn_Cache_inode_access</a>(  <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03013                             <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03014                             FILE * output      <span class="comment">/* IN : output stream          */</span> )
03015 {
03016   
03017   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03018    
03019   <span class="keyword">static</span> <span class="keywordtype">char</span> help_access[]=
03020     <span class="stringliteral">"usage: access [-h][-v] &lt;rights&gt; &lt;path&gt;\n"</span>
03021     <span class="stringliteral">"\n"</span>
03022     <span class="stringliteral">"   -h : print this help\n"</span>
03023     <span class="stringliteral">"   -v : verbose mode\n"</span>
03024     <span class="stringliteral">"   -A : test access from attributes\n"</span>
03025     <span class="stringliteral">"        ( call to getattr + test_access instead of access )\n"</span>
03026     <span class="stringliteral">"\n"</span>
03027     <span class="stringliteral">" &lt;rights&gt; : a set of the following characters:\n"</span>
03028     <span class="stringliteral">"    F: test file existence\n"</span>
03029     <span class="stringliteral">"    R: test read permission\n"</span>
03030     <span class="stringliteral">"    W: test write permission\n"</span>
03031     <span class="stringliteral">"    X: test execute permission\n"</span>
03032     <span class="stringliteral">"\n"</span>
03033     <span class="stringliteral">"Example: access -A RX my_dir\n"</span>
03034     <span class="stringliteral">"test read and exec rights for directory \"my_dir\"\n"</span>
03035     <span class="stringliteral">"by doing a getattr and a test_access call.\n\n"</span>;
03036   
03037 
03038   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03039   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03040   fsal_accessflags_t  test_perms;     <span class="comment">/* permissions to be tested    */</span>
03041   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
03042   
03043   <span class="keywordtype">int</span> rc, option;
03044   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
03045   <span class="keywordtype">int</span> flag_v=0;
03046   <span class="keywordtype">int</span> flag_h=0;
03047   <span class="keywordtype">int</span> err_flag=0;
03048   
03049   <span class="keywordtype">char</span> * file = NULL;      <span class="comment">/* the relative path to the object */</span>  
03050   <span class="keywordtype">char</span> * str_perms = NULL; <span class="comment">/* string that represents the permissions to be tested */</span>
03051       
03052   
03053   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03054    
03055   <span class="comment">/* is the fs initialized ? */</span>
03056   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03057    {
03058      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03059      <span class="keywordflow">return</span> -1;
03060    }
03061 
03062   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03063 
03064     
03065   <span class="comment">/* analysing options */</span>
03066   
03067   getopt_init();
03068   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03069   {   
03070     <span class="keywordflow">switch</span>( option )
03071       {
03072       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03073         <span class="keywordflow">if</span>( flag_v )
03074           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03075         <span class="keywordflow">else</span> 
03076           flag_v++;
03077         <span class="keywordflow">break</span>;
03078         
03079       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03080         <span class="keywordflow">if</span>( flag_h )
03081           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03082         <span class="keywordflow">else</span> 
03083           flag_h++;
03084         <span class="keywordflow">break</span>;
03085         
03086       <span class="keywordflow">default</span>:
03087       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03088         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03089         err_flag ++;
03090         <span class="keywordflow">break</span>;
03091     }    
03092   }
03093   
03094   <span class="keywordflow">if</span>( flag_h )
03095     {
03096       <span class="comment">/* print usage */</span>
03097       fprintf(output,help_access);    
03098       <span class="keywordflow">return</span> 0;
03099     }
03100   
03101   <span class="comment">/* Exactly 2 args expected */</span>
03102   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc -2 ) ) 
03103     {
03104       err_flag ++;
03105     } 
03106   <span class="keywordflow">else</span> 
03107     {
03108       str_perms = argv[Optind];
03109       file = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
03110     }
03111   
03112   <span class="keywordflow">if</span>( err_flag )
03113     {
03114       fprintf( output, help_access );
03115       <span class="keywordflow">return</span> -1;
03116     }
03117     
03118   <span class="comment">/* copy current absolute path to a local variable. */</span>
03119   strncpy(glob_path,context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>,FSAL_MAX_PATH_LEN);
03120   
03121   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03122   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03123     <span class="keywordflow">return</span> rc ; 
03124   
03125   <span class="comment">/* Convert the permission string to an fsal access test. */</span>
03126   test_perms = 0;
03127   
03128   <span class="keywordflow">for</span>( i=0; i &lt; strlen( str_perms ); i++ )
03129     {    
03130       <span class="keywordflow">switch</span>( str_perms[i] )
03131         {
03132         <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:        
03133           <span class="keywordflow">if</span>( flag_v ) 
03134             fprintf( output, <span class="stringliteral">"F_OK flag\n"</span> );
03135           test_perms |= FSAL_F_OK ;
03136         <span class="keywordflow">break</span>;
03137         
03138       <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
03139         <span class="keywordflow">if</span>( flag_v ) 
03140           fprintf( output, <span class="stringliteral">"R_OK flag\n"</span> );
03141         test_perms |= FSAL_R_OK ;
03142         <span class="keywordflow">break</span>;
03143         
03144       <span class="keywordflow">case</span> <span class="charliteral">'W'</span>:
03145         <span class="keywordflow">if</span>( flag_v ) 
03146           fprintf( output, <span class="stringliteral">"W_OK flag\n"</span> );
03147         test_perms |= FSAL_W_OK ;
03148         <span class="keywordflow">break</span>;
03149         
03150       <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:      
03151         <span class="keywordflow">if</span>( flag_v )
03152           fprintf( output, <span class="stringliteral">"X_OK flag\n"</span> );
03153         test_perms |= FSAL_X_OK ;
03154         <span class="keywordflow">break</span>;
03155         
03156         <span class="keywordflow">default</span>:
03157           fprintf( output, <span class="stringliteral">"**** Invalid test: %c ****\n"</span>, str_perms[i] );
03158         fprintf( output, help_access );
03159         <span class="keywordflow">return</span> -1;
03160         }    
03161     }  
03162   
03163   <span class="comment">/* Call to FSAL */</span>
03164   
03165   <span class="keywordflow">if</span>( ( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> = cache_inode_access( obj_hdl, 
03166                                            test_perms, 
03167                                            <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
03168                                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
03169                                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
03170                                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) ) != CACHE_INODE_SUCCESS )
03171     {
03172       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_access : %J%r\n"</span>,
03173                    ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
03174       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
03175     }
03176   <span class="keywordflow">else</span> 
03177     {  
03178       fprintf(output,<span class="stringliteral">"access: Access granted.\n"</span>);
03179       <span class="keywordflow">return</span> 0;   
03180     }
03181 }
03182 
03183 
<a name="l03185"></a><a class="code" href="commands__Cache__inode_8c.html#a43">03185</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a43">fn_Cache_inode_data_cache</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03186                                   <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03187                                   FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03188 {
03189   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03190    
03191   <span class="keyword">static</span> <span class="keywordtype">char</span> help_data_cache[]=
03192     <span class="stringliteral">"usage: data_cache [-h][-v]  &lt;path&gt;\n"</span>
03193     <span class="stringliteral">"\n"</span>
03194     <span class="stringliteral">"   -h : print this help\n"</span>
03195     <span class="stringliteral">"   -v : verbose mode\n"</span> ;
03196   
03197 
03198   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03199   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03200   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
03201   
03202   <span class="keywordtype">int</span> rc,option,i;
03203   <span class="keywordtype">int</span> flag_v=0;
03204   <span class="keywordtype">int</span> flag_h=0;
03205   <span class="keywordtype">int</span> err_flag=0;
03206   
03207   <span class="keywordtype">char</span> * file = NULL; <span class="comment">/* the relative path to the object */</span>  
03208       
03209 <span class="preprocessor">#ifdef _USE_PROXY</span>
03210 <span class="preprocessor"></span>  fsal_name_t name ;
03211 <span class="preprocessor">#endif</span>
03212 <span class="preprocessor"></span>  
03213   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03214    
03215   <span class="comment">/* is the fs initialized ? */</span>
03216   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03217    {
03218      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03219      <span class="keywordflow">return</span> -1;
03220    }
03221 
03222   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03223   
03224   <span class="comment">/* analysing options */</span>
03225   
03226   getopt_init();
03227   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03228   {   
03229     <span class="keywordflow">switch</span>( option )
03230       {
03231       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03232         <span class="keywordflow">if</span>( flag_v )
03233           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03234         <span class="keywordflow">else</span> 
03235           flag_v++;
03236         <span class="keywordflow">break</span>;
03237         
03238       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03239         <span class="keywordflow">if</span>( flag_h )
03240           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03241         <span class="keywordflow">else</span> 
03242           flag_h++;
03243         <span class="keywordflow">break</span>;
03244         
03245       <span class="keywordflow">default</span>:
03246       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03247         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03248         err_flag ++;
03249         <span class="keywordflow">break</span>;
03250     }    
03251   }
03252   
03253   <span class="keywordflow">if</span>( flag_h )
03254     {
03255       <span class="comment">/* print usage */</span>
03256       fprintf( output, help_data_cache );    
03257       <span class="keywordflow">return</span> 0;
03258     }
03259   
03260   <span class="comment">/* Exactly 1 args expected */</span>
03261   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) ) 
03262     {
03263       err_flag ++;
03264     } 
03265   <span class="keywordflow">else</span> 
03266     {
03267       file = argv[Optind];
03268     }
03269   
03270   <span class="keywordflow">if</span>( err_flag )
03271     {
03272       fprintf( output, help_data_cache );
03273       <span class="keywordflow">return</span> -1;
03274     }
03275     
03276   <span class="comment">/* copy current absolute path to a local variable. */</span>
03277   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
03278 
03279  
03280   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03281   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03282     <span class="keywordflow">return</span> rc ; 
03283 
03284 <span class="preprocessor">#ifdef _USE_PROXY</span>
03285 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( FSAL_IS_ERROR( FSAL_str2name( file, MAXPATHLEN, &amp;name) ) )
03286    {
03287       context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> = CACHE_INODE_FSAL_ERROR ;
03288       log_fprintf( output, <span class="stringliteral">"Error opening file during cache_inode_add_cache : %J%r\n"</span>,
03289                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
03290       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
03291 
03292    }
03293 
03294   <span class="keywordflow">if</span>( cache_inode_open_by_name( context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>,
03295                                 &amp;name, 
03296                                 obj_hdl, 
03297                                 &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
03298                                 FSAL_O_RDWR, 
03299                                 &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>,
03300                                 &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
03301     {
03302       log_fprintf( output, <span class="stringliteral">"Error opening file during cache_inode_add_cache : %J%r\n"</span>,
03303                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
03304       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
03305     }
03306  
03307 <span class="preprocessor">#endif </span>
03308 <span class="preprocessor"></span>
03309 
03310   <span class="keywordflow">if</span>( flag_v )
03311     printf( <span class="stringliteral">"---&gt; data_cache using pentry_inode = %p\n"</span>, obj_hdl ) ;
03312   
03313   <span class="keywordflow">if</span>( cache_inode_add_data_cache( obj_hdl, <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>,
03314       &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
03315     {
03316       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_add_cache : %J%r\n"</span>,
03317                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
03318       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
03319     }
03320   
03321   <span class="keywordflow">if</span>( flag_v )
03322     {
03323       fprintf( output, <span class="stringliteral">"Entry %p is now boud to datacache entry %p\n"</span>, obj_hdl, obj_hdl-&gt;object.file.pentry_content ) ;
03324     }
03325 
03326   <span class="keywordflow">return</span> 0 ;
03327 } <span class="comment">/* fn_Cache_inode_data_cache */</span>
03328 
03329 
<a name="l03331"></a><a class="code" href="commands__Cache__inode_8c.html#a44">03331</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a44">fn_Cache_inode_release_cache</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03332                                   <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03333                                   FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03334 {
03335   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03336   
03337   <span class="keyword">static</span> <span class="keywordtype">char</span> help_release_cache[]=
03338     <span class="stringliteral">"usage: release_cache [-h][-v]  &lt;path&gt;\n"</span>
03339     <span class="stringliteral">"\n"</span>
03340     <span class="stringliteral">"   -h : print this help\n"</span>
03341     <span class="stringliteral">"   -v : verbose mode\n"</span> ;
03342   
03343   
03344   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03345   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03346   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
03347   
03348   <span class="keywordtype">int</span> rc,option,i;
03349   <span class="keywordtype">int</span> flag_v=0;
03350   <span class="keywordtype">int</span> flag_h=0;
03351   <span class="keywordtype">int</span> err_flag=0;
03352   
03353   <span class="keywordtype">char</span> * file = NULL;        <span class="comment">/* the relative path to the object */</span>  
03354       
03355   
03356   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03357    
03358   <span class="comment">/* is the fs initialized ? */</span>
03359   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03360    {
03361      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03362      <span class="keywordflow">return</span> -1;
03363    }
03364 
03365   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03366   
03367   <span class="comment">/* analysing options */</span>
03368   
03369   getopt_init();
03370   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03371   {   
03372     <span class="keywordflow">switch</span>( option )
03373       {
03374       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03375         <span class="keywordflow">if</span>( flag_v )
03376           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03377         <span class="keywordflow">else</span> 
03378           flag_v++;
03379         <span class="keywordflow">break</span>;
03380         
03381       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03382         <span class="keywordflow">if</span>( flag_h )
03383           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03384         <span class="keywordflow">else</span> 
03385           flag_h++;
03386         <span class="keywordflow">break</span>;
03387         
03388       <span class="keywordflow">default</span>:
03389       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03390         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03391         err_flag ++;
03392         <span class="keywordflow">break</span>;
03393     }    
03394   }
03395   
03396   <span class="keywordflow">if</span>( flag_h )
03397     {
03398       <span class="comment">/* print usage */</span>
03399       fprintf( output, help_release_cache );    
03400       <span class="keywordflow">return</span> 0;
03401     }
03402   
03403   <span class="comment">/* Exactly 1 args expected */</span>
03404   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) ) 
03405     {
03406       err_flag ++;
03407     } 
03408   <span class="keywordflow">else</span> 
03409     {
03410       file = argv[Optind];
03411     }
03412   
03413   <span class="keywordflow">if</span>( err_flag )
03414     { 
03415       fprintf( output, help_release_cache );
03416       <span class="keywordflow">return</span> -1;
03417     }
03418     
03419   <span class="comment">/* copy current absolute path to a local variable. */</span>
03420   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
03421   
03422   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03423   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03424     <span class="keywordflow">return</span> rc ; 
03425 
03426   <span class="keywordflow">if</span>( cache_inode_release_data_cache( obj_hdl, <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
03427     {
03428       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_release_cache : %J%r\n"</span>,
03429                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
03430       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
03431     }
03432   
03433   <span class="keywordflow">if</span>( flag_v )
03434     {
03435       fprintf( output, <span class="stringliteral">"Entry %p is no more bounded to datacache\n"</span>, obj_hdl ) ;
03436     }
03437 
03438   <span class="keywordflow">return</span> 0 ;
03439 } <span class="comment">/* fn_Cache_inode_release_cache */</span>
03440 
03441 
<a name="l03443"></a><a class="code" href="commands__Cache__inode_8c.html#a45">03443</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a45">fn_Cache_inode_recover_cache</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03444                                   <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03445                                   FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03446 {
03447   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03448   
03449   <span class="keyword">static</span> <span class="keywordtype">char</span> help_recover_cache[]=
03450     <span class="stringliteral">"usage: recover_cache [-h][-v]  &lt;path&gt;\n"</span>
03451     <span class="stringliteral">"\n"</span>
03452     <span class="stringliteral">"   -h : print this help\n"</span>
03453     <span class="stringliteral">"   -v : verbose mode\n"</span> ;
03454   
03455   
03456   cache_content_status_t cache_content_status ;
03457   
03458   <span class="keywordtype">int</span> rc,option,i;
03459   <span class="keywordtype">int</span> flag_v=0;
03460   <span class="keywordtype">int</span> flag_h=0;
03461   <span class="keywordtype">int</span> err_flag=0;
03462   
03463   <span class="keywordtype">char</span> * file;        <span class="comment">/* the relative path to the object */</span>  
03464       
03465   
03466   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03467    
03468   <span class="comment">/* is the fs initialized ? */</span>
03469   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03470    {
03471      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03472      <span class="keywordflow">return</span> -1;
03473    }
03474 
03475   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03476   
03477   <span class="comment">/* analysing options */</span>
03478   
03479   getopt_init();
03480   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03481   {   
03482     <span class="keywordflow">switch</span>( option )
03483       {
03484       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03485         <span class="keywordflow">if</span>( flag_v )
03486           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03487         <span class="keywordflow">else</span> 
03488           flag_v++;
03489         <span class="keywordflow">break</span>;
03490         
03491       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03492         <span class="keywordflow">if</span>( flag_h )
03493           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03494         <span class="keywordflow">else</span> 
03495           flag_h++;
03496         <span class="keywordflow">break</span>;
03497         
03498       <span class="keywordflow">default</span>:
03499       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03500         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03501         err_flag ++;
03502         <span class="keywordflow">break</span>;
03503     }    
03504   }
03505   
03506   <span class="keywordflow">if</span>( flag_h )
03507     {
03508       <span class="comment">/* print usage */</span>
03509       fprintf( output, help_recover_cache );    
03510       <span class="keywordflow">return</span> 0;
03511     }
03512   
03513   <span class="comment">/* Exactly 1 args expected */</span>
03514   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != argc ) 
03515     {
03516       err_flag ++;
03517     } 
03518   
03519   <span class="keywordflow">if</span>( err_flag )
03520     { 
03521       fprintf( output, help_recover_cache );
03522       <span class="keywordflow">return</span> -1;
03523     }
03524     
03525 
03526   <span class="keywordflow">if</span>( cache_content_crash_recover( <a class="code" href="commands__Cache__inode_8c.html#a0">EXPORT_ID</a>, 
03527                                    0,
03528                                    1,
03529                                    (cache_content_client_t *)context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.pcontent_client, 
03530                                    &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>,
03531                                    <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>,
03532                                    &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
03533                                    &amp;cache_content_status ) != CACHE_CONTENT_SUCCESS )
03534     {
03535       fprintf(output,<span class="stringliteral">"Error executing cache_content_crash_recover: %d\n"</span>, cache_content_status );
03536       <span class="keywordflow">return</span> cache_content_status ;
03537     }
03538   
03539   <span class="keywordflow">if</span>( flag_v )
03540     {
03541       fprintf( output, <span class="stringliteral">"Data cache has been recovered\n"</span> ) ;
03542     }
03543 
03544   <span class="keywordflow">return</span> 0 ;
03545 } <span class="comment">/* fn_Cache_inode_recover_cache */</span>
03546 
03547 
<a name="l03549"></a><a class="code" href="commands__Cache__inode_8c.html#a46">03549</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a46">fn_Cache_inode_refresh_cache</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03550                                   <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03551                                   FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03552 {
03553   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03554   
03555   <span class="keyword">static</span> <span class="keywordtype">char</span> help_refresh_cache[]=
03556     <span class="stringliteral">"usage: refresh_cache [-h][-v]  &lt;path&gt;\n"</span>
03557     <span class="stringliteral">"\n"</span>
03558     <span class="stringliteral">"   -h : print this help\n"</span>
03559     <span class="stringliteral">"   -v : verbose mode\n"</span> ;
03560   
03561   
03562   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03563   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03564   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
03565   cache_content_status_t cache_content_status ;
03566   
03567   <span class="keywordtype">int</span> rc,option,i;
03568   <span class="keywordtype">int</span> flag_v=0;
03569   <span class="keywordtype">int</span> flag_h=0;
03570   <span class="keywordtype">int</span> err_flag=0;
03571   
03572   <span class="keywordtype">char</span> * file = NULL;        <span class="comment">/* the relative path to the object */</span>  
03573       
03574   
03575   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03576    
03577   <span class="comment">/* is the fs initialized ? */</span>
03578   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03579    {
03580      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03581      <span class="keywordflow">return</span> -1;
03582    }
03583 
03584   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03585   
03586   <span class="comment">/* analysing options */</span>
03587   
03588   getopt_init();
03589   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03590   {   
03591     <span class="keywordflow">switch</span>( option )
03592       {
03593       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03594         <span class="keywordflow">if</span>( flag_v )
03595           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03596         <span class="keywordflow">else</span> 
03597           flag_v++;
03598         <span class="keywordflow">break</span>;
03599         
03600       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03601         <span class="keywordflow">if</span>( flag_h )
03602           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03603         <span class="keywordflow">else</span> 
03604           flag_h++;
03605         <span class="keywordflow">break</span>;
03606         
03607       <span class="keywordflow">default</span>:
03608       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03609         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03610         err_flag ++;
03611         <span class="keywordflow">break</span>;
03612     }    
03613   }
03614   
03615   <span class="keywordflow">if</span>( flag_h )
03616     {
03617       <span class="comment">/* print usage */</span>
03618       fprintf( output, help_refresh_cache );    
03619       <span class="keywordflow">return</span> 0;
03620     }
03621   
03622   <span class="comment">/* Exactly 1 args expected */</span>
03623   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) ) 
03624     {
03625       err_flag ++;
03626     } 
03627   <span class="keywordflow">else</span> 
03628     {
03629       file = argv[Optind];
03630     }
03631   
03632   <span class="keywordflow">if</span>( err_flag )
03633     { 
03634       fprintf( output, help_refresh_cache );
03635       <span class="keywordflow">return</span> -1;
03636     }
03637     
03638   <span class="comment">/* copy current absolute path to a local variable. */</span>
03639   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
03640   
03641   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03642   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03643     <span class="keywordflow">return</span> rc ; 
03644 
03645   <span class="keywordflow">if</span>( obj_hdl-&gt;object.file.pentry_content == NULL )
03646     {
03647       fprintf( output, <span class="stringliteral">"Error: this entry is not data cached\n"</span> ) ;
03648       <span class="keywordflow">return</span> 1 ;
03649     }
03650 
03651   <span class="keywordflow">if</span>( cache_content_refresh( obj_hdl-&gt;object.file.pentry_content, 
03652                              (cache_content_client_t *)context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.pcontent_client, 
03653                              &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
03654                              FORCE_FROM_FSAL,
03655                              &amp;cache_content_status ) != CACHE_CONTENT_SUCCESS )
03656     {
03657       fprintf(output,<span class="stringliteral">"Error executing cache_content_refresh: %d\n"</span>, cache_content_status );
03658       <span class="keywordflow">return</span> cache_content_status ;
03659     }
03660   
03661   <span class="keywordflow">if</span>( flag_v )
03662     {
03663       fprintf( output, <span class="stringliteral">"Entry %p has been refreshed\n"</span>, obj_hdl ) ;
03664     }
03665 
03666   <span class="keywordflow">return</span> 0 ;
03667 } <span class="comment">/* fn_Cache_inode_refresh_cache */</span>
03668 
03669 
<a name="l03671"></a><a class="code" href="commands__Cache__inode_8c.html#a47">03671</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a47">fn_Cache_inode_flush_cache</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03672                                   <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03673                                   FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03674 {
03675   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hv"</span>;
03676   
03677   <span class="keyword">static</span> <span class="keywordtype">char</span> help_flush_cache[]=
03678     <span class="stringliteral">"usage: flush_cache [-h][-v]  &lt;path&gt;\n"</span>
03679     <span class="stringliteral">"\n"</span>
03680     <span class="stringliteral">"   -h : print this help\n"</span>
03681     <span class="stringliteral">"   -v : verbose mode\n"</span> ;
03682   
03683   
03684   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03685   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03686   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
03687   cache_content_status_t cache_content_status ;
03688   
03689   <span class="keywordtype">int</span> rc,option,i;
03690   <span class="keywordtype">int</span> flag_v=0;
03691   <span class="keywordtype">int</span> flag_h=0;
03692   <span class="keywordtype">int</span> err_flag=0;
03693   
03694   <span class="keywordtype">char</span> * file = NULL;        <span class="comment">/* the relative path to the object */</span>  
03695       
03696   
03697   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03698    
03699   <span class="comment">/* is the fs initialized ? */</span>
03700   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03701    {
03702      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03703      <span class="keywordflow">return</span> -1;
03704    }
03705 
03706   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03707   
03708   <span class="comment">/* analysing options */</span>
03709   
03710   getopt_init();
03711   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03712   {   
03713     <span class="keywordflow">switch</span>( option )
03714       {
03715       <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03716         <span class="keywordflow">if</span>( flag_v )
03717           fprintf(output, <span class="stringliteral">"access: warning: option 'v' has been specified more than once.\n"</span>);
03718         <span class="keywordflow">else</span> 
03719           flag_v++;
03720         <span class="keywordflow">break</span>;
03721         
03722       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03723         <span class="keywordflow">if</span>( flag_h )
03724           fprintf(output, <span class="stringliteral">"access: warning: option 'h' has been specified more than once.\n"</span>);
03725         <span class="keywordflow">else</span> 
03726           flag_h++;
03727         <span class="keywordflow">break</span>;
03728         
03729       <span class="keywordflow">default</span>:
03730       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03731         fprintf(output,<span class="stringliteral">"access: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03732         err_flag ++;
03733         <span class="keywordflow">break</span>;
03734     }    
03735   }
03736   
03737   <span class="keywordflow">if</span>( flag_h )
03738     {
03739       <span class="comment">/* print usage */</span>
03740       fprintf( output, help_flush_cache );    
03741       <span class="keywordflow">return</span> 0;
03742     }
03743   
03744   <span class="comment">/* Exactly 1 args expected */</span>
03745   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) ) 
03746     {
03747       err_flag ++;
03748     } 
03749   <span class="keywordflow">else</span> 
03750     {
03751       file = argv[Optind];
03752     }
03753   
03754   <span class="keywordflow">if</span>( err_flag )
03755     { 
03756       fprintf( output, help_flush_cache );
03757       <span class="keywordflow">return</span> -1;
03758     }
03759     
03760   <span class="comment">/* copy current absolute path to a local variable. */</span>
03761   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
03762   
03763   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03764   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03765     <span class="keywordflow">return</span> rc ; 
03766 
03767   <span class="keywordflow">if</span>( obj_hdl-&gt;object.file.pentry_content == NULL )
03768     {
03769       fprintf( output, <span class="stringliteral">"Error: this entry is not data cached\n"</span> ) ;
03770       <span class="keywordflow">return</span> 1 ;
03771     }
03772 
03773   <span class="keywordflow">if</span>( cache_content_flush( obj_hdl-&gt;object.file.pentry_content, 
03774                            CACHE_CONTENT_FLUSH_AND_DELETE,
03775                            (cache_content_client_t *)context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>.pcontent_client, 
03776                            &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
03777                            &amp;cache_content_status ) != CACHE_CONTENT_SUCCESS )
03778     {
03779       fprintf(output,<span class="stringliteral">"Error executing cache_content_flush: %d\n"</span>, cache_content_status );
03780       <span class="keywordflow">return</span> cache_content_status ;
03781     }
03782   
03783   <span class="keywordflow">if</span>( flag_v )
03784     {
03785       fprintf( output, <span class="stringliteral">"Entry %p has been flushed\n"</span>, obj_hdl ) ;
03786     }
03787 
03788   <span class="keywordflow">return</span> 0 ;
03789 } <span class="comment">/* fn_Cache_inode_flush_cache */</span>
03790 
<a name="l03792"></a><a class="code" href="commands__Cache__inode_8c.html#a48">03792</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a48">fn_Cache_inode_read</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
03793                          <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
03794                          FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
03795 {
03796   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvAXB:s:"</span>;
03797   <span class="keywordtype">int</span> rc,option,i;
03798 
03799   <span class="keywordtype">int</span> err_flag=0 ;
03800   <span class="keywordtype">int</span> flag_v=0;
03801   <span class="keywordtype">int</span> flag_h=0;
03802   <span class="keywordtype">int</span> flag_N=0;
03803   <span class="keywordtype">int</span> flag_s=0;
03804   <span class="keywordtype">int</span> flag_A=0;
03805   <span class="keywordtype">int</span> flag_X=0;
03806   <span class="keywordtype">int</span> flag_B=0;
03807   
03808   fsal_attrib_list_t         fsal_attr ;
03809   
03810   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
03811   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
03812 
03813   <span class="keywordtype">char</span> * str_times = NULL;
03814   <span class="keywordtype">char</span>   str_seek_buff[256];      
03815   <span class="keywordtype">char</span> * str_seek_type = NULL;
03816   <span class="keywordtype">char</span> * str_seek_offset = NULL;  
03817   <span class="keywordtype">char</span> * str_hexa = NULL;  
03818   <span class="keywordtype">char</span> * str_ascii = NULL;
03819   <span class="keywordtype">char</span> * str_total_bytes = NULL;
03820   <span class="keywordtype">char</span> * str_block_size = NULL;
03821 
03822   fsal_size_t block_size = 1024;  <span class="comment">/* default: 1ko */</span>  
03823   fsal_size_t total_bytes = 0; <span class="comment">/* 0 == read all */</span>
03824   fsal_seek_t seek_desc =
03825   { FSAL_SEEK_SET, 0 }; <span class="comment">/* default: start of the file */</span>
03826   
03827   <span class="comment">/* fsal arguments */</span>
03828   
03829   fsal_boolean_t  is_eof = 0;
03830   fsal_size_t     total_nb_read = 0;
03831   fsal_size_t     once_nb_read = 0;
03832   fsal_size_t     nb_block_read = 0;
03833 
03834   <span class="keywordtype">char</span> * p_read_buff;
03835   
03836   <span class="keywordtype">char</span> * file = NULL;        <span class="comment">/* the relative path to the object */</span>  
03837   
03838   <span class="keyword">struct </span>timeval timer_start;
03839   <span class="keyword">struct </span>timeval timer_stop;
03840   <span class="keyword">struct </span>timeval timer_diff;
03841 
03842   <span class="keyword">static</span> <span class="keywordtype">char</span> help_read[]=
03843     <span class="stringliteral">"Usage:\n"</span>
03844     <span class="stringliteral">"  read [-h][-v][-A][-X] [-B &lt;block_size&gt; ] [ -s &lt;seek_type&gt;,&lt;offset&gt; ]  { &lt;total_bytes&gt; | all } filename\n"</span>
03845     <span class="stringliteral">"Options:\n"</span>
03846     <span class="stringliteral">"  -h: print this help\n"</span>
03847     <span class="stringliteral">"  -v: verbose mode\n"</span>
03848     <span class="stringliteral">"  -A: display read data in ascii\n"</span>
03849     <span class="stringliteral">"  -X: display read data in hexa\n"</span>
03850     <span class="stringliteral">"  -B &lt;blocksize&gt;: block size used for reading, in bytes (default 1k).\n"</span>
03851     <span class="stringliteral">"  -s &lt;seek_type&gt;,&lt;offset&gt;: specify the position of the first byte to be read.\n"</span>
03852     <span class="stringliteral">"        &lt;seek_type&gt; can take the values SET, CUR or END.\n"</span>
03853     <span class="stringliteral">"        &lt;offset&gt; is a signed integer.\n"</span>
03854     <span class="stringliteral">"  &lt;total_bytes&gt;: indicates the total number of bytes to be read\n"</span>
03855     <span class="stringliteral">"      ('all' indicates that data are read until the end of the file).\n"</span>
03856     <span class="stringliteral">"Example:\n"</span>
03857     <span class="stringliteral">"  For reading the last 2kB of the opened file, using 1k block size:\n"</span>
03858     <span class="stringliteral">"        read -B 1024 -s END,-2048 all  filename\n"</span>;
03859   
03860   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
03861    
03862   <span class="comment">/* is the fs initialized ? */</span>
03863   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
03864    {
03865      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
03866      <span class="keywordflow">return</span> -1;
03867    }
03868 
03869   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
03870   
03871   <span class="comment">/* analysing options */</span>
03872   getopt_init();
03873 
03874   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
03875     {
03876       <span class="keywordflow">switch</span>( option )
03877         {
03878         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
03879           <span class="keywordflow">if</span> (flag_v)
03880             fprintf(output,
03881                     <span class="stringliteral">"read: warning: option 'v' has been specified more than once.\n"</span>);
03882           <span class="keywordflow">else</span>
03883             flag_v++;
03884           <span class="keywordflow">break</span>;
03885           
03886       <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
03887         <span class="keywordflow">if</span> ( flag_h )
03888           fprintf(output,
03889                   <span class="stringliteral">"read: warning: option 'h' has been specified more than once.\n"</span>);
03890         <span class="keywordflow">else</span> 
03891           flag_h++;
03892         <span class="keywordflow">break</span>;
03893         
03894         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
03895           <span class="keywordflow">if</span> ( flag_A )
03896             fprintf(output,
03897                     <span class="stringliteral">"read: warning: option 'A' has been specified more than once.\n"</span>);
03898           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( flag_X )
03899             {
03900               fprintf(output,
03901                       <span class="stringliteral">"read: option 'A' conflicts with option 'X'.\n"</span>);
03902               err_flag ++;
03903             }
03904           <span class="keywordflow">else</span> 
03905             flag_A++;
03906           <span class="keywordflow">break</span>;
03907           
03908         <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
03909           <span class="keywordflow">if</span> ( flag_X )
03910             fprintf(output,
03911                     <span class="stringliteral">"read: warning: option 'X' has been specified more than once.\n"</span>);
03912           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( flag_A )
03913             {
03914               fprintf(output,
03915                       <span class="stringliteral">"read: option 'X' conflicts with option 'A'.\n"</span>);
03916               err_flag ++;
03917             }
03918           <span class="keywordflow">else</span> 
03919             flag_X++;
03920           <span class="keywordflow">break</span>;
03921           
03922         <span class="keywordflow">case</span> <span class="charliteral">'B'</span>:
03923           <span class="keywordflow">if</span> ( flag_B )
03924             fprintf(output,
03925                     <span class="stringliteral">"read: warning: option 'B' has been specified more than once.\n"</span>);
03926           <span class="keywordflow">else</span>
03927             {
03928               flag_B++;
03929               str_block_size = Optarg;
03930             }
03931           <span class="keywordflow">break</span>;
03932           
03933         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
03934           <span class="keywordflow">if</span> ( flag_s )
03935             fprintf(output,
03936                     <span class="stringliteral">"read: warning: option 's' has been specified more than once.\n"</span>);
03937           <span class="keywordflow">else</span>
03938             {
03939               flag_s++;
03940               strncpy(str_seek_buff,<a class="code" href="Getopt_8c.html#a6">Optarg</a>,256);
03941               str_seek_type = str_seek_buff;
03942             }
03943           <span class="keywordflow">break</span>;
03944           
03945         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
03946           fprintf(output,<span class="stringliteral">"read: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
03947           err_flag ++;
03948           <span class="keywordflow">break</span>;
03949         }    
03950     }
03951   
03952   <span class="keywordflow">if</span>( flag_h )
03953     {
03954       <span class="comment">/* print usage */</span>
03955       fprintf( output, help_read );    
03956       <span class="keywordflow">return</span> 0;
03957     }
03958   
03959   <span class="comment">/* Exactly 1 args expected */</span>
03960   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 2 ) ) 
03961     {
03962       err_flag ++;
03963     } 
03964   <span class="keywordflow">else</span> 
03965     {
03966       str_total_bytes = argv[Optind] ;
03967       file = argv[<a class="code" href="Getopt_8c.html#a4">Optind</a>+1];
03968     }
03969   
03970   <span class="keywordflow">if</span>( err_flag )
03971     { 
03972       fprintf( output, help_read ) ;
03973       <span class="keywordflow">return</span> -1;
03974     }
03975     
03976   <span class="comment">/* copy current absolute path to a local variable. */</span>
03977   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
03978   
03979   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
03980   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
03981     <span class="keywordflow">return</span> rc ; 
03982 
03983   <span class="comment">/* Sanity check */</span>
03984   <span class="keywordflow">if</span>( obj_hdl-&gt;internal_md.type != REGULAR_FILE )
03985     {
03986       fprintf( output, <span class="stringliteral">"Error: This entry is no REGULAR_FILE\n"</span> ) ;
03987       <span class="keywordflow">return</span> 1 ;
03988     }
03989   
03990   <span class="comment">/* Is this entry cached ? */</span>
03991   <span class="keywordflow">if</span>( obj_hdl-&gt;object.file.pentry_content == NULL )
03992     {
03993       <span class="keywordflow">if</span>( flag_v )
03994         fprintf( output, <span class="stringliteral">"Warning: This entry is not data cached\n"</span> )  ;
03995     }
03996   
03997   <span class="comment">/* check argument types */</span>
03998     
03999   <span class="keywordflow">if</span>( flag_B )
04000   {
04001     <span class="comment">/* Try to convert the str_block_size to fsal_size_t */</span>
04002     
04003     rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( str_block_size, &amp;block_size );
04004     
04005     <span class="keywordflow">if</span> ( rc == -1 )
04006       {
04007         fprintf(output,<span class="stringliteral">"read: error: invalid block size \"%s\"\n"</span>,
04008                 str_block_size);
04009         err_flag++;
04010       }
04011     
04012   }
04013   
04014   <span class="keywordflow">if</span>( flag_s )
04015   {
04016     <span class="comment">/* Try to parse the argument */</span>
04017     
04018     str_seek_offset = strchr( str_seek_type, <span class="charliteral">','</span> );
04019     
04020     <span class="keywordflow">if</span> ( str_seek_offset == NULL )
04021       {
04022         fprintf(output,<span class="stringliteral">"read: error: invalid seek specifier \"%s\". &lt;seek_type&gt;,&lt;offset&gt; expected.\n"</span>,
04023                 str_seek_type);
04024         err_flag++;      
04025       }
04026     
04027     <span class="keywordflow">if</span> ( !err_flag )
04028       {
04029         <span class="keywordtype">int</span> sign = 1;
04030         
04031         *str_seek_offset=<span class="charliteral">'\0'</span>;
04032         str_seek_offset++; <span class="comment">/* the first char after the "," */</span>
04033         
04034         <span class="comment">/* Check seek type */</span>
04035         
04036         <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"CUR"</span>, 256 ) )
04037           seek_desc.whence = FSAL_SEEK_CUR;
04038         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"SET"</span>, 256 ) )
04039           seek_desc.whence = FSAL_SEEK_SET;
04040         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"END"</span>, 256 ) )
04041           seek_desc.whence = FSAL_SEEK_END;
04042         <span class="keywordflow">else</span>
04043           {
04044             fprintf(output,<span class="stringliteral">"read: error: invalid seek type \"%s\". CUR, SET or END expected.\n"</span>,
04045                     str_seek_type);
04046             err_flag ++;
04047           }
04048         
04049         <span class="comment">/* Try to convert str_seek_offset to fsal_off_t */</span>
04050         
04051         <span class="keywordflow">switch</span> (str_seek_offset[0])
04052           {
04053           <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
04054             sign = 1;
04055             str_seek_offset ++;
04056             <span class="keywordflow">break</span>;
04057              
04058           <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
04059             sign = -1;
04060             str_seek_offset ++;
04061             <span class="keywordflow">break</span>;
04062           }
04063         
04064         rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( str_seek_offset, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *)&amp;seek_desc.offset );
04065         
04066         <span class="keywordflow">if</span> ( rc == -1 )
04067           {
04068             fprintf(output,<span class="stringliteral">"read: error: invalid offset \"%s\".\n"</span>,
04069                     str_seek_offset);
04070             err_flag++;
04071           }
04072         <span class="keywordflow">else</span>
04073           <span class="keywordflow">if</span> (sign &lt; 0) seek_desc.offset = -seek_desc.offset;
04074         
04075       }
04076     
04077   }
04078   <span class="comment">/* else default seeking : SET,0 */</span>
04079   
04080   
04081   <span class="keywordflow">if</span> (!strcasecmp( str_total_bytes , <span class="stringliteral">"all"</span> ))
04082     {
04083     total_bytes = 0;
04084     }
04085   <span class="keywordflow">else</span>
04086     {
04087       rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( str_total_bytes, &amp;total_bytes );
04088       
04089       <span class="keywordflow">if</span> ( rc == -1 )
04090         {
04091           fprintf(output,<span class="stringliteral">"read: error: invalid read size \"%s\". \"all\" or &lt;nb_bytes&gt; expected.\n"</span>,
04092                   str_total_bytes);
04093           err_flag++;
04094         }
04095     }
04096   
04097   <span class="keywordflow">if</span> (err_flag)
04098     {
04099       fprintf(output,help_read);
04100       <span class="keywordflow">return</span> -1;
04101     }
04102   
04103   <span class="keywordflow">if</span> (flag_v)
04104     {
04105       <span class="comment">/* print a sum-up of read parameters */</span>
04106       fprintf(output, <span class="stringliteral">"Read options: Block size: %llu Bytes, Seek: %s%+lld, Read limit: %llu Bytes\n"</span>,
04107               block_size,
04108               ( seek_desc.whence==FSAL_SEEK_SET ? <span class="stringliteral">"SET"</span>:
04109                 seek_desc.whence==FSAL_SEEK_CUR ? <span class="stringliteral">"CUR"</span>:
04110                 <span class="stringliteral">"END"</span> ),
04111               seek_desc.offset,
04112               total_bytes );
04113     }
04114   
04115   
04116   <span class="comment">/* Now all arguments have been parsed, let's act ! */</span>
04117   
04118   <span class="comment">/* alloc a buffer */</span>
04119   p_read_buff = Mem_Alloc( block_size );
04120   
04121   <span class="keywordflow">if</span> ( p_read_buff == NULL )
04122     {
04123       fprintf(output,<span class="stringliteral">"read: error: Not enough memory to allocate read buffer (%llu Bytes).\n"</span>,block_size);
04124       <span class="keywordflow">return</span> ENOMEM;    
04125     }
04126   
04127   
04128   gettimeofday( &amp;timer_start,<a class="code" href="Getopt_8c.html#a0">NULL</a> );  
04129   
04130   <span class="comment">/* while EOF is not reached, and read&lt;asked (when total_bytes!=0) */</span>
04131   <span class="keywordflow">while</span> ( !is_eof &amp;&amp; !( ( total_bytes!= 0) &amp;&amp; (total_nb_read &gt;= total_bytes) ) )
04132     {
04133       <span class="keywordflow">if</span>( cache_inode_rdwr( obj_hdl, 
04134                             CACHE_INODE_READ,
04135                             &amp;seek_desc, 
04136                             block_size, 
04137                             &amp;once_nb_read, 
04138                             &amp;fsal_attr,
04139                             (caddr_t)p_read_buff, 
04140                             &amp;is_eof,
04141                             <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
04142                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
04143                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
04144                             &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
04145       {
04146         log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_read : %J%r\n"</span>,
04147                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
04148 
04149         <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
04150       }
04151 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
04152 <span class="preprocessor"></span>      DisplayLogFlux( output,
04153                       <span class="stringliteral">"shell: block_size=%llu, once_nb_read=%llu, total_bytes=%llu, total_nb_read=%llu, eof=%d, seek=%d.%llu"</span>, 
04154                       block_size, once_nb_read, total_bytes, total_nb_read, is_eof,
04155                       seek_desc.whence, seek_desc.offset ) ;
04156 <span class="preprocessor">#endif</span>
04157 <span class="preprocessor"></span>      
04158       <span class="comment">/* print what was read. */</span>
04159       <span class="keywordflow">if</span> ( flag_A )
04160         {
04161           fsal_size_t index;
04162           <span class="keywordflow">for</span> (index=0; index&lt;once_nb_read; index ++)
04163             fprintf( output, <span class="stringliteral">"%c."</span>, p_read_buff[index] );
04164         }
04165       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( flag_X )
04166         {
04167           fsal_size_t index;
04168           <span class="keywordflow">for</span> (index=0; index&lt;once_nb_read; index ++)
04169             fprintf( output, <span class="stringliteral">"%.2X "</span>, p_read_buff[index] );      
04170         }
04171       <span class="keywordflow">else</span>
04172         fprintf( output,<span class="stringliteral">"."</span> );
04173       
04174       <span class="comment">/* update stats */</span>    
04175       
04176       <span class="keywordflow">if</span> (once_nb_read&gt;0) nb_block_read ++;
04177       
04178       total_nb_read += once_nb_read;
04179       
04180       <span class="comment">/* flush */</span>
04181       <span class="keywordflow">if</span>( nb_block_read % 10 ) 
04182         fflush( output );
04183       
04184       <span class="comment">/* Update the seek descriptor */</span>
04185       seek_desc.whence = FSAL_SEEK_SET ;
04186       seek_desc.offset += once_nb_read ;
04187       
04188     }
04189   
04190   gettimeofday( &amp;timer_stop,<a class="code" href="Getopt_8c.html#a0">NULL</a> );
04191   
04192   <span class="comment">/* newline after read blocks */</span>
04193   fprintf( output,<span class="stringliteral">"\n"</span> );  
04194   
04195   <span class="keywordflow">if</span>( flag_v )
04196     {
04197       <span class="keywordtype">double</span> bandwidth ;
04198       
04199       <span class="comment">/* print stats */</span>
04200       fprintf(output, <span class="stringliteral">"Nb blocks read: %llu\n"</span>, nb_block_read);
04201       fprintf(output, <span class="stringliteral">"Total: %llu Bytes\n"</span>, total_nb_read );
04202       
04203       fprintf(output, <span class="stringliteral">"Time enlapsed: "</span>);
04204       timer_diff = <a class="code" href="cmd__tools_8h.html#a24">time_diff</a>( timer_start, timer_stop );
04205       <a class="code" href="cmd__tools_8h.html#a0">print_timeval</a>( output, timer_diff );
04206       
04207       bandwidth = total_nb_read/(1024*1024*( timer_diff.tv_sec + 0.000001 * timer_diff.tv_usec ));
04208       
04209       fprintf(output, <span class="stringliteral">"Bandwidth: %f MB/s\n"</span>, bandwidth );
04210       
04211     }
04212   Mem_Free(p_read_buff);
04213   
04214   <span class="keywordflow">return</span> 0;
04215 } <span class="comment">/* fn_Cache_inode_read */</span>
04216 
04217 
<a name="l04219"></a><a class="code" href="commands__Cache__inode_8c.html#a49">04219</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a49">fn_Cache_inode_write</a>( <span class="keywordtype">int</span> argc ,         <span class="comment">/* IN : number of args in argv */</span>
04220                          <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
04221                           FILE * output      <span class="comment">/* IN : output stream          */</span> ) 
04222 {
04223   <span class="keyword">static</span> <span class="keywordtype">char</span> format[]=<span class="stringliteral">"hvs:N:A:X:"</span>;
04224 
04225   <span class="keywordtype">int</span> rc,option,i;
04226   <span class="keywordtype">int</span> err_flag=0 ;
04227 
04228   <span class="keywordtype">int</span> flag_v=0;
04229   <span class="keywordtype">int</span> flag_h=0;
04230   <span class="keywordtype">int</span> flag_N=0;
04231   <span class="keywordtype">int</span> flag_s=0;
04232   <span class="keywordtype">int</span> flag_A=0;
04233   <span class="keywordtype">int</span> flag_X=0;
04234 
04235    <span class="keywordtype">char</span> * str_times = NULL;
04236   <span class="keywordtype">char</span> str_seek_buff[256];      
04237   <span class="keywordtype">char</span> * str_seek_type = NULL;
04238   <span class="keywordtype">char</span> * str_seek_offset = NULL;  
04239   
04240   <span class="keywordtype">char</span> * str_hexa = NULL;  
04241   <span class="keywordtype">char</span> * str_ascii = NULL;
04242   
04243   size_t datasize = 0;
04244   <span class="keywordtype">char</span> * databuff = NULL;
04245 
04246   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> nb_times=1; <span class="comment">/* default = 1 */</span>  
04247   fsal_u64_t  nb_block_written=0;
04248   fsal_size_t size_written=0;
04249   fsal_size_t size_written_once=0;
04250 
04251   fsal_size_t block_size = 1024;  <span class="comment">/* default: 1ko */</span>  
04252   fsal_size_t total_bytes = 0; <span class="comment">/* 0 == read all */</span>
04253   fsal_seek_t seek_desc =
04254   { FSAL_SEEK_SET, 0 }; <span class="comment">/* default: start of the file */</span>
04255  
04256   fsal_attrib_list_t         fsal_attr ;
04257 
04258   fsal_boolean_t fsal_eof ;
04259   
04260   <span class="keyword">struct </span>timeval timer_start;
04261   <span class="keyword">struct </span>timeval timer_stop;
04262   <span class="keyword">struct </span>timeval timer_diff;
04263   
04264     
04265   <span class="keywordtype">char</span> glob_path[FSAL_MAX_PATH_LEN];  <span class="comment">/* absolute path of the object */</span>
04266   cache_entry_t *       obj_hdl;      <span class="comment">/* handle of the object        */</span>
04267   cache_inode_status_t status;        <span class="comment">/* Cache Inode return status   */</span>
04268   
04269   <span class="keywordtype">char</span> * file = NULL;        <span class="comment">/* the relative path to the object */</span>  
04270       
04271   <span class="keyword">static</span> <span class="keywordtype">char</span> help_write[]=
04272     <span class="stringliteral">"Usage:\n"</span>
04273     <span class="stringliteral">"  write [-h][-v] [ -s &lt;seek_type&gt;,&lt;offset&gt; ]  [-N &lt;nb_times&gt;] -A &lt;ascii_string&gt; filename\n"</span>
04274     <span class="stringliteral">"  write [-h][-v] [ -s &lt;seek_type&gt;,&lt;offset&gt; ]  [-N &lt;nb_times&gt;] -X &lt;hexa_data&gt; filename\n"</span>
04275     <span class="stringliteral">"Where:\n"</span>
04276     <span class="stringliteral">"  &lt;seek_type&gt; can be: SET, CUR, END\n"</span>
04277     <span class="stringliteral">"  &lt;offset&gt; is a signed number of bytes.\n"</span>
04278     <span class="stringliteral">"  &lt;nb_times&gt; is the number of times we write the expression into the file.\n"</span>
04279     <span class="stringliteral">"\n"</span>
04280     <span class="stringliteral">"  &lt;ascii_string&gt; is a string to be written to file.\n"</span>
04281     <span class="stringliteral">"      Note that the null terminating character of is also written\n"</span>
04282     <span class="stringliteral">"      to file.\n"</span>
04283     <span class="stringliteral">"or\n"</span>
04284     <span class="stringliteral">"  &lt;hexa_data&gt; is a data represented in hexadecimal format,\n"</span>
04285     <span class="stringliteral">"      that is to be written to file.\n"</span>
04286     <span class="stringliteral">"\n"</span>
04287     <span class="stringliteral">"Examples:\n"</span>
04288     <span class="stringliteral">"\n"</span>
04289     <span class="stringliteral">"  For writing 10 times the null terminated string \"hello world\"\n"</span>
04290     <span class="stringliteral">"  at the end of the file:\n"</span>
04291     <span class="stringliteral">"        write -s END,0 -N 10 -A \"hello world\" filename\n"</span>
04292     <span class="stringliteral">"\n"</span>
04293     <span class="stringliteral">"  For overwriting the beginning of the file with\n"</span>
04294     <span class="stringliteral">"  the pattern 0xA1267AEF31254ADE repeated twice:\n"</span>
04295     <span class="stringliteral">"        write -s SET,0 -N 2 -X \"A1267AEF31254ADE\" filename\n"</span>;
04296   
04297   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
04298    
04299   <span class="comment">/* is the fs initialized ? */</span>
04300   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
04301    {
04302      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
04303      <span class="keywordflow">return</span> -1;
04304    }
04305 
04306   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
04307   
04308   <span class="comment">/* analysing options */</span>
04309   getopt_init();
04310 
04311   <span class="keywordflow">while</span>( ( option = <a class="code" href="Getopt_8h.html#a4">Getopt</a>( argc, argv, format ) ) != -1 )
04312     {
04313       <span class="keywordflow">switch</span>( option )
04314         {
04315         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
04316           <span class="keywordflow">if</span>( flag_v )
04317             fprintf( output,
04318                      <span class="stringliteral">"write: warning: option 'v' has been specified more than once.\n"</span>);
04319           <span class="keywordflow">else</span> 
04320             flag_v++;
04321           <span class="keywordflow">break</span>;
04322           
04323         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
04324           <span class="keywordflow">if</span>( flag_h )
04325             fprintf( output,
04326                      <span class="stringliteral">"write: warning: option 'h' has been specified more than once.\n"</span>);
04327           <span class="keywordflow">else</span> 
04328             flag_h++;
04329           <span class="keywordflow">break</span>;
04330           
04331         <span class="keywordflow">case</span> <span class="charliteral">'N'</span>:
04332           <span class="keywordflow">if</span>( flag_N )
04333             fprintf( output,
04334                      <span class="stringliteral">"write: warning: option 'N' has been specified more than once.\n"</span>);
04335           <span class="keywordflow">else</span>
04336             {
04337               flag_N++;
04338               str_times = Optarg;
04339             }
04340           <span class="keywordflow">break</span>;
04341           
04342         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
04343           <span class="keywordflow">if</span>( flag_s )
04344             fprintf( output,
04345                      <span class="stringliteral">"write: warning: option 's' has been specified more than once.\n"</span>);
04346           <span class="keywordflow">else</span>
04347             {
04348               flag_s++;
04349               strncpy(str_seek_buff,<a class="code" href="Getopt_8c.html#a6">Optarg</a>,256);
04350               str_seek_type = str_seek_buff;
04351             }
04352           <span class="keywordflow">break</span>;
04353           
04354         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
04355           <span class="keywordflow">if</span>( flag_A )
04356             fprintf(output,
04357                     <span class="stringliteral">"write: warning: option 'A' has been specified more than once.\n"</span>);
04358           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_X )
04359             {
04360               fprintf(output,
04361                       <span class="stringliteral">"write: option 'A' conflicts with option 'X'.\n"</span>);
04362               err_flag ++;
04363             }
04364           <span class="keywordflow">else</span>
04365             {
04366               flag_A++;
04367               str_ascii = Optarg;
04368             }
04369           <span class="keywordflow">break</span>;
04370           
04371         <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
04372           <span class="keywordflow">if</span>( flag_X )
04373             fprintf(output,
04374                     <span class="stringliteral">"write: warning: option 'X' has been specified more than once.\n"</span>);
04375           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flag_A )
04376             {
04377               fprintf(output,
04378                       <span class="stringliteral">"write: option 'X' conflicts with option 'A'.\n"</span>);
04379               err_flag ++;
04380             }
04381           <span class="keywordflow">else</span>
04382             {
04383               flag_X++;
04384               str_hexa = Optarg;
04385             }
04386           <span class="keywordflow">break</span>;
04387           
04388         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
04389           fprintf(output,<span class="stringliteral">"write: unknown option : %c\n"</span>,<a class="code" href="Getopt_8c.html#a5">Optopt</a>);
04390           err_flag ++;
04391           <span class="keywordflow">break</span>;
04392         }    
04393     }
04394   
04395   <span class="keywordflow">if</span>( flag_h )
04396     {
04397       <span class="comment">/* print usage */</span>
04398       fprintf( output, help_write );    
04399       <span class="keywordflow">return</span> 0;
04400     }
04401   
04402   <span class="comment">/* Exactly 1 args expected */</span>
04403   <span class="keywordflow">if</span>( <a class="code" href="Getopt_8c.html#a4">Optind</a> != ( argc - 1 ) ) 
04404     {
04405       err_flag ++;
04406     } 
04407   <span class="keywordflow">else</span> 
04408     {
04409       file = argv[Optind];
04410     }
04411   
04412   <span class="keywordflow">if</span>( err_flag )
04413     { 
04414       fprintf( output, help_write ) ;
04415       <span class="keywordflow">return</span> -1;
04416     }
04417     
04418   <span class="comment">/* copy current absolute path to a local variable. */</span>
04419   strncpy( glob_path, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o6">current_path</a>, FSAL_MAX_PATH_LEN);
04420   
04421   <span class="comment">/* retrieve handle to the file whose permissions are to be tested */</span>
04422   <span class="keywordflow">if</span>( rc = <a class="code" href="commands__Cache__inode_8c.html#a26">cache_solvepath</a>( glob_path, FSAL_MAX_PATH_LEN, file, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o5">pentry</a>, &amp;obj_hdl, output ) )
04423     <span class="keywordflow">return</span> rc ; 
04424 
04425   <span class="comment">/* Sanity check */</span>
04426   <span class="keywordflow">if</span>( obj_hdl-&gt;internal_md.type != REGULAR_FILE )
04427     {
04428       fprintf( output, <span class="stringliteral">"Error: This entry is no REGULAR_FILE\n"</span> ) ;
04429       <span class="keywordflow">return</span> 1 ;
04430     }
04431   
04432   <span class="comment">/* Is this entry cached ? */</span>
04433   <span class="keywordflow">if</span>( obj_hdl-&gt;object.file.pentry_content == NULL )
04434     {
04435       <span class="keywordflow">if</span>( flag_v ) 
04436         fprintf( output, <span class="stringliteral">"Warning: This entry is not data cached\n"</span> ) ;
04437     }
04438   
04439     
04440   <span class="comment">/* check argument types */</span>
04441     
04442   <span class="keywordflow">if</span> ( flag_N )
04443   {
04444     <span class="comment">/* Try to convert the str_times to nb_times */</span>
04445     
04446     rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( str_times, &amp;nb_times );
04447     
04448     <span class="keywordflow">if</span> ( rc == -1 )
04449     {
04450       fprintf(output,<span class="stringliteral">"write: error: invalid number \"%s\"\n"</span>,
04451           str_times);
04452       <span class="keywordflow">return</span> EINVAL;
04453     }
04454     
04455   }
04456   
04457   <span class="keywordflow">if</span> ( flag_s )
04458   {
04459     <span class="keywordtype">int</span> sign = 1;
04460 
04461     <span class="comment">/* Try to parse the argument */</span>
04462     
04463     str_seek_offset = strchr( str_seek_type, <span class="charliteral">','</span> );
04464     
04465     <span class="keywordflow">if</span> ( str_seek_offset == NULL )
04466     {
04467       fprintf(output,<span class="stringliteral">"write: error: invalid seek specifier \"%s\". &lt;seek_type&gt;,&lt;offset&gt; expected.\n"</span>,
04468           str_seek_type);
04469       <span class="keywordflow">return</span> EINVAL;
04470     }
04471     
04472     *str_seek_offset=<span class="charliteral">'\0'</span>;
04473     str_seek_offset++; <span class="comment">/* the first char after the "," */</span>
04474 
04475     <span class="comment">/* Check seek type */</span>
04476 
04477     <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"CUR"</span>, 256 ) )
04478       seek_desc.whence = FSAL_SEEK_CUR;
04479     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"SET"</span>, 256 ) )
04480       seek_desc.whence = FSAL_SEEK_SET;
04481     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !strncmp( str_seek_type, <span class="stringliteral">"END"</span>, 256 ) )
04482       seek_desc.whence = FSAL_SEEK_END;
04483     <span class="keywordflow">else</span>
04484     {
04485       fprintf(output,<span class="stringliteral">"write: error: invalid seek type \"%s\". CUR, SET or END expected.\n"</span>,
04486           str_seek_type);
04487       <span class="keywordflow">return</span> EINVAL;
04488     }
04489 
04490     <span class="comment">/* Try to convert str_seek_offset to fsal_off_t */</span>
04491 
04492     <span class="keywordflow">switch</span> (str_seek_offset[0])
04493     {
04494       <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
04495         sign = 1;
04496         str_seek_offset ++;
04497         <span class="keywordflow">break</span>;
04498 
04499       <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
04500         sign = -1;
04501         str_seek_offset ++;
04502         <span class="keywordflow">break</span>;
04503     }
04504 
04505     rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( str_seek_offset, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *)&amp;seek_desc.offset );
04506 
04507     <span class="keywordflow">if</span> ( rc == -1 )
04508     {
04509       fprintf(output,<span class="stringliteral">"write: error: invalid offset \"%s\".\n"</span>,
04510           str_seek_offset);
04511       <span class="keywordflow">return</span> EINVAL;
04512     }
04513     <span class="keywordflow">else</span>
04514        <span class="keywordflow">if</span> (sign &lt; 0) seek_desc.offset = -seek_desc.offset;
04515 
04516     
04517   }
04518   <span class="comment">/* else default seeking : SET,0 */</span>
04519   
04520   <span class="keywordflow">if</span> (flag_A)
04521   {
04522     datasize = strlen(str_ascii)+1; <span class="comment">/* Include null termination char. */</span>
04523     databuff = str_ascii;    
04524   }
04525   
04526   
04527   <span class="keywordflow">if</span> (flag_X)
04528   {
04529     size_t length = strlen( str_hexa );
04530     
04531     datasize = (length &gt;&gt; 1);
04532     
04533     <span class="keywordflow">if</span> ( length % 2 )
04534     {
04535     
04536       <span class="comment">/* if it is not odd: error */</span>
04537       fprintf(output,<span class="stringliteral">"write: error: in \"%s\", data length is not a multiple of 8 bits.\n"</span>,
04538             str_hexa);
04539     
04540       <span class="keywordflow">return</span> EINVAL;
04541     }
04542     
04543     databuff = Mem_Alloc( datasize + 1 );
04544     
04545     <span class="keywordflow">if</span> ( databuff == NULL )
04546     {
04547       fprintf(output,<span class="stringliteral">"write: error: Not enough memory to allocate %llu Bytes.\n"</span>,
04548             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)datasize);
04549       <span class="keywordflow">return</span> ENOMEM;
04550     }
04551 
04552     
04553     memset( databuff, 0, datasize + 1 );
04554       
04555     <span class="comment">/* try to convert the string to hexa */</span>
04556     rc = sscanmem(databuff, datasize, str_hexa );
04557 
04558     <span class="keywordflow">if</span> (rc != (int)(2*datasize) )
04559     {
04560       <span class="comment">/* if it is not odd: error */</span>
04561       fprintf(output,<span class="stringliteral">"write: error: \"%s\" in not a valid hexa format.\n"</span>,
04562             str_hexa);
04563 
04564       Mem_Free( str_hexa );
04565 
04566       <span class="keywordflow">return</span> EINVAL;        
04567     }
04568     
04569   }
04570     
04571   
04572   <span class="keywordflow">if</span> (flag_v)
04573   {    
04574     <span class="comment">/* print a sum-up of write parameters */</span>
04575     fprintf(output, <span class="stringliteral">"Write options: Data length: %llu x %llu Bytes, Seek: %s%+lld\n"</span>,
04576         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)nb_times,
04577         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)datasize,
04578         ( seek_desc.whence==FSAL_SEEK_SET ? <span class="stringliteral">"SET"</span>:
04579           seek_desc.whence==FSAL_SEEK_CUR ? <span class="stringliteral">"CUR"</span>:
04580           <span class="stringliteral">"END"</span> ),
04581         seek_desc.offset);
04582   }
04583   
04584   <span class="comment">/* variables initialisation */</span>
04585     
04586   block_size = (fsal_size_t) datasize;  
04587   nb_block_written=0;
04588   size_written=0;  
04589   size_written_once=0;
04590   
04591   gettimeofday( &amp;timer_start,<a class="code" href="Getopt_8c.html#a0">NULL</a> );  
04592   
04593   <span class="comment">/* write loop */</span>
04594     
04595   <span class="keywordflow">while</span> ( nb_block_written &lt; nb_times )
04596   {
04597     <span class="keywordflow">if</span>( cache_inode_rdwr( obj_hdl, 
04598                           CACHE_INODE_WRITE,
04599                           &amp;seek_desc,
04600                           block_size,
04601                           &amp;size_written_once, 
04602                           &amp;fsal_attr, 
04603                           (caddr_t)databuff,
04604                           &amp;fsal_eof,
04605                           <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a>, 
04606                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o7">client</a>, 
04607                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, 
04608                           &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ) != CACHE_INODE_SUCCESS )
04609     {
04610       log_fprintf( output, <span class="stringliteral">"Error executing cache_inode_write : %J%r\n"</span>,
04611                   ERR_CACHE_INODE, context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> );
04612 
04613       <span class="keywordflow">return</span> context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o3">cache_status</a> ;
04614     }
04615     
04616     fprintf( output,<span class="stringliteral">"."</span> );
04617 
04618     <span class="comment">/* update stats */</span>
04619     
04620     <span class="keywordflow">if</span> (size_written_once&gt;0) nb_block_written ++;
04621     
04622     size_written += size_written_once;
04623     
04624     <span class="comment">/* flush */</span>
04625     <span class="keywordflow">if</span> ( nb_block_written % 10 ) fflush( output );
04626 
04627     
04628     <span class="comment">/* Update the seek descriptor */</span>
04629     seek_desc.whence = FSAL_SEEK_SET ;
04630     seek_desc.offset += size_written_once ;
04631   }
04632   
04633   gettimeofday( &amp;timer_stop,<a class="code" href="Getopt_8c.html#a0">NULL</a> );
04634   
04635   <span class="comment">/* newline after written blocks */</span>
04636   fprintf( output,<span class="stringliteral">"\n"</span> );  
04637   
04638   <span class="keywordflow">if</span> (flag_v)
04639   {
04640     <span class="keywordtype">double</span> bandwidth ;
04641     
04642     <span class="comment">/* print stats */</span>
04643     fprintf(output, <span class="stringliteral">"Nb blocks written: %llu\n"</span>, nb_block_written);
04644     fprintf(output, <span class="stringliteral">"Total volume: %llu Bytes\n"</span>, size_written );
04645     
04646     fprintf(output, <span class="stringliteral">"Time enlapsed: "</span>);
04647     timer_diff = <a class="code" href="cmd__tools_8h.html#a24">time_diff</a>( timer_start, timer_stop );
04648     <a class="code" href="cmd__tools_8h.html#a0">print_timeval</a>( output, timer_diff );
04649     
04650     bandwidth = size_written/(1024*1024*( timer_diff.tv_sec + 0.000001 * timer_diff.tv_usec ));
04651     
04652     fprintf(output, <span class="stringliteral">"Bandwidth: %f MB/s\n"</span>, bandwidth );
04653     
04654   }
04655   
04656   <span class="keywordflow">if</span> (flag_X) Mem_Free( databuff );
04657   
04658   <span class="keywordflow">return</span> 0;
04659 } <span class="comment">/* fn_Cache_inode_write */</span>
04660 
04661 
04662 
<a name="l04664"></a><a class="code" href="commands__Cache__inode_8c.html#a50">04664</a> <span class="keywordtype">int</span> <a class="code" href="commands__Cache__inode_8c.html#a50">fn_Cache_inode_su</a>( <span class="keywordtype">int</span> argc , <span class="comment">/* IN : number of args in argv */</span>
04665                        <span class="keywordtype">char</span> ** argv ,     <span class="comment">/* IN : arg list               */</span>
04666                        FILE * output )    <span class="comment">/* IN : output stream          */</span>
04667 {
04668   
04669   <span class="keywordtype">char</span> * str_uid;
04670   uid_t uid;
04671   fsal_status_t st;
04672   <span class="keyword">struct </span>passwd * pw_struct;
04673   <span class="keywordtype">int</span> i;
04674 
04675 <span class="preprocessor"># define MAX_GRPS  128</span>
04676 <span class="preprocessor"></span>  gid_t   groups_tab[MAX_GRPS];
04677   <span class="keywordtype">int</span>     nb_grp;
04678 
04679   <span class="keyword">static</span> <span class="keywordtype">char</span> help_su[]=
04680   <span class="stringliteral">"usage: su &lt;uid&gt;\n"</span>;
04681 
04682   <a class="code" href="structcmdCacheInode__thr__info____.html">cmdCacheInode_thr_info_t</a> * context;  
04683    
04684   <span class="comment">/* is the fs initialized ? */</span>
04685   <span class="keywordflow">if</span>( <a class="code" href="commands__Cache__inode_8c.html#a10">ht</a> == NULL ) 
04686    {
04687      fprintf(output,<span class="stringliteral">"Error: Cache is not initialized\n"</span>);
04688      <span class="keywordflow">return</span> -1;
04689    }
04690 
04691   context = <a class="code" href="commands__Cache__inode_8c.html#a21">RetrieveInitializedContext</a>();
04692   
04693   <span class="comment">/* UID arg expected */</span>
04694   <span class="keywordflow">if</span> (argc!=2){
04695     fprintf(output,help_su);
04696     <span class="keywordflow">return</span> -1;
04697   } <span class="keywordflow">else</span> {
04698     str_uid = argv[1];
04699   }
04700   
04701   <span class="keywordflow">if</span> ( isdigit( str_uid[0] ) )
04702   {
04703     <span class="keywordflow">if</span> ( (uid = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>(str_uid) ) == (uid_t)-1 )
04704     {
04705       fprintf(output,<span class="stringliteral">"Error: invalid uid \"%s\"\n"</span>,str_uid);
04706       <span class="keywordflow">return</span> -1;
04707     }
04708     pw_struct = getpwuid(uid); 
04709   }
04710   <span class="keywordflow">else</span>
04711   {
04712     pw_struct = getpwnam( str_uid );
04713   }
04714   
04715   <span class="keywordflow">if</span> ( pw_struct == NULL )
04716   {
04717     fprintf( output, <span class="stringliteral">"Unknown user %s\n"</span>, str_uid );
04718     <span class="keywordflow">return</span> errno;
04719   }
04720   
04721   nb_grp = <a class="code" href="cmd__tools_8h.html#a25">getugroups</a>( <a class="code" href="commands__Cache__inode_8c.html#a3">MAX_GRPS</a>, groups_tab, pw_struct-&gt;pw_name, pw_struct-&gt;pw_gid );
04722   
04723   fprintf( output, <span class="stringliteral">"Changing user to : %s ( uid = %d, gid = %d )\n"</span>,
04724        pw_struct-&gt;pw_name , pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid );
04725   
04726   <span class="keywordflow">if</span> ( nb_grp &gt; 1 )
04727   {
04728     fprintf( output, <span class="stringliteral">"altgroups = "</span>);
04729     <span class="keywordflow">for</span> ( i = 1; i &lt; nb_grp; i++ )
04730     {      
04731       <span class="keywordflow">if</span> ( i == 1 )
04732         fprintf( output, <span class="stringliteral">"%d"</span>, groups_tab[i]);
04733       <span class="keywordflow">else</span>
04734         fprintf( output, <span class="stringliteral">", %d"</span>, groups_tab[i]);      
04735     }
04736     fprintf( output, <span class="stringliteral">"\n"</span>);
04737   }
04738 
04739   st = FSAL_GetClientContext( &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o2">context</a>, &amp;context-&gt;<a class="code" href="structcmdCacheInode__thr__info____.html#o1">exp_context</a>,
04740                               pw_struct-&gt;pw_uid, pw_struct-&gt;pw_gid, groups_tab, nb_grp );
04741       
04742   <span class="keywordflow">if</span> ( FSAL_IS_ERROR(st) )
04743   {
04744     fprintf(output,<span class="stringliteral">"Error executing FSAL_GetUserCred:"</span>);
04745     <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>(output,st);
04746     fprintf(output,<span class="stringliteral">"\n"</span>);
04747     <span class="keywordflow">return</span> st.major;
04748   }
04749   
04750   fprintf(output,<span class="stringliteral">"Done.\n"</span>);
04751   
04752   <span class="keywordflow">return</span> 0;
04753   
04754 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:34 2008 for ganeshell by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
