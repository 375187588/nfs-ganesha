<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ganeshell: cmd_tools.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cmd_tools.c</h1><a href="cmd__tools_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00159 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00161 <span class="preprocessor">#endif</span>
00162 <span class="preprocessor"></span>
00163  
00164 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00165 <span class="preprocessor">#include &lt;string.h&gt;</span>
00166 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00167 <span class="preprocessor">#include &lt;err_ghost_fs.h&gt;</span>
00168 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00169 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00170 <span class="preprocessor">#include &lt;time.h&gt;</span>
00171 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00172 <span class="preprocessor">#include "<a class="code" href="cmd__tools_8h.html">cmd_tools.h</a>"</span>
00173 <span class="preprocessor">#include &lt;grp.h&gt;</span>
00174 
00175 <span class="comment">/* mutex for calling localtime... */</span>
00176 <span class="keyword">static</span> pthread_mutex_t mutex_localtime = PTHREAD_MUTEX_INITIALIZER;
00177 
00178 <span class="comment">/* thread-safe and PORTABLE version of localtime... */</span>
<a name="l00179"></a><a class="code" href="cmd__tools_8h.html#a9">00179</a> <span class="keyword">struct </span>tm * <a class="code" href="cmd__tools_8h.html#a9">Localtime_r</a>( <span class="keyword">const</span> time_t * p_time, <span class="keyword">struct</span> tm * p_tm )
00180 {
00181   <span class="keyword">struct </span>tm * p_tmp_tm;
00182   
00183   <span class="keywordflow">if</span> ( !p_tm )
00184   {
00185     errno = EFAULT;
00186     <span class="keywordflow">return</span> NULL;
00187   }
00188   
00189   pthread_mutex_lock( &amp;mutex_localtime );
00190   
00191   p_tmp_tm = localtime( p_time );
00192   
00193   <span class="comment">/* copy the result */</span>
00194    (*p_tm) = (*p_tmp_tm);
00195     
00196   pthread_mutex_unlock( &amp;mutex_localtime );
00197   
00198   <span class="keywordflow">return</span> p_tm;
00199 }
00200 
00201 
<a name="l00211"></a><a class="code" href="cmd__tools_8h.html#a10">00211</a> <span class="keywordtype">int</span> <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>(<span class="keywordtype">char</span> * str){
00212   
00213   <span class="keywordtype">int</span> i;
00214   <span class="keywordtype">int</span> out = 0;
00215   
00216   <span class="keywordflow">for</span> (i=0;str[i];i++){
00217     
00218     <span class="keywordflow">if</span> ((str[i]&lt;<span class="charliteral">'0'</span>) || (str[i]&gt;<span class="charliteral">'9'</span>))
00219       <span class="keywordflow">return</span> -1; <span class="comment">/* error */</span>
00220     <span class="keywordflow">else</span> {
00221       out *= 10;
00222       out += (int)(str[i] - <span class="charliteral">'0'</span>);
00223     }
00224   }
00225   
00226   <span class="keywordflow">if</span> (i==0) <span class="keywordflow">return</span> -1;
00227   
00228   <span class="keywordflow">return</span> out;
00229   
00230 }
00231 
00232 
<a name="l00242"></a><a class="code" href="cmd__tools_8h.html#a11">00242</a> <span class="keywordtype">int</span> <a class="code" href="cmd__tools_8h.html#a11">atomode</a>(<span class="keywordtype">char</span> * str){
00243 
00244   <span class="keywordtype">int</span> i;
00245   <span class="keywordtype">int</span> out = 0;
00246   
00247   <span class="keywordflow">for</span> (i=0;str[i];i++){
00248     
00249     <span class="keywordflow">if</span> ((str[i]&lt;<span class="charliteral">'0'</span>) || (str[i]&gt;<span class="charliteral">'7'</span>))
00250       <span class="keywordflow">return</span> -1; <span class="comment">/* error */</span>
00251     <span class="keywordflow">else</span> {
00252       out *= 8;
00253       out += (int)(str[i] - <span class="charliteral">'0'</span>);
00254     }
00255   }
00256   
00257   <span class="keywordflow">if</span> (i&lt;3) <span class="keywordflow">return</span> -1;
00258   
00259   <span class="keywordflow">return</span> out;
00260 
00261 
00262 }
00263 
00264 
<a name="l00265"></a><a class="code" href="cmd__tools_8h.html#a12">00265</a> <span class="keywordtype">int</span> <a class="code" href="cmd__tools_8h.html#a12">ato64</a>(<span class="keywordtype">char</span> * str, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> * out64){
00266     
00267   <span class="keywordtype">int</span> i;
00268   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> out = 0;
00269   
00270   <span class="keywordflow">if</span> (!out64) <span class="keywordflow">return</span> -1;
00271   
00272   <span class="keywordflow">for</span> (i=0;str[i];i++){
00273     
00274     <span class="keywordflow">if</span> ((str[i]&lt;<span class="charliteral">'0'</span>) || (str[i]&gt;<span class="charliteral">'9'</span>))
00275       <span class="keywordflow">return</span> -1; <span class="comment">/* error */</span>
00276     <span class="keywordflow">else</span> {
00277       out *= 10;
00278       out += (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)(str[i] - <span class="charliteral">'0'</span>);
00279     }
00280   }
00281   
00282   <span class="keywordflow">if</span> (i==0) <span class="keywordflow">return</span> -1;
00283   
00284   *out64 = out;
00285       
00286   <span class="keywordflow">return</span> 0;  
00287 }
00288 
00289 
<a name="l00293"></a><a class="code" href="cmd__tools_8h.html#a13">00293</a> time_t <a class="code" href="cmd__tools_8h.html#a13">atotime</a>(<span class="keywordtype">char</span> * str){
00294   
00295   <span class="keyword">struct </span>tm time_struct;
00296   
00297   <span class="keywordtype">char</span> tmp_str[16];
00298   <span class="keywordtype">int</span> i,j,rc;
00299   
00300   <span class="comment">/* init tm */</span>
00301   
00302   memset ( &amp;time_struct, 0 , <span class="keyword">sizeof</span>( <span class="keyword">struct</span> tm ) );
00303   
00304   
00305   <span class="comment">/* parsing year */</span>
00306   
00307   j=0;
00308   <span class="keywordflow">for</span> ( i=0; i&lt;4; i++ )
00309   {
00310     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00311     tmp_str[j] = str[i];
00312     j++;    
00313   }
00314   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00315   
00316   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00317   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00318   
00319   time_struct.tm_year = rc - 1900 ;
00320   
00321 <span class="comment">/*  printf("Year: %d\n",rc);*/</span>
00322   
00323   
00324   <span class="comment">/* parsing month */</span>
00325   
00326   j=0;  
00327   <span class="keywordflow">for</span> ( i=4; i&lt;6; i++ )
00328   {
00329     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00330     tmp_str[j] = str[i];
00331     j++;
00332   }
00333   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00334   
00335   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00336   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00337   
00338   time_struct.tm_mon = rc - 1 ;
00339 
00340 <span class="comment">/*  printf("Month: %d\n",rc);*/</span>
00341     
00342   
00343   <span class="comment">/* parsing day of month */</span>
00344   
00345   j=0;  
00346   <span class="keywordflow">for</span> ( i=6; i&lt;8; i++ )
00347   {
00348     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00349     tmp_str[j] = str[i];
00350     j++;
00351   }
00352   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00353   
00354   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00355   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00356   
00357   time_struct.tm_mday = rc ;  
00358   
00359 <span class="comment">/*  printf("Day: %d\n",rc);*/</span>
00360 
00361   <span class="comment">/* parsing hour */</span>
00362   
00363   j=0;  
00364   <span class="keywordflow">for</span> ( i=8; i&lt;10; i++ )
00365   {
00366     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00367     tmp_str[j] = str[i];
00368     j++;
00369   }
00370   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00371   
00372   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00373   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00374   
00375   time_struct.tm_hour = rc ;  
00376 
00377 <span class="comment">/*  printf("Hour: %d\n",rc);*/</span>
00378 
00379   <span class="comment">/* parsing minute */</span>
00380   
00381   j=0;  
00382   <span class="keywordflow">for</span> ( i=10; i&lt;12; i++ )
00383   {
00384     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00385     tmp_str[j] = str[i];
00386     j++;
00387   }
00388   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00389   
00390   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00391   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00392   
00393   time_struct.tm_min = rc ;  
00394 
00395 <span class="comment">/*  printf("Min: %d\n",rc);*/</span>
00396   
00397   <span class="comment">/* parsing seconds */</span>
00398   
00399   j=0;  
00400   <span class="keywordflow">for</span> ( i=12; i&lt;14; i++ )
00401   {
00402     <span class="keywordflow">if</span> ( !str[i] ) <span class="keywordflow">return</span> (time_t)-1;    
00403     tmp_str[j] = str[i];
00404     j++;
00405   }
00406   tmp_str[j]=<span class="charliteral">'\0'</span>;j++;
00407   
00408   rc = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( tmp_str );  
00409   <span class="keywordflow">if</span> (rc == -1) <span class="keywordflow">return</span> (time_t)-1;
00410   
00411   time_struct.tm_sec = rc ;  
00412   
00413 <span class="comment">/*  printf("Sec: %d\n",rc);*/</span>
00414   
00415   <span class="comment">/* too many char */</span>
00416   <span class="keywordflow">if</span> (str[i]) <span class="keywordflow">return</span> (time_t)-1;
00417   
00418   <span class="comment">/* actively determines whether it is daylight time or not. */</span>
00419   time_struct.tm_isdst = -1;
00420   
00421   
00422   <span class="keywordflow">return</span> mktime( &amp;time_struct );
00423   
00424       
00425 }
00426 
00427 
00428 
00429 
00430 
00440 <span class="keyword">static</span> <span class="keywordtype">char</span> STR_ROOT_PATH[] = <span class="stringliteral">"/"</span>;
00441 <span class="keyword">static</span> <span class="keywordtype">char</span> CURR_PATH[] = <span class="stringliteral">"."</span>;
00442  
<a name="l00443"></a><a class="code" href="cmd__tools_8h.html#a15">00443</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a15">split_path</a>(<span class="keywordtype">char</span> * in_path, <span class="keywordtype">char</span> ** p_path, <span class="keywordtype">char</span> ** p_file){
00444   
00445   size_t len, index;
00446   
00447   <span class="comment">/* sanity check */</span>
00448   <span class="keywordflow">if</span> (!in_path || !p_path || !p_file) <span class="keywordflow">return</span>;
00449   
00450   len = strlen(in_path);
00451   
00452   <span class="comment">/* If the length is not 1 and the last char is '/' we remove it. */</span>
00453   
00454   <span class="keywordflow">while</span> ( (len&gt;1) &amp;&amp; ( in_path[len-1]==<span class="charliteral">'/'</span> ) ){
00455     in_path[len-1]=<span class="charliteral">'\0'</span> ;
00456     len --;
00457   }
00458   
00459   <span class="comment">/* Now, we look for the last '/', if any. */</span>
00460   
00461   index = len-1;
00462   <span class="keywordflow">while</span> ( (index &gt; 0) &amp;&amp; ( in_path[index] != <span class="charliteral">'/'</span> ) ){
00463     index --;
00464   }
00465   
00466   <span class="comment">/* possible cases :</span>
00467 <span class="comment">   * /toto</span>
00468 <span class="comment">   * xxx/toto</span>
00469 <span class="comment">   * toto</span>
00470 <span class="comment">   */</span>
00471   
00472   <span class="keywordflow">if</span> ((index == 0) &amp;&amp; (in_path[index] == <span class="charliteral">'/'</span>)){
00473       
00474     <span class="comment">/* '/' is the first char */</span>
00475     *p_path = STR_ROOT_PATH ;
00476     *p_file = in_path+index+1 ;
00477     <span class="keywordflow">return</span>;
00478       
00479   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( in_path[index] == <span class="charliteral">'/'</span> ) {
00480     
00481     in_path[index] = <span class="charliteral">'\0'</span>;
00482     *p_path = in_path ;
00483     *p_file = in_path+index+1 ;
00484     <span class="keywordflow">return</span>;    
00485       
00486   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( index == 0 ) {
00487     
00488     <span class="comment">/* no '/' found */</span>
00489     *p_path = CURR_PATH ;
00490     *p_file = in_path ;
00491     <span class="keywordflow">return</span>;
00492     
00493   }  
00494   
00495 }
00496 
00497 
00498 
00499 
00500 <span class="comment">/* Time formatting routine */</span>
<a name="l00501"></a><a class="code" href="cmd__tools_8h.html#a14">00501</a> <span class="keywordtype">char</span> * <a class="code" href="cmd__tools_8h.html#a14">time2str</a>(time_t time_in,<span class="keywordtype">char</span> * str_out){
00502   
00503 <span class="preprocessor">#define TIME_STRLEN 30</span>
00504 <span class="preprocessor"></span>    
00505     <span class="keyword">struct </span>tm paramtm;
00506     time_t now;       <span class="comment">/* Now  */</span>
00507     time_t jan_1;     <span class="comment">/* 01/01 of the current year */</span>
00508     
00509     <span class="comment">/*inits 'jan_1' for date printing*/</span>
00510     time(&amp;now);
00511     <a class="code" href="cmd__tools_8h.html#a9">Localtime_r</a>(&amp;now, &amp;paramtm);
00512     paramtm.tm_mon = 0;
00513     paramtm.tm_mday = 1;
00514     paramtm.tm_hour = 1;
00515     paramtm.tm_min = 0;
00516     paramtm.tm_sec = 1;
00517     jan_1 = mktime( &amp;paramtm );
00518 
00519     <span class="keywordflow">if</span> (time_in&lt;jan_1){ <span class="comment">/* if dates back to last year : MM dd YYYY */</span>
00520         strftime(str_out,<a class="code" href="cmd__tools_8c.html#a0">TIME_STRLEN</a>,<span class="stringliteral">"%b %e %Y "</span>,<a class="code" href="cmd__tools_8h.html#a9">Localtime_r</a>(&amp;time_in,&amp;paramtm));
00521     } <span class="keywordflow">else</span> { <span class="comment">/* MM dd hh:mm */</span>
00522         strftime(str_out,<a class="code" href="cmd__tools_8c.html#a0">TIME_STRLEN</a>,<span class="stringliteral">"%b %e %R"</span>,<a class="code" href="cmd__tools_8h.html#a9">Localtime_r</a>(&amp;time_in,&amp;paramtm));
00523     }
00524     <span class="keywordflow">return</span> str_out;
00525         
00526 }
00527 
00528 
00529 
<a name="l00540"></a><a class="code" href="cmd__tools_8h.html#a16">00540</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a16">clean_path</a>(<span class="keywordtype">char</span> * str,<span class="keywordtype">int</span> len){
00541     
00542     <span class="keywordtype">int</span> indexsrc=0;
00543     <span class="keywordtype">int</span> indexdest=0;
00544     
00545     <span class="keywordtype">int</span> length;
00546     
00547     <span class="keywordtype">char</span> * sdd_index; <span class="comment">/* "slash dot dot" index*/</span>
00548     <span class="keywordtype">char</span> * slash_index;<span class="comment">/* previous slash index*/</span>
00549     
00550     <span class="comment">/* removes double slashes */</span>
00551     <span class="comment">/**************************/</span>
00552     <span class="keywordflow">while</span> (str[indexsrc] &amp;&amp; (indexsrc+1&lt;len)){
00553         <span class="keywordflow">while</span> ((indexsrc+1&lt;len) &amp;&amp; (str[indexsrc]==<span class="charliteral">'/'</span>) &amp;&amp; (str[indexsrc+1]==<span class="charliteral">'/'</span>)) indexsrc++;
00554         str[indexdest++]=str[indexsrc++];
00555     }
00556     <span class="keywordflow">if</span> (!str[indexsrc])str[indexdest]=str[indexsrc];
00557 
00558     
00559     <span class="comment">/* removes '/./' and '/.\0' */</span>
00560     <span class="comment">/****************************/</span>
00561     
00562     <span class="comment">/* if the path ends with /., we add a slash at the end,</span>
00563 <span class="comment">       so '/./' will be detected in the next loop. */</span>
00564 <span class="preprocessor">#ifdef _TOTO</span>
00565 <span class="preprocessor"></span>    length = strlen(str);
00566     <span class="keywordflow">if</span> (length&gt;=2) {
00567         <span class="keywordflow">if</span> ((str[length-1]==<span class="charliteral">'.'</span>) &amp;&amp; (str[length-2]==<span class="charliteral">'/'</span>)){
00568             str[length]=<span class="charliteral">'/'</span>;
00569             str[length+1]=<span class="charliteral">'\0'</span>;
00570         }
00571     }
00572 <span class="preprocessor">#endif</span>
00573 <span class="preprocessor"></span>    
00574     <span class="comment">/* detects and removes '/./' */</span>
00575     
00576     sdd_index=(<span class="keywordtype">char</span> *)strstr(str,<span class="stringliteral">"/./"</span>);
00577     <span class="keywordflow">while</span> (sdd_index){
00578         
00579          <span class="comment">/* we copy everything after "/./" to sdd_index */</span>
00580             indexsrc=3;  <span class="comment">/* index in sdd_index */</span>
00581             indexdest=1; <span class="comment">/* index in sdd_index */</span>
00582             <span class="keywordflow">while</span> (sdd_index[indexdest]=sdd_index[indexsrc]){
00583                 indexdest++;
00584                 indexsrc++;    
00585             }
00586                     
00587         <span class="comment">/* inits the next loop */</span>
00588         sdd_index=(<span class="keywordtype">char</span>*)strstr(str,<span class="stringliteral">"/./"</span>);
00589     }
00590         
00591     <span class="comment">/* removes '/../' and '/..\0' */</span>
00592     <span class="comment">/******************************/</span>
00593     
00594     <span class="comment">/* if the path ends with /.., we add a slash at the end,</span>
00595 <span class="comment">       so '/../' will be detected in the next loop. */</span>
00596     length = strlen(str);
00597     <span class="keywordflow">if</span> (length&gt;=3) {
00598         <span class="keywordflow">if</span> ((str[length-1]==<span class="charliteral">'.'</span>) &amp;&amp; (str[length-2]==<span class="charliteral">'.'</span>) &amp;&amp; (str[length-3]==<span class="charliteral">'/'</span>)){
00599             str[length]=<span class="charliteral">'/'</span>;
00600             str[length+1]=<span class="charliteral">'\0'</span>;
00601         }
00602     }
00603     
00604     <span class="comment">/* detects and removes '/../' */</span>
00605 
00606     sdd_index=(<span class="keywordtype">char</span> *)strstr(str,<span class="stringliteral">"/../"</span>);
00607     
00608     <span class="keywordflow">while</span> (sdd_index){
00609         
00610         <span class="comment">/* look for the first '/' that preceeds sdd_index */</span>
00611         <span class="keywordflow">for</span> (slash_index=sdd_index-1;(slash_index&gt;=str) &amp;&amp; (slash_index[0]!=<span class="charliteral">'/'</span>);slash_index--);
00612         
00613         <span class="comment">/* if found, removes rep/../ path */</span>
00614         
00615         <span class="keywordflow">if</span> ((slash_index[0]==<span class="charliteral">'/'</span>) &amp;&amp; (slash_index&gt;=str)){
00616             
00617             <span class="comment">/* we copy everything after "/../" to slash_index */</span>
00618             indexsrc=4;   <span class="comment">/* index in sdd_index */</span>
00619             indexdest=1; <span class="comment">/* index in slash_index */</span>
00620             <span class="keywordflow">while</span> (slash_index[indexdest]=sdd_index[indexsrc]){
00621                 indexdest++;
00622                 indexsrc++;    
00623             }
00624             
00625         } <span class="keywordflow">else</span> {
00626           
00627           <span class="comment">/* if not found, it is '..' on the root directory. */</span>
00628 
00629           <span class="comment">/* If the path begins with a filehandle,</span>
00630 <span class="comment">             we replace @handle/../ by @handle/..&gt; */</span>
00631 
00632           <span class="keywordflow">if</span> ( str[0] == <span class="charliteral">'@'</span> )
00633           {
00634             
00635             sdd_index[3]= <span class="charliteral">'&gt;'</span> ;
00636 
00637           }        
00638           <span class="keywordflow">else</span>
00639           {        
00640               <span class="comment">/* Else , we remove '/..' */</span>
00641 
00642               indexsrc=3;   <span class="comment">/* index in str */</span>
00643               indexdest=0; <span class="comment">/* index in str */</span>
00644               <span class="keywordflow">while</span> (str[indexdest]=str[indexsrc]){
00645                   indexdest++;
00646                   indexsrc++;    
00647               }
00648 
00649           } <span class="comment">/* end @ */</span>
00650           
00651         }
00652         <span class="comment">/* inits the next loop */</span>
00653         sdd_index=(<span class="keywordtype">char</span> *)strstr(str,<span class="stringliteral">"/../"</span>);
00654     }
00655     
00656         
00657     <span class="comment">/* removes final slash */</span>
00658     <span class="comment">/***********************/</span>
00659     length = strlen(str);
00660     <span class="keywordflow">if</span> (length&gt;1){
00661         <span class="keywordflow">if</span> (str[length-1]==<span class="charliteral">'/'</span>) str[length-1]=<span class="charliteral">'\0'</span>;
00662     }            
00663 
00664 }
00665 
00666 
00667 
<a name="l00677"></a><a class="code" href="cmd__tools_8h.html#a18">00677</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a18">print_fsal_status</a>(FILE * output,fsal_status_t status){
00678 
00679     <span class="keywordtype">char</span> _str_[256];
00680     
00681 <span class="preprocessor">#ifdef _USE_GHOSTFS</span>
00682 <span class="preprocessor"></span>    
00683     log_snprintf( _str_, 256, <span class="stringliteral">"%J%r,%J%r"</span>,
00684                   ERR_FSAL,status.major,
00685                   ERR_GHOSTFS, status.minor );
00686     
00687 <span class="preprocessor">#else</span>
00688 <span class="preprocessor"></span>    
00689     log_snprintf( _str_, 256, <span class="stringliteral">"%J%r, FSAL FLAVOUR SPECIFIC ERROR:%d"</span>,
00690                   ERR_FSAL,status.major,
00691                    status.minor );        
00692     
00693 <span class="preprocessor">#endif</span>
00694 <span class="preprocessor"></span>
00695     fprintf(output,<span class="stringliteral">"%s"</span>,_str_);
00696 }
00697 
00698 
<a name="l00707"></a><a class="code" href="cmd__tools_8h.html#a19">00707</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a19">print_fsal_attrib_mask</a>(fsal_attrib_mask_t mask,FILE * output){
00708 
00709   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_SUPPATTR))
00710     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_SUPPATTR\n"</span>);
00711   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_TYPE))
00712     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_TYPE\n"</span>);
00713   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_SIZE))
00714     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_SIZE\n"</span>);
00715   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_FSID))
00716     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_FSID\n"</span>);
00717   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_ACL ))
00718     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_ACL \n"</span>);
00719   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_FILEID))
00720     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_FILEID\n"</span>);
00721   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_MODE))
00722     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_MODE\n"</span>);
00723   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_NUMLINKS))
00724     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_NUMLINKS\n"</span>);
00725   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_OWNER ))
00726     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_OWNER\n"</span>);
00727   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_GROUP ))
00728     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_GROUP\n"</span>);
00729   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_RAWDEV))
00730     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_RAWDEV\n"</span>);
00731   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_ATIME ))
00732     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_ATIME\n"</span>);
00733   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_CREATION))
00734     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_CREATION\n"</span>);
00735   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_CTIME ))
00736     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_CTIME\n"</span>);
00737   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_MTIME ))
00738     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_MTIME\n"</span>);
00739   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_SPACEUSED ))
00740     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_SPACEUSED\n"</span>);
00741   <span class="keywordflow">if</span> (FSAL_TEST_MASK( mask , FSAL_ATTR_MOUNTFILEID ))
00742     fprintf(output,<span class="stringliteral">"\tFSAL_ATTR_MOUNTFILEID\n"</span>);
00743       
00744 }
00745 
00746 
<a name="l00754"></a><a class="code" href="cmd__tools_8h.html#a20">00754</a> <span class="keywordtype">char</span> * <a class="code" href="cmd__tools_8h.html#a20">strtype</a>(fsal_nodetype_t type){
00755   <span class="keywordflow">switch</span>(type){
00756   <span class="keywordflow">case</span> FSAL_TYPE_FIFO :
00757     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_FIFO "</span>;
00758   <span class="keywordflow">case</span> FSAL_TYPE_CHR  :
00759     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_CHR  "</span>;
00760   <span class="keywordflow">case</span> FSAL_TYPE_DIR  :
00761     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_DIR  "</span>;
00762   <span class="keywordflow">case</span> FSAL_TYPE_BLK  :
00763     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_BLK  "</span>;
00764   <span class="keywordflow">case</span> FSAL_TYPE_FILE :
00765     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_FILE "</span>;
00766   <span class="keywordflow">case</span> FSAL_TYPE_LNK  :
00767     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_LNK  "</span>;
00768   <span class="keywordflow">case</span> FSAL_TYPE_JUNCTION  :
00769     <span class="keywordflow">return</span> <span class="stringliteral">"FSAL_TYPE_JUNCTION  "</span>;
00770   <span class="keywordflow">default</span>:
00771     <span class="keywordflow">return</span> <span class="stringliteral">"Unknown type   "</span>;
00772   }
00773 }
00774 
00775 
<a name="l00784"></a><a class="code" href="cmd__tools_8h.html#a21">00784</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a21">print_fsal_attributes</a>( fsal_attrib_list_t attrs,FILE * output){
00785   
00786   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_TYPE))
00787     fprintf(output,<span class="stringliteral">"\tType : %s\n"</span>,<a class="code" href="cmd__tools_8h.html#a20">strtype</a>(attrs.type));
00788   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_SIZE))
00789     fprintf(output,<span class="stringliteral">"\tSize : %llu\n"</span>,attrs.filesize);
00790   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_FSID))
00791     fprintf(output,<span class="stringliteral">"\tfsId : %llu.%llu\n"</span>,attrs.fsid.major,attrs.fsid.minor);
00792   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_ACL ))
00793     fprintf(output,<span class="stringliteral">"\tACL List : (printing not implemented)\n"</span>);
00794   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_FILEID))
00795     fprintf(output,<span class="stringliteral">"\tFileId : %#llx\n"</span>,attrs.fileid);
00796   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_MODE))
00797     fprintf(output,<span class="stringliteral">"\tMode : %#o\n"</span>,attrs.mode);
00798   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_NUMLINKS))
00799     fprintf(output,<span class="stringliteral">"\tNumlinks : %u\n"</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)attrs.numlinks);
00800   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_OWNER ))
00801     fprintf(output,<span class="stringliteral">"\tuid : %d\n"</span>,attrs.owner);
00802   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_GROUP ))
00803     fprintf(output,<span class="stringliteral">"\tgid : %d\n"</span>,attrs.group);
00804   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_RAWDEV))
00805     fprintf(output,<span class="stringliteral">"\tRawdev ...\n"</span>);
00806   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_ATIME ))
00807     fprintf(output,<span class="stringliteral">"\tatime : %s"</span>,ctime((time_t*)&amp;attrs.atime.seconds));
00808   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_CREATION))
00809     fprintf(output,<span class="stringliteral">"\tcreation time : %s"</span>,ctime((time_t*)&amp;attrs.creation.seconds));
00810   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_CTIME ))
00811     fprintf(output,<span class="stringliteral">"\tctime : %s"</span>,ctime((time_t*)&amp;attrs.ctime.seconds));
00812   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_MTIME ))
00813     fprintf(output,<span class="stringliteral">"\tmtime : %s"</span>,ctime((time_t*)&amp;attrs.mtime.seconds));
00814   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_SPACEUSED ))
00815     fprintf(output,<span class="stringliteral">"\tspaceused : %llu\n"</span>,attrs.spaceused);
00816   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrs.asked_attributes, FSAL_ATTR_MOUNTFILEID ))
00817     fprintf(output,<span class="stringliteral">"\tmounted_on_fileid : %#llx\n"</span>,attrs.mounted_on_fileid);
00818 
00819     
00820 }
00821 
00822 
00823 
<a name="l00836"></a><a class="code" href="cmd__tools_8c.html#a1">00836</a> <span class="preprocessor">#define print_mask(_out,_mode,_mask,_lettre) do {    \</span>
00837 <span class="preprocessor">        if (_mode &amp; _mask) fprintf(_out,_lettre);\</span>
00838 <span class="preprocessor">        else fprintf(_out,"-");                  \</span>
00839 <span class="preprocessor">      } while(0)</span>
00840 <span class="preprocessor"></span>
<a name="l00841"></a><a class="code" href="cmd__tools_8h.html#a22">00841</a> <span class="keywordtype">void</span> <a class="code" href="cmd__tools_8h.html#a22">print_item_line</a>( FILE * out,fsal_attrib_list_t * attrib, <span class="keywordtype">char</span> * name , <span class="keywordtype">char</span> * target){
00842   
00843   <span class="keywordtype">char</span> buff[256];
00844   <span class="keywordtype">int</span> i;
00845   
00846   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_FILEID)){
00847     <span class="comment">/* print inode */</span>
00848     fprintf(out,<span class="stringliteral">"%10llx "</span>,attrib-&gt;fileid);
00849   }
00850     
00851   <span class="comment">/* printing type (mandatory)*/</span>
00852   <span class="keywordflow">switch</span>( attrib-&gt;type ){
00853     <span class="keywordflow">case</span> FSAL_TYPE_FIFO:fprintf(out,<span class="stringliteral">"p"</span>);<span class="keywordflow">break</span>;
00854     <span class="keywordflow">case</span> FSAL_TYPE_CHR:fprintf(out,<span class="stringliteral">"c"</span>);<span class="keywordflow">break</span>;
00855     <span class="keywordflow">case</span> FSAL_TYPE_DIR:fprintf(out,<span class="stringliteral">"d"</span>);<span class="keywordflow">break</span>;
00856     <span class="keywordflow">case</span> FSAL_TYPE_BLK:fprintf(out,<span class="stringliteral">"b"</span>);<span class="keywordflow">break</span>;
00857     <span class="keywordflow">case</span> FSAL_TYPE_FILE:fprintf(out,<span class="stringliteral">"-"</span>);<span class="keywordflow">break</span>;
00858     <span class="keywordflow">case</span> FSAL_TYPE_LNK:fprintf(out,<span class="stringliteral">"l"</span>);<span class="keywordflow">break</span>;
00859     <span class="keywordflow">case</span> FSAL_TYPE_JUNCTION:fprintf(out,<span class="stringliteral">"j"</span>);<span class="keywordflow">break</span>;
00860     <span class="keywordflow">default</span>:fprintf(out,<span class="stringliteral">"?"</span>);
00861   }    
00862   
00863   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_MODE)){
00864 
00865     <span class="comment">/* printing rights */</span>
00866     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_RUSR,<span class="stringliteral">"r"</span>);
00867     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_WUSR,<span class="stringliteral">"w"</span>);  
00868 
00869     <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_SUID ){
00870       <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_XUSR )
00871         fprintf(out,<span class="stringliteral">"s"</span>);
00872       <span class="keywordflow">else</span>
00873         fprintf(out,<span class="stringliteral">"S"</span>);
00874     } <span class="keywordflow">else</span> {
00875       <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_XUSR )
00876         fprintf(out,<span class="stringliteral">"x"</span>);
00877       <span class="keywordflow">else</span>
00878         fprintf(out,<span class="stringliteral">"-"</span>);    
00879     }
00880 
00881     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_RGRP,<span class="stringliteral">"r"</span>);
00882     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_WGRP,<span class="stringliteral">"w"</span>);  
00883 
00884     <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_SGID ){
00885       <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_XGRP )
00886         fprintf(out,<span class="stringliteral">"s"</span>);
00887       <span class="keywordflow">else</span>
00888         fprintf(out,<span class="stringliteral">"l"</span>);
00889     } <span class="keywordflow">else</span> {
00890       <span class="keywordflow">if</span> ( attrib-&gt;mode &amp; FSAL_MODE_XGRP )
00891         fprintf(out,<span class="stringliteral">"x"</span>);
00892       <span class="keywordflow">else</span>
00893         fprintf(out,<span class="stringliteral">"-"</span>);    
00894     }
00895     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_ROTH,<span class="stringliteral">"r"</span>);
00896     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_WOTH,<span class="stringliteral">"w"</span>);  
00897     <a class="code" href="cmd__nfstools_8c.html#a57">print_mask</a>(out,attrib-&gt;mode,FSAL_MODE_XOTH,<span class="stringliteral">"x"</span>);
00898   }
00899 
00900   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_NUMLINKS)){      
00901     <span class="comment">/* print linkcount */</span>
00902     fprintf(out,<span class="stringliteral">" %3u"</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)attrib-&gt;numlinks);
00903   }
00904   
00905   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_OWNER)){
00906     <span class="comment">/* print uid */</span>
00907     fprintf(out,<span class="stringliteral">" %8d"</span>,attrib-&gt;owner);
00908   }
00909 
00910   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_GROUP)){
00911     <span class="comment">/* print gid */</span>
00912     fprintf(out,<span class="stringliteral">" %8d"</span>,attrib-&gt;group);
00913   }
00914   
00915   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_SIZE)){
00916     <span class="comment">/* print size */</span>
00917     fprintf(out,<span class="stringliteral">" %15llu"</span>,attrib-&gt;filesize);
00918   }
00919 
00920   <span class="keywordflow">if</span> (FSAL_TEST_MASK(attrib-&gt;asked_attributes,FSAL_ATTR_MTIME)){  
00921     <span class="comment">/* print mtime */</span>    
00922     fprintf(out,<span class="stringliteral">" %15s"</span>,<a class="code" href="cmd__tools_8h.html#a14">time2str</a>( attrib-&gt;mtime.seconds, buff));
00923   }
00924   
00925   <span class="comment">/* print name */</span>
00926   fprintf(out,<span class="stringliteral">" %s"</span>, name);
00927 
00928   
00929   <span class="keywordflow">if</span> (attrib-&gt;type == FSAL_TYPE_LNK)
00930     fprintf(out,<span class="stringliteral">" -&gt; %s"</span>, target);
00931   
00932   fprintf(out,<span class="stringliteral">"\n"</span>);
00933   <span class="keywordflow">return</span>;
00934   
00935 }
00936 
00937 
00938 
00939 
<a name="l00946"></a><a class="code" href="cmd__tools_8h.html#a23">00946</a> <span class="keywordtype">int</span> <a class="code" href="cmd__tools_8h.html#a23">MkFSALSetAttrStruct</a>( <span class="keywordtype">char</span> * attribute_list,
00947                          fsal_attrib_list_t * fsal_set_attr_struct )
00948 {
00949   <a class="code" href="structshell__attribute____.html">shell_attribute_t</a> * current_attr;
00950   <span class="keywordtype">char</span> attrib_list_tmp[2048];
00951   
00952   <span class="keywordtype">char</span> * attrib_str;
00953   <span class="keywordtype">char</span> * value_str;
00954   <span class="keywordtype">char</span> * next_str = NULL;
00955   
00956   <span class="keywordtype">int</span> rc;
00957   
00958   <span class="keywordtype">int</span>                param_32;
00959   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> param_64;
00960   time_t             param_time;
00961   
00962   <span class="keywordtype">int</span> *                 p_32;
00963   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *  p_64;
00964   time_t *              p_time;
00965   
00966   
00967   
00968   <span class="comment">/* sanity checks */</span>
00969   
00970   <span class="keywordflow">if</span> (!attribute_list || !fsal_set_attr_struct)
00971     <span class="keywordflow">return</span> EFAULT;
00972 
00973   
00974   <span class="comment">/* init output struct */</span>
00975   
00976   memset( fsal_set_attr_struct, 0 , <span class="keyword">sizeof</span>(fsal_attrib_list_t) );
00977 
00978   <span class="comment">/* set attribute mask */</span>
00979     
00980   FSAL_CLEAR_MASK( fsal_set_attr_struct-&gt;asked_attributes );
00981   
00982     
00983   <span class="comment">/* temporary copy the attribute list */</span>
00984   strncpy( attrib_list_tmp, attribute_list, 2048 );
00985 
00986   <span class="comment">/* get the first token */</span>
00987   attrib_str = strtok_r(attrib_list_tmp,<span class="stringliteral">","</span>,&amp;next_str);
00988   
00989   <span class="keywordflow">if</span> ( attrib_str == NULL ) <span class="keywordflow">return</span> EINVAL;
00990   
00991   <span class="keywordflow">while</span> ( attrib_str != NULL )
00992   {
00993      <span class="comment">/* retrieving attribute value */</span>
00994      attrib_str = strtok_r( attrib_str,<span class="stringliteral">"="</span>,&amp;value_str );
00995       
00996      <span class="keywordflow">if</span> ( (attrib_str == NULL) || (value_str == NULL) ) <span class="keywordflow">return</span> EINVAL;
00997 
00998      printf( <span class="stringliteral">"Attribute: \"%s\", Value: \"%s\"\n"</span>,attrib_str,value_str);
00999      
01000     
01001      <span class="comment">/* look for the attribute to be set. */</span>
01002 
01003      <span class="keywordflow">for</span> ( current_attr = shell_attr_list;
01004             current_attr-&gt;<a class="code" href="structshell__attribute____.html#o1">attr_type</a> != ATTR_NONE;
01005             current_attr ++ )
01006      {
01007 
01008         <span class="keywordflow">if</span> ( !strcasecmp( current_attr-&gt;<a class="code" href="structshell__attribute____.html#o0">attr_name</a>, attrib_str) ){
01009 
01010             <span class="comment">/* exists loop */</span>
01011             <span class="keywordflow">break</span>;
01012         }
01013 
01014      }
01015 
01016      <span class="comment">/* attribute not found */</span>
01017 
01018      <span class="keywordflow">if</span> ( current_attr-&gt;<a class="code" href="structshell__attribute____.html#o1">attr_type</a> == ATTR_NONE)
01019         <span class="keywordflow">return</span> ENOENT;
01020   
01021      
01022      FSAL_SET_MASK( fsal_set_attr_struct-&gt;asked_attributes, current_attr-&gt;<a class="code" href="structshell__attribute____.html#o2">attr_mask</a> );
01023 
01024     
01025      <span class="comment">/* convert the attribute value to the correct type */</span>
01026   
01027      <span class="keywordflow">switch</span>( current_attr-&gt;<a class="code" href="structshell__attribute____.html#o1">attr_type</a> )
01028      {
01029         <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a5">ATTR_32</a>:
01030 
01031           param_32 = <a class="code" href="cmd__tools_8h.html#a10">my_atoi</a>( value_str );      
01032           <span class="keywordflow">if</span> ( param_32 == -1 ) <span class="keywordflow">return</span> EINVAL;      
01033           p_32 =(<span class="keywordtype">int</span> *) ( (caddr_t)fsal_set_attr_struct + current_attr-&gt;<a class="code" href="structshell__attribute____.html#o3">attr_offset</a> );
01034 
01035           *p_32 = param_32;
01036 
01037           <span class="keywordflow">break</span>;
01038 
01039         <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a6">ATTR_64</a>:
01040 
01041           rc = <a class="code" href="cmd__tools_8h.html#a12">ato64</a>( value_str, &amp;param_64 );      
01042           <span class="keywordflow">if</span> ( rc == -1 ) <span class="keywordflow">return</span> EINVAL;      
01043           p_64 =(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *) ( (caddr_t)fsal_set_attr_struct + current_attr-&gt;<a class="code" href="structshell__attribute____.html#o3">attr_offset</a> );
01044 
01045           *p_64 = param_64;
01046 
01047           <span class="keywordflow">break</span>;
01048 
01049         <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a7">ATTR_OCTAL</a>: <span class="comment">/* only for modes */</span>
01050 
01051           param_32 = <a class="code" href="cmd__tools_8h.html#a11">atomode</a>( value_str );
01052           <span class="keywordflow">if</span> ( param_32 == -1 ) <span class="keywordflow">return</span> EINVAL;      
01053           p_32 = (<span class="keywordtype">int</span> *)( (caddr_t)fsal_set_attr_struct + current_attr-&gt;<a class="code" href="structshell__attribute____.html#o3">attr_offset</a> );      
01054 
01055           *p_32 = unix2fsal_mode( param_32 );
01056 
01057           <span class="keywordflow">break</span>;
01058 
01059         <span class="keywordflow">case</span> <a class="code" href="cmd__tools_8h.html#a26a8">ATTR_TIME</a>:
01060 
01061           param_time = <a class="code" href="cmd__tools_8h.html#a13">atotime</a>( value_str );
01062           <span class="keywordflow">if</span> ( param_time == (time_t)-1 ) <span class="keywordflow">return</span> EINVAL;
01063           p_time = (time_t *) ( (caddr_t)fsal_set_attr_struct + current_attr-&gt;<a class="code" href="structshell__attribute____.html#o3">attr_offset</a> );
01064 
01065           *p_time = param_time;
01066 
01067           <span class="keywordflow">break</span>;
01068 
01069     }
01070    
01071     <span class="comment">/* now process the next attribute */</span>
01072     
01073     attrib_str = next_str;
01074         
01075     next_str = NULL; <span class="comment">/* paranoid setting */</span>
01076     value_str = NULL; <span class="comment">/* paranoid setting */</span>
01077         
01078     <span class="keywordflow">if</span> ( attrib_str != NULL )
01079        attrib_str = strtok_r(attrib_str,<span class="stringliteral">","</span>,&amp;next_str);
01080     
01081   }
01082     
01083   
01084   <span class="comment">/* OK */</span>
01085   <span class="keywordflow">return</span> 0;
01086   
01087   
01088 }
01089 
01090 
01091 
01092 
01093 <span class="comment">/* timer diffing function */</span>
01094 
<a name="l01095"></a><a class="code" href="cmd__tools_8h.html#a24">01095</a> <span class="keyword">struct </span>timeval <a class="code" href="cmd__tools_8c.html#a19">time_diff</a>(struct timeval time_from, struct timeval time_to)
01096 {
01097   
01098   <span class="keyword">struct </span>timeval result;
01099   
01100   <span class="keywordflow">if</span> (  time_to.tv_usec &lt; time_from.tv_usec ){
01101       result.tv_sec = time_to.tv_sec - time_from.tv_sec - 1;
01102       result.tv_usec = 1000000 + time_to.tv_usec - time_from.tv_usec;
01103   } <span class="keywordflow">else</span> {
01104       result.tv_sec =  time_to.tv_sec - time_from.tv_sec;
01105       result.tv_usec = time_to.tv_usec - time_from.tv_usec;  
01106   }
01107   
01108   <span class="keywordflow">return</span> result;
01109   
01110 }
01111 
01112 
01113 <span class="comment">/* used for concatenation in set */</span>
01114 
<a name="l01115"></a><a class="code" href="cmd__tools_8h.html#a17">01115</a> <span class="keywordtype">char</span> * <a class="code" href="cmd__tools_8h.html#a17">concat</a>( <span class="keywordtype">char</span> * str1, <span class="keywordtype">char</span> * str2, size_t max_len )
01116 {
01117   size_t len1, len2;
01118   
01119   len1 = strlen(str1);
01120   len2 = strlen(str2);
01121 
01122   <span class="keywordflow">if</span> ( len1 + len2 + 1 &gt; max_len ) <span class="keywordflow">return</span> NULL;
01123   
01124   <span class="keywordflow">return</span> strcat( str1, str2 );
01125   
01126 }
01127 
01128 <span class="comment">/* Inspired from Free Software Foundation code. */</span>
<a name="l01129"></a><a class="code" href="cmd__tools_8h.html#a25">01129</a> <span class="keywordtype">int</span> <a class="code" href="cmd__tools_8h.html#a25">getugroups</a>( <span class="keywordtype">int</span> maxcount, gid_t * grouplist, <span class="keywordtype">char</span> * username, gid_t gid )
01130 {
01131   <span class="keyword">struct </span>group * grp;
01132   <span class="keyword">register</span> <span class="keywordtype">char</span> ** cp;
01133   <span class="keyword">register</span> <span class="keywordtype">int</span> count = 0;
01134   
01135   <span class="keywordflow">if</span> ( gid != (gid_t) -1 )
01136   {
01137     <span class="keywordflow">if</span> ( maxcount != 0 )
01138       grouplist[count] = gid;    
01139     
01140     count ++;
01141   }
01142   
01143   setgrent();
01144   <span class="keywordflow">while</span>( (grp = getgrent()) != 0 )
01145   {
01146     <span class="keywordflow">for</span> ( cp = grp-&gt;gr_mem; *cp; ++cp )
01147     {
01148       <span class="keywordtype">int</span> n;
01149       
01150       <span class="keywordflow">if</span> ( strcmp( username, *cp ) )
01151         <span class="keywordflow">continue</span>;
01152       
01153       <span class="comment">/* see if this group number is already in the list */</span>
01154       <span class="keywordflow">for</span> ( n = 0; n &lt; count; ++n )
01155         <span class="keywordflow">if</span> ( grouplist &amp;&amp; grouplist[n] == grp-&gt;gr_gid )
01156           <span class="keywordflow">break</span>;
01157       
01158       <span class="comment">/* add the group to the list */</span>
01159       <span class="keywordflow">if</span> ( n == count )
01160       {
01161         <span class="keywordflow">if</span> ( maxcount != 0 )
01162         {
01163           <span class="keywordflow">if</span> ( count &gt;= maxcount )
01164           {
01165             endgrent();
01166             <span class="keywordflow">return</span> count;
01167           }
01168           grouplist[count] = grp-&gt;gr_gid;
01169           
01170         }
01171         count ++;
01172       }      
01173       
01174     }
01175   }
01176   endgrent();
01177    
01178   <span class="keywordflow">return</span> count;
01179 }
01180 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:34 2008 for ganeshell by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
