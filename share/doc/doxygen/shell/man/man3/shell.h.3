.TH "shell.h" 3 "31 Mar 2009" "Version 0.1" "ganeshell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
shell.h \- Internal routines for the shell.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include 'shell_types.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBMAX_LINE_LEN\fP   1024"
.br
.ti -1c
.RI "#define \fBMAX_ARGS\fP   256"
.br
.ti -1c
.RI "#define \fBSHELL_SUCCESS\fP   0"
.br
.ti -1c
.RI "#define \fBSHELL_ERROR\fP   -1"
.br
.ti -1c
.RI "#define \fBSHELL_NOT_FOUND\fP   -2"
.br
.ti -1c
.RI "#define \fBSHELL_SYNTAX_ERROR\fP   -22"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBshell_Init\fP (int \fBverbose\fP, char *input_file, char *prompt, int shell_index)"
.br
.ti -1c
.RI "int \fBshell_Launch\fP ()"
.br
.ti -1c
.RI "int \fBshell_BarrierInit\fP (int nb_threads)"
.br
.ti -1c
.RI "int \fBshell_ParseLine\fP (char *in_out_line, char **out_arglist, int *p_argcount)"
.br
.ti -1c
.RI "void \fBshell_CleanArgs\fP (int argc, char **in_out_argv, int *in_allocated)"
.br
.ti -1c
.RI "int \fBshell_SolveArgs\fP (int argc, char **in_out_argv, int *out_allocated)"
.br
.ti -1c
.RI "int \fBshell_Execute\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "void \fBshell_PrintError\fP (\fBshell_state_t\fP *context, char *error_msg)"
.br
.ti -1c
.RI "void \fBshell_PrintTrace\fP (\fBshell_state_t\fP *context, char *msg)"
.br
.ti -1c
.RI "int \fBshell_SetLayer\fP (\fBshell_state_t\fP *context, char *layer_name)"
.br
.ti -1c
.RI "\fBlayer_def_t\fP * \fBshell_GetLayer\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshell_SetStatus\fP (\fBshell_state_t\fP *context, int returned_status)"
.br
.ti -1c
.RI "int \fBshell_GetStatus\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshell_SetVerbose\fP (\fBshell_state_t\fP *context, char *str_verbose)"
.br
.ti -1c
.RI "int \fBshell_GetVerbose\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshell_SetDbgLvl\fP (\fBshell_state_t\fP *context, char *str_debug_level)"
.br
.ti -1c
.RI "int \fBshell_GetDbgLvl\fP ()"
.br
.ti -1c
.RI "FILE * \fBshell_GetInputStream\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshell_SetInput\fP (\fBshell_state_t\fP *context, char *file_name)"
.br
.ti -1c
.RI "int \fBshell_SetPrompt\fP (\fBshell_state_t\fP *context, char *str_prompt)"
.br
.ti -1c
.RI "char * \fBshell_GetPrompt\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshell_SetShellId\fP (\fBshell_state_t\fP *context, int shell_index)"
.br
.ti -1c
.RI "int \fBshell_SetLine\fP (\fBshell_state_t\fP *context, int lineno)"
.br
.ti -1c
.RI "int \fBshell_GetLine\fP (\fBshell_state_t\fP *context)"
.br
.ti -1c
.RI "int \fBshellcmd_help\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_if\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_interactive\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_set\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_unset\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_print\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_varlist\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_time\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_quit\fP (int argc, char **argv, FILE *output)"
.br
.ti -1c
.RI "int \fBshellcmd_barrier\fP (int argc, char **argv, FILE *output)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "char * \fBshell_special_vars\fP []"
.br
.in -1c
.SH "Detailed Description"
.PP 
Internal routines for the shell. 

\fBAuthor:\fP
.RS 4
.RE
.PP
\fBAuthor\fP.RS 4
leibovic 
.RE
.PP
\fBDate:\fP
.RS 4
.RE
.PP
\fBDate\fP.RS 4
2006/02/23 07:42:53 
.RE
.PP
\fBVersion:\fP
.RS 4
.RE
.PP
\fBRevision\fP.RS 4
1.7 
.RE
.PP
\fBLog\fP.RS 4
\fBshell.h\fP,v 
.RE
.PP
Revision 1.7 2006/02/23 07:42:53 leibovic Adding -n option to shell.
.PP
Revision 1.6 2005/07/26 12:54:47 leibovic Multi-thread shell with synchronisation routines.
.PP
Revision 1.5 2005/07/25 12:50:46 leibovic Adding thr_create and thr_join commands.
.PP
Revision 1.4 2005/05/27 12:01:48 leibovic Adding write command.
.PP
Revision 1.3 2005/05/11 15:53:37 leibovic Adding time function.
.PP
Revision 1.2 2005/05/09 14:54:59 leibovic Adding if.
.PP
Revision 1.1 2005/05/09 12:23:55 leibovic Version 2 of ganeshell. 
.PP
Definition in file \fBshell.h\fP.
.SH "Define Documentation"
.PP 
.SS "#define MAX_ARGS   256"
.PP
Definition at line 42 of file shell.h.
.SS "#define MAX_LINE_LEN   1024"
.PP
Definition at line 41 of file shell.h.
.SS "#define SHELL_ERROR   -1"
.PP
Definition at line 50 of file shell.h.
.SS "#define SHELL_NOT_FOUND   -2"
.PP
Definition at line 51 of file shell.h.
.SS "#define SHELL_SUCCESS   0"
.PP
Definition at line 49 of file shell.h.
.SS "#define SHELL_SYNTAX_ERROR   -22"
.PP
Definition at line 52 of file shell.h.
.SH "Function Documentation"
.PP 
.SS "int shell_BarrierInit (int nb_threads)"
.PP
Initialize the barrier for shell synchronization routines. The number of threads to wait for is given as parameter. 
.PP
Definition at line 259 of file shell.c.
.SS "void shell_CleanArgs (int argc, char ** in_out_argv, int * in_allocated)"
.PP
shell_CleanArgs: Free allocated arguments.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP The number of command line tokens. 
.br
\fIin_out_argv\fP The list of command line tokens (modified). 
.br
\fIin_allocated\fP Indicates which tokens must be freed.
.RE
.PP
\fBReturns:\fP
.RS 4
0 if no errors.
.RE
.PP
shell_CleanArgs: Free allocated arguments.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP The number of command line tokens. 
.br
\fIin_out_argv\fP The list of command line tokens (modified). 
.br
\fIin_allocated\fP Indicates which tokens must be freed. 
.RE
.PP

.PP
Definition at line 1152 of file shell.c.
.SS "int shell_Execute (int argc, char ** argv, FILE * output)"
.PP
shell_Execute: Execute a command.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP The number of arguments of this command. 
.br
\fIargv\fP The arguments for this command. 
.br
\fIoutput\fP The output stream of this command.
.RE
.PP
\fBReturns:\fP
.RS 4
The returned status of this command.
.RE
.PP
shell_Execute: Commands dispatcher.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP The number of arguments of this command. 
.br
\fIargv\fP The arguments for this command. 
.br
\fIoutput\fP The output stream of this command.
.RE
.PP
\fBReturns:\fP
.RS 4
The returned status of this command. 
.RE
.PP

.PP
Definition at line 1185 of file shell.c.
.SS "int shell_GetDbgLvl ()"
.PP
shell_GetDbgLvl Get the special variable $DEBUG_LEVEL and $DBG_LVL (internal use). 
.SS "FILE* shell_GetInputStream (\fBshell_state_t\fP * context)"
.PP
shell_GetInputStream Get the input stream for reading commands (internal use). 
.PP
Definition at line 1750 of file shell.c.
.SS "\fBlayer_def_t\fP* shell_GetLayer (\fBshell_state_t\fP * context)"
.PP
shell_GetLayer: Retrieves the current active layer (internal use). 
.PP
Definition at line 1428 of file shell.c.
.SS "int shell_GetLine (\fBshell_state_t\fP * context)"
.PP
shell_GetLine Get the special variable $LINE 
.PP
Definition at line 1852 of file shell.c.
.SS "char* shell_GetPrompt (\fBshell_state_t\fP * context)"
.PP
shell_GetPrompt Get the special variable $PROMPT 
.PP
Definition at line 1786 of file shell.c.
.SS "int shell_GetStatus (\fBshell_state_t\fP * context)"
.PP
shell_GetStatus Get the special variables $? or $STATUS (internal use). 
.PP
Definition at line 1478 of file shell.c.
.SS "int shell_GetVerbose (\fBshell_state_t\fP * context)"
.PP
shell_GetVerbose Get the special variable $VERBOSE (internal use). 
.PP
Definition at line 1552 of file shell.c.
.SS "int shell_Init (int verbose, char * input_file, char * prompt, int shell_index)"
.PP
Initialize the shell. The command line for the shell is given as parameter. 
.PP
\fBParameters:\fP
.RS 4
\fIinput_file\fP the file to read from (NULL if stdin). 
.RE
.PP

.PP
Definition at line 407 of file shell.c.
.SS "int shell_Launch ()"
.PP
Launch the interpreter.
.PP
Run the interpreter. 
.PP
Definition at line 535 of file shell.c.
.SS "int shell_ParseLine (char * in_out_line, char ** out_arglist, int * p_argcount)"
.PP
shell_ParseLine: Extract an arglist from a command line.
.PP
\fBParameters:\fP
.RS 4
\fIin_out_line\fP The command line (modified). 
.br
\fIout_arglist\fP The list of command line tokens. 
.br
\fIp_argcount\fP The number of command line tokens.
.RE
.PP
\fBReturns:\fP
.RS 4
0 if no errors. 
.RE
.PP

.PP
Definition at line 757 of file shell.c.
.SS "void shell_PrintError (\fBshell_state_t\fP * context, char * error_msg)"
.PP
shell_PrintError: Prints an error. 
.PP
Definition at line 1319 of file shell.c.
.SS "void shell_PrintTrace (\fBshell_state_t\fP * context, char * msg)"
.PP
shell_PrintTrace: Prints a verbose trace. 
.PP
Definition at line 1337 of file shell.c.
.SS "int shell_SetDbgLvl (\fBshell_state_t\fP * context, char * str_debug_level)"
.PP
shell_SetDbgLvl Set the special variables $DEBUG_LEVEL and $DBG_LVL 
.PP
Definition at line 1562 of file shell.c.
.SS "int shell_SetInput (\fBshell_state_t\fP * context, char * file_name)"
.PP
shell_SetInput Set the input for reading commands and set the value of $INPUT and $INTERACTIVE.
.PP
\fBParameters:\fP
.RS 4
\fIfile_name,:\fP a script file or NULL for reading from stdin. 
.RE
.PP

.PP
Definition at line 1635 of file shell.c.
.SS "int shell_SetLayer (\fBshell_state_t\fP * context, char * layer_name)"
.PP
shell_SetLayer: Set the current active layer. 
.PP
\fBReturns:\fP
.RS 4
0 if OK. else, an error code. 
.RE
.PP

.PP
Definition at line 1368 of file shell.c.
.SS "int shell_SetLine (\fBshell_state_t\fP * context, int lineno)"
.PP
shell_SetLine Set the special variable $LINE 
.PP
Definition at line 1823 of file shell.c.
.SS "int shell_SetPrompt (\fBshell_state_t\fP * context, char * str_prompt)"
.PP
shell_SetPrompt Set the special variable $PROMPT 
.PP
Definition at line 1765 of file shell.c.
.SS "int shell_SetShellId (\fBshell_state_t\fP * context, int shell_index)"
.PP
shell_SetShellId Set the special variable $SHELLID 
.PP
Definition at line 1797 of file shell.c.
.SS "int shell_SetStatus (\fBshell_state_t\fP * context, int returned_status)"
.PP
shell_SetStatus Set the special variables $? and $STATUS. 
.PP
Definition at line 1440 of file shell.c.
.SS "int shell_SetVerbose (\fBshell_state_t\fP * context, char * str_verbose)"
.PP
shell_SetVerbose Set the special variable $VERBOSE. 
.PP
Definition at line 1488 of file shell.c.
.SS "int shell_SolveArgs (int argc, char ** in_out_argv, int * out_allocated)"
.PP
shell_SolveArgs: Interprets arguments if they are vars or commands.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP The number of command line tokens. 
.br
\fIin_out_argv\fP The list of command line tokens (modified). 
.br
\fIout_allocated\fP Indicates which tokens must be freed.
.RE
.PP
\fBReturns:\fP
.RS 4
0 if no errors. 
.RE
.PP

.PP
Definition at line 866 of file shell.c.
.SS "int shellcmd_barrier (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2368 of file shell.c.
.SS "int shellcmd_help (int argc, char ** argv, FILE * output)"
.PP
Definition at line 1864 of file shell.c.
.SS "int shellcmd_if (int argc, char ** argv, FILE * output)"
.PP
Definition at line 1941 of file shell.c.
.SS "int shellcmd_interactive (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2035 of file shell.c.
.SS "int shellcmd_print (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2241 of file shell.c.
.SS "int shellcmd_quit (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2340 of file shell.c.
.SS "int shellcmd_set (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2065 of file shell.c.
.SS "int shellcmd_time (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2293 of file shell.c.
.SS "int shellcmd_unset (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2177 of file shell.c.
.SS "int shellcmd_varlist (int argc, char ** argv, FILE * output)"
.PP
Definition at line 2263 of file shell.c.
.SH "Variable Documentation"
.PP 
.SS "char* \fBshell_special_vars\fP[]"
.PP
List of the shell special variables 
.PP
Definition at line 197 of file shell.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for ganeshell from the source code.
