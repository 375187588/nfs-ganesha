<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Support routines layer: exports.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>exports.c</h1><a href="exports_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00190 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00192 <span class="preprocessor">#endif</span>
00193 <span class="preprocessor"></span>
00194 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00196 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00197 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00198 <span class="preprocessor">#include &lt;gssrpc/pmap_clnt.h&gt;</span>
00199 <span class="preprocessor">#else</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00201 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00202 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00203 <span class="preprocessor">#include &lt;rpc/pmap_clnt.h&gt;</span>
00204 <span class="preprocessor">#endif</span>
00205 <span class="preprocessor"></span>
00206 <span class="preprocessor">#include "log_functions.h"</span>
00207 <span class="preprocessor">#include "stuff_alloc.h"</span>
00208 <span class="preprocessor">#include "fsal.h"</span>
00209 <span class="preprocessor">#include "nfs23.h"</span>
00210 <span class="preprocessor">#include "nfs4.h"</span>
00211 <span class="preprocessor">#include "mount.h"</span>
00212 <span class="preprocessor">#include "nfs_core.h"</span>
00213 <span class="preprocessor">#include "cache_inode.h"</span>
00214 <span class="preprocessor">#include "cache_content.h"</span>
00215 <span class="preprocessor">#include "nfs_file_handle.h"</span>
00216 <span class="preprocessor">#include "nfs_exports.h"</span>
00217 <span class="preprocessor">#include "nfs_tools.h"</span>
00218 <span class="preprocessor">#include "nfs_proto_functions.h"</span>
00219 <span class="preprocessor">#include "nfs_dupreq.h"</span>
00220 <span class="preprocessor">#include "config_parsing.h"</span>
00221 <span class="preprocessor">#include "common_utils.h"</span>
00222 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00223 <span class="preprocessor">#include &lt;fnmatch.h&gt;</span>
00224 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00225 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00226 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00227 <span class="preprocessor">#include &lt;string.h&gt;</span>
00228 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00229 
00230 <span class="keyword">extern</span> nfs_parameter_t nfs_param ;
00231 
00232 <span class="comment">/* Structures to manage a client to cache inode located in the 'main' thread</span>
00233 <span class="comment"> * this cache_inode_client will be used to handle the root of each entry (created when reading export file) */</span>
<a name="l00234"></a><a class="code" href="exports_8c.html#a61">00234</a> cache_inode_client_t           small_client ;
<a name="l00235"></a><a class="code" href="exports_8c.html#a62">00235</a> cache_inode_client_parameter_t small_client_param ;
<a name="l00236"></a><a class="code" href="exports_8c.html#a63">00236</a> cache_content_client_t         recover_datacache_client ;
00237 
<a name="l00238"></a><a class="code" href="exports_8c.html#a0">00238</a> <span class="preprocessor">#define STRCMP strcasecmp</span>
00239 <span class="preprocessor"></span>
<a name="l00240"></a><a class="code" href="exports_8c.html#a1">00240</a> <span class="preprocessor">#define CONF_LABEL_EXPORT "EXPORT"</span>
00241 <span class="preprocessor"></span>
00242 <span class="comment">/* Labels in the export file */</span>
<a name="l00243"></a><a class="code" href="exports_8c.html#a2">00243</a> <span class="preprocessor">#define CONF_EXPORT_ID                 "Export_id"</span>
<a name="l00244"></a><a class="code" href="exports_8c.html#a3">00244</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PATH               "Path"</span>
<a name="l00245"></a><a class="code" href="exports_8c.html#a4">00245</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_ROOT               "Root_Access"</span>
<a name="l00246"></a><a class="code" href="exports_8c.html#a5">00246</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_ACCESS             "Access"</span>
<a name="l00247"></a><a class="code" href="exports_8c.html#a6">00247</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PSEUDO             "Pseudo"</span>
<a name="l00248"></a><a class="code" href="exports_8c.html#a7">00248</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_ACCESSTYPE         "Access_Type"</span>
<a name="l00249"></a><a class="code" href="exports_8c.html#a8">00249</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_ANON_ROOT          "Anonymous_root_uid"</span>
<a name="l00250"></a><a class="code" href="exports_8c.html#a9">00250</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_NFS_PROTO          "NFS_Protocols"</span>
<a name="l00251"></a><a class="code" href="exports_8c.html#a10">00251</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_TRANS_PROTO        "Transport_Protocols"</span>
<a name="l00252"></a><a class="code" href="exports_8c.html#a11">00252</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_SECTYPE            "SecType"</span>
<a name="l00253"></a><a class="code" href="exports_8c.html#a12">00253</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_MAX_READ           "MaxRead"</span>
<a name="l00254"></a><a class="code" href="exports_8c.html#a13">00254</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_MAX_WRITE          "MaxWrite"</span>
<a name="l00255"></a><a class="code" href="exports_8c.html#a14">00255</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PREF_READ          "PrefRead"</span>
<a name="l00256"></a><a class="code" href="exports_8c.html#a15">00256</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PREF_WRITE         "PrefWrite"</span>
<a name="l00257"></a><a class="code" href="exports_8c.html#a16">00257</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PREF_READDIR       "PrefReaddir"</span>
<a name="l00258"></a><a class="code" href="exports_8c.html#a17">00258</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_FSID               "Filesystem_id"</span>
<a name="l00259"></a><a class="code" href="exports_8c.html#a18">00259</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_NOSUID             "NOSUID"</span>
<a name="l00260"></a><a class="code" href="exports_8c.html#a19">00260</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_NOSGID             "NOSGID"</span>
<a name="l00261"></a><a class="code" href="exports_8c.html#a20">00261</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_PRIVILEGED_PORT    "PrivilegedPort"</span>
<a name="l00262"></a><a class="code" href="exports_8c.html#a21">00262</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_USE_DATACACHE      "Cache_Data"</span>
<a name="l00263"></a><a class="code" href="exports_8c.html#a22">00263</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_FS_SPECIFIC        "FS_Specific"</span>
<a name="l00264"></a><a class="code" href="exports_8c.html#a23">00264</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_FS_TAG             "Tag"</span>
<a name="l00265"></a><a class="code" href="exports_8c.html#a24">00265</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_MAX_OFF_WRITE      "MaxOffsetWrite"</span>
<a name="l00266"></a><a class="code" href="exports_8c.html#a25">00266</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_MAX_OFF_READ       "MaxOffsetRead"</span>
<a name="l00267"></a><a class="code" href="exports_8c.html#a26">00267</a> <span class="preprocessor"></span><span class="preprocessor">#define CONF_EXPORT_MAX_CACHE_SIZE     "MaxCacheSize"</span>
00268 <span class="preprocessor"></span>
00272 <span class="comment">/* Internal identifiers */</span>
<a name="l00273"></a><a class="code" href="exports_8c.html#a27">00273</a> <span class="preprocessor">#define FLAG_EXPORT_ID            0x00000001</span>
<a name="l00274"></a><a class="code" href="exports_8c.html#a28">00274</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_PATH          0x00000002</span>
00275 <span class="preprocessor"></span>
<a name="l00276"></a><a class="code" href="exports_8c.html#a29">00276</a> <span class="preprocessor">#define FLAG_EXPORT_ROOT_OR_ACCESS 0x00000004</span>
00277 <span class="preprocessor"></span>
<a name="l00278"></a><a class="code" href="exports_8c.html#a30">00278</a> <span class="preprocessor">#define FLAG_EXPORT_PSEUDO          0x00000010</span>
<a name="l00279"></a><a class="code" href="exports_8c.html#a31">00279</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_ACCESSTYPE      0x00000020</span>
<a name="l00280"></a><a class="code" href="exports_8c.html#a32">00280</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_ANON_ROOT       0x00000040</span>
<a name="l00281"></a><a class="code" href="exports_8c.html#a33">00281</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_NFS_PROTO       0x00000080</span>
<a name="l00282"></a><a class="code" href="exports_8c.html#a34">00282</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_TRANS_PROTO     0x00000100</span>
<a name="l00283"></a><a class="code" href="exports_8c.html#a35">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_SECTYPE         0x00000200</span>
<a name="l00284"></a><a class="code" href="exports_8c.html#a36">00284</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_MAX_READ        0x00000400</span>
<a name="l00285"></a><a class="code" href="exports_8c.html#a37">00285</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_MAX_WRITE       0x00000800</span>
<a name="l00286"></a><a class="code" href="exports_8c.html#a38">00286</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_PREF_READ       0x00001000</span>
<a name="l00287"></a><a class="code" href="exports_8c.html#a39">00287</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_PREF_WRITE      0x00002000</span>
<a name="l00288"></a><a class="code" href="exports_8c.html#a40">00288</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_PREF_READDIR    0x00004000</span>
<a name="l00289"></a><a class="code" href="exports_8c.html#a41">00289</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_FSID            0x00008000</span>
<a name="l00290"></a><a class="code" href="exports_8c.html#a42">00290</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_NOSUID          0x00010000</span>
<a name="l00291"></a><a class="code" href="exports_8c.html#a43">00291</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_NOSGID          0x00020000</span>
<a name="l00292"></a><a class="code" href="exports_8c.html#a44">00292</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_PRIVILEGED_PORT 0x00040000</span>
<a name="l00293"></a><a class="code" href="exports_8c.html#a45">00293</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_USE_DATACACHE   0x00080000</span>
<a name="l00294"></a><a class="code" href="exports_8c.html#a46">00294</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_FS_SPECIFIC     0x00100000</span>
<a name="l00295"></a><a class="code" href="exports_8c.html#a47">00295</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_FS_TAG          0x00200000</span>
<a name="l00296"></a><a class="code" href="exports_8c.html#a48">00296</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_MAX_OFF_WRITE   0x00400000</span>
<a name="l00297"></a><a class="code" href="exports_8c.html#a49">00297</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_MAX_OFF_READ    0x00800000</span>
<a name="l00298"></a><a class="code" href="exports_8c.html#a50">00298</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAG_EXPORT_MAX_CACHE_SIZE  0x01000000</span>
00299 <span class="preprocessor"></span>
<a name="l00300"></a><a class="code" href="exports_8c.html#a65">00300</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a65">local_lru_inode_entry_to_str</a>( LRU_data_t data, <span class="keywordtype">char</span> * str)
00301 {
00302   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"N/A "</span> ) ;
00303 } <span class="comment">/* local_lru_inode_entry_to_str */</span>
00304 
<a name="l00305"></a><a class="code" href="exports_8c.html#a66">00305</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a66">local_lru_inode_clean_entry</a>( LRU_entry_t * entry, <span class="keywordtype">void</span> * adddata)
00306 {
00307   <span class="keywordflow">return</span> 0 ;
00308 } <span class="comment">/* lru_clean_entry */</span>
00309 
00310 
<a name="l00325"></a><a class="code" href="exports_8c.html#a67">00325</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>(<span class="keywordtype">char</span>           *Argv[],
00326                       <span class="keywordtype">int</span>             nbArgv,
00327                       <span class="keywordtype">char</span>           *line,
00328                       <span class="keywordtype">int</span> (          *separator_function) (<span class="keywordtype">char</span>),
00329                       <span class="keywordtype">int</span> (          *endLine_func) (<span class="keywordtype">char</span>))
00330 {
00331         <span class="keywordtype">int</span>             output_value = 0;
00332         <span class="keywordtype">int</span>             endLine = FALSE;
00333 
00334         <span class="keywordtype">char</span>           *p1 = line;      <span class="comment">/* Pointeur sur le debut du token */</span>
00335         <span class="keywordtype">char</span>           *p2 = NULL;      <span class="comment">/* Pointeur sur la fin du token   */</span>
00336 
00337     <span class="comment">/* iteration and checking for array bounds */</span>
00338         <span class="keywordflow">for</span> ( ; output_value &lt; nbArgv; )
00339     {
00340 
00341       <span class="keywordflow">if</span> (*p1 == <span class="charliteral">'\0'</span>)
00342         <span class="keywordflow">return</span> output_value;
00343 
00344       <span class="comment">/* Je recherche le premier caractere valide */</span>
00345       <span class="keywordflow">for</span> (; *p1 == <span class="charliteral">' '</span> || *p1 == <span class="charliteral">'\t'</span>; p1++);
00346 
00347 
00348       <span class="comment">/* p1 pointe sur un debut de token, je cherche la fin */</span>
00349       <span class="comment">/* La fin est un blanc, une fin de chaine ou un CR    */</span>
00350       <span class="keywordflow">for</span> (p2 = p1; !separator_function(*p2) &amp;&amp; !endLine_func(*p2); p2++);
00351 
00352       <span class="comment">/* Possible arret a cet endroit */</span>
00353       <span class="keywordflow">if</span> (endLine_func(*p2))
00354         endLine = TRUE;
00355 
00356 
00357       <span class="comment">/* je valide la lecture du token */</span>
00358       *p2 = <span class="charliteral">'\0'</span>;
00359       strcpy(Argv[output_value++], p1);
00360 
00361       <span class="comment">/* Je me prepare pour la suite */</span>
00362       <span class="keywordflow">if</span> (!endLine)
00363         {
00364           p2 += 1;
00365           p1 = p2;
00366         } <span class="keywordflow">else</span>
00367           <span class="keywordflow">return</span> output_value;
00368 
00369     }                   <span class="comment">/* for( ; ; ) */</span>
00370     
00371     <span class="comment">/* out of bounds */</span>
00372     <span class="keywordflow">if</span> ( output_value &gt;= nbArgv ) <span class="keywordflow">return</span> -1;
00373     
00374     <span class="keywordflow">return</span> -2;
00375     
00376 } <span class="comment">/* nfs_ParseConfLine */</span>
00377 
00378 
00379 
00380 
00402 <span class="keyword">static</span> <span class="keyword">struct </span>hostent * nfs_LookupHostAddr( <span class="keywordtype">char</span> *host )
00403 {
00404         <span class="keyword">struct </span>hostent *output;
00405         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   hostaddr;
00406         <span class="keywordtype">int</span>             length = <span class="keyword">sizeof</span>(hostaddr);
00407 
00408         <span class="comment">/* First try gethhostbyname */</span>
00409         <span class="keywordflow">if</span> ((output = gethostbyname(host)) == NULL)
00410     {
00411       <span class="comment">/* Convert from dotted notation to adddress format */</span>
00412       hostaddr = inet_addr(host);
00413 
00414       <span class="comment">/* gethostbyname was of no help, try gethostaddr */</span>
00415       output = gethostbyaddr((<span class="keywordtype">char</span> *) &amp;hostaddr, length, AF_INET);
00416     }
00417         <span class="keywordflow">return</span> output;
00418 }       <span class="comment">/* nfs_LookupHostAddr */</span>
00419 
<a name="l00443"></a><a class="code" href="exports_8c.html#a69">00443</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a69">nfs_LookupNetworkAddr</a>( <span class="keywordtype">char</span>           *host,      <span class="comment">/* [IN] host/address specifier */</span>
00444                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  *netAddr,   <span class="comment">/* [OUT] return address       */</span>
00445                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  *netMask)   <span class="comment">/* [OUT] return address mask  */</span>
00446 {
00447         <span class="keywordtype">int</span>                error = 0 ;
00448   <span class="keywordtype">int</span>                compute_mask = TRUE;
00449         <span class="keyword">struct </span>hostent   * host_ent;
00450         <span class="keyword">struct </span>netent    * net_ent;
00451         in_addr_t          net_addr;
00452         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      net_mask;
00453         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>      <span class="keyword">class</span>;
00454 
00455 
00456         <span class="comment">/*</span>
00457 <span class="comment">         * Initialize local variables.. </span>
00458 <span class="comment">         */</span>
00459 
00460         net_mask = 0;
00461         net_ent = NULL;
00462         host_ent = NULL;
00463 
00464         <span class="comment">/*</span>
00465 <span class="comment">         * Check for dotted address notation. </span>
00466 <span class="comment">         */</span>
00467 
00468         net_addr = inet_network(host);
00469 
00470         <span class="keywordflow">if</span> (net_addr == (in_addr_t)-1)
00471     {
00472       <span class="comment">/*</span>
00473 <span class="comment">       * Not a valid dotted IP address. Check for host name. </span>
00474 <span class="comment">       */</span>
00475 
00476       <span class="keywordflow">if</span> ((host_ent = gethostbyname(host)) != NULL)
00477         {
00478           <span class="comment">/*</span>
00479 <span class="comment">           * A valid hostname. Just copy the hostent address. </span>
00480 <span class="comment">           */</span>
00481 
00482           memcpy(&amp;net_addr, host_ent-&gt;h_addr, host_ent-&gt;h_length);
00483           compute_mask = FALSE;
00484         } 
00485       <span class="keywordflow">else</span>
00486         {
00487           
00488           <span class="comment">/*</span>
00489 <span class="comment">           * Not a valid hostname. Check for a network name. </span>
00490 <span class="comment">           */</span>
00491           
00492           net_ent = getnetbyname(host);
00493           <span class="keywordflow">if</span> (net_ent == NULL)
00494             {
00495               error = errno;
00496               <span class="keywordflow">if</span> (error == 0)
00497                 error = ENOENT;
00498               endnetent();
00499             } 
00500           <span class="keywordflow">else</span>
00501             {
00502               net_addr = net_ent-&gt;n_net;
00503               endnetent();
00504             }
00505         }
00506     }
00507         <span class="comment">/*</span>
00508 <span class="comment">         * If no error and address is a network address, convert address to</span>
00509 <span class="comment">         * inaddr format by left justifying, determine the network address</span>
00510 <span class="comment">         * class, and compute the network mask.  </span>
00511 <span class="comment">         */</span>
00512 
00513         <span class="keywordflow">if</span> (error == 0 &amp;&amp; compute_mask)
00514     {
00515 
00516       <span class="keywordflow">if</span> ((net_addr &amp; 0xffffff00) == 0)
00517         net_addr &lt;&lt;= 24;
00518       <span class="keywordflow">else</span>
00519         <span class="keywordflow">if</span> ((net_addr &amp; 0xffff0000) == 0)
00520           net_addr &lt;&lt;= 16;
00521         <span class="keywordflow">else</span>
00522           <span class="keywordflow">if</span> ((net_addr &amp; 0xff000000) == 0)
00523             net_addr &lt;&lt;= 8;
00524       <span class="keyword">class </span>= (net_addr &amp; 0xc0000000) &gt;&gt; 30;
00525       <span class="keywordflow">switch</span> (<span class="keyword">class</span>)
00526         {
00527         <span class="keywordflow">case</span> 0: <span class="comment">/* class A address           */</span>
00528         <span class="keywordflow">case</span> 1:
00529           <span class="keywordflow">if</span> ((net_addr &amp; 0x00ffffff) == 0)
00530             net_mask = 0xff000000;
00531           <span class="keywordflow">else</span>
00532             <span class="keywordflow">if</span> ((net_addr &amp; 0x0000ffff) == 0)
00533               net_mask = 0xffff0000;
00534             <span class="keywordflow">else</span>
00535               <span class="keywordflow">if</span> ((net_addr &amp; 0x000000ff) == 0)
00536                 net_mask = 0xffffff00;
00537           <span class="keywordflow">break</span>;
00538         <span class="keywordflow">case</span> 2: <span class="comment">/* class B address           */</span>
00539           <span class="keywordflow">if</span> ((net_addr &amp; 0x0000ffff) == 0)
00540             net_mask = 0xffff0000;
00541           <span class="keywordflow">else</span>
00542             <span class="keywordflow">if</span> ((net_addr &amp; 0x000000ff) == 0)
00543               net_mask = 0xffffff00;
00544           <span class="keywordflow">break</span>;
00545         <span class="keywordflow">case</span> 3: <span class="comment">/* class C address            */</span>
00546           <span class="keywordflow">if</span> ((net_addr &amp; 0x000000ff) == 0)
00547             net_mask = 0xffffff00;
00548           <span class="keywordflow">break</span>;
00549         <span class="keywordflow">default</span>:
00550           <span class="keywordflow">break</span>;
00551         }
00552     }
00553         <span class="keywordflow">if</span> (error == 0)
00554     {
00555       <span class="keywordflow">if</span> (netAddr != (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) NULL)
00556         *netAddr = net_addr;
00557       <span class="keywordflow">if</span> (netMask != (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) NULL)
00558         *netMask = net_mask;
00559     }
00560         <span class="keywordflow">return</span> (error);
00561 } <span class="comment">/* nfs_LookupNetworkAddr */</span>
00562 
00572 <span class="keyword">static</span> <span class="keywordtype">int</span> nfs_AddClientsToExportList( exportlist_t   * ExportEntry,
00573                                        <span class="keywordtype">int</span>              new_clients_number,
00574                                        <span class="keywordtype">char</span>          ** new_clients_name,
00575                                        <span class="keywordtype">int</span>              option)
00576 {
00577   <span class="keywordtype">int</span>                         i = 0 ;
00578   <span class="keywordtype">int</span>                         j = 0 ;
00579   <span class="keywordtype">int</span>                         k = 0 ;
00580   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                l = 0 ;
00581   <span class="keywordtype">char</span>                      * client_hostname;
00582   <span class="keyword">struct </span>hostent            * hostEntry;
00583   exportlist_client_entry_t * p_clients;
00584   <span class="keywordtype">int</span>                         is_wildcarded_host = FALSE ;
00585   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               netMask;
00586   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               netAddr;
00587   <span class="keywordtype">int</span>                         error;
00588   <span class="keywordtype">char</span>                        FunctionName[] = <span class="stringliteral">"nfs_AddClientsToExportList"</span>;
00589   <span class="keywordtype">char</span>                        buff[INET_ADDRSTRLEN+1];
00590     
00591   <span class="comment">/*</span>
00592 <span class="comment">   * Notifying the export list structure that another option is to be</span>
00593 <span class="comment">   * handled </span>
00594 <span class="comment">   */</span>
00595   ExportEntry-&gt;options |= option;
00596   
00597   <span class="comment">/* How many clients are there in the ExportEntry ? */</span>
00598   j = ExportEntry-&gt;clients.num_clients;
00599     
00600   p_clients = ExportEntry-&gt;clients.clientarray ;
00601   
00602   <span class="keywordflow">if</span> ( p_clients == NULL ) 
00603     <span class="keywordflow">return</span> ENOMEM ;
00604 
00605         <span class="comment">/* It's now time to set the information related to the new clients */</span>
00606         <span class="keywordflow">for</span> (i = j; i &lt; j + new_clients_number; i++)
00607     {
00608       <span class="comment">/* cleans the export entry */</span>
00609       memset( &amp;p_clients[i], 0, <span class="keyword">sizeof</span>( exportlist_client_entry_t ) );
00610 
00611       
00612       netMask = 0;      <span class="comment">/* default value for a host */</span>
00613       client_hostname = new_clients_name[i - j];
00614 
00615       <span class="comment">/* Set client options */</span>
00616       p_clients[i].options |= option;
00617 
00618       <span class="comment">/* using netdb to get information about the hostname */</span>
00619       <span class="keywordflow">if</span>( client_hostname[0] == <span class="charliteral">'@'</span> )
00620         {
00621           
00622           <span class="comment">/* Entry is a netgroup definition */</span>
00623           strncpy( p_clients[i].client.netgroup.netgroupname, (<span class="keywordtype">char</span> *)(client_hostname + 1), MAXHOSTNAMELEN ) ;
00624           
00625           p_clients[i].options |= EXPORT_OPTION_NETGRP ;
00626           p_clients[i].type = NETGROUP_CLIENT ;
00627           
00628 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
00629 <span class="preprocessor"></span>          printf(<span class="stringliteral">"----------------- %s to netgroup %s\n"</span>,(option==EXPORT_OPTION_ROOT ? <span class="stringliteral">"Root-access"</span>:<span class="stringliteral">"Access"</span>), p_clients[i].client.netgroup.netgroupname );
00630 <span class="preprocessor">#endif          </span>
00631 <span class="preprocessor"></span>        }
00632       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((hostEntry = nfs_LookupHostAddr(client_hostname)) != NULL)
00633         {
00634 
00635           <span class="comment">/* Entry is a hostif */</span>
00636           memcpy( &amp;(p_clients[i].client.hostif.clientaddr), hostEntry-&gt;h_addr, hostEntry-&gt;h_length);
00637           p_clients[i].type = HOSTIF_CLIENT ;          
00638                  
00639 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
00640 <span class="preprocessor"></span>          printf(<span class="stringliteral">"----------------- %s to client %s = %d.%d.%d.%d\n"</span>,(option==EXPORT_OPTION_ROOT ? <span class="stringliteral">"Root-access"</span>:<span class="stringliteral">"Access"</span>), 
00641               client_hostname, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(p_clients[i].client.hostif.clientaddr &gt;&gt; 24),
00642               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((p_clients[i].client.hostif.clientaddr &gt;&gt; 16)&amp;0xFF),
00643               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((p_clients[i].client.hostif.clientaddr &gt;&gt; 8)&amp;0xFF),
00644               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(p_clients[i].client.hostif.clientaddr &amp; 0xFF));
00645 <span class="preprocessor">#endif          </span>
00646 <span class="preprocessor"></span>        }
00647       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( ((error = <a class="code" href="exports_8c.html#a69">nfs_LookupNetworkAddr</a>(client_hostname,
00648                                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) &amp;netAddr,
00649                                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) &amp;netMask) ) ) == 0 )
00650         {
00651           <span class="comment">/* Entry is a network definition */</span>
00652           p_clients[i].client.network.netaddr = netAddr ;
00653           p_clients[i].options |= EXPORT_OPTION_NETENT ;
00654           p_clients[i].client.network.netmask = netMask;
00655           p_clients[i].type = NETWORK_CLIENT ;
00656           
00657 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
00658 <span class="preprocessor"></span>          printf(<span class="stringliteral">"----------------- %s to network %s = %d.%d.%d.%d\n"</span>,
00659               (option==EXPORT_OPTION_ROOT ? <span class="stringliteral">"Root-access"</span>:<span class="stringliteral">"Access"</span>), 
00660               client_hostname, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(p_clients[i].client.network.netaddr &gt;&gt; 24),
00661               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((p_clients[i].client.network.netaddr &gt;&gt; 16)&amp;0xFF),
00662               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((p_clients[i].client.network.netaddr &gt;&gt; 8)&amp;0xFF),
00663               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(p_clients[i].client.network.netaddr &amp; 0xFF));
00664 <span class="preprocessor">#endif</span>
00665 <span class="preprocessor"></span>        }
00666       <span class="keywordflow">else</span>
00667         {
00668           <span class="comment">/* this may be  a wildcarded host */</span>
00669           <span class="comment">/* Lookup into the string to see if it contains '*' or '?' */</span>
00670           is_wildcarded_host = FALSE ;
00671           <span class="keywordflow">for</span>( l = 0 ; l &lt; strlen( client_hostname ) ; l++ )
00672             {
00673               <span class="keywordflow">if</span>( ( client_hostname[l] == <span class="charliteral">'*'</span> ) ||
00674                   ( client_hostname[l] == <span class="charliteral">'?'</span> ) )
00675                 {
00676                   is_wildcarded_host = TRUE ;
00677                   break ;
00678                 }
00679             }
00680           
00681           <span class="keywordflow">if</span>( is_wildcarded_host == TRUE )
00682             {
00683               p_clients[i].type = WILDCARDHOST_CLIENT ;
00684               strncpy(  p_clients[i].client.wildcard.wildcard,  client_hostname, MAXHOSTNAMELEN ) ;
00685               
00686 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
00687 <span class="preprocessor"></span>              printf(<span class="stringliteral">"----------------- %s to wildcard %s\n"</span>,
00688               (option==EXPORT_OPTION_ROOT ? <span class="stringliteral">"Root-access"</span>:<span class="stringliteral">"Access"</span>), client_hostname);
00689 <span class="preprocessor">#endif</span>
00690 <span class="preprocessor"></span>            }
00691           <span class="keywordflow">else</span>
00692             {
00693               <span class="comment">/* Last case: type for client could not be identified. This should not occur */</span>
00694               printf( <span class="stringliteral">"Unsupported type for client %s\n"</span>, client_hostname ) ;
00695             }
00696         }
00697     }   <span class="comment">/* for i */</span>
00698   
00699         <span class="comment">/* Before we finish, do not forget to set the new number of clients</span>
00700 <span class="comment">   * and the new pointer to client array.</span>
00701 <span class="comment">   */</span>
00702         ExportEntry-&gt;clients.num_clients += new_clients_number ;
00703 
00704         <span class="keywordflow">return</span> 0;               <span class="comment">/* success !! */</span>
00705 }                               <span class="comment">/* nfs_AddClientsToExportList */</span>
00706 
00707 
00708 
00709 
<a name="l00710"></a><a class="code" href="exports_8c.html#a51">00710</a> <span class="preprocessor">#define DEFINED_TWICE_WARNING( _str_ ) \</span>
00711 <span class="preprocessor">  DisplayLog( "NFS READ_EXPORT: WARNING: %s defined twice !!! (ignored)", _str_ )</span>
00712 <span class="preprocessor"></span>
00713 
00714 
00720 <span class="keyword">static</span> <span class="keywordtype">int</span> BuildExportEntry( config_file_t in_config,
00721                              <span class="keywordtype">int</span> block_index,
00722                              exportlist_t ** pp_export )
00723 {
00724   <span class="comment">/* limites for nfs_ParseConfLine */</span>
00725 <span class="preprocessor">  #define EXPORT_MAX_CLIENTS   EXPORTS_NB_MAX_CLIENTS </span><span class="comment">/* number of clients */</span>
00726 <span class="preprocessor">  #define EXPORT_MAX_CLIENTLEN 256 </span><span class="comment">/* client name len */</span>
00727 
00728   exportlist_t * p_entry;
00729   <span class="keywordtype">int</span> i, rc;
00730   <span class="keywordtype">char</span> * var_name;
00731   <span class="keywordtype">char</span> * var_value;
00732   
00733   <span class="comment">/* the mandatory options */</span>
00734   
00735   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mandatory_options =
00736       ( <a class="code" href="exports_8c.html#a27">FLAG_EXPORT_ID</a> | <a class="code" href="exports_8c.html#a28">FLAG_EXPORT_PATH</a> |
00737         <a class="code" href="exports_8c.html#a29">FLAG_EXPORT_ROOT_OR_ACCESS</a> | FLAG_EXPORT_PSEUDO );
00738 
00739   <span class="comment">/* the given options */</span>
00740   
00741   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> set_options = 0;
00742   
00743   <span class="keywordtype">int</span> err_flag = FALSE;
00744     
00745   <span class="comment">/* allocates export entry */</span>
00746   p_entry = (exportlist_t *)Mem_Alloc( <span class="keyword">sizeof</span>( exportlist_t ));
00747   
00748   
00749   <span class="keywordflow">if</span> ( p_entry == NULL ) <span class="keywordflow">return</span> Mem_Errno;
00750     
00753   p_entry-&gt;next                = NULL;
00754   p_entry-&gt;options             = 0;
00755   p_entry-&gt;status              = EXPORTLIST_OK ;
00756   p_entry-&gt;clients.num_clients = 0 ;
00757   p_entry-&gt;access_type         = ACCESSTYPE_RW ;  
00758   p_entry-&gt;anonymous_uid       = (uid_t)-2;
00759   p_entry-&gt;MaxOffsetWrite      = (fsal_off_t)0 ;
00760   p_entry-&gt;MaxOffsetRead       = (fsal_off_t)0 ;
00761   p_entry-&gt;MaxCacheSize        = (fsal_off_t)0 ;
00762   
00763   <span class="comment">/* by default, we support auth_none and auth_sys */</span>
00764   p_entry-&gt;options |= EXPORT_OPTION_AUTH_NONE | EXPORT_OPTION_AUTH_UNIX ;
00765 
00766   <span class="comment">/* by default, we support both NFS versions and transport protocols */</span>
00767   p_entry-&gt;options |= EXPORT_OPTION_NFSV2 | EXPORT_OPTION_NFSV3 | EXPORT_OPTION_NFSV4 ;
00768   p_entry-&gt;options |= EXPORT_OPTION_UDP | EXPORT_OPTION_TCP ;
00769   
00770   p_entry-&gt;filesystem_id.major = (fsal_u64_t)666;
00771   p_entry-&gt;filesystem_id.minor = (fsal_u64_t)666;  
00772 
00774   p_entry-&gt;MaxWrite = (fsal_size_t)4096 ;
00775   p_entry-&gt;MaxRead  = (fsal_size_t)4096 ;
00776 
00777   strcpy( p_entry-&gt;FS_specific, <span class="stringliteral">""</span> );
00778   strcpy( p_entry-&gt;FS_tag, <span class="stringliteral">""</span> ); 
00779       
00780   <span class="comment">/* parse options for this export entry */</span>
00781   
00782   <span class="keywordflow">for</span> (i=0; i&lt;config_GetNbKeys( in_config, block_index ) ; i++)
00783   {
00784    
00785     <span class="comment">/* get var name and value */</span>
00786     rc = config_GetKeyValue( in_config, block_index, i,
00787                              &amp;var_name, &amp;var_value );
00788     
00789     <span class="keywordflow">if</span> ( (rc != 0) || (var_value == NULL) )
00790     {
00791       Mem_Free( p_entry );
00792       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: internal error %d"</span>, rc );
00793       <span class="comment">/* free the entry before exiting */</span>
00794       <span class="keywordflow">return</span> -1;
00795     }
00796     
00797     <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a2">CONF_EXPORT_ID</a> ) )
00798     {
00799       
00800       <span class="keywordtype">long</span> <span class="keywordtype">int</span> export_id ;
00801       <span class="keywordtype">char</span> * end_ptr;
00802 
00803       <span class="comment">/* check if it has not already been set */</span>
00804       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_ID ) == FLAG_EXPORT_ID )
00805       {
00806         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a2">CONF_EXPORT_ID</a> );
00807         <span class="keywordflow">continue</span>;
00808       }
00809             
00810       <span class="comment">/* parse and check export_id */</span>
00811       errno = 0;      
00812       export_id = strtol( var_value, &amp;end_ptr, 10 );
00813       
00814       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
00815       {
00816         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid export_id: \"%s\""</span>, var_value );
00817         err_flag = TRUE;
00818         <span class="keywordflow">continue</span>;
00819       }
00820       
00821       <span class="keywordflow">if</span> ( export_id &lt;= 0 || export_id &gt; USHRT_MAX )
00822       {
00823         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Export_id out of range: \"%ld\""</span>, export_id );
00824         err_flag = TRUE;
00825         <span class="keywordflow">continue</span>;
00826       }
00827       
00828       <span class="comment">/* set export_id */</span>
00829       
00830       p_entry-&gt;id = (<span class="keywordtype">unsigned</span> short) export_id;      
00831       
00832       set_options |= FLAG_EXPORT_ID;
00833       
00834     }
00835     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a3">CONF_EXPORT_PATH</a> ) )
00836     {
00837       <span class="comment">/* check if it has not already been set */</span>
00838       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PATH ) == FLAG_EXPORT_PATH )
00839       {
00840         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a3">CONF_EXPORT_PATH</a> );
00841         <span class="keywordflow">continue</span>;
00842       }
00843       
00844       <span class="keywordflow">if</span> ( *var_value == <span class="charliteral">'\0'</span> )
00845       {
00846         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Empty export path"</span> );
00847         err_flag = TRUE;
00848         <span class="keywordflow">continue</span>;
00849       }
00850       
00853       strncpy( p_entry-&gt;fullpath, var_value, MAXPATHLEN );
00854       
00856       strncpy(p_entry-&gt;dirname, var_value, MAXNAMLEN );
00857       strncpy(p_entry-&gt;fsname, <span class="stringliteral">""</span>, MAXNAMLEN );
00858       
00859       set_options |= FLAG_EXPORT_PATH;
00860       
00861     }
00862     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a4">CONF_EXPORT_ROOT</a> ) )
00863     {
00864       <span class="comment">/* array of clients */</span>
00865       <span class="keywordtype">char</span> * client_list[ EXPORT_MAX_CLIENTS ];
00866       <span class="keywordtype">int</span> idx;
00867       
00868       <span class="comment">/* allocate clients strings  */</span>
00869       <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00870         client_list[idx] = (<span class="keywordtype">char</span> *)Mem_Alloc( <a class="code" href="exports_8c.html#a53">EXPORT_MAX_CLIENTLEN</a> );
00871       
00872       <span class="comment">/*</span>
00873 <span class="comment">       * Search for coma-separated list of hosts, networks and netgroups</span>
00874 <span class="comment">       */</span>
00875       rc = <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>( client_list, <a class="code" href="exports_8c.html#a52">EXPORT_MAX_CLIENTS</a>,
00876                               var_value, find_comma, find_endLine) ;
00877       
00878       <span class="keywordflow">if</span> ( rc &lt; 0 )
00879       {
00880         err_flag = TRUE;        
00881         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Client list too long (&gt;%d)"</span>,
00882                       <a class="code" href="exports_8c.html#a52">EXPORT_MAX_CLIENTS</a> );
00883 
00884         <span class="comment">/* free client strings */</span>
00885         <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00886           Mem_Free( (caddr_t) client_list[idx] );
00887 
00888         <span class="keywordflow">continue</span>;
00889       }
00890       
00891       rc = nfs_AddClientsToExportList( p_entry, 
00892                                        rc,
00893                                       (<span class="keywordtype">char</span> **)client_list, 
00894                                        EXPORT_OPTION_ROOT );
00895       
00896       <span class="keywordflow">if</span> ( rc != 0 )
00897       {
00898         err_flag = TRUE;
00899         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid client found in \"%s\""</span>,
00900                     var_value );
00901 
00902         <span class="comment">/* free client strings */</span>
00903         <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00904           Mem_Free( (caddr_t) client_list[idx] );
00905 
00906         <span class="keywordflow">continue</span>;
00907       }
00908       
00909       <span class="comment">/* everything is OK */</span>
00910       
00911       <span class="comment">/* free client strings */</span>
00912       <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00913         Mem_Free( (caddr_t) client_list[idx] );
00914       
00915       <span class="comment">/* Notice that as least one of the two options</span>
00916 <span class="comment">       * Root_Access or access has been specified.</span>
00917 <span class="comment">       */</span>
00918       set_options |= FLAG_EXPORT_ROOT_OR_ACCESS;
00919       
00920     }
00921     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a5">CONF_EXPORT_ACCESS</a> ) )
00922     {
00923       <span class="comment">/* array of clients */</span>
00924       <span class="keywordtype">char</span> * client_list[ EXPORT_MAX_CLIENTS ];
00925       <span class="keywordtype">int</span> idx;
00926       
00927       <span class="comment">/* allocate clients strings  */</span>
00928       <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00929         client_list[idx] = (<span class="keywordtype">char</span> *)Mem_Alloc( <a class="code" href="exports_8c.html#a53">EXPORT_MAX_CLIENTLEN</a> );
00930       
00931       <span class="comment">/*</span>
00932 <span class="comment">       * Search for coma-separated list of hosts, networks and netgroups</span>
00933 <span class="comment">       */</span>
00934       rc = <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>( client_list, <a class="code" href="exports_8c.html#a52">EXPORT_MAX_CLIENTS</a>,
00935                               var_value, find_comma, find_endLine) ;
00936       
00937       <span class="keywordflow">if</span> ( rc &lt; 0 )
00938       {
00939         err_flag = TRUE;        
00940         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Client list too long (&gt;%d)"</span>,
00941                       <a class="code" href="exports_8c.html#a52">EXPORT_MAX_CLIENTS</a> );
00942 
00943         <span class="comment">/* free client strings */</span>
00944         <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00945           Mem_Free( (caddr_t) client_list[idx] );
00946 
00947         <span class="keywordflow">continue</span>;
00948       }
00949       
00950       rc = nfs_AddClientsToExportList( p_entry, rc,
00951                                       (<span class="keywordtype">char</span> **)client_list, EXPORT_OPTION_ACCESS );
00952       
00953       <span class="keywordflow">if</span> ( rc != 0 )
00954       {
00955         err_flag = TRUE;
00956         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid client found in \"%s\""</span>,
00957                     var_value );
00958 
00959         <span class="comment">/* free client strings */</span>
00960         <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00961           Mem_Free( (caddr_t) client_list[idx] );
00962 
00963         <span class="keywordflow">continue</span>;
00964       }
00965       
00966       <span class="comment">/* everything is OK */</span>
00967       
00968       <span class="comment">/* free client strings */</span>
00969       <span class="keywordflow">for</span> ( idx = 0; idx &lt; EXPORT_MAX_CLIENTS ; idx++ )
00970         Mem_Free( (caddr_t) client_list[idx] );
00971       
00972       <span class="comment">/* Notice that as least one of the two options</span>
00973 <span class="comment">       * Root_Access or access has been specified.</span>
00974 <span class="comment">       */</span>
00975       set_options |= FLAG_EXPORT_ROOT_OR_ACCESS;
00976       
00977     }
00978     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a6">CONF_EXPORT_PSEUDO</a> ) )
00979     {
00980       
00981       <span class="comment">/* check if it has not already been set */</span>
00982       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PSEUDO ) == FLAG_EXPORT_PSEUDO )
00983       {
00984         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a6">CONF_EXPORT_PSEUDO</a> );
00985         <span class="keywordflow">continue</span>;
00986       }
00987       
00988       <span class="keywordflow">if</span> ( *var_value != <span class="charliteral">'/'</span> )
00989       {
00990         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Pseudo path must begin with a slash (invalid pseudo path: %s)."</span>, var_value );
00991         err_flag = TRUE;
00992         <span class="keywordflow">continue</span>;
00993       }
00994       
00995       strncpy( p_entry-&gt;pseudopath, var_value, MAXPATHLEN );
00996       
00997       set_options |= FLAG_EXPORT_PSEUDO;
00998       p_entry-&gt;options |= EXPORT_OPTION_PSEUDO;
00999       
01000     }
01001     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a7">CONF_EXPORT_ACCESSTYPE</a> ) )
01002     {
01003       
01004       <span class="comment">/* check if it has not already been set */</span>
01005       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_ACCESSTYPE ) == FLAG_EXPORT_ACCESSTYPE )
01006       {
01007         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>(  <a class="code" href="exports_8c.html#a7">CONF_EXPORT_ACCESSTYPE</a> );
01008         <span class="keywordflow">continue</span>;
01009       }
01010       
01011       <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_value, <span class="stringliteral">"RW"</span> ) )
01012       {
01013         p_entry-&gt;access_type = ACCESSTYPE_RW;
01014       }
01015       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_value, <span class="stringliteral">"RO"</span> ) )
01016       {
01017         p_entry-&gt;access_type = ACCESSTYPE_RO;
01018       }
01019       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_value, <span class="stringliteral">"MDONLY"</span> ) )
01020       {
01021         p_entry-&gt;access_type = ACCESSTYPE_MDONLY;
01022       }
01023       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_value, <span class="stringliteral">"MDONLY_RO"</span> ) )
01024       {
01025         p_entry-&gt;access_type = ACCESSTYPE_MDONLY_RO;
01026       }
01027       <span class="keywordflow">else</span>
01028       {
01029         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid access type \"%s\". Values can be: RW, RO, MDONLY, MDONLY_RO."</span>, var_value );
01030         err_flag = TRUE;
01031         <span class="keywordflow">continue</span>;
01032       }
01033       
01034       set_options |= FLAG_EXPORT_ACCESSTYPE;
01035       
01036     }
01037     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a9">CONF_EXPORT_NFS_PROTO</a> ) )
01038     {
01039       
01040 <span class="preprocessor">#     define MAX_NFSPROTO      10  </span><span class="comment">/* large enough !!! */</span>
01041 <span class="preprocessor">#     define MAX_NFSPROTO_LEN  256 </span><span class="comment">/* so is it !!! */</span>
01042       
01043       <span class="keywordtype">char</span> * nfsvers_list[ MAX_NFSPROTO ];
01044       <span class="keywordtype">int</span> idx,count;
01045       
01046       
01047       <span class="comment">/* check if it has not already been set */</span>
01048       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_NFS_PROTO ) == FLAG_EXPORT_NFS_PROTO )
01049       {
01050         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a9">CONF_EXPORT_NFS_PROTO</a> );
01051         <span class="keywordflow">continue</span>;
01052       }
01053       
01054       <span class="comment">/* reset nfs proto flags (clean defaults) */</span>
01055       p_entry-&gt;options &amp;= ~( EXPORT_OPTION_NFSV2
01056                              | EXPORT_OPTION_NFSV3
01057                              | EXPORT_OPTION_NFSV4 );
01058 
01059       
01060       <span class="comment">/* allocate nfs vers strings */</span>
01061       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_NFSPROTO ; idx++ )
01062         nfsvers_list[idx] = (<span class="keywordtype">char</span> *)Mem_Alloc( <a class="code" href="exports_8c.html#a55">MAX_NFSPROTO_LEN</a> );
01063       
01064       <span class="comment">/*</span>
01065 <span class="comment">       * Search for coma-separated list of nfsprotos</span>
01066 <span class="comment">       */</span>
01067       count = <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>( nfsvers_list, <a class="code" href="exports_8c.html#a54">MAX_NFSPROTO</a>,
01068                               var_value, find_comma, find_endLine ) ;
01069       
01070       <span class="keywordflow">if</span> ( count &lt; 0 )
01071       {
01072         err_flag = TRUE;        
01073         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: NFS protocols list too long (&gt;%d)"</span>,
01074                       <a class="code" href="exports_8c.html#a54">MAX_NFSPROTO</a> );
01075 
01076         <span class="comment">/* free sec strings */</span>
01077         <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_NFSPROTO ; idx++ )
01078           Mem_Free( (caddr_t) nfsvers_list[idx] );
01079 
01080         <span class="keywordflow">continue</span>;
01081       }
01082       
01083       <span class="comment">/* add each Nfs protocol flag to the option field.  */</span>
01084       
01085       <span class="keywordflow">for</span> ( idx = 0; idx &lt; count; idx++ )
01086       {
01087         <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( nfsvers_list[idx], <span class="stringliteral">"2"</span> ) )
01088         {
01089           p_entry-&gt;options |= EXPORT_OPTION_NFSV2;
01090         }
01091         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( nfsvers_list[idx], <span class="stringliteral">"3"</span> ) )
01092         {
01093           p_entry-&gt;options |= EXPORT_OPTION_NFSV3;
01094         }
01095         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( nfsvers_list[idx], <span class="stringliteral">"4"</span> ) )
01096         {
01097           p_entry-&gt;options |= EXPORT_OPTION_NFSV4;
01098         }
01099         <span class="keywordflow">else</span>
01100         {
01101           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid NFS version \"%s\". Values can be: 2, 3, 4."</span>, nfsvers_list[idx] );
01102           err_flag = TRUE;
01103         }
01104       }
01105       
01106       <span class="comment">/* free sec strings */</span>
01107       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_NFSPROTO ; idx++ )
01108         Mem_Free( (caddr_t) nfsvers_list[idx] );
01109 
01110       <span class="comment">/* check that at least one nfs protocol has been specified */</span>      
01111       <span class="keywordflow">if</span> ( ( p_entry-&gt;options &amp; ( EXPORT_OPTION_NFSV2
01112                                 | EXPORT_OPTION_NFSV3
01113                                 | EXPORT_OPTION_NFSV4 )) == 0 )
01114         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: WARNING: /!\\ Empty NFS_protocols list"</span> );
01115       
01116       
01117       set_options |= FLAG_EXPORT_NFS_PROTO;      
01118       
01119     }
01120     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a10">CONF_EXPORT_TRANS_PROTO</a> ) )
01121     {
01122       
01123 <span class="preprocessor">#     define MAX_TRANSPROTO      10  </span><span class="comment">/* large enough !!! */</span>
01124 <span class="preprocessor">#     define MAX_TRANSPROTO_LEN  256 </span><span class="comment">/* so is it !!! */</span>
01125       
01126       <span class="keywordtype">char</span> * transproto_list[ MAX_TRANSPROTO ];
01127       <span class="keywordtype">int</span> idx,count;
01128       
01129       
01130       <span class="comment">/* check if it has not already been set */</span>
01131       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_TRANS_PROTO ) == FLAG_EXPORT_TRANS_PROTO )
01132       {
01133         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a10">CONF_EXPORT_TRANS_PROTO</a> );
01134         <span class="keywordflow">continue</span>;
01135       }
01136       
01137       <span class="comment">/* reset TRANS proto flags (clean defaults) */</span>
01138       p_entry-&gt;options &amp;= ~( EXPORT_OPTION_UDP | EXPORT_OPTION_TCP );
01139 
01140       
01141       <span class="comment">/* allocate TRANS vers strings */</span>
01142       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_TRANSPROTO ; idx++ )
01143         transproto_list[idx] = (<span class="keywordtype">char</span> *)Mem_Alloc( <a class="code" href="exports_8c.html#a57">MAX_TRANSPROTO_LEN</a> );
01144       
01145       <span class="comment">/*</span>
01146 <span class="comment">       * Search for coma-separated list of TRANSprotos</span>
01147 <span class="comment">       */</span>
01148       count = <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>( transproto_list, <a class="code" href="exports_8c.html#a56">MAX_TRANSPROTO</a>,
01149                               var_value, find_comma, find_endLine ) ;
01150       
01151       <span class="keywordflow">if</span> ( count &lt; 0 )
01152       {
01153         err_flag = TRUE;        
01154         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Protocol list too long (&gt;%d)"</span>,
01155                       <a class="code" href="exports_8c.html#a56">MAX_TRANSPROTO</a> );
01156 
01157         <span class="comment">/* free sec strings */</span>
01158         <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_TRANSPROTO ; idx++ )
01159           Mem_Free( (caddr_t) transproto_list[idx] );
01160 
01161         <span class="keywordflow">continue</span>;
01162       }
01163       
01164       <span class="comment">/* add each TRANS protocol flag to the option field.  */</span>
01165       
01166       <span class="keywordflow">for</span> ( idx = 0; idx &lt; count; idx++ )
01167       {
01168         <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( transproto_list[idx], <span class="stringliteral">"UDP"</span> ) )
01169         {
01170           p_entry-&gt;options |= EXPORT_OPTION_UDP;
01171         }
01172         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( transproto_list[idx], <span class="stringliteral">"TCP"</span> ) )
01173         {
01174           p_entry-&gt;options |= EXPORT_OPTION_TCP;
01175         }
01176         <span class="keywordflow">else</span>
01177         {
01178           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid protocol \"%s\". Values can be: UDP, TCP."</span>, transproto_list[idx] );
01179           err_flag = TRUE;
01180         }
01181       }
01182       
01183       <span class="comment">/* free sec strings */</span>
01184       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_TRANSPROTO ; idx++ )
01185         Mem_Free( (caddr_t) transproto_list[idx] );
01186 
01187       <span class="comment">/* check that at least one TRANS protocol has been specified */</span>      
01188       <span class="keywordflow">if</span> ( ( p_entry-&gt;options &amp; ( EXPORT_OPTION_UDP
01189                                 | EXPORT_OPTION_TCP )) == 0 )
01190         DisplayLog( <span class="stringliteral">"TRANS READ_EXPORT: WARNING: /!\\ Empty protocol list"</span> );      
01191       
01192       set_options |= FLAG_EXPORT_TRANS_PROTO;
01193       
01194     }
01195     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a8">CONF_EXPORT_ANON_ROOT</a> ) )
01196     {
01197       
01198       <span class="keywordtype">long</span> <span class="keywordtype">int</span> anon_uid ;
01199       <span class="keywordtype">char</span> * end_ptr;
01200       
01201       <span class="comment">/* check if it has not already been set */</span>
01202       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_ANON_ROOT ) == FLAG_EXPORT_ANON_ROOT )
01203       {
01204         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a8">CONF_EXPORT_ANON_ROOT</a> );
01205         <span class="keywordflow">continue</span>;
01206       }
01207       
01208       <span class="comment">/* parse and check anon_uid */</span>
01209       errno = 0;
01210 
01211       anon_uid = strtol( var_value, &amp;end_ptr, 10 );
01212       
01213       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01214       {
01215         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid Anonymous_root_uid: \"%s\""</span>, var_value );
01216         err_flag = TRUE;
01217         <span class="keywordflow">continue</span>;
01218       }
01219       
01220       <span class="comment">/* set anon_uid */</span>
01221       
01222       p_entry-&gt;anonymous_uid = (uid_t) anon_uid;
01223       
01224       set_options |= FLAG_EXPORT_ANON_ROOT;
01225       
01226     }
01227     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a11">CONF_EXPORT_SECTYPE</a> ) )
01228     {
01229 <span class="preprocessor">#     define MAX_SECTYPE      10  </span><span class="comment">/* large enough !!! */</span>
01230 <span class="preprocessor">#     define MAX_SECTYPE_LEN  256 </span><span class="comment">/* so is it !!! */</span>
01231       
01232       <span class="keywordtype">char</span> * sec_list[ MAX_SECTYPE ];
01233       <span class="keywordtype">int</span> idx,count;
01234       
01235       
01236       <span class="comment">/* check if it has not already been set */</span>
01237       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_SECTYPE ) == FLAG_EXPORT_SECTYPE )
01238       {
01239         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a11">CONF_EXPORT_SECTYPE</a> );
01240         <span class="keywordflow">continue</span>;
01241       }
01242       
01243       <span class="comment">/* reset security flags (clean defaults) */</span>
01244       p_entry-&gt;options &amp;= ~( EXPORT_OPTION_AUTH_NONE
01245                              | EXPORT_OPTION_AUTH_UNIX
01246                              | EXPORT_OPTION_RPCSEC_GSS_NONE
01247                              | EXPORT_OPTION_RPCSEC_GSS_INTG
01248                              | EXPORT_OPTION_RPCSEC_GSS_PRIV );
01249 
01250       
01251       <span class="comment">/* allocate sec strings */</span>
01252       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_SECTYPE ; idx++ )
01253         sec_list[idx] = (<span class="keywordtype">char</span> *)Mem_Alloc( <a class="code" href="exports_8c.html#a59">MAX_SECTYPE_LEN</a> );
01254       
01255       <span class="comment">/*</span>
01256 <span class="comment">       * Search for coma-separated list of sectypes</span>
01257 <span class="comment">       */</span>
01258       count = <a class="code" href="exports_8c.html#a67">nfs_ParseConfLine</a>( sec_list, <a class="code" href="exports_8c.html#a58">MAX_SECTYPE</a>,
01259                               var_value, find_comma, find_endLine ) ;
01260       
01261       <span class="keywordflow">if</span> ( count &lt; 0 )
01262       {
01263         err_flag = TRUE;        
01264         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: SecType list too long (&gt;%d)"</span>,
01265                       <a class="code" href="exports_8c.html#a58">MAX_SECTYPE</a> );
01266 
01267         <span class="comment">/* free sec strings */</span>
01268         <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_SECTYPE ; idx++ )
01269           Mem_Free( (caddr_t) sec_list[idx] );
01270 
01271         <span class="keywordflow">continue</span>;
01272       }
01273       
01274       <span class="comment">/* add each sectype flag to the option field.  */</span>
01275       
01276       <span class="keywordflow">for</span> ( idx = 0; idx &lt; count; idx++ )
01277       {
01278         <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( sec_list[idx], <span class="stringliteral">"none"</span> ) )
01279         {
01280           p_entry-&gt;options |= EXPORT_OPTION_AUTH_NONE;
01281         }
01282         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( sec_list[idx], <span class="stringliteral">"sys"</span> ) )
01283         {
01284           p_entry-&gt;options |= EXPORT_OPTION_AUTH_UNIX;
01285         }
01286         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( sec_list[idx], <span class="stringliteral">"krb5"</span> ) )
01287         {
01288           p_entry-&gt;options |= EXPORT_OPTION_RPCSEC_GSS_NONE;
01289         }
01290         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( sec_list[idx], <span class="stringliteral">"krb5i"</span> ) )
01291         {
01292           p_entry-&gt;options |= EXPORT_OPTION_RPCSEC_GSS_INTG;
01293         }
01294         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( sec_list[idx], <span class="stringliteral">"krb5p"</span> ) )
01295         {
01296           p_entry-&gt;options |= EXPORT_OPTION_RPCSEC_GSS_PRIV;
01297         }    
01298         <span class="keywordflow">else</span>
01299         {
01300           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid SecType \"%s\". Values can be: none, sys, krb5, krb5i, krb5p."</span>, sec_list[idx] );
01301           err_flag = TRUE;
01302         }
01303       }
01304       
01305       <span class="comment">/* free sec strings */</span>
01306       <span class="keywordflow">for</span> ( idx = 0; idx &lt; MAX_SECTYPE ; idx++ )
01307         Mem_Free( (caddr_t) sec_list[idx] );
01308 
01309       <span class="comment">/* check that at least one sectype has been specified */</span>      
01310       <span class="keywordflow">if</span> ( ( p_entry-&gt;options &amp; ( EXPORT_OPTION_AUTH_NONE
01311                                 | EXPORT_OPTION_AUTH_UNIX
01312                                 | EXPORT_OPTION_RPCSEC_GSS_NONE
01313                                 | EXPORT_OPTION_RPCSEC_GSS_INTG
01314                                 | EXPORT_OPTION_RPCSEC_GSS_PRIV )) == 0 )
01315         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: WARNING: /!\\ Empty SecType"</span> );
01316       
01317       
01318       set_options |= FLAG_EXPORT_SECTYPE;      
01319       
01320     }
01321     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a12">CONF_EXPORT_MAX_READ</a> ) )
01322     {
01323       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01324       <span class="keywordtype">char</span> * end_ptr;
01325       
01326       <span class="comment">/* check if it has not already been set */</span>
01327       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_MAX_READ ) == FLAG_EXPORT_MAX_READ )
01328       {
01329         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a12">CONF_EXPORT_MAX_READ</a> );
01330         <span class="keywordflow">continue</span>;
01331       }
01332       
01333       errno = 0;
01334       size = strtoll( var_value, &amp;end_ptr, 10 );
01335       
01336       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01337       {
01338         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid MaxRead: \"%s\""</span>, var_value );
01339         err_flag = TRUE;
01340         <span class="keywordflow">continue</span>;
01341       }
01342       
01343       <span class="keywordflow">if</span> ( size &lt; 0 )
01344       {
01345         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: MaxRead out of range: %lld"</span>, size );
01346         err_flag = TRUE;
01347         <span class="keywordflow">continue</span>;
01348       }
01349       
01350       <span class="comment">/* set filesystem_id */</span>
01351       
01352       p_entry-&gt;MaxRead = (fsal_size_t) size;
01353       p_entry-&gt;options |= EXPORT_OPTION_MAXREAD;
01354       
01355       set_options |= FLAG_EXPORT_MAX_READ;
01356     }
01357     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a13">CONF_EXPORT_MAX_WRITE</a> ) )
01358     {
01359       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01360       <span class="keywordtype">char</span> * end_ptr;
01361       
01362       <span class="comment">/* check if it has not already been set */</span>
01363       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_MAX_WRITE ) == FLAG_EXPORT_MAX_WRITE )
01364       {
01365         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a13">CONF_EXPORT_MAX_WRITE</a> );
01366         <span class="keywordflow">continue</span>;
01367       }
01368       
01369       errno = 0;
01370       size = strtoll( var_value, &amp;end_ptr, 10 );
01371       
01372       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01373       {
01374         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid MaxWrite: \"%s\""</span>, var_value );
01375         err_flag = TRUE;
01376         <span class="keywordflow">continue</span>;
01377       }
01378       
01379       <span class="keywordflow">if</span> ( size &lt; 0 )
01380       {
01381         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: MaxWrite out of range: %lld"</span>, size );
01382         err_flag = TRUE;
01383         <span class="keywordflow">continue</span>;
01384       }
01385       
01386       <span class="comment">/* set filesystem_id */</span>
01387       
01388       p_entry-&gt;MaxWrite = (fsal_size_t) size;
01389       p_entry-&gt;options |= EXPORT_OPTION_MAXWRITE;
01390       
01391       set_options |= FLAG_EXPORT_MAX_WRITE;
01392     }
01393     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a14">CONF_EXPORT_PREF_READ</a> ) )
01394     {
01395       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01396       <span class="keywordtype">char</span> * end_ptr;
01397       
01398       <span class="comment">/* check if it has not already been set */</span>
01399       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PREF_READ ) == FLAG_EXPORT_PREF_READ )
01400       {
01401         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a14">CONF_EXPORT_PREF_READ</a> );
01402         <span class="keywordflow">continue</span>;
01403       }
01404       
01405       errno = 0;
01406       size = strtoll( var_value, &amp;end_ptr, 10 );
01407       
01408       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01409       {
01410         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid PrefRead: \"%s\""</span>, var_value );
01411         err_flag = TRUE;
01412         <span class="keywordflow">continue</span>;
01413       }
01414       
01415       <span class="keywordflow">if</span> ( size &lt; 0 )
01416       {
01417         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: PrefRead out of range: %lld"</span>, size );
01418         err_flag = TRUE;
01419         <span class="keywordflow">continue</span>;
01420       }
01421       
01422       <span class="comment">/* set filesystem_id */</span>
01423       
01424       p_entry-&gt;PrefRead = (fsal_size_t) size;
01425       p_entry-&gt;options |= EXPORT_OPTION_PREFREAD;
01426       
01427       set_options |= FLAG_EXPORT_PREF_READ;
01428     }
01429     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a15">CONF_EXPORT_PREF_WRITE</a> ) )
01430     {
01431       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01432       <span class="keywordtype">char</span> * end_ptr;
01433       
01434       <span class="comment">/* check if it has not already been set */</span>
01435       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PREF_WRITE ) == FLAG_EXPORT_PREF_WRITE )
01436       {
01437         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a15">CONF_EXPORT_PREF_WRITE</a> );
01438         <span class="keywordflow">continue</span>;
01439       }
01440       
01441       errno = 0;
01442       size = strtoll( var_value, &amp;end_ptr, 10 );
01443       
01444       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01445       {
01446         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid PrefWrite: \"%s\""</span>, var_value );
01447         err_flag = TRUE;
01448         <span class="keywordflow">continue</span>;
01449       }
01450       
01451       <span class="keywordflow">if</span> ( size &lt; 0 )
01452       {
01453         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: PrefWrite out of range: %lld"</span>, size );
01454         err_flag = TRUE;
01455         <span class="keywordflow">continue</span>;
01456       }
01457       
01458       <span class="comment">/* set filesystem_id */</span>
01459       
01460       p_entry-&gt;PrefWrite = (fsal_size_t) size;
01461       p_entry-&gt;options |= EXPORT_OPTION_PREFWRITE;
01462       
01463       set_options |= FLAG_EXPORT_PREF_WRITE;
01464     }
01465     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a16">CONF_EXPORT_PREF_READDIR</a> ) )
01466     {
01467       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01468       <span class="keywordtype">char</span> * end_ptr;
01469       
01470       <span class="comment">/* check if it has not already been set */</span>
01471       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PREF_READDIR ) == FLAG_EXPORT_PREF_READDIR )
01472       {
01473         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a16">CONF_EXPORT_PREF_READDIR</a> );
01474         <span class="keywordflow">continue</span>;
01475       }
01476       
01477       errno = 0;
01478       size = strtoll( var_value, &amp;end_ptr, 10 );
01479       
01480       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01481       {
01482         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid PrefReaddir: \"%s\""</span>, var_value );
01483         err_flag = TRUE;
01484         <span class="keywordflow">continue</span>;
01485       }
01486       
01487       <span class="keywordflow">if</span> ( size &lt; 0 )
01488       {
01489         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: PrefReaddir out of range: %lld"</span>, size );
01490         err_flag = TRUE;
01491         <span class="keywordflow">continue</span>;
01492       }
01493       
01494       <span class="comment">/* set filesystem_id */</span>
01495       
01496       p_entry-&gt;PrefReaddir = (fsal_size_t) size;
01497       p_entry-&gt;options |= EXPORT_OPTION_PREFRDDIR;
01498       
01499       set_options |= FLAG_EXPORT_PREF_READDIR;
01500     }
01501     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a15">CONF_EXPORT_PREF_WRITE</a> ) )
01502     {
01503       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> size ;
01504       <span class="keywordtype">char</span> * end_ptr;
01505       
01506       <span class="comment">/* check if it has not already been set */</span>
01507       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PREF_WRITE ) == FLAG_EXPORT_PREF_WRITE )
01508       {
01509         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a15">CONF_EXPORT_PREF_WRITE</a> );
01510         <span class="keywordflow">continue</span>;
01511       }
01512       
01513       errno = 0;
01514       size = strtoll( var_value, &amp;end_ptr, 10 );
01515       
01516       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01517       {
01518         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid PrefWrite: \"%s\""</span>, var_value );
01519         err_flag = TRUE;
01520         <span class="keywordflow">continue</span>;
01521       }
01522       
01523       <span class="keywordflow">if</span> ( size &lt; 0 )
01524       {
01525         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: PrefWrite out of range: %lld"</span>, size );
01526         err_flag = TRUE;
01527         <span class="keywordflow">continue</span>;
01528       }
01529       
01530       <span class="comment">/* set filesystem_id */</span>
01531       
01532       p_entry-&gt;PrefWrite = (fsal_size_t) size;
01533       p_entry-&gt;options |= EXPORT_OPTION_PREFWRITE;
01534       
01535       set_options |= FLAG_EXPORT_PREF_WRITE;
01536 
01537     }
01538     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a17">CONF_EXPORT_FSID</a> ) )
01539     {
01540       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> major, minor ;
01541       <span class="keywordtype">char</span> * end_ptr;
01542       
01543       <span class="comment">/* check if it has not already been set */</span>
01544       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_FSID ) == FLAG_EXPORT_FSID )
01545       {
01546         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a17">CONF_EXPORT_FSID</a> );
01547         <span class="keywordflow">continue</span>;
01548       }
01549       
01550       <span class="comment">/* parse and check filesystem id */</span>
01551       errno = 0;
01552       major = strtoll( var_value, &amp;end_ptr, 10 );
01553       
01554       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'.'</span> || errno != 0 )
01555       {
01556         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid filesystem_id: \"%s\""</span>, var_value );
01557         err_flag = TRUE;
01558         <span class="keywordflow">continue</span>;
01559       }
01560       
01561       end_ptr++; <span class="comment">/* the first character after the dot */</span>
01562       
01563       errno = 0;
01564       minor = strtoll( end_ptr, &amp;end_ptr, 10 );
01565       
01566       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01567       {
01568         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid filesystem_id: \"%s\""</span>, var_value );
01569         err_flag = TRUE;
01570         <span class="keywordflow">continue</span>;
01571       }
01572       
01573       <span class="keywordflow">if</span> ( major &lt; 0  || minor &lt; 0 )
01574       {
01575         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: filesystem_id out of range: %lld.%lld"</span>, major, minor );
01576         err_flag = TRUE;
01577         <span class="keywordflow">continue</span>;
01578       }
01579       
01580       <span class="comment">/* set filesystem_id */</span>
01581       
01582       p_entry-&gt;filesystem_id.major = (fsal_u64_t) major;
01583       p_entry-&gt;filesystem_id.minor = (fsal_u64_t) minor;
01584       
01585       set_options |= FLAG_EXPORT_FSID;
01586       
01587     }
01588     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a18">CONF_EXPORT_NOSUID</a> ) )
01589     {
01590       <span class="comment">/* check if it has not already been set */</span>
01591       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_NOSUID ) == FLAG_EXPORT_NOSUID )
01592       {
01593         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a18">CONF_EXPORT_NOSUID</a> );
01594         <span class="keywordflow">continue</span>;
01595       }
01596       
01597       <span class="keywordflow">switch</span>( StrToBoolean ( var_value ) )
01598       {
01599         <span class="keywordflow">case</span> 1:
01600           p_entry-&gt;options |= EXPORT_OPTION_NOSUID;
01601           <span class="keywordflow">break</span>;
01602           
01603         <span class="keywordflow">case</span> 0:
01604           <span class="comment">/*default (false)*/</span>
01605           <span class="keywordflow">break</span>;
01606           
01607         <span class="keywordflow">default</span>: <span class="comment">/* error */</span>
01608         {
01609           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid value for %s (%s): TRUE or FALSE expected."</span>,var_name, var_value );
01610           err_flag = TRUE;
01611           <span class="keywordflow">continue</span>;
01612         }
01613       }
01614       
01615       set_options |= FLAG_EXPORT_NOSUID;
01616       
01617     }
01618     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a19">CONF_EXPORT_NOSGID</a> ) )
01619     {
01620       <span class="comment">/* check if it has not already been set */</span>
01621       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_NOSGID ) == FLAG_EXPORT_NOSGID )
01622       {
01623         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a19">CONF_EXPORT_NOSGID</a> );
01624         <span class="keywordflow">continue</span>;
01625       }
01626       
01627       <span class="keywordflow">switch</span>( StrToBoolean ( var_value ) )
01628       {
01629         <span class="keywordflow">case</span> 1:
01630           p_entry-&gt;options |= EXPORT_OPTION_NOSGID;
01631           <span class="keywordflow">break</span>;
01632           
01633         <span class="keywordflow">case</span> 0:
01634           <span class="comment">/*default (false)*/</span>
01635           <span class="keywordflow">break</span>;
01636         
01637         <span class="keywordflow">default</span>: <span class="comment">/* error */</span>
01638           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid value for %s (%s): TRUE or FALSE expected."</span>,var_name, var_value );
01639           err_flag = TRUE;
01640           <span class="keywordflow">continue</span>;
01641       }
01642       
01643       set_options |= FLAG_EXPORT_NOSGID;
01644     }
01645     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(  ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a20">CONF_EXPORT_PRIVILEGED_PORT</a> ) )
01646     {
01647       <span class="comment">/* check if it has not already been set */</span>
01648       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_PRIVILEGED_PORT ) == FLAG_EXPORT_PRIVILEGED_PORT )
01649       {
01650         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a44">FLAG_EXPORT_PRIVILEGED_PORT</a> );
01651         <span class="keywordflow">continue</span>;
01652       }
01653       
01654       <span class="keywordflow">switch</span>( StrToBoolean ( var_value ) )
01655         {
01656         <span class="keywordflow">case</span> 1:
01657           p_entry-&gt;options |= EXPORT_OPTION_PRIVILEGED_PORT ;
01658           <span class="keywordflow">break</span>;
01659 
01660         <span class="keywordflow">case</span> 0:
01661           <span class="comment">/*default (false)*/</span>
01662           <span class="keywordflow">break</span>;
01663 
01664         <span class="keywordflow">default</span>: <span class="comment">/* error */</span>
01665           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid value for '%s' (%s): TRUE or FALSE expected."</span>, var_name, var_value );
01666           err_flag = TRUE;
01667           <span class="keywordflow">continue</span>;
01668         }
01669       set_options |= FLAG_EXPORT_PRIVILEGED_PORT ;
01670     }
01671     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(  ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a21">CONF_EXPORT_USE_DATACACHE</a> ) ) 
01672     {
01673       <span class="comment">/* check if it has not already been set */</span>
01674       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_USE_DATACACHE ) == FLAG_EXPORT_USE_DATACACHE )
01675       {
01676         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a45">FLAG_EXPORT_USE_DATACACHE</a> );
01677         <span class="keywordflow">continue</span>;
01678       }
01679       
01680       <span class="keywordflow">switch</span>( StrToBoolean ( var_value ) )
01681         {
01682         <span class="keywordflow">case</span> 1:
01683           p_entry-&gt;options |= EXPORT_OPTION_USE_DATACACHE ;
01684           <span class="keywordflow">break</span>;
01685 
01686         <span class="keywordflow">case</span> 0:
01687           <span class="comment">/*default (false)*/</span>
01688           <span class="keywordflow">break</span>;
01689 
01690         <span class="keywordflow">default</span>: <span class="comment">/* error */</span>
01691           DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid value for '%s' (%s): TRUE or FALSE expected."</span>, var_name,var_value );
01692           err_flag = TRUE;
01693           <span class="keywordflow">continue</span>;
01694         }
01695       set_options |= FLAG_EXPORT_USE_DATACACHE ;
01696     }
01697     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a22">CONF_EXPORT_FS_SPECIFIC</a> ) )
01698     {
01699       <span class="comment">/* check if it has not already been set */</span>
01700       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_FS_SPECIFIC) == FLAG_EXPORT_FS_SPECIFIC )
01701       {
01702         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a22">CONF_EXPORT_FS_SPECIFIC</a> );
01703         <span class="keywordflow">continue</span>;
01704       }
01705       
01706       strncpy( p_entry-&gt;FS_specific, var_value, MAXPATHLEN );
01707       
01708       set_options |= FLAG_EXPORT_FS_SPECIFIC;
01709       
01710     }
01711     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a23">CONF_EXPORT_FS_TAG</a> ) )
01712     {
01713       <span class="comment">/* check if it has not already been set */</span>
01714       <span class="keywordflow">if</span> ( ( set_options &amp; FLAG_EXPORT_FS_TAG) == FLAG_EXPORT_FS_TAG )
01715       {
01716         <a class="code" href="exports_8c.html#a51">DEFINED_TWICE_WARNING</a>( <a class="code" href="exports_8c.html#a23">CONF_EXPORT_FS_TAG</a> );
01717         <span class="keywordflow">continue</span>;
01718       }
01719 
01720       strncpy( p_entry-&gt;FS_tag, var_value, MAXPATHLEN );
01721 
01722       set_options |= FLAG_EXPORT_FS_TAG;
01723 
01724     }
01725    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a24">CONF_EXPORT_MAX_OFF_WRITE</a> ) )
01726     {
01727       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> offset ;
01728       <span class="keywordtype">char</span> * end_ptr;
01729       
01730       
01731       errno = 0;
01732       offset = strtoll( var_value, &amp;end_ptr, 10 );
01733       
01734       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01735       {
01736         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid MaxOffsetWrite: \"%s\""</span>, var_value );
01737         err_flag = TRUE;
01738         <span class="keywordflow">continue</span>;
01739       }
01740       
01741       <span class="comment">/* set filesystem_id */</span>
01742       
01743       p_entry-&gt;MaxOffsetWrite = (fsal_size_t) offset;
01744       p_entry-&gt;options  |= EXPORT_OPTION_MAXOFFSETWRITE ;
01745 
01746       set_options |= FLAG_EXPORT_MAX_OFF_WRITE ;
01747 
01748     }
01749    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a26">CONF_EXPORT_MAX_CACHE_SIZE</a> ) )
01750     {
01751       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> offset ;
01752       <span class="keywordtype">char</span> * end_ptr;
01753       
01754       
01755       errno = 0;
01756       offset = strtoll( var_value, &amp;end_ptr, 10 );
01757       
01758       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01759       {
01760         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid MaxCacheSize: \"%s\""</span>, var_value );
01761         err_flag = TRUE;
01762         <span class="keywordflow">continue</span>;
01763       }
01764       
01765       <span class="comment">/* set filesystem_id */</span>
01766       
01767       p_entry-&gt;MaxCacheSize = (fsal_size_t) offset;
01768       p_entry-&gt;options  |= EXPORT_OPTION_MAXCACHESIZE ;
01769 
01770       set_options |= FLAG_EXPORT_MAX_CACHE_SIZE ;
01771 
01772     }
01773      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( var_name, <a class="code" href="exports_8c.html#a25">CONF_EXPORT_MAX_OFF_READ</a> ) )
01774     {
01775       <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> offset ;
01776       <span class="keywordtype">char</span> * end_ptr;
01777       
01778       
01779       errno = 0;
01780       offset = strtoll( var_value, &amp;end_ptr, 10 );
01781       
01782       <span class="keywordflow">if</span> ( end_ptr == NULL || *end_ptr != <span class="charliteral">'\0'</span> || errno != 0 )
01783       {
01784         DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid MaxOffsetRead: \"%s\""</span>, var_value );
01785         err_flag = TRUE;
01786         <span class="keywordflow">continue</span>;
01787       }
01788       
01789       <span class="comment">/* set filesystem_id */</span>
01790       
01791       p_entry-&gt;MaxOffsetRead = (fsal_size_t) offset;
01792       p_entry-&gt;options  |= EXPORT_OPTION_MAXOFFSETREAD ;
01793 
01794       set_options |= FLAG_EXPORT_MAX_OFF_READ ;
01795 
01796     }
01797     <span class="keywordflow">else</span>
01798     {
01799       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: WARNING: Unknown option: %s"</span>, var_name );
01800     }
01801      
01802   }
01803   
01804   
01807   <span class="keywordflow">if</span> ( ( set_options &amp; mandatory_options ) != mandatory_options )
01808   {    
01809     <span class="keywordflow">if</span> ( (set_options &amp; FLAG_EXPORT_ID ) != FLAG_EXPORT_ID ) 
01810       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Missing mandatory parameter %s"</span>,<a class="code" href="exports_8c.html#a2">CONF_EXPORT_ID</a> );
01811     
01812     <span class="keywordflow">if</span> ( (set_options &amp; FLAG_EXPORT_PATH ) != FLAG_EXPORT_PATH )
01813       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Missing mandatory parameter %s"</span>,<a class="code" href="exports_8c.html#a3">CONF_EXPORT_PATH</a> );
01814     
01815 
01816     <span class="keywordflow">if</span> ( (set_options &amp; FLAG_EXPORT_ROOT_OR_ACCESS ) != FLAG_EXPORT_ROOT_OR_ACCESS )
01817       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Missing mandatory parameter %s or %s"</span>,
01818           <a class="code" href="exports_8c.html#a4">CONF_EXPORT_ROOT</a>, <a class="code" href="exports_8c.html#a5">CONF_EXPORT_ACCESS</a> );
01819     
01820     <span class="keywordflow">if</span> ( (set_options &amp; FLAG_EXPORT_PSEUDO ) != FLAG_EXPORT_PSEUDO )
01821       DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Missing mandatory parameter %s"</span>, <a class="code" href="exports_8c.html#a6">CONF_EXPORT_PSEUDO</a> );
01822         
01823     err_flag = TRUE;    
01824   }
01825   
01826   <span class="comment">/* check if there had any error.</span>
01827 <span class="comment">   * if so, free the p_entry and return an error.</span>
01828 <span class="comment">   */</span>
01829   <span class="keywordflow">if</span> ( err_flag )
01830   {
01831     Mem_Free( p_entry );
01832     <span class="keywordflow">return</span> -1;
01833   }
01834   
01835   *pp_export = p_entry;
01836   
01837   DisplayLogLevel( NIV_EVENT,
01838       <span class="stringliteral">"NFS READ_EXPORT: Export %d (%s) successfully parsed"</span>,
01839       p_entry-&gt;id, p_entry-&gt;fullpath );
01840   
01841   <span class="keywordflow">return</span> 0;
01842   
01843 }
01844 
01845 
01846 
01852 <span class="keyword">static</span>  <span class="keywordtype">char</span> * client_root_access [] = { <span class="stringliteral">"*"</span> };
01853 
01854 
<a name="l01855"></a><a class="code" href="exports_8c.html#a72">01855</a> exportlist_t * <a class="code" href="exports_8c.html#a72">BuildDefaultExport</a>()
01856 {
01857   exportlist_t * p_entry;
01858   <span class="keywordtype">int</span> i, rc;
01859     
01860   <span class="comment">/* allocates new export entry */</span>
01861   p_entry = (exportlist_t *)Mem_Alloc( <span class="keyword">sizeof</span>( exportlist_t ));
01862   
01863   <span class="keywordflow">if</span> ( p_entry == NULL ) <span class="keywordflow">return</span> NULL;
01864   
01867   p_entry-&gt;next                = NULL;
01868   p_entry-&gt;options             = 0;
01869   p_entry-&gt;status              = EXPORTLIST_OK ;
01870   p_entry-&gt;clients.num_clients = 0 ;
01871   p_entry-&gt;access_type         = ACCESSTYPE_RW ;  
01872   p_entry-&gt;anonymous_uid       = (uid_t)-2;
01873   p_entry-&gt;MaxOffsetWrite      = (fsal_off_t)0 ;
01874   p_entry-&gt;MaxOffsetRead       = (fsal_off_t)0 ;
01875   p_entry-&gt;MaxCacheSize        = (fsal_off_t)0 ;
01876   
01877   <span class="comment">/* by default, we support auth_none and auth_sys */</span>
01878   p_entry-&gt;options |= EXPORT_OPTION_AUTH_NONE | EXPORT_OPTION_AUTH_UNIX ;
01879 
01880   <span class="comment">/* by default, we support both NFS versions and transport protocols */</span>
01881   p_entry-&gt;options |= EXPORT_OPTION_NFSV2 | EXPORT_OPTION_NFSV3 | EXPORT_OPTION_NFSV4 ;
01882   p_entry-&gt;options |= EXPORT_OPTION_UDP | EXPORT_OPTION_TCP ;
01883   
01884   p_entry-&gt;filesystem_id.major = (fsal_u64_t)101;
01885   p_entry-&gt;filesystem_id.minor = (fsal_u64_t)101;  
01886 
01888   p_entry-&gt;MaxWrite = (fsal_size_t)4096 ;
01889   p_entry-&gt;MaxRead  = (fsal_size_t)4096 ;
01890 
01891   strcpy( p_entry-&gt;FS_specific, <span class="stringliteral">""</span> );
01892   strcpy( p_entry-&gt;FS_tag, <span class="stringliteral">"ganesha"</span> );
01893     
01894   p_entry-&gt;id = 1;
01895   
01896   strcpy( p_entry-&gt;fullpath, <span class="stringliteral">"/"</span> );      
01897   strcpy(p_entry-&gt;dirname, <span class="stringliteral">"/"</span> );
01898   strcpy(p_entry-&gt;fsname, <span class="stringliteral">""</span> );
01899   strcpy( p_entry-&gt;pseudopath, <span class="stringliteral">"/"</span> );
01900         
01904   rc = nfs_AddClientsToExportList( p_entry, 
01905                                   1,
01906                                   client_root_access,
01907                                   EXPORT_OPTION_ROOT );
01908       
01909   <span class="keywordflow">if</span> ( rc != 0 )
01910   {
01911     DisplayLog( <span class="stringliteral">"NFS READ_EXPORT: ERROR: Invalid client \"%s\""</span>,
01912                 client_root_access );
01913     <span class="keywordflow">return</span> NULL;
01914   }
01915       
01916 
01917   DisplayLogLevel( NIV_EVENT,
01918       <span class="stringliteral">"NFS READ_EXPORT: Export %d (%s) successfully parsed"</span>,
01919       p_entry-&gt;id, p_entry-&gt;fullpath );
01920   
01921   <span class="keywordflow">return</span> p_entry;
01922   
01923 } <span class="comment">/* BuildDefaultExport */</span>
01924 
01925 
01926 
01927 
01928 
01929 
01930 
01931 
01932 
01933 
<a name="l01940"></a><a class="code" href="exports_8c.html#a73">01940</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a73">ReadExports</a> ( config_file_t   in_config, <span class="comment">/* The file that contains the export list */</span>
01941                   exportlist_t ** ppexportlist ) <span class="comment">/* Pointer to the export list */</span>
01942 {
01943 
01944  <span class="keywordtype">int</span> blk_idx, nb_blk, rc, i;
01945  <span class="keywordtype">char</span> * blk_name;
01946  <span class="keywordtype">int</span> err_flag = FALSE;
01947  
01948  exportlist_t * p_export_item;
01949  exportlist_t * p_export_last = NULL ;
01950  
01951  <span class="keywordtype">int</span> nb_entries = 0;
01952  
01953  <span class="keywordflow">if</span> ( !ppexportlist ) 
01954    <span class="keywordflow">return</span> -EFAULT; 
01955   
01956  *ppexportlist = NULL ;
01957  
01958  <span class="comment">/* get the number of blocks in the configuration file */</span>
01959  nb_blk = config_GetNbBlocks( in_config );
01960  
01961  <span class="keywordflow">if</span> ( nb_blk &lt; 0 ) 
01962    <span class="keywordflow">return</span> -1;
01963  
01964  <span class="comment">/* Iteration on config file blocks. */</span>
01965  <span class="keywordflow">for</span> ( i=0; i&lt; nb_blk; i++ )
01966  {
01967    <span class="comment">/* get the name of the block */</span>
01968    blk_name = config_GetBlockName( in_config , i );
01969    
01970    <span class="keywordflow">if</span> ( blk_name == NULL ) <span class="keywordflow">return</span> -1;
01971    
01972    <span class="keywordflow">if</span> ( ! <a class="code" href="exports_8c.html#a0">STRCMP</a>( blk_name, <a class="code" href="exports_8c.html#a1">CONF_LABEL_EXPORT</a> ) )
01973    {
01974      
01975      rc = BuildExportEntry( in_config, i, &amp;p_export_item );
01976      
01977      <span class="comment">/* If the entry is errorneous, ignore it</span>
01978 <span class="comment">      * and continue checking syntax of other entries.</span>
01979 <span class="comment">      */</span>
01980      <span class="keywordflow">if</span> ( rc != 0 )
01981        {
01982          err_flag = TRUE;
01983          <span class="keywordflow">continue</span>;
01984        }
01985      
01986      p_export_item-&gt;next = NULL;
01987      
01988      <span class="keywordflow">if</span> ( *ppexportlist == NULL )
01989      {
01990        *ppexportlist = p_export_item;
01991      }
01992      <span class="keywordflow">else</span>
01993      {
01994        p_export_last-&gt;next = p_export_item;
01995      }
01996      p_export_last = p_export_item;
01997 
01998      nb_entries ++;
01999      
02000    }
02001 
02002  }
02003  
02004  <span class="keywordflow">if</span> ( err_flag )
02005  { 
02006    <span class="keywordflow">return</span> -1;
02007  }
02008  <span class="keywordflow">else</span>
02009    <span class="keywordflow">return</span> nb_entries;
02010 }
02011 
<a name="l02030"></a><a class="code" href="exports_8c.html#a74">02030</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a74">nfs_export_check_access</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                addr,
02031                              <span class="keyword">struct</span> svc_req            * ptr_req,
02032                              exportlist_t              * pexport,
02033                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nfs_prog,
02034                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                mnt_prog,
02035                              hash_table_t              * ht_ip_stats,
02036                              nfs_ip_stats_t            * ip_stats_pool,
02037                              exportlist_client_entry_t * pclient_found )
02038 {
02039   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         i ;
02040   <span class="keywordtype">int</span>                  rc ;
02041   <span class="keywordtype">char</span>                 hostname[MAXHOSTNAMELEN] ;
02042  
02043   <span class="comment">/* Fopr now, no matching client is found */</span>
02044   memset( pclient_found, 0, <span class="keyword">sizeof</span>( exportlist_client_entry_t ));
02045 
02046   <span class="comment">/* PROC NULL is always authorized, in all protocols */</span>
02047   <span class="keywordflow">if</span>( ptr_req-&gt;rq_proc == 0 )
02048     <span class="keywordflow">return</span> TRUE ;
02049 
02050   <span class="comment">/* If mount protocol is called, just check that AUTH_NONE is not used */</span>
02051   <span class="keywordflow">if</span>( ptr_req-&gt;rq_prog == mnt_prog )
02052     {
02053       <span class="keywordflow">if</span>( ptr_req-&gt;rq_cred.oa_flavor != AUTH_NONE ) 
02054         <span class="keywordflow">return</span> TRUE ;
02055       <span class="keywordflow">else</span>
02056         <span class="keywordflow">return</span> FALSE ;
02057     }
02058 
02059   <span class="comment">/* Increment the stats per client address */</span>
02060   <span class="keywordflow">if</span>( ( rc = <a class="code" href="nfs__ip__stats_8c.html#a7">nfs_ip_stats_incr</a>( ht_ip_stats, addr, nfs_prog, mnt_prog, ptr_req ) ) == IP_STATS_NOT_FOUND )
02061     {
02062       <span class="keywordflow">if</span>( <a class="code" href="nfs__ip__stats_8c.html#a6">nfs_ip_stats_add</a>( ht_ip_stats, addr, ip_stats_pool ) ==  IP_STATS_SUCCESS )
02063         rc = <a class="code" href="nfs__ip__stats_8c.html#a7">nfs_ip_stats_incr</a>( ht_ip_stats, addr, nfs_prog, mnt_prog, ptr_req ) ;
02064     }
02065   
02066   <span class="keywordflow">for</span>( i = 0 ; i &lt; pexport-&gt;clients.num_clients ; i++ ) 
02067     {
02068       
02069       <span class="keywordflow">switch</span>( pexport-&gt;clients.clientarray[i].type )
02070         {
02071         <span class="keywordflow">case</span> HOSTIF_CLIENT:
02072 
02073 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02074 <span class="preprocessor"></span>          printf( <span class="stringliteral">"Test host %d.%d.%d.%d = %d.%d.%d.%d ??\n"</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 24),
02075               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 16)&amp;0xFF),
02076               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 8)&amp;0xFF),
02077               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(pexport-&gt;clients.clientarray[i].client.network.netaddr &amp; 0xFF),
02078               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 24),
02079               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 16)&amp;0xFF,
02080               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 8)&amp;0xFF,
02081               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &amp; 0xFF) );          
02082 <span class="preprocessor">#endif</span>
02083 <span class="preprocessor"></span>          <span class="keywordflow">if</span>( pexport-&gt;clients.clientarray[i].client.hostif.clientaddr == addr )
02084             {
02085 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02086 <span class="preprocessor"></span>              printf(<span class="stringliteral">"This matches host adress\n"</span>);
02087 <span class="preprocessor">#endif</span>
02088 <span class="preprocessor"></span>              *pclient_found = pexport-&gt;clients.clientarray[i] ;
02089               <span class="keywordflow">return</span> TRUE ;
02090             }
02091           break ;
02092 
02093         <span class="keywordflow">case</span> NETWORK_CLIENT:
02094           
02095 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02096 <span class="preprocessor"></span>          printf( <span class="stringliteral">"Test net %d.%d.%d.%d in %d.%d.%d.%d ??\n"</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 24),
02097               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 16)&amp;0xFF),
02098               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)((pexport-&gt;clients.clientarray[i].client.network.netaddr &gt;&gt; 8)&amp;0xFF),
02099               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(pexport-&gt;clients.clientarray[i].client.network.netaddr &amp; 0xFF),
02100               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 24),
02101               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 16)&amp;0xFF,
02102               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 8)&amp;0xFF,
02103               (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &amp; 0xFF));
02104 <span class="preprocessor">#endif</span>
02105 <span class="preprocessor"></span>          
02106           <span class="keywordflow">if</span>( ( pexport-&gt;clients.clientarray[i].client.network.netmask &amp; addr)  ==  pexport-&gt;clients.clientarray[i].client.network.netaddr )
02107             {
02108 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02109 <span class="preprocessor"></span>              printf(<span class="stringliteral">"This matches network adress\n"</span>);
02110 <span class="preprocessor">#endif</span>
02111 <span class="preprocessor"></span>              *pclient_found = pexport-&gt;clients.clientarray[i] ;
02112               <span class="keywordflow">return</span> TRUE ;
02113             }
02114           break ;
02115           
02116         <span class="keywordflow">case</span> NETGROUP_CLIENT:
02117           <span class="comment">/* Try to get the entry from th IP/name cache */</span>
02118           <span class="keywordflow">if</span>( ( rc = <a class="code" href="nfs__ip__name_8c.html#a9">nfs_ip_name_get</a>( addr, hostname ) ) != IP_NAME_SUCCESS )
02119             {
02120               <span class="keywordflow">if</span>( rc == IP_NAME_NOT_FOUND )
02121                 {
02122                   <span class="comment">/* IPaddr was not cached, add it to the cache */</span>
02123                   <span class="keywordflow">if</span>( <a class="code" href="nfs__ip__name_8c.html#a8">nfs_ip_name_add</a>( addr, hostname ) != IP_NAME_SUCCESS )
02124                     {
02125                       <span class="comment">/* Major failure, name could not be resolved */</span>
02126                       break ;
02127                     }
02128                 }
02129             }
02130           
02131           <span class="comment">/* At this point 'hostname' should contain the name that was found */</span>
02132           <span class="keywordflow">if</span>( innetgr(  pexport-&gt;clients.clientarray[i].client.netgroup.netgroupname, hostname, NULL, NULL ) == 1 )
02133           {
02134             *pclient_found = pexport-&gt;clients.clientarray[i] ;
02135             <span class="keywordflow">return</span> TRUE ; 
02136           }
02137           break ;
02138           
02139 
02140         <span class="keywordflow">case</span> WILDCARDHOST_CLIENT:
02141           <span class="comment">/* Try to get the entry from th IP/name cache */</span>
02142           <span class="keywordflow">if</span>( ( rc = <a class="code" href="nfs__ip__name_8c.html#a9">nfs_ip_name_get</a>( addr, hostname ) ) != IP_NAME_SUCCESS )
02143             {
02144               <span class="keywordflow">if</span>( rc == IP_NAME_NOT_FOUND )
02145                 {
02146                   <span class="comment">/* IPaddr was not cached, add it to the cache */</span>
02147                   <span class="keywordflow">if</span>( <a class="code" href="nfs__ip__name_8c.html#a8">nfs_ip_name_add</a>( addr, hostname ) != IP_NAME_SUCCESS )
02148                     {
02149                       <span class="comment">/* Major failure, name could not be resolved */</span>
02150 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02151 <span class="preprocessor"></span>                      printf(<span class="stringliteral">"Could not resolve addr %u.%u.%u.%u\n"</span>,
02152                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 24),
02153                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 16)&amp;0xFF,
02154                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &gt;&gt; 8)&amp;0xFF,
02155                                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(addr &amp; 0xFF) );
02156 <span class="preprocessor">#endif                        </span>
02157 <span class="preprocessor"></span>                      break ;
02158                     }
02159                 }
02160             }
02161           
02162 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02163 <span class="preprocessor"></span>          printf(<span class="stringliteral">"Wildcarded hostname: testing if '%s' matches '%s'\n"</span>,
02164                   hostname, pexport-&gt;clients.clientarray[i].client.wildcard.wildcard );
02165 <span class="preprocessor">#endif                        </span>
02166 <span class="preprocessor"></span>            
02167             
02168           <span class="comment">/* At this point 'hostname' should contain the name that was found */</span>
02169           <span class="keywordflow">if</span>( fnmatch(  pexport-&gt;clients.clientarray[i].client.wildcard.wildcard, hostname, FNM_PATHNAME ) == 0 )
02170           {
02171             *pclient_found = pexport-&gt;clients.clientarray[i];
02172             <span class="keywordflow">return</span> TRUE ;
02173           }
02174           
02175 <span class="preprocessor">#ifdef _DEBUG_DISPATCH                    </span>
02176 <span class="preprocessor"></span>          printf(<span class="stringliteral">"'%s' not matching '%s'\n"</span>,
02177               hostname, pexport-&gt;clients.clientarray[i].client.wildcard.wildcard );
02178 <span class="preprocessor">#endif</span>
02179 <span class="preprocessor"></span>          
02180           break ;
02181           
02182         <span class="keywordflow">case</span> GSSPRINCIPAL_CLIENT:
02184           printf( <span class="stringliteral">"----------&gt; Unsupported type GSS_PRINCIPAL_CLIENT\n"</span> ) ;
02185           <span class="keywordflow">return</span> FALSE ;
02186           break ;
02187           
02188         <span class="keywordflow">default</span>:
02189           printf( <span class="stringliteral">"----------&gt; Unknown type \n"</span> ) ;
02190           <span class="keywordflow">return</span> FALSE ; <span class="comment">/* Should never occurs */</span>
02191           break ;
02192         } <span class="comment">/* switch */</span>
02193     } <span class="comment">/* for */</span>
02194   
02195   <span class="comment">/* If this point is reached, no matching entry was found */</span>
02196   <span class="keywordflow">return</span> FALSE ;  
02197 } <span class="comment">/* nfs_export_check_access */</span>
02198   
<a name="l02211"></a><a class="code" href="exports_8c.html#a75">02211</a> <span class="keywordtype">int</span> <a class="code" href="exports_8c.html#a75">nfs_export_create_root_entry</a>( exportlist_t *  pexportlist, hash_table_t * ht )
02212 {
02213   <span class="keyword">static</span>  <span class="keywordtype">int</span>               once = 0 ;
02214   exportlist_t            * pcurrent = NULL ;
02215   cache_inode_status_t      cache_status ;
02216   cache_content_status_t    cache_content_status ;
02217   fsal_status_t             fsal_status ;
02218   cache_inode_fsal_data_t   fsdata ;
02219   fsal_handle_t             fsal_handle ;
02220   fsal_path_t               exportpath_fsal ;
02221   fsal_mdsize_t             strsize = MNTPATHLEN + 1 ;
02222   cache_entry_t           * pentry = NULL ;
02223   fsal_staticfsinfo_t     * pstaticinfo = NULL ;
02224   fsal_op_context_t         context ;
02225   
02226   <span class="keywordflow">if</span>( once == 0 )
02227     {
02228       <span class="comment">/* setting the 'small_client' structure */</span>
02229       <a class="code" href="exports_8c.html#a62">small_client_param</a>.lru_param.nb_entry_prealloc = 10 ;
02230       <a class="code" href="exports_8c.html#a62">small_client_param</a>.lru_param.entry_to_str      = local_lru_inode_entry_to_str ;
02231       <a class="code" href="exports_8c.html#a62">small_client_param</a>.lru_param.clean_entry       = local_lru_inode_clean_entry ;
02232       <a class="code" href="exports_8c.html#a62">small_client_param</a>.nb_prealloc_entry           = 10 ;
02233       <a class="code" href="exports_8c.html#a62">small_client_param</a>.nb_pre_dir_data             = 10 ;
02234       <a class="code" href="exports_8c.html#a62">small_client_param</a>.nb_pre_parent               = 10 ;
02235       <a class="code" href="exports_8c.html#a62">small_client_param</a>.nb_pre_state_v4             = 10 ;
02236       <a class="code" href="exports_8c.html#a62">small_client_param</a>.grace_period_link           = 0 ;
02237       <a class="code" href="exports_8c.html#a62">small_client_param</a>.grace_period_attr           = 0 ;
02238       <a class="code" href="exports_8c.html#a62">small_client_param</a>.grace_period_dirent         = 0 ;
02239       <a class="code" href="exports_8c.html#a62">small_client_param</a>.use_test_access             = 1 ;
02240       <a class="code" href="exports_8c.html#a62">small_client_param</a>.attrmask                    = FSAL_ATTR_MASK_V2_V3 ; 
02241       
02242       <span class="comment">/* creating the 'small_client' */</span>
02243       <span class="keywordflow">if</span>( cache_inode_client_init( &amp;<a class="code" href="exports_8c.html#a61">small_client</a>, <a class="code" href="exports_8c.html#a62">small_client_param</a>, 255, NULL ) )
02244         {
02245           DisplayLog( <span class="stringliteral">"NFS_STARTUP: CRITICAL: small cache inode client could not be allocated, exiting..."</span> ) ;
02246           exit ( 1 ) ;
02247         }
02248       <span class="keywordflow">else</span>
02249         DisplayLog( <span class="stringliteral">"NFS STARTUP: small cache inode client successfully inited"</span> ) ;
02250 
02251       <span class="comment">/* creating the datacache client for recovering data cache */</span>
02252       <span class="keywordflow">if</span>( cache_content_client_init( &amp;<a class="code" href="exports_8c.html#a63">recover_datacache_client</a>, <a class="code" href="exports_8c.html#a60">nfs_param</a>.cache_layers_param.cache_content_client_param )  )
02253         {
02254            DisplayLog( <span class="stringliteral">"NFS_STARTUP: CRITICAL: cache content client (for datacache recovery) could not be allocated, exiting..."</span> ) ;
02255            exit( 1 ) ;
02256         }
02257 
02258       <span class="comment">/* Link together the small client and the recover_datacache_client */</span>
02259       <a class="code" href="exports_8c.html#a61">small_client</a>.pcontent_client = (<span class="keywordtype">void</span> *)&amp;recover_datacache_client ;
02260 
02261       <span class="comment">/* Get the context for FSAL super user */</span>
02262       fsal_status =  FSAL_InitClientContext( &amp;context );
02263       
02264       <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) )
02265         {
02266           DisplayLog( <span class="stringliteral">"NFS STARTUP: Couldn't get the context for FSAL super user"</span> ) ;
02267           <span class="keywordflow">return</span> FALSE ;
02268         }
02269       
02270       <span class="comment">/* loop the export list */</span>
02271 
02272       <span class="keywordflow">for</span>( pcurrent = pexportlist ; pcurrent != NULL ; pcurrent = pcurrent-&gt;next )
02273         {
02274           <span class="comment">/* Build the FSAL path */</span>
02275           <span class="keywordflow">if</span>( FSAL_IS_ERROR( ( fsal_status = FSAL_str2path( pcurrent-&gt;fullpath, 
02276                                                             strsize, 
02277                                                             &amp;exportpath_fsal ) ) ) )
02278                 <span class="keywordflow">return</span> FALSE;
02279 
02280           <span class="comment">/* inits context for the current export entry */</span>
02281           
02282           fsal_status = FSAL_BuildExportContext( &amp;pcurrent-&gt;FS_export_context, &amp;exportpath_fsal, pcurrent-&gt;FS_specific  );
02283           
02284           <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) )
02285             {
02286               DisplayLog( <span class="stringliteral">"NFS STARTUP: Couldn't build export context for %s"</span>, pcurrent-&gt;fullpath ) ;
02287               <span class="keywordflow">return</span> FALSE ;
02288             }
02289     
02290           <span class="comment">/* get the related client context */</span>
02291           fsal_status =  FSAL_GetClientContext( &amp;context, &amp;pcurrent-&gt;FS_export_context , 0, 0, NULL, 0 );
02292       
02293           <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) )
02294             {
02295               DisplayLog( <span class="stringliteral">"NFS STARTUP: Couldn't get the credentials for FSAL super user"</span> ) ;
02296               <span class="keywordflow">return</span> FALSE ;
02297             }
02298 
02299           
02300           <span class="comment">/* Lookup for the FSAL Path */</span>
02301           <span class="keywordflow">if</span>( FSAL_IS_ERROR( ( fsal_status = FSAL_lookupPath( &amp;exportpath_fsal,
02302                                                               &amp;context, 
02303                                                               &amp;fsal_handle, 
02304                                                               NULL ) ) ) )
02305             {
02306               DisplayLog( <span class="stringliteral">"NFS STARTUP: Couldn't access the root of the exported namespace, ExportId=%u Path=%s FSAL_ERROR=(%u,%u)"</span>,
02307                            pcurrent-&gt;id, pcurrent-&gt;fullpath, fsal_status.major, fsal_status.minor ) ;
02308               <span class="keywordflow">return</span> FALSE ;
02309             }
02310 
02311           <span class="comment">/* stores handle to the export entry */</span>
02312 
02313           pcurrent-&gt;proot_handle = (fsal_handle_t *)Mem_Alloc( <span class="keyword">sizeof</span>( fsal_handle_t ) ); 
02314           
02315           <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) )
02316             {
02317               DisplayLog( <span class="stringliteral">"NFS STARTUP: Couldn't allocate memory"</span> ) ;
02318               <span class="keywordflow">return</span> FALSE ;
02319             }
02320 
02321           *pcurrent-&gt;proot_handle = fsal_handle ;
02322 
02323 
02324           <span class="comment">/* Add this entry to the Cache Inode as a "root" entry */</span>
02325           fsdata.handle = fsal_handle ;
02326           fsdata.cookie = 0 ;
02327 
02328           <span class="keywordflow">if</span>( ( pentry = cache_inode_make_root( &amp;fsdata, 
02329                                                 ht, 
02330                                                 &amp;<a class="code" href="exports_8c.html#a61">small_client</a>,
02331                                                 &amp;context, 
02332                                                 &amp;cache_status ) ) == NULL )
02333             {
02334               DisplayLog( <span class="stringliteral">"NFS STARTUP: /!\\ | Error when creating root cached entry for %s, export_id=%d, cache_status=%d"</span>, 
02335                           pcurrent-&gt;fullpath, pcurrent-&gt;id, cache_status ) ;
02336               <span class="keywordflow">return</span> FALSE ;
02337             }
02338           <span class="keywordflow">else</span>
02339             DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"NFS STARTUP: Added root entry for path %s on export_id=%d"</span>,
02340                              pcurrent-&gt;fullpath, pcurrent-&gt;id ) ;
02341 
02342           <span class="comment">/* Get FSAL specific info for this entry */</span>
02343           <span class="keywordflow">if</span>( ( pstaticinfo = (fsal_staticfsinfo_t *)Mem_Alloc( ( <span class="keyword">sizeof</span>( fsal_staticfsinfo_t ) ) ) ) == NULL )
02344                 <span class="keywordflow">return</span> FALSE ;
02345 
02346           <span class="keywordflow">if</span>( FSAL_IS_ERROR( ( fsal_status = FSAL_static_fsinfo( &amp;fsal_handle, &amp;context, pstaticinfo ) ) ) )
02347                 <span class="keywordflow">return</span> FALSE ;
02348 
02349           <span class="comment">/* Attach to the exportlist entry */</span>
02350           pcurrent-&gt;fs_static_info = pstaticinfo ;
02351 
02352 <span class="preprocessor">#ifdef _CRASH_RECOVERY_AT_STARTUP</span>
02353 <span class="preprocessor"></span>          <span class="comment">/* Recover the datacache from a previous crah */</span>
02354           <span class="keywordflow">if</span>( pcurrent-&gt;options &amp; EXPORT_OPTION_USE_DATACACHE )
02355              {
02356                  DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"Recovering Data Cache for export id %u"</span>, pcurrent-&gt;id ) ;
02357                  <span class="keywordflow">if</span>( cache_content_crash_recover( pcurrent-&gt;id,
02358                                                   &amp;<a class="code" href="exports_8c.html#a63">recover_datacache_client</a>,
02359                                                   &amp;<a class="code" href="exports_8c.html#a61">small_client</a>,
02360                                                   ht,
02361                                                   &amp;context,
02362                                                   &amp;cache_content_status ) != CACHE_CONTENT_SUCCESS )
02363                    {
02364                        DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"Datacache for export id %u is not recoverable: error = %d"</span>,
02365                                         pcurrent-&gt;id, cache_content_status ) ;
02366                    }
02367              }
02368 
02369 <span class="preprocessor">#endif</span>
02370 <span class="preprocessor"></span>        }
02371 
02372       <span class="comment">/* Do not call me again */</span>
02373       once = 1 ;
02374     }
02375  
02376   <span class="keywordflow">return</span> TRUE ;
02377 } <span class="comment">/* nfs_export_create_root_entry */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:40 2008 for Support routines layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
