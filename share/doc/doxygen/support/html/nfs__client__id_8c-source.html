<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Support routines layer: nfs_client_id.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>nfs_client_id.c</h1><a href="nfs__client__id_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00082 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00084 <span class="preprocessor">#endif</span>
00085 <span class="preprocessor"></span>
00086 
00087 <span class="preprocessor">#include "HashData.h"</span>
00088 <span class="preprocessor">#include "HashTable.h"</span>
00089 <span class="preprocessor">#include "log_functions.h"</span>
00090 <span class="preprocessor">#include "stuff_alloc.h"</span>
00091 <span class="preprocessor">#include "nfs_core.h"</span>
00092 <span class="preprocessor">#include "nfs_exports.h"</span>
00093 <span class="preprocessor">#include "config_parsing.h"</span>
00094 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00095 <span class="preprocessor">#include &lt;string.h&gt;</span>
00096 <span class="preprocessor">#include "nfs4.h"</span>
00097 <span class="preprocessor">#include "SHA1.h"</span>
00098 
00099 size_t <a class="code" href="nfs__state__id_8c.html#a3">strnlen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t maxlen);
00100 
00101 <span class="comment">/* Hashtable used to cache the hostname, accessed by their IP addess */</span>
<a name="l00102"></a><a class="code" href="nfs__client__id_8c.html#a0">00102</a> hash_table_t            * ht_client_id ; 
<a name="l00103"></a><a class="code" href="nfs__client__id_8c.html#a1">00103</a> hash_table_t            * ht_client_id_reverse ; 
00104 <span class="keyword">extern</span> nfs_parameter_t    nfs_param ;
00105 
00106 
00107 
<a name="l00123"></a><a class="code" href="nfs__client__id_8c.html#a4">00123</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nfs__client__id_8c.html#a4">client_id_value_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef ) 
00124 {
00125   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hash_func ;
00126   clientid4    clientid ;
00127 
00128   clientid = *((clientid4 *)(buffclef-&gt;pdata)) ;
00129 
00130   <span class="comment">/* Sum upper and lower 32bits fields to build the key */</span>
00131   hash_func = ( (<span class="keywordtype">unsigned</span> long)( clientid &amp;0x00000000FFFFFFFFLL ) +
00132                 (<span class="keywordtype">unsigned</span> long)( clientid &gt;&gt; 32 ) ) ;
00133 
00134   <span class="keywordflow">return</span> hash_func % p_hparam-&gt;index_size ;
00135 } <span class="comment">/*  client_id_value_hash_func */</span>
00136 
00137 
<a name="l00153"></a><a class="code" href="nfs__client__id_8c.html#a5">00153</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nfs__client__id_8c.html#a5">client_id_value_hash_func_reverse</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00154 {
00155   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  sum = 0 ;
00156   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i = 0 ;
00157   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c ;
00158 
00159   <span class="comment">/* Compute the sum of all the characters */</span>
00160   <span class="keywordflow">for</span>( i = 0 , c = ((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[0] ; ((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[i] != <span class="charliteral">'\0'</span> ; c=((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[++i], sum += c ) ;
00161 
00162   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> long)( sum % p_hparam-&gt;index_size ) ;
00163 } <span class="comment">/*  client_id_reverse_value_hash_func */</span>
00164 
<a name="l00181"></a><a class="code" href="nfs__client__id_8c.html#a6">00181</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nfs__client__id_8c.html#a6">client_id_rbt_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef ) 
00182 {
00183   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hash_func ;
00184   clientid4    clientid ;
00185 
00186   clientid = *((clientid4 *)(buffclef-&gt;pdata)) ;
00187 
00188   <span class="comment">/* Xor upper and lower 32bits fields to build the key */</span>
00189   hash_func = ( (<span class="keywordtype">unsigned</span> long)( clientid &amp; 0x00000000FFFFFFFFLL ) ^ 
00190                 (<span class="keywordtype">unsigned</span> long)( clientid &gt;&gt; 32 ) ) ;
00191  
00192   <span class="keywordflow">return</span> hash_func ;
00193 } <span class="comment">/* client_id_rbt_hash_func */</span>
00194 
<a name="l00195"></a><a class="code" href="nfs__client__id_8c.html#a7">00195</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nfs__client__id_8c.html#a7">client_id_rbt_hash_func_reverse</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00196 {
00197   clientid4  result ;
00198 
00199   <span class="keywordflow">if</span>( <a class="code" href="test__clientid__full_8c.html#a0">nfs_client_id_compute</a>( (<span class="keywordtype">char</span> *)buffclef-&gt;pdata,
00200                              &amp;result ) != CLIENT_ID_SUCCESS )
00201         <span class="keywordflow">return</span> 0 ;
00202 
00203   <span class="keywordflow">return</span> ( (<span class="keywordtype">unsigned</span> long)(result &amp; 0x00000000FFFFFFFFLL ) );
00204 } <span class="comment">/* ip_name_rbt_hash_func */</span>
00205 
<a name="l00219"></a><a class="code" href="nfs__client__id_8c.html#a8">00219</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a8">compare_client_id</a>(  hash_buffer_t * buff1, hash_buffer_t * buff2 )
00220 {
00221   clientid4 cl1 = *((clientid4 *)(buff1-&gt;pdata)) ;
00222   clientid4 cl2 = *((clientid4 *)(buff2-&gt;pdata)) ;
00223   <span class="keywordflow">return</span> (cl1 == cl2)?0:1 ;
00224 } <span class="comment">/* compare_xid */</span>
00225 
<a name="l00226"></a><a class="code" href="nfs__client__id_8c.html#a9">00226</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a9">compare_client_id_reverse</a>(  hash_buffer_t * buff1, hash_buffer_t * buff2 )
00227 {
00228   <span class="keywordtype">char</span> * cl1 = (<span class="keywordtype">char</span> *)(buff1-&gt;pdata) ;
00229   <span class="keywordtype">char</span> * cl2 = (<span class="keywordtype">char</span> *)(buff2-&gt;pdata) ;
00230   <span class="keywordflow">return</span> strncmp( cl1, cl2, MAXNAMLEN ) ;
00231 } <span class="comment">/* compare_xid */</span>
00232 
00233 
<a name="l00247"></a><a class="code" href="nfs__client__id_8c.html#a10">00247</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a10">display_client_id</a>( hash_buffer_t * pbuff, <span class="keywordtype">char</span> * str ) 
00248 {
00249   clientid4 clientid ;
00250  
00251   clientid = *((clientid4 *)(pbuff-&gt;pdata)) ;
00252 
00253   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"%llu"</span>, clientid ) ;
00254 } <span class="comment">/* display_client_id */</span>
00255 
<a name="l00256"></a><a class="code" href="nfs__client__id_8c.html#a11">00256</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a11">display_client_id_reverse</a>( hash_buffer_t * pbuff, <span class="keywordtype">char</span> * str ) 
00257 {
00258   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"%s"</span>,
00259                   (<span class="keywordtype">char</span> *)(pbuff-&gt;pdata) );
00260 } <span class="comment">/* display_client_id_reverse */</span>
00261 
<a name="l00262"></a><a class="code" href="nfs__client__id_8c.html#a12">00262</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a12">display_client_id_val</a>( hash_buffer_t * pbuff, <span class="keywordtype">char</span> * str ) 
00263 {
00264    nfs_client_id_t * precord ;
00265 
00266    precord = (nfs_client_id_t *)(pbuff-&gt;pdata) ;
00267 
00268    <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"#%s#=&gt;%llu cb_prog=%u r_addr=%s r_netid=%s"</span>, 
00269                    precord-&gt;client_name, 
00270                    precord-&gt;clientid, 
00271                    precord-&gt;cb_program, 
00272                    precord-&gt;client_r_addr,
00273                    precord-&gt;client_r_netid ) ;
00274 } <span class="comment">/* display_client_id_val */</span>
00275 
<a name="l00292"></a><a class="code" href="nfs__client__id_8c.html#a13">00292</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a13">nfs_client_id_add</a>(  clientid4         clientid,
00293                         nfs_client_id_t   client_record,
00294                         nfs_client_id_t * nfs_client_id_pool )
00295 {
00296   hash_buffer_t       buffkey  ;
00297   hash_buffer_t       buffdata ;
00298   hash_buffer_t       buffkey_reverse  ;
00299   hash_buffer_t       buffdata_reverse ;
00300   nfs_client_id_t   * pnfs_client_id  = NULL ;
00301   clientid4         * pclientid = NULL ;
00302 
00303 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00304 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00305   BuddySetDebugLabel( <span class="stringliteral">"nfs_client_id_t"</span> ) ;
00306 <span class="preprocessor">#endif</span>
00307 <span class="preprocessor"></span>
00308   <span class="comment">/* Entry to be cached */</span>
00309   GET_PREALLOC( pnfs_client_id, 
00310                 nfs_client_id_pool, 
00311                 <a class="code" href="exports_8c.html#a60">nfs_param</a>.worker_param.nb_client_id_prealloc, 
00312                 nfs_client_id_t, 
00313                 next_alloc ) ;
00314 
00315 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00316 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00317   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00318 <span class="preprocessor">#endif</span>
00319 <span class="preprocessor"></span>
00320   <span class="keywordflow">if</span>( pnfs_client_id == NULL ) 
00321     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00322 
00323   <span class="keywordflow">if</span>( ( pclientid = (clientid4 *)Mem_Alloc( <span class="keyword">sizeof</span>( clientid4 ) ) ) == NULL )
00324     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00325  
00326   <span class="keywordflow">if</span>( ( buffkey_reverse.pdata = (caddr_t)Mem_Alloc( MAXNAMLEN ) ) == NULL ) 
00327     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00328 
00329   <span class="comment">/* I have to keep an integer as key, I wil use the pointer buffkey-&gt;pdata for this, </span>
00330 <span class="comment">   * this also means that buffkey-&gt;len will be 0 */</span>
00331   *pclientid = clientid ;
00332   buffkey.pdata = (caddr_t)pclientid ;
00333   buffkey.len = <span class="keyword">sizeof</span>( clientid ) ;
00334 
00335   *pnfs_client_id = client_record ;
00336   buffdata.pdata = (caddr_t)pnfs_client_id ;
00337   buffdata.len = <span class="keyword">sizeof</span>( nfs_client_id_t ) ;
00338   
00339   <span class="keywordflow">if</span>( HashTable_Test_And_Set( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a>, &amp;buffkey, &amp;buffdata, HASHTABLE_SET_HOW_SET_NO_OVERWRITE ) != HASHTABLE_SUCCESS )
00340     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00341  
00342   <span class="comment">/* Keep information in reverse hash table */</span>
00343   strncpy( (<span class="keywordtype">char</span> *)(buffkey_reverse.pdata), client_record.client_name, MAXNAMLEN ) ;
00344   buffkey_reverse.len = MAXNAMLEN ;
00345 
00346   buffdata_reverse.pdata = (caddr_t)pnfs_client_id ;
00347   buffdata_reverse.len = <span class="keyword">sizeof</span>( nfs_client_id_t ) ;
00348    
00349   <span class="keywordflow">if</span>( HashTable_Test_And_Set( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a>, &amp;buffkey_reverse, &amp;buffdata_reverse, HASHTABLE_SET_HOW_SET_NO_OVERWRITE ) != HASHTABLE_SUCCESS )
00350     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00351 
00352 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00353 <span class="preprocessor"></span>  printf( <span class="stringliteral">"-=-=-=-=-=-=-=-=-=-&gt; ht_client_id \n"</span> ) ;
00354   HashTable_Print( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a> ) ;
00355   printf( <span class="stringliteral">"-=-=-=-=-=-=-=-=-=-&gt; ht_client_id_reverse \n"</span> ) ;
00356   HashTable_Print( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a> ) ;
00357 <span class="preprocessor">#endif</span>
00358 <span class="preprocessor"></span>
00359   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS ; 
00360 } <span class="comment">/* nfs_client_id_add */</span>
00361 
<a name="l00378"></a><a class="code" href="nfs__client__id_8c.html#a14">00378</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a14">nfs_client_id_set</a>(  clientid4         clientid,
00379                         nfs_client_id_t   client_record,
00380                         nfs_client_id_t * nfs_client_id_pool )
00381 {
00382   hash_buffer_t       buffkey  ;
00383   hash_buffer_t       buffdata ;
00384   hash_buffer_t       buffkey_reverse  ;
00385   hash_buffer_t       buffdata_reverse ;
00386   nfs_client_id_t   * pnfs_client_id  = NULL ;
00387   clientid4         * pclientid = NULL ;
00388 
00389 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00390 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00391   BuddySetDebugLabel( <span class="stringliteral">"nfs_client_id_t"</span> ) ;
00392 <span class="preprocessor">#endif</span>
00393 <span class="preprocessor"></span>
00394   <span class="comment">/* Entry to be cached */</span>
00395   GET_PREALLOC( pnfs_client_id, 
00396                 nfs_client_id_pool, 
00397                 <a class="code" href="exports_8c.html#a60">nfs_param</a>.worker_param.nb_client_id_prealloc, 
00398                 nfs_client_id_t, 
00399                 next_alloc ) ;
00400 
00401 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00402 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00403   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00404 <span class="preprocessor">#endif</span>
00405 <span class="preprocessor"></span>
00406   <span class="keywordflow">if</span>( pnfs_client_id == NULL ) 
00407     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00408 
00409   <span class="keywordflow">if</span>( ( pclientid = (clientid4 *)Mem_Alloc( <span class="keyword">sizeof</span>( clientid4 ) ) ) == NULL )
00410     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00411   
00412   <span class="keywordflow">if</span>( ( buffkey_reverse.pdata = (caddr_t)Mem_Alloc( MAXNAMLEN ) ) == NULL ) 
00413     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00414   
00415   <span class="comment">/* I have to keep an integer as key, I wil use the pointer buffkey-&gt;pdata for this, </span>
00416 <span class="comment">   * this also means that buffkey-&gt;len will be 0 */</span>
00417   *pclientid = clientid ;
00418   buffkey.pdata = (caddr_t)pclientid ;
00419   buffkey.len = <span class="keyword">sizeof</span>( clientid ) ;
00420 
00421 
00422   *pnfs_client_id = client_record ;
00423   buffdata.pdata = (caddr_t)pnfs_client_id ;
00424   buffdata.len = <span class="keyword">sizeof</span>( nfs_client_id_t ) ;
00425   
00426   <span class="keywordflow">if</span>( HashTable_Test_And_Set( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a>, &amp;buffkey, &amp;buffdata, HASHTABLE_SET_HOW_SET_OVERWRITE ) != HASHTABLE_SUCCESS )
00427     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00428  
00429   <span class="comment">/* Reverse hashtable */</span>
00430   strncpy( (<span class="keywordtype">char</span> *)(buffkey_reverse.pdata), client_record.client_name, MAXNAMLEN ) ;
00431   buffkey_reverse.len = MAXNAMLEN ;
00432   
00433   buffdata_reverse.pdata = (caddr_t)pnfs_client_id ;
00434   buffdata_reverse.len = <span class="keyword">sizeof</span>( nfs_client_id_t ) ;
00435 
00436   <span class="keywordflow">if</span>( HashTable_Test_And_Set( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a>, &amp;buffkey_reverse, &amp;buffdata_reverse, HASHTABLE_SET_HOW_SET_OVERWRITE ) != HASHTABLE_SUCCESS )
00437     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00438 
00439   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS ; 
00440 } <span class="comment">/* nfs_client_id_set */</span>
00441 
<a name="l00454"></a><a class="code" href="nfs__client__id_8c.html#a15">00454</a> <span class="keywordtype">int</span>  <a class="code" href="nfs__client__id_8c.html#a15">nfs_client_id_get</a>( clientid4         clientid,
00455                         nfs_client_id_t * client_id_res )
00456 {
00457   hash_buffer_t       buffkey ;
00458   hash_buffer_t       buffval ;
00459   <span class="keywordtype">int</span>                 status ;
00460   nfs_client_id_t   * pnfs_client_id = NULL ;
00461   clientid4         * pclientid      = NULL ;
00462  
00463   <span class="keywordflow">if</span>( client_id_res == NULL ) 
00464     <span class="keywordflow">return</span> CLIENT_ID_INVALID_ARGUMENT ;
00465  
00466   <span class="keywordflow">if</span>( ( pclientid = (clientid4 *)Mem_Alloc( <span class="keyword">sizeof</span>( clientid4 ) ) ) == NULL )
00467     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00468 
00469   *pclientid = clientid ; 
00470   buffkey.pdata = (caddr_t)pclientid ;
00471   buffkey.len = <span class="keyword">sizeof</span>( clientid4 )  ;
00472   
00473   <span class="keywordflow">if</span>( HashTable_Get( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a>, &amp;buffkey, &amp;buffval ) == HASHTABLE_SUCCESS )
00474     {
00475       pnfs_client_id = (nfs_client_id_t *)buffval.pdata ;
00476 
00477       *client_id_res = *pnfs_client_id ;
00478       status = CLIENT_ID_SUCCESS ;
00479 
00480 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00481 <span class="preprocessor"></span>      printf( <span class="stringliteral">"-=-=-=-=-=-=-=-=-=-&gt; ht_client_id \n"</span> ) ;
00482       HashTable_Print( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a> ) ;
00483       printf( <span class="stringliteral">"-=-=-=-=-=-=-=-=-=-&gt; ht_client_id_reverse \n"</span> ) ;
00484       HashTable_Print( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a> ) ;
00485 <span class="preprocessor">#endif</span>
00486 <span class="preprocessor"></span>    }
00487   <span class="keywordflow">else</span>
00488     {
00489       status = CLIENT_ID_NOT_FOUND ;
00490     }
00491 
00492   <span class="comment">/* free the allocated key */</span>
00493   Mem_Free( pclientid ) ;
00494 
00495 
00496   <span class="keywordflow">return</span> status ;
00497 } <span class="comment">/* nfs_client_id_get */</span>
00498 
<a name="l00499"></a><a class="code" href="nfs__client__id_8c.html#a16">00499</a> <span class="keywordtype">int</span>  <a class="code" href="nfs__client__id_8c.html#a16">nfs_client_id_get_reverse</a>( <span class="keywordtype">char</span> * key,
00500                                 nfs_client_id_t * client_id_res )
00501 {
00502   hash_buffer_t       buffkey ;
00503   hash_buffer_t       buffval ;
00504   <span class="keywordtype">int</span>                 status ;
00505   nfs_client_id_t   * pnfs_client_id = NULL ;
00506  
00507   <span class="keywordflow">if</span>( client_id_res == NULL ) 
00508     <span class="keywordflow">return</span> CLIENT_ID_INVALID_ARGUMENT ;
00509  
00510   buffkey.pdata = (caddr_t)key ;
00511   buffkey.len = MAXNAMLEN ;
00512   
00513   <span class="keywordflow">if</span>( HashTable_Get( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a>, &amp;buffkey, &amp;buffval ) == HASHTABLE_SUCCESS )
00514     {
00515       pnfs_client_id = (nfs_client_id_t *)buffval.pdata ;
00516 
00517       *client_id_res = *pnfs_client_id ;
00518       status = CLIENT_ID_SUCCESS ;
00519     }
00520   <span class="keywordflow">else</span>
00521     {
00522       status = CLIENT_ID_NOT_FOUND ;
00523     }
00524 
00525   <span class="keywordflow">return</span> status ;
00526 } <span class="comment">/* nfs_client_id_get_reverse */</span>
00527 
00528 
<a name="l00541"></a><a class="code" href="nfs__client__id_8c.html#a17">00541</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a17">nfs_client_id_remove</a>( clientid4         clientid,
00542                           nfs_client_id_t * nfs_client_id_pool )
00543 {
00544   hash_buffer_t       buffkey , old_key, old_key_reverse, old_value ;
00545   nfs_client_id_t   * pnfs_client_id  = NULL ;
00546   clientid4         * pclientid = NULL ;
00547 
00548   <span class="keywordflow">if</span>( ( pclientid = (clientid4 *)Mem_Alloc( <span class="keyword">sizeof</span>( clientid4 ) ) ) == NULL )
00549     <span class="keywordflow">return</span> CLIENT_ID_INSERT_MALLOC_ERROR ;
00550 
00551   *pclientid = clientid ; 
00552   buffkey.pdata = (caddr_t)pclientid ;
00553   buffkey.len = 0 ;
00554 
00555    <span class="comment">/* Remove entry */</span>
00556 
00557    <span class="keywordflow">if</span>( HashTable_Del( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a>, &amp;buffkey, &amp;old_key, &amp;old_value ) != HASHTABLE_SUCCESS )
00558    {
00559        Mem_Free( pclientid ) ;
00560        <span class="keywordflow">return</span> CLIENT_ID_NOT_FOUND;
00561    }
00562    
00563    <span class="comment">/* Remove reverse entry */</span>
00564    pnfs_client_id = (nfs_client_id_t *)old_value.pdata ;
00565    
00566    buffkey.pdata = pnfs_client_id-&gt;client_name;
00567    buffkey.len   = MAXNAMLEN;
00568    
00569    <span class="keywordflow">if</span>( HashTable_Del( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a>, &amp;buffkey, &amp;old_key_reverse, &amp;old_value ) != HASHTABLE_SUCCESS )
00570    {
00571        RELEASE_PREALLOC( pnfs_client_id, nfs_client_id_pool, next_alloc ) ;
00572        Mem_Free( old_key.pdata ) ;
00573        Mem_Free( pclientid ) ;
00574        <span class="keywordflow">return</span> CLIENT_ID_NOT_FOUND;
00575    }
00576    
00577    
00578    RELEASE_PREALLOC( pnfs_client_id, nfs_client_id_pool, next_alloc ) ;
00579    Mem_Free( old_key_reverse.pdata ) ;
00580    Mem_Free( old_key.pdata ) ;
00581    Mem_Free( pclientid ) ;
00582       
00583    <span class="keywordflow">return</span> CLIENT_ID_SUCCESS ;
00584    
00585 } <span class="comment">/* nfs_client_id_remove */</span>
00586 
00587 
00588 
<a name="l00600"></a><a class="code" href="nfs__client__id_8c.html#a18">00600</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a18">nfs_Init_client_id</a>( nfs_client_id_parameter_t  param ) 
00601 { 
00602   <span class="keywordflow">if</span>( ( <a class="code" href="nfs__client__id_8c.html#a0">ht_client_id</a> = HashTable_Init( param.hash_param  ) ) == NULL )
00603     {
00604       DisplayLog( <span class="stringliteral">"NFS CLIENT_ID: Cannot init Client Id cache"</span> ) ;
00605       <span class="keywordflow">return</span> -1 ;
00606     }
00607 
00608   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS;
00609 } <span class="comment">/* nfs_Init_client_id */</span>
00610 
<a name="l00622"></a><a class="code" href="nfs__client__id_8c.html#a19">00622</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a19">nfs_Init_client_id_reverse</a>( nfs_client_id_parameter_t  param ) 
00623 { 
00624   <span class="keywordflow">if</span>( ( <a class="code" href="nfs__client__id_8c.html#a1">ht_client_id_reverse</a> = HashTable_Init( param.hash_param_reverse ) ) == NULL )
00625     {
00626       DisplayLog( <span class="stringliteral">"NFS CLIENT_ID: Cannot init Client Id cache"</span> ) ;
00627       <span class="keywordflow">return</span> -1 ;
00628     }
00629 
00630   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS;
00631 } <span class="comment">/* nfs_Init_client_id */</span>
00632 
00633 
00634 
00635 
<a name="l00644"></a><a class="code" href="nfs__client__id_8c.html#a20">00644</a> <span class="keywordtype">int</span> <a class="code" href="test__clientid__full_8c.html#a0">nfs_client_id_compute</a>( <span class="keywordtype">char</span>      * name,
00645                            clientid4 * pclientid )
00646 {
00647   <span class="keywordtype">char</span>         padded_name[CLIENT_ID_MAX_LEN] ;
00648   clientid4    computed_value = 0 ;
00649   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i              = 0  ;
00650   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset         = 0 ;
00651   uint64_t     extract        = 0 ;
00652   uint64_t     sum            = 0 ;
00653   uint64_t     i1 ;
00654   uint64_t     i2 ;
00655   uint64_t     i3 ;
00656   uint64_t     i4 ;
00657   uint64_t     i5 ;
00658   uint64_t     i6 ;
00659   uint64_t     i7 ;
00660   uint64_t     i8 ;
00661   uint64_t     i9 ;
00662   uint64_t     l  ;
00663 
00664   <span class="keywordflow">if</span>( name == NULL || pclientid == NULL )
00665     <span class="keywordflow">return</span> CLIENT_ID_INVALID_ARGUMENT ;
00666 
00667   memset( padded_name, 0, CLIENT_ID_MAX_LEN ) ;
00668 
00669   <span class="comment">/* Copy the string to the padded one */</span>
00670   <span class="keywordflow">for</span>( i = 0 ; i &lt; <a class="code" href="nfs__state__id_8c.html#a3">strnlen</a>( name, CLIENT_ID_MAX_LEN ) ; padded_name[i] = name[i], i++ ) ;
00671 
00672 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00673 <span class="preprocessor"></span>  printf( <span class="stringliteral">"%s :"</span>, padded_name ) ; 
00674 <span class="preprocessor">#endif</span>
00675 <span class="preprocessor"></span>
00676   <span class="comment">/* For each 9 character pack:</span>
00677 <span class="comment">   *   - keep the 7 first bit (the 8th is often 0: ascii string) </span>
00678 <span class="comment">   *   - pack 7x9 bit to 63 bits using xor</span>
00679 <span class="comment">   *   - xor the last 8th bit to a single 0 , or-ed with the rest</span>
00680 <span class="comment">   * Proceeding with the next 9 bytes pack will produce a new value that is xored with the </span>
00681 <span class="comment">   * one of the previous iteration */</span>
00682 
00683   <span class="keywordflow">for</span>( offset = 0 ; offset &lt; CLIENT_ID_MAX_LEN ; offset += 9 )
00684     {
00685       <span class="comment">/* input name is ascii string, remove 8th bit on each byte, not significant */</span>
00686       i1 = padded_name[offset+0] &amp; 0x7F ;
00687       i2 = (uint64_t)( padded_name[offset+1] &amp; 0x7F ) &lt;&lt; 7 ; 
00688       i3 = (uint64_t)( padded_name[offset+2] &amp; 0x7F ) &lt;&lt; 14 ; 
00689       i4 = (uint64_t)( padded_name[offset+3] &amp; 0x7F ) &lt;&lt; 21 ; 
00690       i5 = (uint64_t)( padded_name[offset+4] &amp; 0x7F ) &lt;&lt; 28 ; 
00691       i6 = (uint64_t)( padded_name[offset+5] &amp; 0x7F ) &lt;&lt; 35 ; 
00692       i7 = (uint64_t)( padded_name[offset+6] &amp; 0x7F ) &lt;&lt; 42 ; 
00693       i8 = (uint64_t)( padded_name[offset+7] &amp; 0x7F ) &lt;&lt; 49 ; 
00694       i9 = (uint64_t)( padded_name[offset+8] &amp; 0x7F ) &lt;&lt; 56 ; 
00695 
00696   sum = (uint64_t)padded_name[offset+0] +
00697         (uint64_t)padded_name[offset+1] +
00698         (uint64_t)padded_name[offset+2] +
00699         (uint64_t)padded_name[offset+3] +
00700         (uint64_t)padded_name[offset+4] +
00701         (uint64_t)padded_name[offset+5] +
00702         (uint64_t)padded_name[offset+6] +
00703         (uint64_t)padded_name[offset+7] +
00704         (uint64_t)padded_name[offset+8] ;
00705 
00706 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00707 <span class="preprocessor"></span>      printf( <span class="stringliteral">"|%llx |%llx |%llx |%llx |%llx |%llx |%llx |%llx |%llx | = "</span>,
00708              i1, i2, i3, i4, i5, i6, i7, i8, i9 ) ;
00709 <span class="preprocessor">#endif</span>
00710 <span class="preprocessor"></span>
00711       <span class="comment">/* Get xor combibation of all the 8h bit */</span>
00712       l = ( padded_name[offset+0] &amp; 0x80 ) ^
00713           ( padded_name[offset+1] &amp; 0x80 ) ^
00714           ( padded_name[offset+2] &amp; 0x80 ) ^
00715           ( padded_name[offset+3] &amp; 0x80 ) ^
00716           ( padded_name[offset+4] &amp; 0x80 ) ^
00717           ( padded_name[offset+5] &amp; 0x80 ) ^
00718           ( padded_name[offset+6] &amp; 0x80 ) ^
00719           ( padded_name[offset+7] &amp; 0x80 ) ^
00720           ( padded_name[offset+8] &amp; 0x80 ) ^
00721           ( padded_name[offset+9] &amp; 0x80 ) ;
00722     
00723       extract = i1 ^ i2 ^ i3 ^ i4 ^ i5 ^ i6 ^ i7 ^ i8 ^ i9 | l ;
00724 
00725 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00726 <span class="preprocessor"></span>      printf( <span class="stringliteral">"%llx "</span>, extract ) ; 
00727 <span class="preprocessor">#endif</span>
00728 <span class="preprocessor"></span>
00729       computed_value ^= extract ;
00730       computed_value ^= sum ;
00731     }
00732 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00733 <span class="preprocessor"></span>  printf( <span class="stringliteral">"\n"</span> ) ; 
00734 <span class="preprocessor">#endif</span>
00735 <span class="preprocessor"></span>
00736       computed_value = (computed_value &gt;&gt; 32 ) ^ (computed_value &amp; 0x00000000FFFFFFFFLL ) ;
00737 
00738   *pclientid = computed_value ;
00739 
00740 
00741   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS ;
00742 } <span class="comment">/* nfs_client_id_compute */</span>
00743 
<a name="l00752"></a><a class="code" href="nfs__client__id_8c.html#a21">00752</a> <span class="keywordtype">int</span> <a class="code" href="nfs__client__id_8c.html#a21">nfs_client_id_sha1_compute</a>( <span class="keywordtype">char</span>      * name,
00753                                clientid4 * pclientid )
00754 {
00755    clientid4      computed_value = 0LL ;
00756    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  sha1digest[SHA1_DIGEST_LENGTH] ;
00757 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00758 <span class="preprocessor"></span>   <span class="keywordtype">char</span>           strbuff[80] ;
00759    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   i = 0 ;
00760 <span class="preprocessor">#endif</span>
00761 <span class="preprocessor"></span>   SHA1_CTX       ctx ;
00762    <span class="keywordtype">char</span> protection[2048] ;
00763    
00764    <span class="keywordflow">if</span>( name == NULL || pclientid == NULL )
00765         <span class="keywordflow">return</span> CLIENT_ID_INVALID_ARGUMENT ;
00766 
00767    <a class="code" href="SHA1_8c.html#a1">SHA1Init</a>( &amp;ctx ) ;
00768    <a class="code" href="SHA1_8c.html#a2">SHA1Update</a>( &amp;ctx, name, strlen( name ) ) ;
00769    <a class="code" href="SHA1_8c.html#a3">SHA1Final</a>( sha1digest, &amp;ctx ) ;
00770    
00771 
00772    memcpy( &amp;computed_value, sha1digest, <span class="keyword">sizeof</span>( clientid4 ) ) ;
00773 
00774    *pclientid = (computed_value &gt;&gt; 32 ) ^ (computed_value &amp; 0x00000000FFFFFFFFLL ) ;
00775  
00776 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_CLIENT_ID_COMPUTE</span>
00777 <span class="preprocessor"></span>   <span class="keywordflow">for</span>( i = 0 ; i &lt; SHA1_DIGEST_LENGTH ; i++ ) 
00778      sprintf( &amp;(strbuff[i*2]), <span class="stringliteral">"%02x"</span>, sha1digest[i] ) ;
00779    printf( <span class="stringliteral">"------------&gt; sha1digest = %s  clientid= %llx\n"</span>, strbuff, *pclientid ) ;
00780 <span class="preprocessor">#endif</span>
00781 <span class="preprocessor"></span>   <span class="keywordflow">return</span> CLIENT_ID_SUCCESS ;
00782 } <span class="comment">/* nfs_client_id_sha1compute */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:40 2008 for Support routines layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
