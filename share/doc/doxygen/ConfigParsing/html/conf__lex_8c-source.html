<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ConfigParsing: conf_lex.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>conf_lex.c</h1><a href="conf__lex_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* A lexical scanner generated by flex */</span>
00002 
00003 <span class="comment">/* Scanner skeleton version:</span>
00004 <span class="comment"> * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $</span>
00005 <span class="comment"> */</span>
00006 
<a name="l00007"></a><a class="code" href="conf__lex_8c.html#a0">00007</a> <span class="preprocessor">#define FLEX_SCANNER</span>
<a name="l00008"></a><a class="code" href="conf__lex_8c.html#a1">00008</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FLEX_MAJOR_VERSION 2</span>
<a name="l00009"></a><a class="code" href="conf__lex_8c.html#a2">00009</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FLEX_MINOR_VERSION 5</span>
00010 <span class="preprocessor"></span>
00011 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00012 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00013 
00014 
00015 <span class="comment">/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */</span>
00016 <span class="preprocessor">#ifdef c_plusplus</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#ifndef __cplusplus</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define __cplusplus</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 
00023 <span class="preprocessor">#ifdef __cplusplus</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00026 
00027 <span class="comment">/* Use prototypes in function declarations. */</span>
00028 <span class="preprocessor">#define YY_USE_PROTOS</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">/* The "const" storage-class-modifier is valid. */</span>
00031 <span class="preprocessor">#define YY_USE_CONST</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#else   </span><span class="comment">/* ! __cplusplus */</span>
00034 
00035 <span class="preprocessor">#if __STDC__</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#define YY_USE_PROTOS</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define YY_USE_CONST</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#endif  </span><span class="comment">/* __STDC__ */</span>
00041 <span class="preprocessor">#endif  </span><span class="comment">/* ! __cplusplus */</span>
00042 
00043 <span class="preprocessor">#ifdef __TURBOC__</span>
00044 <span class="preprocessor"></span><span class="preprocessor"> #pragma warn -rch</span>
00045 <span class="preprocessor"></span><span class="preprocessor"> #pragma warn -use</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span>
00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00048 <span class="preprocessor">#define YY_USE_CONST</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define YY_USE_PROTOS</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#ifdef YY_USE_CONST</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define yyconst const</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00055"></a><a class="code" href="conf__lex_8c.html#a3">00055</a> <span class="preprocessor"></span><span class="preprocessor">#define yyconst</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00057 <span class="preprocessor"></span>
00058 
00059 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#define YY_PROTO(proto) proto</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00062"></a><a class="code" href="conf__lex_8c.html#a4">00062</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_PROTO(proto) ()</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">/* Returned upon end-of-file. */</span>
<a name="l00066"></a><a class="code" href="conf__lex_8c.html#a5">00066</a> <span class="preprocessor">#define YY_NULL 0</span>
00067 <span class="preprocessor"></span>
00068 <span class="comment">/* Promotes a possibly negative, possibly signed char to an unsigned</span>
00069 <span class="comment"> * integer for use as an array index.  If the signed char is negative,</span>
00070 <span class="comment"> * we want to instead treat it as an 8-bit unsigned char, hence the</span>
00071 <span class="comment"> * double cast.</span>
00072 <span class="comment"> */</span>
<a name="l00073"></a><a class="code" href="conf__lex_8c.html#a6">00073</a> <span class="preprocessor">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span>
00074 <span class="preprocessor"></span>
00075 <span class="comment">/* Enter a start condition.  This macro really ought to take a parameter,</span>
00076 <span class="comment"> * but we do it the disgusting crufty way forced on us by the ()-less</span>
00077 <span class="comment"> * definition of BEGIN.</span>
00078 <span class="comment"> */</span>
<a name="l00079"></a><a class="code" href="conf__lex_8c.html#a7">00079</a> <span class="preprocessor">#define BEGIN yy_start = 1 + 2 *</span>
00080 <span class="preprocessor"></span>
00081 <span class="comment">/* Translate the current start state into a value that can be later handed</span>
00082 <span class="comment"> * to BEGIN to return to the state.  The YYSTATE alias is for lex</span>
00083 <span class="comment"> * compatibility.</span>
00084 <span class="comment"> */</span>
<a name="l00085"></a><a class="code" href="conf__lex_8c.html#a8">00085</a> <span class="preprocessor">#define YY_START ((yy_start - 1) / 2)</span>
<a name="l00086"></a><a class="code" href="conf__lex_8c.html#a9">00086</a> <span class="preprocessor"></span><span class="preprocessor">#define YYSTATE YY_START</span>
00087 <span class="preprocessor"></span>
00088 <span class="comment">/* Action number for EOF rule of a given start state. */</span>
<a name="l00089"></a><a class="code" href="conf__lex_8c.html#a10">00089</a> <span class="preprocessor">#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</span>
00090 <span class="preprocessor"></span>
00091 <span class="comment">/* Special action meaning "start processing a new file". */</span>
<a name="l00092"></a><a class="code" href="conf__lex_8c.html#a11">00092</a> <span class="preprocessor">#define YY_NEW_FILE yyrestart( yyin )</span>
00093 <span class="preprocessor"></span>
<a name="l00094"></a><a class="code" href="conf__lex_8c.html#a12">00094</a> <span class="preprocessor">#define YY_END_OF_BUFFER_CHAR 0</span>
00095 <span class="preprocessor"></span>
00096 <span class="comment">/* Size of default input buffer. */</span>
<a name="l00097"></a><a class="code" href="conf__lex_8c.html#a13">00097</a> <span class="preprocessor">#define YY_BUF_SIZE 16384</span>
00098 <span class="preprocessor"></span>
<a name="l00099"></a><a class="code" href="conf__lex_8c.html#a63">00099</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> *<a class="code" href="structyy__buffer__state.html">YY_BUFFER_STATE</a>;
00100 
00101 <span class="keyword">extern</span> <span class="keywordtype">int</span> yyleng;
00102 <span class="keyword">extern</span> FILE *yyin, *yyout;
00103 
<a name="l00104"></a><a class="code" href="conf__lex_8c.html#a14">00104</a> <span class="preprocessor">#define EOB_ACT_CONTINUE_SCAN 0</span>
<a name="l00105"></a><a class="code" href="conf__lex_8c.html#a15">00105</a> <span class="preprocessor"></span><span class="preprocessor">#define EOB_ACT_END_OF_FILE 1</span>
<a name="l00106"></a><a class="code" href="conf__lex_8c.html#a16">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define EOB_ACT_LAST_MATCH 2</span>
00107 <span class="preprocessor"></span>
00108 <span class="comment">/* The funky do-while in the following #define is used to turn the definition</span>
00109 <span class="comment"> * int a single C statement (which needs a semi-colon terminator).  This</span>
00110 <span class="comment"> * avoids problems with code like:</span>
00111 <span class="comment"> *</span>
00112 <span class="comment"> *      if ( condition_holds )</span>
00113 <span class="comment"> *              yyless( 5 );</span>
00114 <span class="comment"> *      else</span>
00115 <span class="comment"> *              do_something_else();</span>
00116 <span class="comment"> *</span>
00117 <span class="comment"> * Prior to using the do-while the compiler would get upset at the</span>
00118 <span class="comment"> * "else" because it interpreted the "if" statement as being all</span>
00119 <span class="comment"> * done when it reached the ';' after the yyless() call.</span>
00120 <span class="comment"> */</span>
00121 
00122 <span class="comment">/* Return all but the first 'n' matched characters back to the input stream. */</span>
00123 
<a name="l00124"></a><a class="code" href="conf__lex_8c.html#a62">00124</a> <span class="preprocessor">#define yyless(n) \</span>
00125 <span class="preprocessor">        do \</span>
00126 <span class="preprocessor">                { \</span>
00127 <span class="preprocessor">                </span><span class="comment">/* Undo effects of setting up yytext. */</span> \
00128                 *yy_cp = yy_hold_char; \
00129                 YY_RESTORE_YY_MORE_OFFSET \
00130                 yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
00131                 YY_DO_BEFORE_ACTION; <span class="comment">/* set up yytext again */</span> \
00132                 } \
00133         while ( 0 )
00134 
<a name="l00135"></a><a class="code" href="conf__lex_8c.html#a18">00135</a> <span class="preprocessor">#define unput(c) yyunput( c, yytext_ptr )</span>
00136 <span class="preprocessor"></span>
00137 <span class="comment">/* The following is because we cannot portably get our hands on size_t</span>
00138 <span class="comment"> * (without autoconf's help, which isn't available because we want</span>
00139 <span class="comment"> * flex-generated scanners to compile on their own).</span>
00140 <span class="comment"> */</span>
<a name="l00141"></a><a class="code" href="conf__lex_8c.html#a67">00141</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yy_size_t;
00142 
00143 
<a name="l00144"></a><a class="code" href="structyy__buffer__state.html">00144</a> <span class="keyword">struct </span><a class="code" href="structyy__buffer__state.html">yy_buffer_state</a>
00145         {
<a name="l00146"></a><a class="code" href="structyy__buffer__state.html#o0">00146</a>         FILE *yy_input_file;
00147 
<a name="l00148"></a><a class="code" href="structyy__buffer__state.html#o1">00148</a>         <span class="keywordtype">char</span> *yy_ch_buf;                <span class="comment">/* input buffer */</span>
<a name="l00149"></a><a class="code" href="structyy__buffer__state.html#o2">00149</a>         <span class="keywordtype">char</span> *yy_buf_pos;               <span class="comment">/* current position in input buffer */</span>
00150 
00151         <span class="comment">/* Size of input buffer in bytes, not including room for EOB</span>
00152 <span class="comment">         * characters.</span>
00153 <span class="comment">         */</span>
<a name="l00154"></a><a class="code" href="structyy__buffer__state.html#o3">00154</a>         <a class="code" href="conf__lex_8c.html#a67">yy_size_t</a> yy_buf_size;
00155 
00156         <span class="comment">/* Number of characters read into yy_ch_buf, not including EOB</span>
00157 <span class="comment">         * characters.</span>
00158 <span class="comment">         */</span>
<a name="l00159"></a><a class="code" href="structyy__buffer__state.html#o4">00159</a>         <span class="keywordtype">int</span> yy_n_chars;
00160 
00161         <span class="comment">/* Whether we "own" the buffer - i.e., we know we created it,</span>
00162 <span class="comment">         * and can realloc() it to grow it, and should free() it to</span>
00163 <span class="comment">         * delete it.</span>
00164 <span class="comment">         */</span>
<a name="l00165"></a><a class="code" href="structyy__buffer__state.html#o5">00165</a>         <span class="keywordtype">int</span> yy_is_our_buffer;
00166 
00167         <span class="comment">/* Whether this is an "interactive" input source; if so, and</span>
00168 <span class="comment">         * if we're using stdio for input, then we want to use getc()</span>
00169 <span class="comment">         * instead of fread(), to make sure we stop fetching input after</span>
00170 <span class="comment">         * each newline.</span>
00171 <span class="comment">         */</span>
<a name="l00172"></a><a class="code" href="structyy__buffer__state.html#o6">00172</a>         <span class="keywordtype">int</span> yy_is_interactive;
00173 
00174         <span class="comment">/* Whether we're considered to be at the beginning of a line.</span>
00175 <span class="comment">         * If so, '^' rules will be active on the next match, otherwise</span>
00176 <span class="comment">         * not.</span>
00177 <span class="comment">         */</span>
<a name="l00178"></a><a class="code" href="structyy__buffer__state.html#o7">00178</a>         <span class="keywordtype">int</span> yy_at_bol;
00179 
00180         <span class="comment">/* Whether to try to fill the input buffer when we reach the</span>
00181 <span class="comment">         * end of it.</span>
00182 <span class="comment">         */</span>
<a name="l00183"></a><a class="code" href="structyy__buffer__state.html#o8">00183</a>         <span class="keywordtype">int</span> yy_fill_buffer;
00184 
<a name="l00185"></a><a class="code" href="structyy__buffer__state.html#o9">00185</a>         <span class="keywordtype">int</span> yy_buffer_status;
<a name="l00186"></a><a class="code" href="conf__lex_8c.html#a19">00186</a> <span class="preprocessor">#define YY_BUFFER_NEW 0</span>
<a name="l00187"></a><a class="code" href="conf__lex_8c.html#a20">00187</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_BUFFER_NORMAL 1</span>
00188 <span class="preprocessor"></span>        <span class="comment">/* When an EOF's been seen but there's still some text to process</span>
00189 <span class="comment">         * then we mark the buffer as YY_EOF_PENDING, to indicate that we</span>
00190 <span class="comment">         * shouldn't try reading from the input source any more.  We might</span>
00191 <span class="comment">         * still have a bunch of tokens to match, though, because of</span>
00192 <span class="comment">         * possible backing-up.</span>
00193 <span class="comment">         *</span>
00194 <span class="comment">         * When we actually see the EOF, we change the status to "new"</span>
00195 <span class="comment">         * (via yyrestart()), so that the user can continue scanning by</span>
00196 <span class="comment">         * just pointing yyin at a new input file.</span>
00197 <span class="comment">         */</span>
<a name="l00198"></a><a class="code" href="conf__lex_8c.html#a21">00198</a> <span class="preprocessor">#define YY_BUFFER_EOF_PENDING 2</span>
00199 <span class="preprocessor"></span>        };
00200 
00201 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_current_buffer = 0;
00202 
00203 <span class="comment">/* We provide macros for accessing buffer states in case in the</span>
00204 <span class="comment"> * future we want to put the buffer states in a more general</span>
00205 <span class="comment"> * "scanner state".</span>
00206 <span class="comment"> */</span>
<a name="l00207"></a><a class="code" href="conf__lex_8c.html#a22">00207</a> <span class="preprocessor">#define YY_CURRENT_BUFFER yy_current_buffer</span>
00208 <span class="preprocessor"></span>
00209 
00210 <span class="comment">/* yy_hold_char holds the character lost when yytext is formed. */</span>
00211 <span class="keyword">static</span> <span class="keywordtype">char</span> yy_hold_char;
00212 
00213 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_n_chars;          <span class="comment">/* number of characters read into yy_ch_buf */</span>
00214 
00215 
<a name="l00216"></a><a class="code" href="conf__lex_8c.html#a64">00216</a> <span class="keywordtype">int</span> yyleng;
00217 
00218 <span class="comment">/* Points to current character in buffer. */</span>
00219 <span class="keyword">static</span> <span class="keywordtype">char</span> *yy_c_buf_p = (<span class="keywordtype">char</span> *) 0;
00220 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_init = 1;         <span class="comment">/* whether we need to initialize */</span>
00221 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_start = 0;        <span class="comment">/* start state number */</span>
00222 
00223 <span class="comment">/* Flag which is used to allow yywrap()'s to do buffer switches</span>
00224 <span class="comment"> * instead of setting up a fresh yyin.  A bit of a hack ...</span>
00225 <span class="comment"> */</span>
00226 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_did_buffer_switch_on_eof;
00227 
00228 <span class="keywordtype">void</span> yyrestart <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( FILE *input_file ));
00229 
00230 <span class="keywordtype">void</span> yy_switch_to_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE new_buffer ));
00231 <span class="keywordtype">void</span> yy_load_buffer_state <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00232 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_create_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( FILE *file, <span class="keywordtype">int</span> size ));
00233 <span class="keywordtype">void</span> yy_delete_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b ));
00234 <span class="keywordtype">void</span> yy_init_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b, FILE *file ));
00235 <span class="keywordtype">void</span> yy_flush_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b ));
<a name="l00236"></a><a class="code" href="conf__lex_8c.html#a23">00236</a> <span class="preprocessor">#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )</span>
00237 <span class="preprocessor"></span>
00238 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">char</span> *base, yy_size_t size ));
00239 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_string <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> *yy_str ));
00240 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_bytes <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> *bytes, <span class="keywordtype">int</span> len ));
00241 
00242 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yy_size_t ));
00243 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_realloc <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> *, yy_size_t ));
00244 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_free <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> * ));
00245 
<a name="l00246"></a><a class="code" href="conf__lex_8c.html#a24">00246</a> <span class="preprocessor">#define yy_new_buffer yy_create_buffer</span>
00247 <span class="preprocessor"></span>
<a name="l00248"></a><a class="code" href="conf__lex_8c.html#a25">00248</a> <span class="preprocessor">#define yy_set_interactive(is_interactive) \</span>
00249 <span class="preprocessor">        { \</span>
00250 <span class="preprocessor">        if ( ! yy_current_buffer ) \</span>
00251 <span class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span>
00252 <span class="preprocessor">        yy_current_buffer-&gt;yy_is_interactive = is_interactive; \</span>
00253 <span class="preprocessor">        }</span>
00254 <span class="preprocessor"></span>
<a name="l00255"></a><a class="code" href="conf__lex_8c.html#a26">00255</a> <span class="preprocessor">#define yy_set_bol(at_bol) \</span>
00256 <span class="preprocessor">        { \</span>
00257 <span class="preprocessor">        if ( ! yy_current_buffer ) \</span>
00258 <span class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span>
00259 <span class="preprocessor">        yy_current_buffer-&gt;yy_at_bol = at_bol; \</span>
00260 <span class="preprocessor">        }</span>
00261 <span class="preprocessor"></span>
<a name="l00262"></a><a class="code" href="conf__lex_8c.html#a27">00262</a> <span class="preprocessor">#define YY_AT_BOL() (yy_current_buffer-&gt;yy_at_bol)</span>
00263 <span class="preprocessor"></span>
<a name="l00264"></a><a class="code" href="conf__lex_8c.html#a75">00264</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> YY_CHAR;
<a name="l00265"></a><a class="code" href="conf__lex_8c.html#a65">00265</a> FILE *<a class="code" href="conf__lex_8c.html#a65">yyin</a> = (FILE *) 0, *<a class="code" href="conf__lex_8c.html#a66">yyout</a> = (FILE *) 0;
<a name="l00266"></a><a class="code" href="conf__lex_8c.html#a76">00266</a> <span class="keyword">typedef</span> <span class="keywordtype">int</span> yy_state_type;
00267 <span class="keyword">extern</span> <span class="keywordtype">char</span> *yytext;
<a name="l00268"></a><a class="code" href="conf__lex_8c.html#a28">00268</a> <span class="preprocessor">#define yytext_ptr yytext</span>
00269 <span class="preprocessor"></span>
00270 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_get_previous_state <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00271 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_try_NUL_trans <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yy_state_type current_state ));
00272 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_get_next_buffer <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00273 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> msg[] ));
00274 
00275 <span class="comment">/* Done after the current pattern has been matched and before the</span>
00276 <span class="comment"> * corresponding action - sets up yytext.</span>
00277 <span class="comment"> */</span>
<a name="l00278"></a><a class="code" href="conf__lex_8c.html#a29">00278</a> <span class="preprocessor">#define YY_DO_BEFORE_ACTION \</span>
00279 <span class="preprocessor">        yytext_ptr = yy_bp; \</span>
00280 <span class="preprocessor">        yyleng = (int) (yy_cp - yy_bp); \</span>
00281 <span class="preprocessor">        yy_hold_char = *yy_cp; \</span>
00282 <span class="preprocessor">        *yy_cp = '\0'; \</span>
00283 <span class="preprocessor">        yy_c_buf_p = yy_cp;</span>
00284 <span class="preprocessor"></span>
<a name="l00285"></a><a class="code" href="conf__lex_8c.html#a30">00285</a> <span class="preprocessor">#define YY_NUM_RULES 23</span>
<a name="l00286"></a><a class="code" href="conf__lex_8c.html#a31">00286</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_END_OF_BUFFER 24</span>
00287 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yy_accept[56] =
00288     {   0,
00289         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
00290         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
00291        24,   22,   20,   21,   22,    1,    2,    3,    4,    5,
00292         8,    6,    7,    9,   13,   13,   12,   11,   13,   10,
00293        18,   18,   17,   18,   16,   15,   15,   14,   15,    0,
00294        19,    1,    3,    8,    0
00295     } ;
00296 
00297 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">int</span> yy_ec[256] =
00298     {   0,
00299         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
00300         1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
00301         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00302         1,    2,    1,    4,    5,    1,    1,    1,    6,    1,
00303         1,    1,    1,    1,    7,    8,    1,    7,    7,    7,
00304         7,    7,    7,    7,    7,    7,    7,    7,    9,    1,
00305        10,    1,    1,    1,    8,    8,    8,    8,    8,    8,
00306         8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
00307         8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
00308         1,   11,    1,    1,    8,    1,    8,    8,    8,    8,
00309 
00310         8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
00311         8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
00312         8,    8,   12,    1,   13,    1,    1,    1,    1,    1,
00313         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00314         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00315         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00316         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00317         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00318         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00319         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00320 
00321         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00322         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00323         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00324         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00325         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00326         1,    1,    1,    1,    1
00327     } ;
00328 
00329 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">int</span> yy_meta[14] =
00330     {   0,
00331         1,    2,    2,    2,    2,    2,    3,    3,    2,    1,
00332         1,    1,    1
00333     } ;
00334 
00335 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yy_base[64] =
00336     {   0,
00337         0,    4,   41,   35,   30,   29,    2,    8,   30,   29,
00338        21,    0,   11,   10,   33,   43,   53,   58,   63,   67,
00339        18,   91,   91,   91,   14,    0,   91,    0,   91,   91,
00340         0,   91,   91,   91,   91,   91,   91,   91,   11,   91,
00341        91,   91,   91,   10,   91,   91,   91,   91,    9,    8,
00342        91,    0,    0,    0,   91,   72,   75,   78,   81,   84,
00343         5,    1,   87
00344     } ;
00345 
00346 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yy_def[64] =
00347     {   0,
00348        56,   56,    2,    2,    2,    2,    2,    2,    2,    2,
00349        55,   11,    2,    2,   57,   57,   58,   58,   59,   59,
00350        55,   55,   55,   55,   60,   61,   55,   62,   55,   55,
00351        63,   55,   55,   55,   55,   55,   55,   55,   60,   55,
00352        55,   55,   55,   60,   55,   55,   55,   55,   60,   60,
00353        55,   61,   62,   63,    0,   55,   55,   55,   55,   55,
00354        55,   55,   55
00355     } ;
00356 
00357 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yy_nxt[105] =
00358     {   0,
00359        55,   23,   24,   53,   25,   23,   24,   52,   25,   28,
00360        51,   51,   51,   51,   29,   28,   51,   55,   34,   34,
00361        29,   31,   23,   24,   32,   25,   33,   31,   31,   22,
00362        31,   31,   31,   31,   36,   37,   38,   39,   30,   30,
00363        27,   27,   26,   40,   36,   37,   38,   39,   26,   55,
00364        55,   55,   55,   40,   42,   43,   55,   44,   45,   42,
00365        43,   55,   44,   45,   47,   48,   55,   49,   47,   48,
00366        55,   49,   22,   22,   22,   35,   35,   35,   41,   41,
00367        41,   46,   46,   46,   50,   50,   50,   54,   55,   54,
00368        21,   55,   55,   55,   55,   55,   55,   55,   55,   55,
00369 
00370        55,   55,   55,   55
00371     } ;
00372 
00373 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yy_chk[105] =
00374     {   0,
00375         0,    1,    1,   62,    1,    2,    2,   61,    2,    7,
00376        50,   49,   44,   39,    7,    8,   25,   21,   14,   13,
00377         8,   11,   11,   11,   11,   11,   11,   11,   11,   11,
00378        11,   11,   11,   11,   15,   15,   15,   15,   10,    9,
00379         6,    5,    4,   15,   16,   16,   16,   16,    3,    0,
00380         0,    0,    0,   16,   17,   17,    0,   17,   17,   18,
00381        18,    0,   18,   18,   19,   19,    0,   19,   20,   20,
00382         0,   20,   56,   56,   56,   57,   57,   57,   58,   58,
00383        58,   59,   59,   59,   60,   60,   60,   63,    0,   63,
00384        55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
00385 
00386        55,   55,   55,   55
00387     } ;
00388 
00389 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_last_accepting_state;
00390 <span class="keyword">static</span> <span class="keywordtype">char</span> *yy_last_accepting_cpos;
00391 
00392 <span class="comment">/* The intent behind this definition is that it'll catch</span>
00393 <span class="comment"> * any uses of REJECT which flex missed.</span>
00394 <span class="comment"> */</span>
<a name="l00395"></a><a class="code" href="conf__lex_8c.html#a32">00395</a> <span class="preprocessor">#define REJECT reject_used_but_not_detected</span>
<a name="l00396"></a><a class="code" href="conf__lex_8c.html#a33">00396</a> <span class="preprocessor"></span><span class="preprocessor">#define yymore() yymore_used_but_not_detected</span>
<a name="l00397"></a><a class="code" href="conf__lex_8c.html#a34">00397</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_MORE_ADJ 0</span>
<a name="l00398"></a><a class="code" href="conf__lex_8c.html#a35">00398</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_RESTORE_YY_MORE_OFFSET</span>
<a name="l00399"></a><a class="code" href="conf__lex_8c.html#a77">00399</a> <span class="preprocessor"></span><span class="keywordtype">char</span> *yytext;
00400 <span class="preprocessor">#line 1 "conf_lex.l"</span>
<a name="l00401"></a><a class="code" href="conf__lex_8c.html#a36">00401</a> <span class="preprocessor"></span><span class="preprocessor">#define INITIAL 0</span>
00402 <span class="preprocessor"></span><span class="preprocessor">#line 2 "conf_lex.l"</span>
00403 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
00404 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00405 <span class="preprocessor">#include &lt;string.h&gt;</span>
00406 <span class="preprocessor">#include "<a class="code" href="analyse_8h.html">analyse.h</a>"</span>
00407 <span class="preprocessor">#include "<a class="code" href="conf__yacc_8h.html">conf_yacc.h</a>"</span>
00408 
00409 <span class="comment">/* Numero de la ligne courante */</span>
<a name="l00410"></a><a class="code" href="conf__lex_8c.html#a87">00410</a> <span class="keywordtype">int</span> yylineno;
00411 
00412 <span class="comment">/* Traitement des messages d'erreur */</span>
00413 <span class="keywordtype">void</span> <a class="code" href="conf__yacc_8c.html#a88">set_error</a>(<span class="keywordtype">char</span> * s);
00414 
<a name="l00415"></a><a class="code" href="conf__lex_8c.html#a37">00415</a> <span class="preprocessor">#define ERRLEN 1024</span>
<a name="l00416"></a><a class="code" href="conf__lex_8c.html#a88">00416</a> <span class="preprocessor"></span><span class="keywordtype">char</span> <a class="code" href="conf__lex_8c.html#a88">err_str</a>[ERRLEN]=<span class="stringliteral">""</span>;
00417 
00418 <span class="comment">/* Stockage des chaines */</span>
<a name="l00419"></a><a class="code" href="conf__lex_8c.html#a89">00419</a> <span class="keywordtype">char</span> <a class="code" href="conf__lex_8c.html#a89">YY_PARSED_STRING</a>[MAXSTRLEN];
00420 
<a name="l00421"></a><a class="code" href="conf__lex_8c.html#a109">00421</a> <span class="keywordtype">void</span> <a class="code" href="conf__lex_8c.html#a109">YY_BUFFER_APPEND</a>(<span class="keywordtype">char</span> * s){
00422     strncat( <a class="code" href="conf__lex_8c.html#a89">YY_PARSED_STRING</a>,s, <a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>);
00423 }
00424 
<a name="l00425"></a><a class="code" href="conf__lex_8c.html#a110">00425</a> <span class="keywordtype">void</span> <a class="code" href="conf__lex_8c.html#a110">YY_BUFFER_RESET</a>(<span class="keywordtype">void</span>){
00426     <span class="keywordtype">int</span> i;
00427     <span class="keywordflow">for</span> (i=0;i&lt;MAXSTRLEN;i++){
00428         <a class="code" href="conf__lex_8c.html#a89">YY_PARSED_STRING</a>[i]=<span class="charliteral">'\0'</span>;
00429     }
00430 }
00431 
00432 <span class="comment">/* initialisation du parser */</span>
00433 
<a name="l00434"></a><a class="code" href="conf__lex_8c.html#a38">00434</a> <span class="preprocessor">#define YY_USER_INIT {\</span>
00435 <span class="preprocessor">    yylineno=1;\</span>
00436 <span class="preprocessor">    BEGIN YY_INIT;\</span>
00437 <span class="preprocessor">}</span>
00438 <span class="preprocessor"></span>
00439 <span class="preprocessor">#ifdef _DEBUG_PARSING</span>
00440 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_LEX   printf</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00442"></a><a class="code" href="conf__lex_8c.html#a39">00442</a> <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_LEX</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00444 <span class="preprocessor"></span>
00445 
00446 <span class="comment">/* lettre posant probleme dans une chaine */</span>
00447 <span class="comment">/* comment est compose un identifiant */</span>
<a name="l00448"></a><a class="code" href="conf__lex_8c.html#a40">00448</a> <span class="preprocessor">#define YY_INIT 1</span>
<a name="l00449"></a><a class="code" href="conf__lex_8c.html#a41">00449</a> <span class="preprocessor"></span><span class="preprocessor">#define BLOC 2</span>
<a name="l00450"></a><a class="code" href="conf__lex_8c.html#a42">00450</a> <span class="preprocessor"></span><span class="preprocessor">#define INBLOC 3</span>
<a name="l00451"></a><a class="code" href="conf__lex_8c.html#a43">00451</a> <span class="preprocessor"></span><span class="preprocessor">#define AFFECT 4</span>
<a name="l00452"></a><a class="code" href="conf__lex_8c.html#a44">00452</a> <span class="preprocessor"></span><span class="preprocessor">#define VALUE 5</span>
<a name="l00453"></a><a class="code" href="conf__lex_8c.html#a45">00453</a> <span class="preprocessor"></span><span class="preprocessor">#define ENDVALUE 6</span>
<a name="l00454"></a><a class="code" href="conf__lex_8c.html#a46">00454</a> <span class="preprocessor"></span><span class="preprocessor">#define STRING1 7</span>
<a name="l00455"></a><a class="code" href="conf__lex_8c.html#a47">00455</a> <span class="preprocessor"></span><span class="preprocessor">#define STRING2 8</span>
<a name="l00456"></a><a class="code" href="conf__lex_8c.html#a48">00456</a> <span class="preprocessor"></span><span class="preprocessor">#define ESC1 9</span>
00457 <span class="preprocessor"></span> 
00458 <span class="preprocessor">#line 459 "conf_lex.c"</span>
00459 <span class="preprocessor"></span>
00460 <span class="comment">/* Macros after this point can all be overridden by user definitions in</span>
00461 <span class="comment"> * section 1.</span>
00462 <span class="comment"> */</span>
00463 
00464 <span class="preprocessor">#ifndef YY_SKIP_YYWRAP</span>
00465 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
00466 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> <span class="keywordtype">int</span> yywrap <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00467 <span class="preprocessor">#else</span>
00468 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> yywrap <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00469 <span class="preprocessor">#endif</span>
00470 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00471 <span class="preprocessor"></span>
00472 <span class="preprocessor">#ifndef YY_NO_UNPUT</span>
00473 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yyunput <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">int</span> c, <span class="keywordtype">char</span> *buf_ptr ));
00474 <span class="preprocessor">#endif</span>
00475 <span class="preprocessor"></span>
00476 <span class="preprocessor">#ifndef yytext_ptr</span>
00477 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">char</span> *, yyconst <span class="keywordtype">char</span> *, <span class="keywordtype">int</span> ));
00478 <span class="preprocessor">#endif</span>
00479 <span class="preprocessor"></span>
00480 <span class="preprocessor">#ifdef YY_NEED_STRLEN</span>
00481 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_flex_strlen <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> * ));
00482 <span class="preprocessor">#endif</span>
00483 <span class="preprocessor"></span>
00484 <span class="preprocessor">#ifndef YY_NO_INPUT</span>
00485 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
00486 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yyinput <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00487 <span class="preprocessor">#else</span>
00488 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> input <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00489 <span class="preprocessor">#endif</span>
00490 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00491 <span class="preprocessor"></span>
00492 <span class="preprocessor">#if YY_STACK_USED</span>
00493 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_start_stack_ptr = 0;
00494 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_start_stack_depth = 0;
00495 <span class="keyword">static</span> <span class="keywordtype">int</span> *yy_start_stack = 0;
00496 <span class="preprocessor">#ifndef YY_NO_PUSH_STATE</span>
00497 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_push_state <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">int</span> new_state ));
00498 <span class="preprocessor">#endif</span>
00499 <span class="preprocessor"></span><span class="preprocessor">#ifndef YY_NO_POP_STATE</span>
00500 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_pop_state <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00501 <span class="preprocessor">#endif</span>
00502 <span class="preprocessor"></span><span class="preprocessor">#ifndef YY_NO_TOP_STATE</span>
00503 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_top_state <a class="code" href="conf__lex_8c.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00504 <span class="preprocessor">#endif</span>
00505 <span class="preprocessor"></span>
00506 <span class="preprocessor">#else</span>
<a name="l00507"></a><a class="code" href="conf__lex_8c.html#a49">00507</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_PUSH_STATE 1</span>
<a name="l00508"></a><a class="code" href="conf__lex_8c.html#a50">00508</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_POP_STATE 1</span>
<a name="l00509"></a><a class="code" href="conf__lex_8c.html#a51">00509</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_TOP_STATE 1</span>
00510 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00511 <span class="preprocessor"></span>
00512 <span class="preprocessor">#ifdef YY_MALLOC_DECL</span>
00513 <span class="preprocessor"></span>YY_MALLOC_DECL
00514 <span class="preprocessor">#else</span>
00515 <span class="preprocessor"></span><span class="preprocessor">#if __STDC__</span>
00516 <span class="preprocessor"></span><span class="preprocessor">#ifndef __cplusplus</span>
00517 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00518 <span class="preprocessor">#endif</span>
00519 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00520 <span class="preprocessor"></span><span class="comment">/* Just try to get by without declaring the routines.  This will fail</span>
00521 <span class="comment"> * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)</span>
00522 <span class="comment"> * or sizeof(void*) != sizeof(int).</span>
00523 <span class="comment"> */</span>
00524 <span class="preprocessor">#endif</span>
00525 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00526 <span class="preprocessor"></span>
00527 <span class="comment">/* Amount of stuff to slurp up with each read. */</span>
00528 <span class="preprocessor">#ifndef YY_READ_BUF_SIZE</span>
<a name="l00529"></a><a class="code" href="conf__lex_8c.html#a52">00529</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_READ_BUF_SIZE 8192</span>
00530 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00531 <span class="preprocessor"></span>
00532 <span class="comment">/* Copy whatever the last rule matched to the standard output. */</span>
00533 
00534 <span class="preprocessor">#ifndef ECHO</span>
00535 <span class="preprocessor"></span><span class="comment">/* This used to be an fputs(), but since the string might contain NUL's,</span>
00536 <span class="comment"> * we now use fwrite().</span>
00537 <span class="comment"> */</span>
<a name="l00538"></a><a class="code" href="conf__lex_8c.html#a53">00538</a> <span class="preprocessor">#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )</span>
00539 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00540 <span class="preprocessor"></span>
00541 <span class="comment">/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</span>
00542 <span class="comment"> * is returned in "result".</span>
00543 <span class="comment"> */</span>
00544 <span class="preprocessor">#ifndef YY_INPUT</span>
<a name="l00545"></a><a class="code" href="conf__lex_8c.html#a54">00545</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_INPUT(buf,result,max_size) \</span>
00546 <span class="preprocessor">        if ( yy_current_buffer-&gt;yy_is_interactive ) \</span>
00547 <span class="preprocessor">                { \</span>
00548 <span class="preprocessor">                int c = '*', n; \</span>
00549 <span class="preprocessor">                for ( n = 0; n &lt; max_size &amp;&amp; \</span>
00550 <span class="preprocessor">                             (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \</span>
00551 <span class="preprocessor">                        buf[n] = (char) c; \</span>
00552 <span class="preprocessor">                if ( c == '\n' ) \</span>
00553 <span class="preprocessor">                        buf[n++] = (char) c; \</span>
00554 <span class="preprocessor">                if ( c == EOF &amp;&amp; ferror( yyin ) ) \</span>
00555 <span class="preprocessor">                        YY_FATAL_ERROR( "input in flex scanner failed" ); \</span>
00556 <span class="preprocessor">                result = n; \</span>
00557 <span class="preprocessor">                } \</span>
00558 <span class="preprocessor">        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \</span>
00559 <span class="preprocessor">                  &amp;&amp; ferror( yyin ) ) \</span>
00560 <span class="preprocessor">                YY_FATAL_ERROR( "input in flex scanner failed" );</span>
00561 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00562 <span class="preprocessor"></span>
00563 <span class="comment">/* No semi-colon after return; correct usage is to write "yyterminate();" -</span>
00564 <span class="comment"> * we don't want an extra ';' after the "return" because that will cause</span>
00565 <span class="comment"> * some compilers to complain about unreachable statements.</span>
00566 <span class="comment"> */</span>
00567 <span class="preprocessor">#ifndef yyterminate</span>
<a name="l00568"></a><a class="code" href="conf__lex_8c.html#a55">00568</a> <span class="preprocessor"></span><span class="preprocessor">#define yyterminate() return YY_NULL</span>
00569 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00570 <span class="preprocessor"></span>
00571 <span class="comment">/* Number of entries by which start-condition stack grows. */</span>
00572 <span class="preprocessor">#ifndef YY_START_STACK_INCR</span>
<a name="l00573"></a><a class="code" href="conf__lex_8c.html#a56">00573</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_START_STACK_INCR 25</span>
00574 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00575 <span class="preprocessor"></span>
00576 <span class="comment">/* Report a fatal error. */</span>
00577 <span class="preprocessor">#ifndef YY_FATAL_ERROR</span>
<a name="l00578"></a><a class="code" href="conf__lex_8c.html#a57">00578</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</span>
00579 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00580 <span class="preprocessor"></span>
00581 <span class="comment">/* Default declaration of generated scanner - a define so the user can</span>
00582 <span class="comment"> * easily add parameters.</span>
00583 <span class="comment"> */</span>
00584 <span class="preprocessor">#ifndef YY_DECL</span>
<a name="l00585"></a><a class="code" href="conf__lex_8c.html#a58">00585</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_DECL int yylex YY_PROTO(( void ))</span>
00586 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00587 <span class="preprocessor"></span>
00588 <span class="comment">/* Code executed at the beginning of each rule, after yytext and yyleng</span>
00589 <span class="comment"> * have been set up.</span>
00590 <span class="comment"> */</span>
00591 <span class="preprocessor">#ifndef YY_USER_ACTION</span>
00592 <span class="preprocessor"></span><span class="preprocessor">#define YY_USER_ACTION</span>
00593 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>
00595 <span class="comment">/* Code executed at the end of each rule. */</span>
00596 <span class="preprocessor">#ifndef YY_BREAK</span>
<a name="l00597"></a><a class="code" href="conf__lex_8c.html#a59">00597</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_BREAK break;</span>
00598 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00599 <span class="preprocessor"></span>
<a name="l00600"></a><a class="code" href="conf__lex_8c.html#a60">00600</a> <span class="preprocessor">#define YY_RULE_SETUP \</span>
00601 <span class="preprocessor">        YY_USER_ACTION</span>
00602 <span class="preprocessor"></span>
00603 <a class="code" href="conf__lex_8c.html#a58">YY_DECL</a>
00604         {
00605         <span class="keyword">register</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_current_state;
00606         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp = NULL, *<a class="code" href="conf__lex_8c.html#a90">yy_bp</a> = NULL;
00607         <span class="keyword">register</span> <span class="keywordtype">int</span> yy_act;
00608 
00609 <span class="preprocessor">#line 61 "conf_lex.l"</span>
00610 <span class="preprocessor"></span>
00611 
00612 
00613 
00614 <span class="preprocessor">#line 615 "conf_lex.c"</span>
00615 <span class="preprocessor"></span>
00616         <span class="keywordflow">if</span> ( yy_init )
00617                 {
00618                 yy_init = 0;
00619 
00620 <span class="preprocessor">#ifdef YY_USER_INIT</span>
00621 <span class="preprocessor"></span>                YY_USER_INIT;
00622 <span class="preprocessor">#endif</span>
00623 <span class="preprocessor"></span>
00624                 <span class="keywordflow">if</span> ( ! yy_start )
00625                         yy_start = 1;   <span class="comment">/* first start state */</span>
00626 
00627                 <span class="keywordflow">if</span> ( ! yyin )
00628                         <a class="code" href="conf__lex_8c.html#a65">yyin</a> = stdin;
00629 
00630                 <span class="keywordflow">if</span> ( ! yyout )
00631                         <a class="code" href="conf__lex_8c.html#a66">yyout</a> = stdout;
00632 
00633                 <span class="keywordflow">if</span> ( ! yy_current_buffer )
00634                         yy_current_buffer =
00635                                 yy_create_buffer( <a class="code" href="conf__lex_8c.html#a65">yyin</a>, <a class="code" href="conf__lex_8c.html#a13">YY_BUF_SIZE</a> );
00636 
00637                 yy_load_buffer_state();
00638                 }
00639 
00640         <span class="keywordflow">while</span> ( 1 )             <span class="comment">/* loops until end-of-file is reached */</span>
00641                 {
00642                 yy_cp = yy_c_buf_p;
00643 
00644                 <span class="comment">/* Support of yytext. */</span>
00645                 *yy_cp = yy_hold_char;
00646 
00647                 <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span>
00648 <span class="comment">                 * the current run.</span>
00649 <span class="comment">                 */</span>
00650                 <a class="code" href="conf__lex_8c.html#a90">yy_bp</a> = yy_cp;
00651 
00652                 yy_current_state = yy_start;
00653 yy_match:
00654                 <span class="keywordflow">do</span>
00655                         {
00656                         <span class="keyword">register</span> <a class="code" href="conf__lex_8c.html#a75">YY_CHAR</a> yy_c = yy_ec[<a class="code" href="conf__lex_8c.html#a6">YY_SC_TO_UI</a>(*yy_cp)];
00657                         <span class="keywordflow">if</span> ( yy_accept[yy_current_state] )
00658                                 {
00659                                 yy_last_accepting_state = yy_current_state;
00660                                 yy_last_accepting_cpos = yy_cp;
00661                                 }
00662                         <span class="keywordflow">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
00663                                 {
00664                                 yy_current_state = (int) yy_def[yy_current_state];
00665                                 <span class="keywordflow">if</span> ( yy_current_state &gt;= 56 )
00666                                         yy_c = yy_meta[(<span class="keywordtype">unsigned</span> int) yy_c];
00667                                 }
00668                         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keywordtype">unsigned</span> int) yy_c];
00669                         ++yy_cp;
00670                         }
00671                 <span class="keywordflow">while</span> ( yy_base[yy_current_state] != 91 );
00672 
00673 yy_find_action:
00674                 yy_act = yy_accept[yy_current_state];
00675                 <span class="keywordflow">if</span> ( yy_act == 0 )
00676                         { <span class="comment">/* have to back up */</span>
00677                         yy_cp = yy_last_accepting_cpos;
00678                         yy_current_state = yy_last_accepting_state;
00679                         yy_act = yy_accept[yy_current_state];
00680                         }
00681 
00682                 YY_DO_BEFORE_ACTION;
00683 
00684 
00685 do_action:      <span class="comment">/* This label is used only to access EOF actions. */</span>
00686 
00687 
00688                 <span class="keywordflow">switch</span> ( yy_act )
00689         { <span class="comment">/* beginning of action switch */</span>
00690                         <span class="keywordflow">case</span> 0: <span class="comment">/* must back up */</span>
00691                         <span class="comment">/* undo the effects of YY_DO_BEFORE_ACTION */</span>
00692                         *yy_cp = yy_hold_char;
00693                         yy_cp = yy_last_accepting_cpos;
00694                         yy_current_state = yy_last_accepting_state;
00695                         <span class="keywordflow">goto</span> yy_find_action;
00696 
00697 <span class="keywordflow">case</span> 1:
00698 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00699 <span class="preprocessor">#line 65 "conf_lex.l"</span>
00700 <span class="preprocessor"></span>{<span class="comment">/* identifier */</span> <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"[bloc:%s]\n"</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>); strncpy(<a class="code" href="conf__yacc_8c.html#a75">yylval</a>.<a class="code" href="unionYYSTYPE.html#o0">str_val</a>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>); <a class="code" href="conf__lex_8c.html#a7">BEGIN</a> BLOC; <span class="keywordflow">return</span> IDENTIFIER;}
00701         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00702 <span class="keywordflow">case</span> 2:
00703 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00704 <span class="preprocessor">#line 68 "conf_lex.l"</span>
00705 <span class="preprocessor"></span>{<span class="comment">/* identifier */</span> <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"BEGIN_BLOCK\n"</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__lex_8c.html#a7">BEGIN</a> INBLOC;<span class="keywordflow">return</span> BEGIN_BLOCK;}
00706         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00707 <span class="keywordflow">case</span> 3:
00708 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00709 <span class="preprocessor">#line 70 "conf_lex.l"</span>
00710 <span class="preprocessor"></span>{<span class="comment">/* identifier */</span> <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"[id:%s"</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>);strncpy(<a class="code" href="conf__yacc_8c.html#a75">yylval</a>.<a class="code" href="unionYYSTYPE.html#o0">str_val</a>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>); <a class="code" href="conf__lex_8c.html#a7">BEGIN</a> AFFECT;<span class="keywordflow">return</span> IDENTIFIER;}
00711         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00712 <span class="keywordflow">case</span> 4:
00713 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00714 <span class="preprocessor">#line 71 "conf_lex.l"</span>
00715 <span class="preprocessor"></span>{<span class="comment">/* identifier */</span> <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"END_BLOCK\n"</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__lex_8c.html#a7">BEGIN</a> YY_INIT;<span class="keywordflow">return</span> END_BLOCK;}
00716         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00717 <span class="keywordflow">case</span> 5:
00718 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00719 <span class="preprocessor">#line 73 "conf_lex.l"</span>
00720 <span class="preprocessor"></span>{<span class="comment">/* identifier */</span> <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">" , "</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__lex_8c.html#a7">BEGIN</a> VALUE;<span class="keywordflow">return</span> AFFECTATION;}
00721         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00722 <span class="keywordflow">case</span> 6:
00723 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00724 <span class="preprocessor">#line 75 "conf_lex.l"</span>
00725 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> STRING1;<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"value:&lt;"</span>);<a class="code" href="conf__lex_8c.html#a110">YY_BUFFER_RESET</a>();} <span class="comment">/* ouverture string 1 */</span>
00726         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00727 <span class="keywordflow">case</span> 7:
00728 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00729 <span class="preprocessor">#line 76 "conf_lex.l"</span>
00730 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> STRING2;<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"value:&lt;"</span>);<a class="code" href="conf__lex_8c.html#a110">YY_BUFFER_RESET</a>();} <span class="comment">/* ouverture string 2 */</span>
00731         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00732 <span class="keywordflow">case</span> 8:
00733 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00734 <span class="preprocessor">#line 77 "conf_lex.l"</span>
00735 <span class="preprocessor"></span>{<span class="comment">/* valeur */</span><a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"value:%s"</span>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> ENDVALUE;strncpy(<a class="code" href="conf__yacc_8c.html#a75">yylval</a>.<a class="code" href="unionYYSTYPE.html#o0">str_val</a>,<a class="code" href="conf__lex_8c.html#a77">yytext</a>,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>); <span class="keywordflow">return</span> KEYVALUE;}
00736         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00737 <span class="keywordflow">case</span> 9:
00738 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00739 <span class="preprocessor">#line 79 "conf_lex.l"</span>
00740 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"]\n"</span>);<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> INBLOC;<span class="keywordflow">return</span> END_AFFECT;}
00741         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00742 <span class="keywordflow">case</span> 10:
00743 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00744 <span class="preprocessor">#line 81 "conf_lex.l"</span>
00745 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> ESC1;}
00746         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00747 <span class="keywordflow">case</span> 11:
00748 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00749 <span class="preprocessor">#line 82 "conf_lex.l"</span>
00750 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"&gt;"</span>);strncpy(<a class="code" href="conf__yacc_8c.html#a75">yylval</a>.<a class="code" href="unionYYSTYPE.html#o0">str_val</a>,<a class="code" href="conf__lex_8c.html#a89">YY_PARSED_STRING</a>,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>);<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> ENDVALUE;<span class="comment">/* chaine finie */</span> <span class="keywordflow">return</span> KEYVALUE;}
00751         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00752 <span class="keywordflow">case</span> 12:
00753 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00754 <span class="preprocessor">#line 83 "conf_lex.l"</span>
00755 <span class="preprocessor"></span>{snprintf(<a class="code" href="conf__lex_8c.html#a88">err_str</a>,<a class="code" href="conf__lex_8c.html#a37">ERRLEN</a>,<span class="stringliteral">"line %d: missing closing quote."</span>,<a class="code" href="conf__lex_8c.html#a87">yylineno</a>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__yacc_8c.html#a88">set_error</a>(<a class="code" href="conf__lex_8c.html#a88">err_str</a>);<a class="code" href="conf__lex_8c.html#a87">yylineno</a>++;<span class="keywordflow">return</span> _ERROR_;}
00756         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00757 <span class="keywordflow">case</span> 13:
00758 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00759 <span class="preprocessor">#line 84 "conf_lex.l"</span>
00760 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a109">YY_BUFFER_APPEND</a>(<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"%c"</span>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<span class="comment">/* caractere de la chaine */</span>}
00761         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00762 <span class="keywordflow">case</span> 14:
00763 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00764 <span class="preprocessor">#line 86 "conf_lex.l"</span>
00765 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a7">BEGIN</a> STRING1;<a class="code" href="conf__lex_8c.html#a87">yylineno</a>++;<span class="comment">/* ignore un saut de ligne echappe*/</span>
00766         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00767 <span class="keywordflow">case</span> 15:
00768 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00769 <span class="preprocessor">#line 87 "conf_lex.l"</span>
00770 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"%c"</span>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<a class="code" href="conf__lex_8c.html#a109">YY_BUFFER_APPEND</a>(<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> STRING1;<span class="comment">/* caractere de la chaine */</span>}
00771         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00772 <span class="keywordflow">case</span> 16:
00773 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00774 <span class="preprocessor">#line 89 "conf_lex.l"</span>
00775 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"&gt;"</span>);strncpy(<a class="code" href="conf__yacc_8c.html#a75">yylval</a>.<a class="code" href="unionYYSTYPE.html#o0">str_val</a>,<a class="code" href="conf__lex_8c.html#a89">YY_PARSED_STRING</a>,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>);<a class="code" href="conf__lex_8c.html#a7">BEGIN</a> ENDVALUE;<span class="comment">/* chaine finie */</span> <span class="keywordflow">return</span> KEYVALUE;}
00776         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00777 <span class="keywordflow">case</span> 17:
00778 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00779 <span class="preprocessor">#line 90 "conf_lex.l"</span>
00780 <span class="preprocessor"></span>{snprintf(<a class="code" href="conf__lex_8c.html#a88">err_str</a>,<a class="code" href="conf__lex_8c.html#a37">ERRLEN</a>,<span class="stringliteral">"line %d: closing quote missing."</span>,<a class="code" href="conf__lex_8c.html#a87">yylineno</a>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__yacc_8c.html#a88">set_error</a>(<a class="code" href="conf__lex_8c.html#a88">err_str</a>);<a class="code" href="conf__lex_8c.html#a87">yylineno</a>++;<span class="keywordflow">return</span> _ERROR_;}
00781         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00782 <span class="keywordflow">case</span> 18:
00783 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00784 <span class="preprocessor">#line 91 "conf_lex.l"</span>
00785 <span class="preprocessor"></span>{<a class="code" href="conf__lex_8c.html#a109">YY_BUFFER_APPEND</a>(<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<a class="code" href="conf__lex_8c.html#a39">DEBUG_LEX</a>(<span class="stringliteral">"%c"</span>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>);<span class="comment">/* caractere de la chaine */</span>}
00786         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00787 <span class="keywordflow">case</span> 19:
00788 *yy_cp = yy_hold_char; <span class="comment">/* undo effects of setting up yytext */</span>
00789 yy_c_buf_p = yy_cp -= 1;
00790 YY_DO_BEFORE_ACTION; <span class="comment">/* set up yytext again */</span>
00791 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00792 <span class="preprocessor">#line 93 "conf_lex.l"</span>
00793 <span class="preprocessor"></span>;<span class="comment">/* ignore */</span>
00794         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00795 <span class="keywordflow">case</span> 20:
00796 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00797 <span class="preprocessor">#line 94 "conf_lex.l"</span>
00798 <span class="preprocessor"></span>;<span class="comment">/* ignore */</span>
00799         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00800 <span class="keywordflow">case</span> 21:
00801 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00802 <span class="preprocessor">#line 95 "conf_lex.l"</span>
00803 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a87">yylineno</a>++;<span class="comment">/* ignore */</span>
00804         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00805 <span class="keywordflow">case</span> 22:
00806 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00807 <span class="preprocessor">#line 97 "conf_lex.l"</span>
00808 <span class="preprocessor"></span>{ snprintf(<a class="code" href="conf__lex_8c.html#a88">err_str</a>,<a class="code" href="conf__lex_8c.html#a37">ERRLEN</a>,<span class="stringliteral">"line %d: '%c' unexpected"</span>,<a class="code" href="conf__lex_8c.html#a87">yylineno</a>,*<a class="code" href="conf__lex_8c.html#a77">yytext</a>); <a class="code" href="conf__yacc_8c.html#a88">set_error</a>(<a class="code" href="conf__lex_8c.html#a88">err_str</a>);<span class="keywordflow">return</span> _ERROR_;}
00809         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00810 <span class="keywordflow">case</span> 23:
00811 <a class="code" href="conf__lex_8c.html#a60">YY_RULE_SETUP</a>
00812 <span class="preprocessor">#line 99 "conf_lex.l"</span>
00813 <span class="preprocessor"></span>ECHO;
00814         <a class="code" href="conf__lex_8c.html#a59">YY_BREAK</a>
00815 <span class="preprocessor">#line 816 "conf_lex.c"</span>
00816 <span class="preprocessor"></span><span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a36">INITIAL</a>):
00817 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a40">YY_INIT</a>):
00818 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a41">BLOC</a>):
00819 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a42">INBLOC</a>):
00820 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a43">AFFECT</a>):
00821 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a44">VALUE</a>):
00822 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a45">ENDVALUE</a>):
00823 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a46">STRING1</a>):
00824 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a47">STRING2</a>):
00825 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a48">ESC1</a>):
00826         <a class="code" href="conf__lex_8c.html#a55">yyterminate</a>();
00827 
00828         <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a31">YY_END_OF_BUFFER</a>:
00829                 {
00830                 <span class="comment">/* Amount of text matched not including the EOB char. */</span>
00831                 <span class="keywordtype">int</span> yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
00832 
00833                 <span class="comment">/* Undo the effects of YY_DO_BEFORE_ACTION. */</span>
00834                 *yy_cp = yy_hold_char;
00835                 <a class="code" href="conf__lex_8c.html#a35">YY_RESTORE_YY_MORE_OFFSET</a>
00836 
00837                 <span class="keywordflow">if</span> ( yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> == YY_BUFFER_NEW )
00838                         {
00839                         <span class="comment">/* We're scanning a new file or input source.  It's</span>
00840 <span class="comment">                         * possible that this happened because the user</span>
00841 <span class="comment">                         * just pointed yyin at a new source and called</span>
00842 <span class="comment">                         * yylex().  If so, then we have to assure</span>
00843 <span class="comment">                         * consistency between yy_current_buffer and our</span>
00844 <span class="comment">                         * globals.  Here is the right place to do so, because</span>
00845 <span class="comment">                         * this is the first action (other than possibly a</span>
00846 <span class="comment">                         * back-up) that will match for the new input source.</span>
00847 <span class="comment">                         */</span>
00848                         yy_n_chars = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a>;
00849                         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a> = yyin;
00850                         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> = YY_BUFFER_NORMAL;
00851                         }
00852 
00853                 <span class="comment">/* Note that here we test for yy_c_buf_p "&lt;=" to the position</span>
00854 <span class="comment">                 * of the first EOB in the buffer, since yy_c_buf_p will</span>
00855 <span class="comment">                 * already have been incremented past the NUL character</span>
00856 <span class="comment">                 * (since all states make transitions on EOB to the</span>
00857 <span class="comment">                 * end-of-buffer state).  Contrast this with the test</span>
00858 <span class="comment">                 * in input().</span>
00859 <span class="comment">                 */</span>
00860                 <span class="keywordflow">if</span> ( yy_c_buf_p &lt;= &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars] )
00861                         { <span class="comment">/* This was really a NUL. */</span>
00862                         <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_next_state;
00863 
00864                         yy_c_buf_p = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + yy_amount_of_matched_text;
00865 
00866                         yy_current_state = yy_get_previous_state();
00867 
00868                         <span class="comment">/* Okay, we're now positioned to make the NUL</span>
00869 <span class="comment">                         * transition.  We couldn't have</span>
00870 <span class="comment">                         * yy_get_previous_state() go ahead and do it</span>
00871 <span class="comment">                         * for us because it doesn't know how to deal</span>
00872 <span class="comment">                         * with the possibility of jamming (and we don't</span>
00873 <span class="comment">                         * want to build jamming into it because then it</span>
00874 <span class="comment">                         * will run more slowly).</span>
00875 <span class="comment">                         */</span>
00876 
00877                         yy_next_state = yy_try_NUL_trans( yy_current_state );
00878 
00879                         <a class="code" href="conf__lex_8c.html#a90">yy_bp</a> = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + YY_MORE_ADJ;
00880 
00881                         <span class="keywordflow">if</span> ( yy_next_state )
00882                                 {
00883                                 <span class="comment">/* Consume the NUL. */</span>
00884                                 yy_cp = ++yy_c_buf_p;
00885                                 yy_current_state = yy_next_state;
00886                                 <span class="keywordflow">goto</span> yy_match;
00887                                 }
00888 
00889                         <span class="keywordflow">else</span>
00890                                 {
00891                                 yy_cp = yy_c_buf_p;
00892                                 <span class="keywordflow">goto</span> yy_find_action;
00893                                 }
00894                         }
00895 
00896                 <span class="keywordflow">else</span> <span class="keywordflow">switch</span> ( yy_get_next_buffer() )
00897                         {
00898                         <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a15">EOB_ACT_END_OF_FILE</a>:
00899                                 {
00900                                 yy_did_buffer_switch_on_eof = 0;
00901 
00902                                 <span class="keywordflow">if</span> ( yywrap() )
00903                                         {
00904                                         <span class="comment">/* Note: because we've taken care in</span>
00905 <span class="comment">                                         * yy_get_next_buffer() to have set up</span>
00906 <span class="comment">                                         * yytext, we can now set up</span>
00907 <span class="comment">                                         * yy_c_buf_p so that if some total</span>
00908 <span class="comment">                                         * hoser (like flex itself) wants to</span>
00909 <span class="comment">                                         * call the scanner after we return the</span>
00910 <span class="comment">                                         * YY_NULL, it'll still work - another</span>
00911 <span class="comment">                                         * YY_NULL will get returned.</span>
00912 <span class="comment">                                         */</span>
00913                                         yy_c_buf_p = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + YY_MORE_ADJ;
00914 
00915                                         yy_act = <a class="code" href="conf__lex_8c.html#a10">YY_STATE_EOF</a>(<a class="code" href="conf__lex_8c.html#a8">YY_START</a>);
00916                                         <span class="keywordflow">goto</span> do_action;
00917                                         }
00918 
00919                                 <span class="keywordflow">else</span>
00920                                         {
00921                                         <span class="keywordflow">if</span> ( ! yy_did_buffer_switch_on_eof )
00922                                                 YY_NEW_FILE;
00923                                         }
00924                                 <span class="keywordflow">break</span>;
00925                                 }
00926 
00927                         <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a14">EOB_ACT_CONTINUE_SCAN</a>:
00928                                 yy_c_buf_p =
00929                                         <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + yy_amount_of_matched_text;
00930 
00931                                 yy_current_state = yy_get_previous_state();
00932 
00933                                 yy_cp = yy_c_buf_p;
00934                                 <a class="code" href="conf__lex_8c.html#a90">yy_bp</a> = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + YY_MORE_ADJ;
00935                                 <span class="keywordflow">goto</span> yy_match;
00936 
00937                         <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a16">EOB_ACT_LAST_MATCH</a>:
00938                                 yy_c_buf_p =
00939                                 &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars];
00940 
00941                                 yy_current_state = yy_get_previous_state();
00942 
00943                                 yy_cp = yy_c_buf_p;
00944                                 <a class="code" href="conf__lex_8c.html#a90">yy_bp</a> = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + YY_MORE_ADJ;
00945                                 <span class="keywordflow">goto</span> yy_find_action;
00946                         }
00947                 <span class="keywordflow">break</span>;
00948                 }
00949 
00950         <span class="keywordflow">default</span>:
00951                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>(
00952                         <span class="stringliteral">"fatal flex scanner internal error--no action found"</span> );
00953         } <span class="comment">/* end of action switch */</span>
00954                 } <span class="comment">/* end of scanning one token */</span>
00955         } <span class="comment">/* end of yylex */</span>
00956 
00957 
00958 <span class="comment">/* yy_get_next_buffer - try to read in a new buffer</span>
00959 <span class="comment"> *</span>
00960 <span class="comment"> * Returns a code representing an action:</span>
00961 <span class="comment"> *      EOB_ACT_LAST_MATCH -</span>
00962 <span class="comment"> *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position</span>
00963 <span class="comment"> *      EOB_ACT_END_OF_FILE - end of file</span>
00964 <span class="comment"> */</span>
00965 
00966 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_get_next_buffer()
00967         {
00968         <span class="keyword">register</span> <span class="keywordtype">char</span> *dest = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>;
00969         <span class="keyword">register</span> <span class="keywordtype">char</span> *source = yytext_ptr;
00970         <span class="keyword">register</span> <span class="keywordtype">int</span> number_to_move, i;
00971         <span class="keywordtype">int</span> ret_val;
00972 
00973         <span class="keywordflow">if</span> ( yy_c_buf_p &gt; &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars + 1] )
00974                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>(
00975                 <span class="stringliteral">"fatal flex scanner internal error--end of buffer missed"</span> );
00976 
00977         <span class="keywordflow">if</span> ( yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o8">yy_fill_buffer</a> == 0 )
00978                 { <span class="comment">/* Don't try to fill the buffer, so this is an EOF. */</span>
00979                 <span class="keywordflow">if</span> ( yy_c_buf_p - <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> - <a class="code" href="conf__lex_8c.html#a34">YY_MORE_ADJ</a> == 1 )
00980                         {
00981                         <span class="comment">/* We matched a single character, the EOB, so</span>
00982 <span class="comment">                         * treat this as a final EOF.</span>
00983 <span class="comment">                         */</span>
00984                         <span class="keywordflow">return</span> EOB_ACT_END_OF_FILE;
00985                         }
00986 
00987                 <span class="keywordflow">else</span>
00988                         {
00989                         <span class="comment">/* We matched some text prior to the EOB, first</span>
00990 <span class="comment">                         * process it.</span>
00991 <span class="comment">                         */</span>
00992                         <span class="keywordflow">return</span> EOB_ACT_LAST_MATCH;
00993                         }
00994                 }
00995 
00996         <span class="comment">/* Try to read more data. */</span>
00997 
00998         <span class="comment">/* First move last chars to start of buffer. */</span>
00999         number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
01000 
01001         <span class="keywordflow">for</span> ( i = 0; i &lt; number_to_move; ++i )
01002                 *(dest++) = *(source++);
01003 
01004         <span class="keywordflow">if</span> ( yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> == YY_BUFFER_EOF_PENDING )
01005                 <span class="comment">/* don't do the read, it's not guaranteed to return an EOF,</span>
01006 <span class="comment">                 * just force an EOF</span>
01007 <span class="comment">                 */</span>
01008                 yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = yy_n_chars = 0;
01009 
01010         <span class="keywordflow">else</span>
01011                 {
01012                 <span class="keywordtype">int</span> num_to_read =
01013                         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> - number_to_move - 1;
01014 
01015                 <span class="keywordflow">while</span> ( num_to_read &lt;= 0 )
01016                         { <span class="comment">/* Not enough room in the buffer - grow it. */</span>
01017 <span class="preprocessor">#ifdef YY_USES_REJECT</span>
01018 <span class="preprocessor"></span>                        <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>(
01019 <span class="stringliteral">"input buffer overflow, can't enlarge buffer because scanner uses REJECT"</span> );
01020 <span class="preprocessor">#else</span>
01021 <span class="preprocessor"></span>
01022                         <span class="comment">/* just a shorter name for the current buffer */</span>
01023                         <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> b = yy_current_buffer;
01024 
01025                         <span class="keywordtype">int</span> yy_c_buf_p_offset =
01026                                 (int) (yy_c_buf_p - b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>);
01027 
01028                         <span class="keywordflow">if</span> ( b-&gt;<a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a> )
01029                                 {
01030                                 <span class="keywordtype">int</span> new_size = b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> * 2;
01031 
01032                                 <span class="keywordflow">if</span> ( new_size &lt;= 0 )
01033                                         b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> += b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> / 8;
01034                                 <span class="keywordflow">else</span>
01035                                         b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> *= 2;
01036 
01037                                 b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> = (<span class="keywordtype">char</span> *)
01038                                         <span class="comment">/* Include room in for 2 EOB chars. */</span>
01039                                         yy_flex_realloc( (<span class="keywordtype">void</span> *) b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>,
01040                                                          b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> + 2 );
01041                                 }
01042                         <span class="keywordflow">else</span>
01043                                 <span class="comment">/* Can't grow it, we don't own it. */</span>
01044                                 b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> = 0;
01045 
01046                         <span class="keywordflow">if</span> ( ! b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> )
01047                                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>(
01048                                 <span class="stringliteral">"fatal error - scanner input buffer overflow"</span> );
01049 
01050                         yy_c_buf_p = &amp;b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_c_buf_p_offset];
01051 
01052                         num_to_read = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> -
01053                                                 number_to_move - 1;
01054 <span class="preprocessor">#endif</span>
01055 <span class="preprocessor"></span>                        }
01056 
01057                 <span class="keywordflow">if</span> ( num_to_read &gt; YY_READ_BUF_SIZE )
01058                         num_to_read = YY_READ_BUF_SIZE;
01059 
01060                 <span class="comment">/* Read in more data. */</span>
01061                 <a class="code" href="conf__lex_8c.html#a54">YY_INPUT</a>( (&amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[number_to_move]),
01062                         yy_n_chars, num_to_read );
01063 
01064                 yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = yy_n_chars;
01065                 }
01066 
01067         <span class="keywordflow">if</span> ( yy_n_chars == 0 )
01068                 {
01069                 <span class="keywordflow">if</span> ( number_to_move == YY_MORE_ADJ )
01070                         {
01071                         ret_val = EOB_ACT_END_OF_FILE;
01072                         yyrestart( yyin );
01073                         }
01074 
01075                 <span class="keywordflow">else</span>
01076                         {
01077                         ret_val = EOB_ACT_LAST_MATCH;
01078                         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> =
01079                                 YY_BUFFER_EOF_PENDING;
01080                         }
01081                 }
01082 
01083         <span class="keywordflow">else</span>
01084                 ret_val = EOB_ACT_CONTINUE_SCAN;
01085 
01086         yy_n_chars += number_to_move;
01087         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
01088         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
01089 
01090         <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> = &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[0];
01091 
01092         <span class="keywordflow">return</span> ret_val;
01093         }
01094 
01095 
01096 <span class="comment">/* yy_get_previous_state - get the state just before the EOB char was reached */</span>
01097 
01098 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_get_previous_state()
01099         {
01100         <span class="keyword">register</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_current_state;
01101         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp;
01102 
01103         yy_current_state = yy_start;
01104 
01105         <span class="keywordflow">for</span> ( yy_cp = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + YY_MORE_ADJ; yy_cp &lt; yy_c_buf_p; ++yy_cp )
01106                 {
01107                 <span class="keyword">register</span> <a class="code" href="conf__lex_8c.html#a75">YY_CHAR</a> yy_c = (*yy_cp ? yy_ec[<a class="code" href="conf__lex_8c.html#a6">YY_SC_TO_UI</a>(*yy_cp)] : 1);
01108                 <span class="keywordflow">if</span> ( yy_accept[yy_current_state] )
01109                         {
01110                         yy_last_accepting_state = yy_current_state;
01111                         yy_last_accepting_cpos = yy_cp;
01112                         }
01113                 <span class="keywordflow">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
01114                         {
01115                         yy_current_state = (int) yy_def[yy_current_state];
01116                         <span class="keywordflow">if</span> ( yy_current_state &gt;= 56 )
01117                                 yy_c = yy_meta[(<span class="keywordtype">unsigned</span> int) yy_c];
01118                         }
01119                 yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keywordtype">unsigned</span> int) yy_c];
01120                 }
01121 
01122         <span class="keywordflow">return</span> yy_current_state;
01123         }
01124 
01125 
01126 <span class="comment">/* yy_try_NUL_trans - try to make a transition on the NUL character</span>
01127 <span class="comment"> *</span>
01128 <span class="comment"> * synopsis</span>
01129 <span class="comment"> *      next_state = yy_try_NUL_trans( current_state );</span>
01130 <span class="comment"> */</span>
01131 
01132 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01133 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_try_NUL_trans( yy_state_type yy_current_state )
01134 #<span class="keywordflow">else</span>
01135 <span class="keyword">static</span> <a class="code" href="conf__lex_8c.html#a76">yy_state_type</a> yy_try_NUL_trans( yy_current_state )
01136 yy_state_type yy_current_state;
01137 #endif
01138         {
01139         <span class="keyword">register</span> <span class="keywordtype">int</span> yy_is_jam;
01140         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp = yy_c_buf_p;
01141 
01142         <span class="keyword">register</span> <a class="code" href="conf__lex_8c.html#a75">YY_CHAR</a> yy_c = 1;
01143         <span class="keywordflow">if</span> ( yy_accept[yy_current_state] )
01144                 {
01145                 yy_last_accepting_state = yy_current_state;
01146                 yy_last_accepting_cpos = yy_cp;
01147                 }
01148         <span class="keywordflow">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
01149                 {
01150                 yy_current_state = (int) yy_def[yy_current_state];
01151                 <span class="keywordflow">if</span> ( yy_current_state &gt;= 56 )
01152                         yy_c = yy_meta[(<span class="keywordtype">unsigned</span> int) yy_c];
01153                 }
01154         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keywordtype">unsigned</span> int) yy_c];
01155         yy_is_jam = (yy_current_state == 55);
01156 
01157         <span class="keywordflow">return</span> yy_is_jam ? 0 : yy_current_state;
01158         }
01159 
01160 
01161 <span class="preprocessor">#ifndef YY_NO_UNPUT</span>
01162 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01163 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yyunput( <span class="keywordtype">int</span> c, <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_bp )
01164 #<span class="keywordflow">else</span>
01165 <span class="keyword">static</span> <span class="keywordtype">void</span> yyunput( c, yy_bp )
01166 int c;
<a name="l01167"></a><a class="code" href="conf__lex_8c.html#a90">01167</a> register <span class="keywordtype">char</span> *yy_bp;
01168 #endif
01169         {
01170         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp = yy_c_buf_p;
01171 
01172         <span class="comment">/* undo effects of setting up yytext */</span>
01173         *yy_cp = yy_hold_char;
01174 
01175         <span class="keywordflow">if</span> ( yy_cp &lt; yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> + 2 )
01176                 { <span class="comment">/* need to shift things up to make room */</span>
01177                 <span class="comment">/* +2 for EOB chars. */</span>
01178                 <span class="keyword">register</span> <span class="keywordtype">int</span> number_to_move = yy_n_chars + 2;
01179                 <span class="keyword">register</span> <span class="keywordtype">char</span> *dest = &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[
01180                                         yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> + 2];
01181                 <span class="keyword">register</span> <span class="keywordtype">char</span> *source =
01182                                 &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[number_to_move];
01183 
01184                 <span class="keywordflow">while</span> ( source &gt; yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> )
01185                         *--dest = *--source;
01186 
01187                 yy_cp += (int) (dest - source);
01188                 <a class="code" href="conf__lex_8c.html#a90">yy_bp</a> += (int) (dest - source);
01189                 yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> =
01190                         yy_n_chars = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a>;
01191 
01192                 <span class="keywordflow">if</span> ( yy_cp &lt; yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> + 2 )
01193                         <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"flex scanner push-back overflow"</span> );
01194                 }
01195 
01196         *--yy_cp = (char) c;
01197 
01198 
01199         <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> = yy_bp;
01200         yy_hold_char = *yy_cp;
01201         yy_c_buf_p = yy_cp;
01202         }
01203 <span class="preprocessor">#endif  </span><span class="comment">/* ifndef YY_NO_UNPUT */</span>
01204 
01205 
01206 <span class="preprocessor">#ifndef YY_NO_INPUT</span>
01207 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
01208 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yyinput()
01209 #<span class="keywordflow">else</span>
01210 <span class="keyword">static</span> <span class="keywordtype">int</span> input()
01211 #endif
01212         {
01213         <span class="keywordtype">int</span> c;
01214 
01215         *yy_c_buf_p = yy_hold_char;
01216 
01217         <span class="keywordflow">if</span> ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
01218                 {
01219                 <span class="comment">/* yy_c_buf_p now points to the character we want to return.</span>
01220 <span class="comment">                 * If this occurs *before* the EOB characters, then it's a</span>
01221 <span class="comment">                 * valid NUL; if not, then we've hit the end of the buffer.</span>
01222 <span class="comment">                 */</span>
01223                 <span class="keywordflow">if</span> ( yy_c_buf_p &lt; &amp;yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars] )
01224                         <span class="comment">/* This was really a NUL. */</span>
01225                         *yy_c_buf_p = <span class="charliteral">'\0'</span>;
01226 
01227                 <span class="keywordflow">else</span>
01228                         { <span class="comment">/* need more input */</span>
01229                         <span class="keywordtype">int</span> offset = yy_c_buf_p - yytext_ptr;
01230                         ++yy_c_buf_p;
01231 
01232                         <span class="keywordflow">switch</span> ( yy_get_next_buffer() )
01233                                 {
01234                                 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a16">EOB_ACT_LAST_MATCH</a>:
01235                                         <span class="comment">/* This happens because yy_g_n_b()</span>
01236 <span class="comment">                                         * sees that we've accumulated a</span>
01237 <span class="comment">                                         * token and flags that we need to</span>
01238 <span class="comment">                                         * try matching the token before</span>
01239 <span class="comment">                                         * proceeding.  But for input(),</span>
01240 <span class="comment">                                         * there's no matching to consider.</span>
01241 <span class="comment">                                         * So convert the EOB_ACT_LAST_MATCH</span>
01242 <span class="comment">                                         * to EOB_ACT_END_OF_FILE.</span>
01243 <span class="comment">                                         */</span>
01244 
01245                                         <span class="comment">/* Reset buffer status. */</span>
01246                                         yyrestart( yyin );
01247 
01248                                         <span class="comment">/* fall through */</span>
01249 
01250                                 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a15">EOB_ACT_END_OF_FILE</a>:
01251                                         {
01252                                         <span class="keywordflow">if</span> ( yywrap() )
01253                                                 <span class="keywordflow">return</span> EOF;
01254 
01255                                         <span class="keywordflow">if</span> ( ! yy_did_buffer_switch_on_eof )
01256                                                 YY_NEW_FILE;
01257 <span class="preprocessor">#ifdef __cplusplus</span>
01258 <span class="preprocessor"></span>                                        <span class="keywordflow">return</span> yyinput();
01259 <span class="preprocessor">#else</span>
01260 <span class="preprocessor"></span>                                        <span class="keywordflow">return</span> input();
01261 <span class="preprocessor">#endif</span>
01262 <span class="preprocessor"></span>                                        }
01263 
01264                                 <span class="keywordflow">case</span> <a class="code" href="conf__lex_8c.html#a14">EOB_ACT_CONTINUE_SCAN</a>:
01265                                         yy_c_buf_p = <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> + offset;
01266                                         <span class="keywordflow">break</span>;
01267                                 }
01268                         }
01269                 }
01270 
01271         c = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) yy_c_buf_p;      <span class="comment">/* cast for 8-bit char's */</span>
01272         *yy_c_buf_p = <span class="charliteral">'\0'</span>;     <span class="comment">/* preserve yytext */</span>
01273         yy_hold_char = *++yy_c_buf_p;
01274 
01275 
01276         <span class="keywordflow">return</span> c;
01277         }
01278 <span class="preprocessor">#endif </span><span class="comment">/* YY_NO_INPUT */</span>
01279 
01280 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01281 <span class="preprocessor"></span><span class="keywordtype">void</span> yyrestart( FILE *input_file )
01282 #<span class="keywordflow">else</span>
01283 <span class="keywordtype">void</span> yyrestart( input_file )
01284 FILE *input_file;
01285 #endif
01286         {
01287         <span class="keywordflow">if</span> ( ! yy_current_buffer )
01288                 yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
01289 
01290         yy_init_buffer( yy_current_buffer, input_file );
01291         yy_load_buffer_state();
01292         }
01293 
01294 
01295 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01296 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
01297 #<span class="keywordflow">else</span>
01298 <span class="keywordtype">void</span> yy_switch_to_buffer( new_buffer )
01299 YY_BUFFER_STATE new_buffer;
01300 #endif
01301         {
01302         <span class="keywordflow">if</span> ( yy_current_buffer == new_buffer )
01303                 <span class="keywordflow">return</span>;
01304 
01305         <span class="keywordflow">if</span> ( yy_current_buffer )
01306                 {
01307                 <span class="comment">/* Flush out information for old buffer. */</span>
01308                 *yy_c_buf_p = yy_hold_char;
01309                 yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a> = yy_c_buf_p;
01310                 yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = yy_n_chars;
01311                 }
01312 
01313         yy_current_buffer = new_buffer;
01314         yy_load_buffer_state();
01315 
01316         <span class="comment">/* We don't actually know whether we did this switch during</span>
01317 <span class="comment">         * EOF (yywrap()) processing, but the only time this flag</span>
01318 <span class="comment">         * is looked at is after yywrap() is called, so it's safe</span>
01319 <span class="comment">         * to go ahead and always set it.</span>
01320 <span class="comment">         */</span>
01321         yy_did_buffer_switch_on_eof = 1;
01322         }
01323 
01324 
01325 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01326 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_load_buffer_state( <span class="keywordtype">void</span> )
01327 #<span class="keywordflow">else</span>
01328 <span class="keywordtype">void</span> yy_load_buffer_state()
01329 #endif
01330         {
01331         yy_n_chars = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a>;
01332         <a class="code" href="conf__lex_8c.html#a28">yytext_ptr</a> = yy_c_buf_p = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a>;
01333         <a class="code" href="conf__lex_8c.html#a65">yyin</a> = yy_current_buffer-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a>;
01334         yy_hold_char = *yy_c_buf_p;
01335         }
01336 
01337 
01338 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01339 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_create_buffer( FILE *file, <span class="keywordtype">int</span> size )
01340 #<span class="keywordflow">else</span>
01341 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_create_buffer( file, size )
01342 FILE *file;
01343 <span class="keywordtype">int</span> size;
01344 #endif
01345         {
01346         <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> b;
01347 
01348         b = (YY_BUFFER_STATE) yy_flex_alloc( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> <a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> ) );
01349         <span class="keywordflow">if</span> ( ! b )
01350                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"out of dynamic memory in yy_create_buffer()"</span> );
01351 
01352         b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> = size;
01353 
01354         <span class="comment">/* yy_ch_buf has to be 2 characters longer than the size given because</span>
01355 <span class="comment">         * we need to put in 2 end-of-buffer characters.</span>
01356 <span class="comment">         */</span>
01357         b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> = (<span class="keywordtype">char</span> *) yy_flex_alloc( b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> + 2 );
01358         <span class="keywordflow">if</span> ( ! b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> )
01359                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"out of dynamic memory in yy_create_buffer()"</span> );
01360 
01361         b-&gt;<a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a> = 1;
01362 
01363         yy_init_buffer( b, file );
01364 
01365         <span class="keywordflow">return</span> b;
01366         }
01367 
01368 
01369 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01370 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_delete_buffer( YY_BUFFER_STATE b )
01371 #<span class="keywordflow">else</span>
01372 <span class="keywordtype">void</span> yy_delete_buffer( b )
01373 YY_BUFFER_STATE b;
01374 #endif
01375         {
01376         <span class="keywordflow">if</span> ( ! b )
01377                 <span class="keywordflow">return</span>;
01378 
01379         <span class="keywordflow">if</span> ( b == yy_current_buffer )
01380                 yy_current_buffer = (YY_BUFFER_STATE) 0;
01381 
01382         <span class="keywordflow">if</span> ( b-&gt;yy_is_our_buffer )
01383                 yy_flex_free( (<span class="keywordtype">void</span> *) b-&gt;yy_ch_buf );
01384 
01385         yy_flex_free( (<span class="keywordtype">void</span> *) b );
01386         }
01387 
01388 
01389 
01390 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01391 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
01392 #<span class="keywordflow">else</span>
01393 <span class="keywordtype">void</span> yy_init_buffer( b, file )
01394 YY_BUFFER_STATE b;
<a name="l01395"></a><a class="code" href="conf__lex_8c.html#a92">01395</a> FILE *file;
01396 #endif
01397 
01398 
01399         {
01400         yy_flush_buffer( b );
01401 
01402         b-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a> = file;
01403         b-&gt;<a class="code" href="structyy__buffer__state.html#o8">yy_fill_buffer</a> = 1;
01404 
01405 <span class="preprocessor">#if YY_ALWAYS_INTERACTIVE</span>
01406 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = 1;
01407 <span class="preprocessor">#else</span>
01408 <span class="preprocessor"></span><span class="preprocessor">#if YY_NEVER_INTERACTIVE</span>
01409 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = 0;
01410 <span class="preprocessor">#else</span>
01411 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = <a class="code" href="conf__lex_8c.html#a92">file</a> ? (isatty( fileno(<a class="code" href="conf__lex_8c.html#a92">file</a>) ) &gt; 0) : 0;
01412 <span class="preprocessor">#endif</span>
01413 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01414 <span class="preprocessor"></span>        }
01415 
01416 
01417 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01418 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_flush_buffer( YY_BUFFER_STATE b )
01419 #<span class="keywordflow">else</span>
01420 <span class="keywordtype">void</span> yy_flush_buffer( b )
01421 YY_BUFFER_STATE b;
01422 #endif
01423 
01424         {
01425         <span class="keywordflow">if</span> ( ! b )
01426                 <span class="keywordflow">return</span>;
01427 
01428         b-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = 0;
01429 
01430         <span class="comment">/* We always need two end-of-buffer characters.  The first causes</span>
01431 <span class="comment">         * a transition to the end-of-buffer state.  The second causes</span>
01432 <span class="comment">         * a jam in that state.</span>
01433 <span class="comment">         */</span>
01434         b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[0] = YY_END_OF_BUFFER_CHAR;
01435         b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[1] = YY_END_OF_BUFFER_CHAR;
01436 
01437         b-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a> = &amp;b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[0];
01438 
01439         b-&gt;<a class="code" href="structyy__buffer__state.html#o7">yy_at_bol</a> = 1;
01440         b-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> = YY_BUFFER_NEW;
01441 
01442         <span class="keywordflow">if</span> ( b == yy_current_buffer )
01443                 yy_load_buffer_state();
01444         }
01445 
01446 
01447 <span class="preprocessor">#ifndef YY_NO_SCAN_BUFFER</span>
01448 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01449 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_buffer( <span class="keywordtype">char</span> *base, yy_size_t size )
01450 #<span class="keywordflow">else</span>
01451 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_buffer( base, size )
01452 char *base;
01453 yy_size_t size;
01454 #endif
01455         {
01456         <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> b;
01457 
01458         <span class="keywordflow">if</span> ( <a class="code" href="conf__lex_8c.html#a91">size</a> &lt; 2 ||
01459              base[<a class="code" href="conf__lex_8c.html#a91">size</a>-2] != <a class="code" href="conf__lex_8c.html#a12">YY_END_OF_BUFFER_CHAR</a> ||
01460              base[<a class="code" href="conf__lex_8c.html#a91">size</a>-1] != YY_END_OF_BUFFER_CHAR )
01461                 <span class="comment">/* They forgot to leave room for the EOB's. */</span>
01462                 <span class="keywordflow">return</span> 0;
01463 
01464         b = (YY_BUFFER_STATE) yy_flex_alloc( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> <a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> ) );
01465         <span class="keywordflow">if</span> ( ! b )
01466                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"out of dynamic memory in yy_scan_buffer()"</span> );
01467 
01468         b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> = <a class="code" href="conf__lex_8c.html#a91">size</a> - 2;      <span class="comment">/* "- 2" to take care of EOB's */</span>
01469         b-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a> = b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> = base;
01470         b-&gt;<a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a> = 0;
01471         b-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a> = 0;
01472         b-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a>;
01473         b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = 0;
01474         b-&gt;<a class="code" href="structyy__buffer__state.html#o7">yy_at_bol</a> = 1;
01475         b-&gt;<a class="code" href="structyy__buffer__state.html#o8">yy_fill_buffer</a> = 0;
01476         b-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> = YY_BUFFER_NEW;
01477 
01478         yy_switch_to_buffer( b );
01479 
01480         <span class="keywordflow">return</span> b;
01481         }
01482 <span class="preprocessor">#endif</span>
01483 <span class="preprocessor"></span>
01484 
01485 <span class="preprocessor">#ifndef YY_NO_SCAN_STRING</span>
01486 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01487 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_string( yyconst <span class="keywordtype">char</span> *yy_str )
01488 #<span class="keywordflow">else</span>
01489 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_string( yy_str )
01490 yyconst <span class="keywordtype">char</span> *yy_str;
01491 #endif
01492         {
01493         <span class="keywordtype">int</span> len;
01494         <span class="keywordflow">for</span> ( <a class="code" href="conf__lex_8c.html#a93">len</a> = 0; yy_str[len]; ++len )
01495                 ;
01496 
01497         <span class="keywordflow">return</span> yy_scan_bytes( yy_str, len );
01498         }
01499 <span class="preprocessor">#endif</span>
01500 <span class="preprocessor"></span>
01501 
01502 <span class="preprocessor">#ifndef YY_NO_SCAN_BYTES</span>
01503 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01504 <span class="preprocessor"></span><a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_bytes( yyconst <span class="keywordtype">char</span> *bytes, <span class="keywordtype">int</span> len )
01505 #<span class="keywordflow">else</span>
01506 <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> yy_scan_bytes( bytes, len )
01507 yyconst <span class="keywordtype">char</span> *bytes;
<a name="l01508"></a><a class="code" href="conf__lex_8c.html#a93">01508</a> <span class="keywordtype">int</span> len;
01509 #endif
01510         {
01511         <a class="code" href="conf__lex_8c.html#a63">YY_BUFFER_STATE</a> b;
01512         <span class="keywordtype">char</span> *buf;
01513         <a class="code" href="conf__lex_8c.html#a67">yy_size_t</a> n;
01514         <span class="keywordtype">int</span> i;
01515 
01516         <span class="comment">/* Get memory for full buffer, including space for trailing EOB's. */</span>
01517         n = <a class="code" href="conf__lex_8c.html#a93">len</a> + 2;
01518         buf = (<span class="keywordtype">char</span> *) yy_flex_alloc( n );
01519         <span class="keywordflow">if</span> ( ! buf )
01520                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"out of dynamic memory in yy_scan_bytes()"</span> );
01521 
01522         <span class="keywordflow">for</span> ( i = 0; i &lt; len; ++i )
01523                 buf[i] = bytes[i];
01524 
01525         buf[len] = buf[<a class="code" href="conf__lex_8c.html#a93">len</a>+1] = YY_END_OF_BUFFER_CHAR;
01526 
01527         b = yy_scan_buffer( buf, n );
01528         <span class="keywordflow">if</span> ( ! b )
01529                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"bad buffer in yy_scan_bytes()"</span> );
01530 
01531         <span class="comment">/* It's okay to grow etc. this buffer, and we should throw it</span>
01532 <span class="comment">         * away when we're done.</span>
01533 <span class="comment">         */</span>
01534         b-&gt;<a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a> = 1;
01535 
01536         <span class="keywordflow">return</span> b;
01537         }
01538 <span class="preprocessor">#endif</span>
01539 <span class="preprocessor"></span>
01540 
01541 <span class="preprocessor">#ifndef YY_NO_PUSH_STATE</span>
01542 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01543 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_push_state( <span class="keywordtype">int</span> new_state )
01544 #<span class="keywordflow">else</span>
01545 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_push_state( new_state )
01546 int new_state;
01547 #endif
01548         {
01549         <span class="keywordflow">if</span> ( yy_start_stack_ptr &gt;= yy_start_stack_depth )
01550                 {
01551                 <a class="code" href="conf__lex_8c.html#a67">yy_size_t</a> new_size;
01552 
01553                 yy_start_stack_depth += YY_START_STACK_INCR;
01554                 new_size = yy_start_stack_depth * <span class="keyword">sizeof</span>( int );
01555 
01556                 <span class="keywordflow">if</span> ( ! yy_start_stack )
01557                         yy_start_stack = (<span class="keywordtype">int</span> *) yy_flex_alloc( new_size );
01558 
01559                 <span class="keywordflow">else</span>
01560                         yy_start_stack = (<span class="keywordtype">int</span> *) yy_flex_realloc(
01561                                         (<span class="keywordtype">void</span> *) yy_start_stack, new_size );
01562 
01563                 <span class="keywordflow">if</span> ( ! yy_start_stack )
01564                         <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>(
01565                         <span class="stringliteral">"out of memory expanding start-condition stack"</span> );
01566                 }
01567 
01568         yy_start_stack[yy_start_stack_ptr++] = YY_START;
01569 
01570         <a class="code" href="conf__lex_8c.html#a7">BEGIN</a>(new_state);
01571         }
01572 <span class="preprocessor">#endif</span>
01573 <span class="preprocessor"></span>
01574 
01575 <span class="preprocessor">#ifndef YY_NO_POP_STATE</span>
01576 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_pop_state()
01577         {
01578         <span class="keywordflow">if</span> ( --yy_start_stack_ptr &lt; 0 )
01579                 <a class="code" href="conf__lex_8c.html#a57">YY_FATAL_ERROR</a>( <span class="stringliteral">"start-condition stack underflow"</span> );
01580 
01581         <a class="code" href="conf__lex_8c.html#a7">BEGIN</a>(yy_start_stack[yy_start_stack_ptr]);
01582         }
01583 <span class="preprocessor">#endif</span>
01584 <span class="preprocessor"></span>
01585 
01586 <span class="preprocessor">#ifndef YY_NO_TOP_STATE</span>
01587 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_top_state()
01588         {
01589         <span class="keywordflow">return</span> yy_start_stack[yy_start_stack_ptr - 1];
01590         }
01591 <span class="preprocessor">#endif</span>
01592 <span class="preprocessor"></span>
01593 <span class="preprocessor">#ifndef YY_EXIT_FAILURE</span>
01594 <span class="preprocessor"></span><span class="preprocessor">#define YY_EXIT_FAILURE 2</span>
01595 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01596 <span class="preprocessor"></span>
01597 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01598 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error( yyconst <span class="keywordtype">char</span> msg[] )
01599 #<span class="keywordflow">else</span>
01600 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error( msg )
01601 char msg[];
01602 #endif
01603         {
01604         (void) fprintf( stderr, <span class="stringliteral">"%s\n"</span>, msg );
01605         exit( YY_EXIT_FAILURE );
01606         }
01607 
01608 
01609 
01610 <span class="comment">/* Redefine yyless() so it works in section 3 code. */</span>
01611 
01612 <span class="preprocessor">#undef yyless</span>
01613 <span class="preprocessor"></span><span class="preprocessor">#define yyless(n) \</span>
01614 <span class="preprocessor">        do \</span>
01615 <span class="preprocessor">                { \</span>
01616 <span class="preprocessor">                </span><span class="comment">/* Undo effects of setting up yytext. */</span> \
01617                 yytext[yyleng] = yy_hold_char; \
01618                 yy_c_buf_p = yytext + n; \
01619                 yy_hold_char = *yy_c_buf_p; \
01620                 *yy_c_buf_p = '\0'; \
01621                 yyleng = n; \
01622                 } \
01623         while ( 0 )
01624 
01625 
01626 <span class="comment">/* Internal utility routines. */</span>
01627 
01628 <span class="preprocessor">#ifndef yytext_ptr</span>
01629 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01630 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy( <span class="keywordtype">char</span> *s1, yyconst <span class="keywordtype">char</span> *s2, <span class="keywordtype">int</span> n )
01631 #<span class="keywordflow">else</span>
01632 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy( s1, s2, n )
01633 char *s1;
01634 yyconst <span class="keywordtype">char</span> *s2;
01635 <span class="keywordtype">int</span> n;
01636 #endif
01637         {
01638         <span class="keyword">register</span> <span class="keywordtype">int</span> i;
01639         <span class="keywordflow">for</span> ( i = 0; i &lt; n; ++i )
01640                 s1[i] = s2[i];
01641         }
01642 <span class="preprocessor">#endif</span>
01643 <span class="preprocessor"></span>
01644 <span class="preprocessor">#ifdef YY_NEED_STRLEN</span>
01645 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01646 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_flex_strlen( yyconst <span class="keywordtype">char</span> *s )
01647 #<span class="keywordflow">else</span>
01648 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_flex_strlen( s )
01649 yyconst <span class="keywordtype">char</span> *s;
01650 #endif
01651         {
01652         <span class="keyword">register</span> <span class="keywordtype">int</span> n;
01653         <span class="keywordflow">for</span> ( n = 0; s[n]; ++n )
01654                 ;
01655 
01656         <span class="keywordflow">return</span> n;
01657         }
01658 <span class="preprocessor">#endif</span>
01659 <span class="preprocessor"></span>
01660 
01661 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01662 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc( yy_size_t size )
01663 #<span class="keywordflow">else</span>
01664 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc( size )
01665 yy_size_t size;
01666 #endif
01667         {
01668         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) malloc( size );
01669         }
01670 
01671 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01672 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_realloc( <span class="keywordtype">void</span> *ptr, yy_size_t size )
01673 #<span class="keywordflow">else</span>
01674 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_realloc( ptr, size )
01675 void *ptr;
<a name="l01676"></a><a class="code" href="conf__lex_8c.html#a91">01676</a> yy_size_t size;
01677 #endif
01678         {
01679         <span class="comment">/* The cast to (char *) in the following accommodates both</span>
01680 <span class="comment">         * implementations that use char* generic pointers, and those</span>
01681 <span class="comment">         * that use void* generic pointers.  It works with the latter</span>
01682 <span class="comment">         * because both ANSI C and C++ allow castless assignment from</span>
01683 <span class="comment">         * any pointer type to void*, and deal with argument conversions</span>
01684 <span class="comment">         * as though doing an assignment.</span>
01685 <span class="comment">         */</span>
01686         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) realloc( (<span class="keywordtype">char</span> *) ptr, <a class="code" href="conf__lex_8c.html#a91">size</a> );
01687         }
01688 
01689 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01690 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_free( <span class="keywordtype">void</span> *ptr )
01691 #<span class="keywordflow">else</span>
01692 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_free( ptr )
01693 void *ptr;
01694 #endif
01695         {
01696         free( ptr );
01697         }
01698 
01699 <span class="preprocessor">#if YY_MAIN</span>
01700 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="verif__syntax_8c.html#a0">main</a>()
01701         {
01702         <a class="code" href="conf__yacc_8c.html#a84">yylex</a>();
01703         <span class="keywordflow">return</span> 0;
01704         }
01705 <span class="preprocessor">#endif</span>
01706 <span class="preprocessor"></span><span class="preprocessor">#line 99 "conf_lex.l"</span>
01707 <span class="preprocessor"></span>
01708 
01709 <span class="keywordtype">int</span> yywrap(<span class="keywordtype">void</span>){
01710     <span class="keywordflow">return</span> 1;
01711 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:55 2008 for ConfigParsing by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
