<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ConfigParsing: config_parsing.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>config_parsing.c</h1><a href="config__parsing_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00084 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00086 <span class="preprocessor">#endif</span>
00087 <span class="preprocessor"></span>
00088 <span class="preprocessor">#include "config_parsing.h"</span>
00089 <span class="preprocessor">#include "<a class="code" href="analyse_8h.html">analyse.h</a>"</span>
00090 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00091 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00092 <span class="preprocessor">#include &lt;string.h&gt;</span>
00093 
00094 <span class="comment">/* case unsensitivity */</span>
<a name="l00095"></a><a class="code" href="config__parsing_8c.html#a0">00095</a> <span class="preprocessor">#define STRNCMP   strncasecmp</span>
00096 <span class="preprocessor"></span>
00097 
<a name="l00098"></a><a class="code" href="structconfig__struct__t.html">00098</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structconfig__struct__t.html">config_struct_t</a>
00099 {
00100   
00101   <span class="comment">/* Syntax tree */</span>
00102   
<a name="l00103"></a><a class="code" href="structconfig__struct__t.html#o0">00103</a>   <a class="code" href="struct__type__block__.html">list_block</a> * syntax_tree ;
00104 
00105   <span class="comment">/* cache pour l'optimisation du parcours de la liste */</span>
00106 
00107   <span class="comment">/* cache le nombre d'elements */</span>
<a name="l00108"></a><a class="code" href="structconfig__struct__t.html#o1">00108</a>   <span class="keywordtype">int</span> cache_nb_items ;
00109   
00110   <span class="comment">/* cache pour optimiser l'acces a la liste chainee des items */</span>
<a name="l00111"></a><a class="code" href="structconfig__struct__t.html#o2">00111</a>   <a class="code" href="struct__type__block__.html">type_block</a>  * last_item_ptr ;
<a name="l00112"></a><a class="code" href="structconfig__struct__t.html#o3">00112</a>   <span class="keywordtype">int</span>           last_item_index ;
00113 
00114 } <a class="code" href="structconfig__struct__t.html">config_struct_t</a> ;
00115 
00116 
00117 
00118 <span class="comment">/***************************************</span>
00119 <span class="comment"> * ACCES AUX VARIABLES EXTERNES</span>
00120 <span class="comment"> ***************************************/</span>
00121  
00122 <span class="comment">/* fichier d'entree du lexer */</span>
00123 <span class="keyword">extern</span> FILE * yyin;
00124 <span class="comment">/* routine de parsing */</span>
00125 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="conf__yacc_8c.html#a87">yyparse</a>();
00126 <span class="comment">/* variable renseignee lors du parsing */</span>
00127 <span class="keyword">extern</span> <a class="code" href="struct__type__block__.html">list_block</a> * program_result;
00128 <span class="comment">/* message d'erreur */</span>
00129 <span class="keyword">extern</span> <span class="keywordtype">char</span> <a class="code" href="conf__yacc_8c.html#a61">extern_errormsg</a>[1024];
00130 
00131 
00132 <span class="comment">/* config_ParseFile:</span>
00133 <span class="comment"> * Reads the content of a configuration file and</span>
00134 <span class="comment"> * stores it in a memory structure.</span>
00135 <span class="comment"> */</span>   
<a name="l00136"></a><a class="code" href="config__parsing_8c.html#a6">00136</a> config_file_t <a class="code" href="config__parsing_8c.html#a6">config_ParseFile</a>(  <span class="keywordtype">char</span> * file_path ){
00137   
00138   FILE * configuration_file;
00139   <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * output_struct;
00140   
00141   <span class="comment">/* Inits error message */</span>
00142   
00143   <a class="code" href="conf__yacc_8c.html#a61">extern_errormsg</a>[0] = <span class="charliteral">'\0'</span>;
00144   
00145     
00146   <span class="comment">/* Sanity check */</span>
00147   
00148   <span class="keywordflow">if</span> ( !file_path || !file_path[0] ){
00149     strcpy( <a class="code" href="conf__yacc_8c.html#a61">extern_errormsg</a>, <span class="stringliteral">"Invalid arguments"</span> );
00150     <span class="keywordflow">return</span> NULL;
00151   }
00152     
00153   
00154   <span class="comment">/* First, opens the file. */</span>
00155   
00156   configuration_file = fopen( file_path, <span class="stringliteral">"r"</span> );
00157   
00158   <span class="keywordflow">if</span> ( !configuration_file ){    
00159     strcpy( <a class="code" href="conf__yacc_8c.html#a61">extern_errormsg</a>, strerror(errno) );
00160     <span class="keywordflow">return</span> NULL;
00161   }
00162   
00163     
00164   <span class="comment">/* Then, parse the file. */</span>
00165   
00166   <a class="code" href="conf__lex_8c.html#a65">yyin</a> = configuration_file;
00167   <span class="keywordflow">if</span> (<a class="code" href="conf__yacc_8c.html#a87">yyparse</a>()){
00168     fclose( configuration_file );
00169     <span class="keywordflow">return</span> NULL;
00170   }  
00171 
00175   <span class="comment">/* Finally, build the output struct. */</span>
00176   
00177   output_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structconfig__struct__t.html">config_struct_t</a>));
00178   
00179   <span class="keywordflow">if</span> (!output_struct){
00180     strcpy( <a class="code" href="conf__yacc_8c.html#a61">extern_errormsg</a>, strerror(errno) );
00181     fclose( configuration_file );
00182     <span class="keywordflow">return</span> NULL;    
00183   }
00184   
00185   output_struct-&gt;<a class="code" href="structconfig__struct__t.html#o1">cache_nb_items</a> = -1;
00186   output_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>  = NULL;
00187   output_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a>  = -1;
00188       
00189   output_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a> = program_result;
00190   
00191   <span class="comment">/* converts pointer to pointer */</span>
00192   fclose( configuration_file );
00193   <span class="keywordflow">return</span> (config_file_t) output_struct;
00194     
00195 }
00196 
00197 
00198 
00199 <span class="comment">/* If config_ParseFile returns a NULL pointer,</span>
00200 <span class="comment"> * config_GetErrorMsg returns a detailled message</span>
00201 <span class="comment"> * to indicate the reason for this error.</span>
00202 <span class="comment"> */</span>
<a name="l00203"></a><a class="code" href="config__parsing_8c.html#a7">00203</a> <span class="keywordtype">char</span> * <a class="code" href="config__parsing_8c.html#a7">config_GetErrorMsg</a>(){
00204 
00205   <span class="keywordflow">return</span> extern_errormsg;
00206   
00207 }
00208 
00209 
00210 
00211 
<a name="l00217"></a><a class="code" href="config__parsing_8c.html#a8">00217</a> <span class="keywordtype">void</span> <a class="code" href="config__parsing_8c.html#a8">config_Print</a>( FILE * output, config_file_t config ){
00218   
00219     <span class="comment">/* sanity check */</span>
00220     <span class="keywordflow">if</span> (!config) return ;
00221     
00222     <a class="code" href="analyse_8h.html#a11">config_print_list</a>( output, ((<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config)-&gt;syntax_tree );
00223     
00224   
00225 }
00226 
00227 
00228 
00229 
00230 
00231 
<a name="l00237"></a><a class="code" href="config__parsing_8c.html#a9">00237</a> <span class="keywordtype">void</span> <a class="code" href="config__parsing_8c.html#a9">config_Free</a>( config_file_t config ){
00238   
00239   <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;
00240   
00241   <span class="keywordflow">if</span> ( !config_struct ) <span class="keywordflow">return</span>;
00242   
00243   <a class="code" href="analyse_8h.html#a12">config_free_list</a>( config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a> );
00244   
00245   free( config_struct );
00246   
00247   return ;
00248   
00249 }
00250 
00251 
00252 
00253 
<a name="l00258"></a><a class="code" href="config__parsing_8c.html#a10">00258</a> <span class="keywordtype">int</span> <a class="code" href="config__parsing_8c.html#a10">config_GetNbBlocks</a>( config_file_t config ){
00259   
00260   <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;
00261   
00262   <span class="keywordflow">if</span> ( !config_struct ) <span class="keywordflow">return</span> -EFAULT;
00263   
00264   
00265   <span class="comment">/* si le cache est renseigne, on renvoie la valeur */</span>
00266   <span class="keywordflow">if</span> (config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o1">cache_nb_items</a> != -1)
00267     <span class="keywordflow">return</span> config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o1">cache_nb_items</a>;
00268 
00269   <span class="comment">/* on regarde si la liste est vide */</span>
00270   <span class="keywordflow">if</span> ( !(config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a>) ) {
00271       config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o1">cache_nb_items</a> = 0;
00272       <span class="keywordflow">return</span> 0;
00273   }
00274   <span class="comment">/* on compte le nombre d'elements */</span>
00275   <span class="keywordflow">else</span>
00276   {
00277       <span class="comment">/* il y a au moins un element : le premier */</span>
00278       <a class="code" href="struct__type__block__.html">type_block</a> * curr_block = (*config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a>);
00279       <span class="keywordtype">int</span> nb = 1;
00280 
00281       <span class="comment">/*</span>
00282 <span class="comment">       * on en profite pour renseigner le cache</span>
00283 <span class="comment">       * des blocks</span>
00284 <span class="comment">       */</span>
00285       config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a> = curr_block;
00286       config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a>  = 0;
00287 
00288       <span class="keywordflow">while</span> (curr_block = curr_block-&gt;<a class="code" href="struct__type__block__.html#o2">next</a>){nb++;}
00289 
00290       <span class="comment">/* on cache le nbr de blocks et on renvoie ce nombre */</span>
00291       config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o1">cache_nb_items</a> = nb;
00292       <span class="keywordflow">return</span> nb;
00293   }
00294     
00295     
00296 }
00297 
00298 
00299 <span class="comment">/* utilisation interne :</span>
00300 <span class="comment"> * charge un element dans le cache.</span>
00301 <span class="comment"> * \return &lt;&gt;0 si le'element n'est pas trouve.</span>
00302 <span class="comment"> */</span>
00303 <span class="keyword">static</span> <span class="keywordtype">int</span> load_item_into_cache( <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct, <span class="keywordtype">int</span> item_no )
00304 {
00305     
00306     <span class="comment">/* Sanity checks */</span>
00307     <span class="keywordflow">if</span> (!config_struct || !config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a>)
00308       <span class="keywordflow">return</span> -1;
00309     
00310     <span class="comment">/* On verifie que l'index est correct */</span>
00311     <span class="keywordflow">if</span> ( (item_no&lt;0)
00312          ||(item_no &gt;= <a class="code" href="config__parsing_8c.html#a10">config_GetNbBlocks</a>((config_file_t)config_struct)) )
00313       <span class="keywordflow">return</span> -1;
00314     
00315     <span class="comment">/* L'element est-il deja dans le cache ? */</span>
00316     <span class="keywordflow">if</span> (item_no == config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a>)
00317       <span class="keywordflow">return</span> 0;
00318     
00319     <span class="comment">/* L'element n'est pas dans le cache, on le cherche */</span>
00320     <span class="comment">/*else*/</span>{
00321         <span class="comment">/* premier element */</span>
00322         <a class="code" href="struct__type__block__.html">type_block</a> * curr_block = (*config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a>);
00323         <span class="keywordtype">int</span> index = 0;
00324         
00325         <span class="keywordflow">while</span> (index != item_no){
00326             curr_block=curr_block-&gt;<a class="code" href="struct__type__block__.html#o2">next</a>;
00327             <span class="keywordflow">if</span> (!curr_block) <span class="keywordflow">return</span> -1; <span class="comment">/* on est arrive a la fin ss trouver*/</span>
00328             index++;
00329         }
00330         
00331         <span class="keywordflow">if</span> (index == item_no){
00332             <span class="comment">/* on le memorise ds le cache */</span>
00333             config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a> = index;
00334             config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a> = curr_block;
00335             <span class="keywordflow">return</span> 0;
00336         } <span class="keywordflow">else</span> {
00337             <span class="comment">/* pas normal du tout*/</span>
00338             <span class="keywordflow">return</span> -1;
00339         }
00340     }
00341 
00342 }
00343 
00344 
00345 
00346 
<a name="l00351"></a><a class="code" href="config__parsing_8c.html#a12">00351</a> <span class="keywordtype">int</span> <a class="code" href="config__parsing_8c.html#a12">config_GetBlockIndexByName</a>( config_file_t config,
00352                                 <span class="keywordtype">char</span> * block_name )
00353 {
00354 
00355     <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;
00356     
00357     <span class="comment">/* L'element est-il deja dans le cache ? */</span>
00358     
00359     <span class="keywordflow">if</span> ( ( config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a> != NULL )
00360          &amp;&amp; !<a class="code" href="config__parsing_8c.html#a0">STRNCMP</a>( config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>-&gt;<a class="code" href="struct__type__block__.html#o0">name</a> , block_name,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a> ) )
00361        <span class="keywordflow">return</span> config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a> ;
00362     
00363     
00364     <span class="comment">/* L'element n'est pas dans le cache, on le cherche */</span>
00365     <span class="comment">/*else*/</span>{
00366         <span class="comment">/* premier element */</span>
00367         <a class="code" href="struct__type__block__.html">type_block</a> * curr_block = (*config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o0">syntax_tree</a>);
00368         <span class="keywordtype">int</span> index = 0;
00369         
00370         <span class="keywordflow">while</span> (<a class="code" href="config__parsing_8c.html#a0">STRNCMP</a>( curr_block-&gt;<a class="code" href="struct__type__block__.html#o0">name</a> , block_name,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a> )){
00371             curr_block=curr_block-&gt;<a class="code" href="struct__type__block__.html#o2">next</a>;
00372             <span class="keywordflow">if</span> (!curr_block) <span class="keywordflow">return</span> -1; <span class="comment">/* on est arrive a la fin ss trouver*/</span>
00373             index++;
00374         }
00375         
00376         <span class="keywordflow">if</span> (!<a class="code" href="config__parsing_8c.html#a0">STRNCMP</a>( curr_block-&gt;<a class="code" href="struct__type__block__.html#o0">name</a> , block_name,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a> )){
00377             <span class="comment">/* on le memorise ds le cache */</span>
00378             config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o3">last_item_index</a> = index;
00379             config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a> = curr_block;
00380             <span class="keywordflow">return</span> index;
00381         } <span class="keywordflow">else</span> {
00382             <span class="comment">/* pas normal du tout*/</span>
00383             <span class="keywordflow">return</span> -1;
00384         }
00385     }
00386       
00387 }
00388 
00389 
00390 
00391 
<a name="l00397"></a><a class="code" href="config__parsing_8c.html#a13">00397</a> <span class="keywordtype">char</span> * <a class="code" href="config__parsing_8c.html#a13">config_GetBlockName</a>( config_file_t config , <span class="keywordtype">int</span> block_no )
00398 {
00399   <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;
00400   
00401   <span class="comment">/* met l'element dans le cache */</span>
00402   
00403   <span class="keywordflow">if</span> (load_item_into_cache(config_struct,block_no))
00404     <span class="comment">/* sort en cas d'erreur*/</span>
00405     <span class="keywordflow">return</span> NULL;
00406   <span class="keywordflow">else</span>
00407     <span class="comment">/* renvoie le nom sinon*/</span>
00408     <span class="keywordflow">return</span> config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>-&gt;<a class="code" href="struct__type__block__.html#o0">name</a>;
00409   
00410 }
00411 
00412 
00413 
00414 
<a name="l00421"></a><a class="code" href="config__parsing_8c.html#a14">00421</a> <span class="keywordtype">int</span> <a class="code" href="config__parsing_8c.html#a14">config_GetNbKeys</a>( config_file_t config, <span class="keywordtype">int</span> block_no )
00422 {
00423   <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;
00424   
00425   <span class="comment">/* met l'element dans le cache */</span>
00426   <span class="keywordflow">if</span> (load_item_into_cache(config_struct,block_no))
00427     <span class="keywordflow">return</span> -1; <span class="comment">/* sort en cas d'erreur*/</span>
00428   <span class="keywordflow">else</span>
00429   {
00430       <span class="comment">/* recupere la premiere variable */</span>
00431       <a class="code" href="struct__type__affect__.html">type_affect</a> * curr_def = config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>-&gt;<a class="code" href="struct__type__block__.html#o1">list_def</a>;
00432       <span class="keywordtype">int</span> nb_vars = 0;
00433 
00434       <span class="keywordflow">while</span> (curr_def){
00435           nb_vars++;
00436           curr_def=curr_def-&gt;<a class="code" href="struct__type__affect__.html#o2">next</a>;
00437       }
00438       <span class="comment">/* elements trouves */</span>
00439       <span class="keywordflow">return</span> nb_vars;
00440 
00441   }
00442   
00443 }
00444 
00445 
00446 
00447 
<a name="l00453"></a><a class="code" href="config__parsing_8c.html#a15">00453</a> <span class="keywordtype">int</span> <a class="code" href="config__parsing_8c.html#a15">config_GetKeyValue</a>( 
00454                         config_file_t config,
00455                         <span class="keywordtype">int</span> block_no,
00456                         <span class="keywordtype">int</span> key_no,
00457                         <span class="keywordtype">char</span> ** var_name,
00458                         <span class="keywordtype">char</span> ** var_value
00459                        )
00460 {
00461 
00462     <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;  
00463 
00464     <span class="comment">/* met l'element dans le cache */</span>
00465     <span class="keywordflow">if</span> ( load_item_into_cache( config_struct, block_no ) )
00466       <span class="keywordflow">return</span> -1; <span class="comment">/* sort en cas d'erreur*/</span>
00467     
00468     <span class="comment">/* cherche la variable dont l'index est celui donne en parametre */</span>
00469     <span class="comment">/*else*/</span>
00470     {
00471         <span class="comment">/* recupere la premiere variable */</span>
00472         <a class="code" href="struct__type__affect__.html">type_affect</a> * curr_def = config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>-&gt;<a class="code" href="struct__type__block__.html#o1">list_def</a>;
00473         <span class="keywordtype">int</span> index=0;
00474         
00475         <span class="keywordflow">if</span> (!curr_def) <span class="keywordflow">return</span> -1;
00476                 
00477         <span class="keywordflow">while</span> (index != key_no){
00478             index++;
00479             curr_def=curr_def-&gt;<a class="code" href="struct__type__affect__.html#o2">next</a>;
00480             <span class="keywordflow">if</span> (!curr_def) <span class="keywordflow">return</span> -1; <span class="comment">/* on est arrives a la fin ss trouver*/</span>
00481         }
00482         
00483         <span class="keywordflow">if</span> (index == key_no){
00484             (*var_name) = curr_def-&gt;<a class="code" href="struct__type__affect__.html#o0">varname</a>;
00485             (*var_value) = curr_def-&gt;<a class="code" href="struct__type__affect__.html#o1">varvalue</a>;
00486             <span class="keywordflow">return</span> 0;
00487         } <span class="keywordflow">else</span> {
00488             <span class="comment">/* pas trouve*/</span>
00489             <span class="keywordflow">return</span> -1;
00490         }
00491             
00492     }
00493   
00494 }
00495 
00496 
00497 
00498 
<a name="l00504"></a><a class="code" href="config__parsing_8c.html#a16">00504</a> <span class="keywordtype">char</span> * <a class="code" href="config__parsing_8c.html#a16">config_GetKeyValueByName</a>( config_file_t config,
00505                                  <span class="keywordtype">int</span> block_no,
00506                                  <span class="keywordtype">char</span> * key_name )
00507 {
00508   
00509     <a class="code" href="structconfig__struct__t.html">config_struct_t</a> * config_struct = (<a class="code" href="structconfig__struct__t.html">config_struct_t</a> *)config ;  
00510 
00511     <span class="comment">/* met l'element dans le cache */</span>
00512     <span class="keywordflow">if</span> ( load_item_into_cache( config_struct, block_no ) )
00513       <span class="keywordflow">return</span> NULL; <span class="comment">/* sort en cas d'erreur*/</span>
00514   
00515     <span class="comment">/* cherche la variable dont le nom est celui donne en parametre */</span>
00516     <span class="comment">/*else*/</span>
00517     {
00518         <span class="comment">/* recupere la premiere variable */</span>
00519         <a class="code" href="struct__type__affect__.html">type_affect</a> * curr_def = config_struct-&gt;<a class="code" href="structconfig__struct__t.html#o2">last_item_ptr</a>-&gt;<a class="code" href="struct__type__block__.html#o1">list_def</a> ;
00520                 
00521         <span class="keywordflow">while</span> (curr_def){
00522             <span class="keywordflow">if</span> (!<a class="code" href="config__parsing_8c.html#a0">STRNCMP</a>(curr_def-&gt;<a class="code" href="struct__type__affect__.html#o0">varname</a>,key_name,<a class="code" href="analyse_8h.html#a0">MAXSTRLEN</a>)){
00523                 <span class="keywordflow">return</span> curr_def-&gt;<a class="code" href="struct__type__affect__.html#o1">varvalue</a>;
00524             } <span class="keywordflow">else</span> {
00525                 curr_def=curr_def-&gt;<a class="code" href="struct__type__affect__.html#o2">next</a>;
00526             }
00527         }
00528         <span class="comment">/* pas d'element trouve */</span>
00529         <span class="keywordflow">return</span> NULL;        
00530             
00531     }
00532     
00533 }
00534 
00535 
00536 
00537 
00538 
00539 
00540 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:55 2008 for ConfigParsing by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
