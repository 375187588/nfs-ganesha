<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Pmap_rmt.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Pmap_rmt.c</h1><a href="Pmap__rmt_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 Paul Ashley</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> * </span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00007 <span class="comment"> * are met:</span>
00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00009 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00011 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
00012 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
00013 <span class="comment"> * 3. All advertising materials mentioning features or use of this software</span>
00014 <span class="comment"> *    must display the following acknowledgement:</span>
00015 <span class="comment"> *      This product includes software developed by Paul Ashley while in</span>
00016 <span class="comment"> *      the employ of the Queensland University of Technology.</span>
00017 <span class="comment"> * 4. The name of the author may not be used to endorse or promote products</span>
00018 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00019 <span class="comment"> * </span>
00020 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</span>
00021 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00022 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
00023 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00024 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00025 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00029 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> */</span>
00031 <span class="comment">/* @(#)pmap_rmt.c       2.2 88/08/01 4.0 RPCSRC */</span>
00032 <span class="comment">/*</span>
00033 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00034 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00035 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00036 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00037 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00038 <span class="comment"> * program developed by the user.</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00041 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00042 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00045 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00046 <span class="comment"> * modification or enhancement.</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00049 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00050 <span class="comment"> * OR ANY PART THEREOF.</span>
00051 <span class="comment"> *</span>
00052 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00053 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00054 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00055 <span class="comment"> *</span>
00056 <span class="comment"> * Sun Microsystems, Inc.</span>
00057 <span class="comment"> * 2550 Garcia Avenue</span>
00058 <span class="comment"> * Mountain View, California  94043</span>
00059 <span class="comment"> */</span>
00060 
00061 <span class="comment">/*</span>
00062 <span class="comment"> * pmap_rmt.c</span>
00063 <span class="comment"> * Client interface to pmap rpc service.</span>
00064 <span class="comment"> * remote call and broadcast service</span>
00065 <span class="comment"> *</span>
00066 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00067 <span class="comment"> */</span>
00068 
00069 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00070 <span class="preprocessor">#include "Rpc.h"</span>
00071 <span class="preprocessor">#include "Auth_unix.h"</span>
00072 <span class="preprocessor">#include "Pmap_prot.h"</span>
00073 <span class="preprocessor">#include "Pmap_clnt.h"</span>
00074 <span class="preprocessor">#include "Pmap_rmt.h"</span>
00075 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00076 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00077 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00078 <span class="preprocessor">#undef   _POSIX_SOURCE          </span><span class="comment">/* Ultrix &lt;sys/param.h&gt; needs --roland@gnu */</span>
00079 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>          <span class="comment">/* Ultrix needs before net/if --roland@gnu */</span>
00080 <span class="preprocessor">#include &lt;net/if.h&gt;</span>
00081 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
00082 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
<a name="l00083"></a><a class="code" href="Pmap__rmt_8c.html#a0">00083</a> <span class="preprocessor">#define MAX_BROADCAST_SIZE 1400</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00086 <span class="keyword">static</span> <span class="keyword">struct </span>timeval timeout = { 3, 0 };
00087 
00088 
00089 
00090 <span class="comment">/*</span>
00091 <span class="comment"> * pmapper remote-call-service interface.</span>
00092 <span class="comment"> * This routine is used to call the pmapper remote call service</span>
00093 <span class="comment"> * which will look up a service program in the port maps, and then</span>
00094 <span class="comment"> * remotely call that routine with the given parameters.  This allows</span>
00095 <span class="comment"> * programs to do a lookup and call in one step.</span>
00096 <span class="comment">*/</span>
<a name="l00097"></a><a class="code" href="Pmap__rmt_8c.html#a2">00097</a> <span class="keyword">enum</span> Clnt_stat <a class="code" href="Pmap__rmt_8c.html#a2">Pmap_rmtcall</a>(<span class="keyword">struct</span> sockaddr_in *  addr,
00098                             u_long prog, 
00099                             u_long vers, 
00100                             u_long proc, 
00101                             Xdrproc_t xdrargs, 
00102                             caddr_t argsp, 
00103                             Xdrproc_t xdrres, 
00104                             caddr_t resp, 
00105                             <span class="keyword">struct</span> timeval tout,
00106                             u_long * port_ptr)
00107 {
00108         <span class="keywordtype">int</span> socket = -1;
00109         <span class="keyword">register</span> Client *client;
00110         <span class="keyword">struct </span>Rmtcallargs a;
00111         <span class="keyword">struct </span>Rmtcallres r;
00112         <span class="keyword">enum</span> Clnt_stat stat;
00113 
00114         addr-&gt;sin_port = htons(PMAPPORT);
00115         client = <a class="code" href="Clnt__udp_8c.html#a9">Clntudp_create</a>(addr, PMAPPROG, PMAPVERS, timeout, &amp;socket);
00116         <span class="keywordflow">if</span> (client != (Client *)NULL) {
00117                 a.prog = prog;
00118                 a.vers = vers;
00119                 a.proc = proc;
00120                 a.args_ptr = argsp;
00121                 a.xdr_args = xdrargs;
00122                 r.port_ptr = port_ptr;
00123                 r.results_ptr = resp;
00124                 r.xdr_results = xdrres;
00125                 stat = Clnt_call(client, PMAPPROC_CALLIT, <a class="code" href="Pmap__rmt_8c.html#a3">Xdr_Rmtcall_args</a>, (caddr_t)&amp;a,
00126                      <a class="code" href="Pmap__rmt_8c.html#a4">Xdr_Rmtcallres</a>, (caddr_t)&amp;r, tout);
00127                 CLNT_DESTROY(client);
00128         } <span class="keywordflow">else</span> {
00129                 stat = RPC_FAILED;
00130         }
00131         <span class="comment">/* (void)close(socket); CLNT_DESTROY already closed it */</span>
00132         addr-&gt;sin_port = 0;
00133         <span class="keywordflow">return</span> (stat);
00134 }
00135 
00136 
00137 <span class="comment">/*</span>
00138 <span class="comment"> * XDR remote call arguments</span>
00139 <span class="comment"> * written for XDR_ENCODE direction only</span>
00140 <span class="comment"> */</span>
<a name="l00141"></a><a class="code" href="Pmap__rmt_8c.html#a3">00141</a> bool_t <a class="code" href="Pmap__rmt_8c.html#a3">Xdr_Rmtcall_args</a>( XDR * xdrs, <span class="keyword">struct</span> Rmtcallargs * cap)
00142 {
00143         u_int lenposition, argposition, position;
00144 
00145         <span class="keywordflow">if</span> (<a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;(cap-&gt;prog)) &amp;&amp;
00146             <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;(cap-&gt;vers)) &amp;&amp;
00147             <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;(cap-&gt;proc))) {
00148                 lenposition = XDR_GETPOS(xdrs);
00149                 <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;(cap-&gt;arglen)))
00150                     <span class="keywordflow">return</span> (FALSE);
00151                 argposition = XDR_GETPOS(xdrs);
00152                 <span class="keywordflow">if</span> (! (*(cap-&gt;xdr_args))(xdrs, cap-&gt;args_ptr))
00153                     <span class="keywordflow">return</span> (FALSE);
00154                 position = XDR_GETPOS(xdrs);
00155                 cap-&gt;arglen = (u_long)position - (u_long)argposition;
00156                 XDR_SETPOS(xdrs, lenposition);
00157                 <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;(cap-&gt;arglen)))
00158                     <span class="keywordflow">return</span> (FALSE);
00159                 XDR_SETPOS(xdrs, position);
00160                 <span class="keywordflow">return</span> (TRUE);
00161         }
00162         <span class="keywordflow">return</span> (FALSE);
00163 }
00164 
00165 <span class="comment">/*</span>
00166 <span class="comment"> * XDR remote call results</span>
00167 <span class="comment"> * written for XDR_DECODE direction only</span>
00168 <span class="comment"> */</span>
<a name="l00169"></a><a class="code" href="Pmap__rmt_8c.html#a4">00169</a> bool_t <a class="code" href="Pmap__rmt_8c.html#a4">Xdr_Rmtcallres</a>( XDR * xdrs, <span class="keyword">struct</span> Rmtcallres *  crp)
00170 {
00171         caddr_t port_ptr;
00172 
00173         port_ptr = (caddr_t)crp-&gt;port_ptr;
00174         <span class="keywordflow">if</span> (<a class="code" href="Xdr__reference_8c.html#a0">Xdr_reference</a>(xdrs, &amp;port_ptr, <span class="keyword">sizeof</span> (u_long),
00175             <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>) &amp;&amp; <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, &amp;crp-&gt;resultslen)) {
00176                 crp-&gt;port_ptr = (u_long *)port_ptr;
00177                 <span class="keywordflow">return</span> ((*(crp-&gt;xdr_results))(xdrs, crp-&gt;results_ptr));
00178         }
00179         <span class="keywordflow">return</span> (FALSE);
00180 }
00181 
00182 
00183 <span class="comment">/*</span>
00184 <span class="comment"> * The following is kludged-up support for simple rpc broadcasts.</span>
00185 <span class="comment"> * Someday a large, complicated system will replace these trivial</span>
00186 <span class="comment"> * routines which only support udp/ip .</span>
00187 <span class="comment"> */</span>
00188 
00189 <span class="keyword">static</span> <span class="keywordtype">int</span> getbroadcastnets( <span class="keyword">struct</span> in_addr * addrs, <span class="keywordtype">int</span> sock, <span class="keywordtype">char</span> *buf)
00190 {
00191         <span class="keyword">struct </span>ifconf ifc;
00192   <span class="keyword">struct </span>ifreq ifreq, *ifr;
00193         <span class="keyword">struct </span>sockaddr_in *sin;  <span class="keywordtype">int</span> n, i;
00194 
00195   ifc.ifc_len = UDPMSGSIZE;
00196   ifc.ifc_buf = buf;
00197 
00198   ifr = ifc.ifc_req;
00199 
00200   sin = (<span class="keyword">struct </span>sockaddr_in *)&amp;ifr-&gt;ifr_addr;
00201   
00202   addrs[i++] = sin-&gt;sin_addr ;
00203   
00204   <span class="keywordflow">return</span> (i);
00205 }
00206 
00207 
<a name="l00208"></a><a class="code" href="Pmap__rmt_8c.html#a6">00208</a> <span class="keyword">enum</span> Clnt_stat <a class="code" href="Pmap__rmt_8c.html#a6">Clnt_broadcast</a>( u_long   prog, 
00209                                u_long   vers, 
00210                                u_long   proc, 
00211                                Xdrproc_t        xargs, 
00212                                caddr_t argsp,
00213                                Xdrproc_t        xresults, 
00214                                caddr_t resultsp, 
00215                                resultproc_t eachresult)
00216 {
00217         <span class="keyword">enum</span> Clnt_stat stat;
00218         AUTH *unix_auth = <a class="code" href="Auth__unix_8c.html#a11">Authunix_create_default</a>();
00219         XDR xdr_stream;
00220         <span class="keyword">register</span> XDR *xdrs = &amp;xdr_stream;
00221         <span class="keywordtype">int</span> outlen, inlen, fromlen, nets;
00222         <span class="keyword">register</span> <span class="keywordtype">int</span> sock;
00223         <span class="keywordtype">int</span> on = 1;
00224 <span class="preprocessor">#ifdef FD_SETSIZE</span>
00225 <span class="preprocessor"></span>        fd_set mask;
00226         fd_set readfds;
00227 <span class="preprocessor">#else</span>
00228 <span class="preprocessor"></span>        <span class="keywordtype">int</span> readfds;
00229         <span class="keyword">register</span> <span class="keywordtype">int</span> mask;
00230 <span class="preprocessor">#endif </span><span class="comment">/* def FD_SETSIZE */</span>
00231         <span class="keyword">register</span> <span class="keywordtype">int</span> i;
00232         bool_t done = FALSE;
00233         <span class="keyword">register</span> u_long xid;
00234         u_long port;
00235         <span class="keyword">struct </span>in_addr addrs[20];
00236         <span class="keyword">struct </span>sockaddr_in baddr, raddr; <span class="comment">/* broadcast and response addresses */</span>
00237         <span class="keyword">struct </span>Rmtcallargs a;
00238         <span class="keyword">struct </span>Rmtcallres r;
00239         <span class="keyword">struct </span>Rpc_msg msg;
00240         <span class="keyword">struct </span>timeval t, t1;
00241         <span class="keywordtype">char</span> outbuf[MAX_BROADCAST_SIZE], inbuf[UDPMSGSIZE];
00242 
00243         <span class="comment">/*</span>
00244 <span class="comment">         * initialization: create a socket, a broadcast address, and</span>
00245 <span class="comment">         * preserialize the arguments into a send buffer.</span>
00246 <span class="comment">         */</span>
00247         <span class="keywordflow">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0) {
00248                 perror(<span class="stringliteral">"Cannot create socket for broadcast rpc"</span>);
00249                 stat = RPC_CANTSEND;
00250                 <span class="keywordflow">goto</span> done_broad;
00251         }
00252 <span class="preprocessor">#ifdef SO_BROADCAST</span>
00253 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &amp;on, <span class="keyword">sizeof</span> (on)) &lt; 0) {
00254                 perror(<span class="stringliteral">"Cannot set socket option SO_BROADCAST"</span>);
00255                 stat = RPC_CANTSEND;
00256                 <span class="keywordflow">goto</span> done_broad;
00257         }
00258 <span class="preprocessor">#endif </span><span class="comment">/* def SO_BROADCAST */</span>
00259 <span class="preprocessor">#ifdef FD_SETSIZE</span>
00260 <span class="preprocessor"></span>        FD_ZERO(&amp;mask);
00261         FD_SET(sock, &amp;mask);
00262 <span class="preprocessor">#else</span>
00263 <span class="preprocessor"></span>        mask = (1 &lt;&lt; sock);
00264 <span class="preprocessor">#endif </span><span class="comment">/* def FD_SETSIZE */</span>
00265         nets = getbroadcastnets(addrs, sock, inbuf);
00266         bzero((<span class="keywordtype">char</span> *)&amp;baddr, <span class="keyword">sizeof</span> (baddr));
00267         baddr.sin_family = AF_INET;
00268         baddr.sin_port = htons(PMAPPORT);
00269         baddr.sin_addr.s_addr = htonl(INADDR_ANY);
00270 <span class="comment">/*      baddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); */</span>
00271         (void)gettimeofday(&amp;t, (<span class="keyword">struct</span> timezone *)0);
00272         msg.rm_xid = xid = getpid() ^ t.tv_sec ^ t.tv_usec;
00273         t.tv_usec = 0;
00274         msg.rm_direction = CALL;
00275         msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
00276         msg.rm_call.cb_prog = PMAPPROG;
00277         msg.rm_call.cb_vers = PMAPVERS;
00278         msg.rm_call.cb_proc = PMAPPROC_CALLIT;
00279         msg.rm_call.cb_cred = unix_auth-&gt;ah_cred;
00280         msg.rm_call.cb_verf = unix_auth-&gt;ah_verf;
00281         a.prog = prog;
00282         a.vers = vers;
00283         a.proc = proc;
00284         a.xdr_args = xargs;
00285         a.args_ptr = argsp;
00286         r.port_ptr = &amp;port;
00287         r.xdr_results = xresults;
00288         r.results_ptr = resultsp;
00289         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(xdrs, outbuf, <a class="code" href="Pmap__rmt_8c.html#a0">MAX_BROADCAST_SIZE</a>, XDR_ENCODE);
00290         <span class="keywordflow">if</span> ((! <a class="code" href="Rpc__cmsg_8c.html#a0">Xdr_callmsg</a>(xdrs, &amp;msg)) || (! <a class="code" href="Pmap__rmt_8c.html#a3">Xdr_Rmtcall_args</a>(xdrs, &amp;a))) {
00291                 stat = RPC_CANTENCODEARGS;
00292                 <span class="keywordflow">goto</span> done_broad;
00293         }
00294         outlen = (int)Xdr_getpos(xdrs);
00295         Xdr_destroy(xdrs);
00296         <span class="comment">/*</span>
00297 <span class="comment">         * Basic loop: broadcast a packet and wait a while for response(s).</span>
00298 <span class="comment">         * The response timeout grows larger per iteration.</span>
00299 <span class="comment">         */</span>
00300         <span class="keywordflow">for</span> (t.tv_sec = 4; t.tv_sec &lt;= 14; t.tv_sec += 2) {
00301                 <span class="keywordflow">for</span> (i = 0; i &lt; nets; i++) {
00302                         baddr.sin_addr = addrs[i];
00303                         <span class="keywordflow">if</span> (sendto(sock, outbuf, outlen, 0,
00304                                 (<span class="keyword">struct</span> sockaddr *)&amp;baddr,
00305                                 <span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr)) != outlen) {
00306                                 perror(<span class="stringliteral">"Cannot send broadcast packet"</span>);
00307                                 stat = RPC_CANTSEND;
00308                                 <span class="keywordflow">goto</span> done_broad;
00309                         }
00310                 }
00311                 <span class="keywordflow">if</span> (eachresult == NULL) {
00312                         stat = RPC_SUCCESS;
00313                         <span class="keywordflow">goto</span> done_broad;
00314                 }
00315         recv_again:
00316                 msg.acpted_rply.ar_verf = _null_auth;
00317                 msg.acpted_rply.ar_results.where = (caddr_t)&amp;r;
00318                 msg.acpted_rply.ar_results.proc = Xdr_Rmtcallres;
00319                 readfds = mask;
00320                 t1 = t;
00321                 <span class="keywordflow">switch</span> (select( _rpc_dtablesize(), &amp;readfds, (fd_set *)NULL, (fd_set *)NULL, &amp;t1))
00322       {
00323         
00324       <span class="keywordflow">case</span> 0:  <span class="comment">/* timed out */</span>
00325         stat = RPC_TIMEDOUT;
00326         <span class="keywordflow">continue</span>;
00327         
00328       <span class="keywordflow">case</span> -1:  <span class="comment">/* some kind of error */</span>
00329         <span class="keywordflow">if</span> (errno == EINTR)
00330           <span class="keywordflow">goto</span> recv_again;
00331         perror(<span class="stringliteral">"Broadcast select problem"</span>);
00332         stat = RPC_CANTRECV;
00333         <span class="keywordflow">goto</span> done_broad;
00334         
00335       }  <span class="comment">/* end of select results switch */</span>
00336 
00337 try_again:
00338                 fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00339                 inlen = recvfrom(sock, inbuf, <a class="code" href="Svc__udp_8c.html#a0">UDPMSGSIZE</a>, 0,
00340                      (<span class="keyword">struct</span> sockaddr *)&amp;raddr, &amp;fromlen);
00341                 <span class="keywordflow">if</span> (inlen &lt; 0) {
00342                         <span class="keywordflow">if</span> (errno == EINTR)
00343                                 <span class="keywordflow">goto</span> try_again;
00344                         perror(<span class="stringliteral">"Cannot receive reply to broadcast"</span>);
00345                         stat = RPC_CANTRECV;
00346                         <span class="keywordflow">goto</span> done_broad;
00347                 }
00348                 <span class="keywordflow">if</span> (inlen &lt; <span class="keyword">sizeof</span>(u_long))
00349                         <span class="keywordflow">goto</span> recv_again;
00350                 <span class="comment">/*</span>
00351 <span class="comment">                 * see if reply transaction id matches sent id.</span>
00352 <span class="comment">                 * If so, decode the results.</span>
00353 <span class="comment">                 */</span>
00354                 <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(xdrs, inbuf, (u_int)inlen, XDR_DECODE);
00355                 <span class="keywordflow">if</span> (<a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, &amp;msg)) {
00356                         <span class="keywordflow">if</span> ((msg.rm_xid == xid) &amp;&amp;
00357                                 (msg.rm_reply.rp_stat == MSG_ACCEPTED) &amp;&amp;
00358                                 (msg.acpted_rply.ar_stat == SUCCESS)) {
00359                                 raddr.sin_port = htons((u_short)port);
00360                                 done = (*eachresult)(resultsp, &amp;raddr);
00361                         }
00362                         <span class="comment">/* otherwise, we just ignore the errors ... */</span>
00363                 } <span class="keywordflow">else</span> {
00364 <span class="preprocessor">#ifdef notdef</span>
00365 <span class="preprocessor"></span>                        <span class="comment">/* some kind of deserialization problem ... */</span>
00366                         <span class="keywordflow">if</span> (msg.rm_xid == xid)
00367                                 fprintf(stderr, <span class="stringliteral">"Broadcast deserialization problem"</span>);
00368                         <span class="comment">/* otherwise, just random garbage */</span>
00369 <span class="preprocessor">#endif</span>
00370 <span class="preprocessor"></span>                }
00371                 xdrs-&gt;x_op = XDR_FREE;
00372                 msg.acpted_rply.ar_results.proc = Xdr_void;
00373                 (void)<a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, &amp;msg);
00374                 (void)(*xresults)(xdrs, resultsp);
00375                 Xdr_destroy(xdrs);
00376                 <span class="keywordflow">if</span> (done) {
00377                         stat = RPC_SUCCESS;
00378                         <span class="keywordflow">goto</span> done_broad;
00379                 } <span class="keywordflow">else</span> {
00380                         <span class="keywordflow">goto</span> recv_again;
00381                 }
00382         }
00383 done_broad:
00384         (void)close(sock);
00385         AUTH_DESTROY(unix_auth);
00386         <span class="keywordflow">return</span> (stat);
00387 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
