<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Xdr_rec.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Xdr_rec.c</h1><a href="Xdr__rec_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 <span class="preprocessor">#if defined(LIBC_SCCS) &amp;&amp; !defined(lint) </span>
00030 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="client-gss_8c.html#a12">rcsid</a> = <span class="stringliteral">"$OpenBSD: xdr_rec.c,v 1.6 1998/05/20 23:50:02 deraadt Exp $"</span>;
00031 <span class="preprocessor">#endif </span><span class="comment">/* LIBC_SCCS and not lint */</span>
00032 
00033 <span class="comment">/*</span>
00034 <span class="comment"> * xdr_rec.c, Implements TCP/IP based XDR streams with a "record marking"</span>
00035 <span class="comment"> * layer above tcp (for rpc's use).</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * These routines interface XDRSTREAMS to a tcp/ip connection.</span>
00040 <span class="comment"> * There is a record marking layer between the xdr stream</span>
00041 <span class="comment"> * and the tcp transport level.  A record is composed on one or more</span>
00042 <span class="comment"> * record fragments.  A record fragment is a thirty-two bit header followed</span>
00043 <span class="comment"> * by n bytes of data, where n is contained in the header.  The header</span>
00044 <span class="comment"> * is represented as a htonl(u_int32_t).  The high order bit encodes</span>
00045 <span class="comment"> * whether or not the fragment is the last fragment of the record</span>
00046 <span class="comment"> * (1 =&gt; fragment is last, 0 =&gt; more fragments to follow. </span>
00047 <span class="comment"> * The other 31 bits encode the byte length of the fragment.</span>
00048 <span class="comment"> */</span>
00049 
00050 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00051 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00053 <span class="preprocessor">#include &lt;string.h&gt;</span>
00054 <span class="preprocessor">#include "Types.h"</span>
00055 <span class="preprocessor">#include "Xdr.h"</span>
00056 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00057 
00058 <span class="keyword">static</span> u_int    fix_buf_size();
00059 <span class="keyword">static</span> bool_t   flush_out();
00060 <span class="keyword">static</span> bool_t   get_input_bytes();
00061 <span class="keyword">static</span> bool_t   set_input_fragment();
00062 <span class="keyword">static</span> bool_t   skip_input_bytes();
00063 
00064 <span class="keyword">static</span> bool_t   Xdrrec_getlong();
00065 <span class="keyword">static</span> bool_t   Xdrrec_putlong();
00066 <span class="keyword">static</span> bool_t   Xdrrec_getbytes();
00067 <span class="keyword">static</span> bool_t   Xdrrec_putbytes();
00068 <span class="keyword">static</span> u_int    Xdrrec_getpos();
00069 <span class="keyword">static</span> bool_t   Xdrrec_setpos();
00070 <span class="keyword">static</span> int32_t *Xdrrec_inline();
00071 <span class="keyword">static</span> <span class="keywordtype">void</span>     Xdrrec_destroy();
00072 
00073 <span class="keyword">static</span> <span class="keyword">struct  </span>Xdr_ops Xdrrec_ops = {
00074         Xdrrec_getlong,
00075         Xdrrec_putlong,
00076         Xdrrec_getbytes,
00077         Xdrrec_putbytes,
00078         Xdrrec_getpos,
00079         Xdrrec_setpos,
00080         Xdrrec_inline,
00081         Xdrrec_destroy
00082 };
00083 
00084 <span class="comment">/*</span>
00085 <span class="comment"> * A record is composed of one or more record fragments.</span>
00086 <span class="comment"> * A record fragment is a four-byte header followed by zero to</span>
00087 <span class="comment"> * 2**32-1 bytes.  The header is treated as a long unsigned and is</span>
00088 <span class="comment"> * encode/decoded to the network via htonl/ntohl.  The low order 31 bits</span>
00089 <span class="comment"> * are a byte count of the fragment.  The highest order bit is a boolean:</span>
00090 <span class="comment"> * 1 =&gt; this fragment is the last fragment of the record,</span>
00091 <span class="comment"> * 0 =&gt; this fragment is followed by more fragment(s).</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> * The fragment/record machinery is not general;  it is constructed to</span>
00094 <span class="comment"> * meet the needs of xdr and rpc based on tcp.</span>
00095 <span class="comment"> */</span>
00096 
<a name="l00097"></a><a class="code" href="Xdr__rec_8c.html#a0">00097</a> <span class="preprocessor">#define LAST_FRAG ((u_int32_t)(1 &lt;&lt; 31))</span>
00098 <span class="preprocessor"></span>
<a name="l00099"></a><a class="code" href="structrec__strm.html">00099</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structrec__strm.html">rec_strm</a> {
<a name="l00100"></a><a class="code" href="structrec__strm.html#o0">00100</a>         caddr_t tcp_handle;
<a name="l00101"></a><a class="code" href="structrec__strm.html#o1">00101</a>         caddr_t the_buffer;
00102         <span class="comment">/*</span>
00103 <span class="comment">         * out-goung bits</span>
00104 <span class="comment">         */</span>
00105         int (*writeit) (caddr_t, caddr_t, int);
<a name="l00106"></a><a class="code" href="structrec__strm.html#o3">00106</a>         caddr_t out_base;       <span class="comment">/* output buffer (points to frag header) */</span>
<a name="l00107"></a><a class="code" href="structrec__strm.html#o4">00107</a>         caddr_t out_finger;     <span class="comment">/* next output position */</span>
<a name="l00108"></a><a class="code" href="structrec__strm.html#o5">00108</a>         caddr_t out_boundry;    <span class="comment">/* data cannot up to this address */</span>
<a name="l00109"></a><a class="code" href="structrec__strm.html#o6">00109</a>         u_int32_t *frag_header; <span class="comment">/* beginning of current fragment */</span>
<a name="l00110"></a><a class="code" href="structrec__strm.html#o7">00110</a>         bool_t frag_sent;       <span class="comment">/* true if buffer sent in middle of record */</span>
00111         <span class="comment">/*</span>
00112 <span class="comment">         * in-coming bits</span>
00113 <span class="comment">         */</span>
00114         int (*readit) (caddr_t, caddr_t, int);
<a name="l00115"></a><a class="code" href="structrec__strm.html#o9">00115</a>         u_long in_size; <span class="comment">/* fixed size of the input buffer */</span>
<a name="l00116"></a><a class="code" href="structrec__strm.html#o10">00116</a>         caddr_t in_base;
<a name="l00117"></a><a class="code" href="structrec__strm.html#o11">00117</a>         caddr_t in_finger;      <span class="comment">/* location of next byte to be had */</span>
<a name="l00118"></a><a class="code" href="structrec__strm.html#o12">00118</a>         caddr_t in_boundry;     <span class="comment">/* can read up to this location */</span>
<a name="l00119"></a><a class="code" href="structrec__strm.html#o13">00119</a>         <span class="keywordtype">long</span> fbtbc;             <span class="comment">/* fragment bytes to be consumed */</span>
<a name="l00120"></a><a class="code" href="structrec__strm.html#o14">00120</a>         bool_t last_frag;
<a name="l00121"></a><a class="code" href="structrec__strm.html#o15">00121</a>         u_int sendsize;
<a name="l00122"></a><a class="code" href="structrec__strm.html#o16">00122</a>         u_int recvsize;
00123 } <a class="code" href="structrec__strm.html">RECSTREAM</a>;
00124 
00125 
00126 <span class="comment">/*</span>
00127 <span class="comment"> * Create an xdr handle for xdrrec</span>
00128 <span class="comment"> * xdrrec_create fills in xdrs.  Sendsize and recvsize are</span>
00129 <span class="comment"> * send and recv buffer sizes (0 =&gt; use default).</span>
00130 <span class="comment"> * tcp_handle is an opaque handle that is passed as the first parameter to</span>
00131 <span class="comment"> * the procedures readit and writeit.  Readit and writeit are read and</span>
00132 <span class="comment"> * write respectively.   They are like the system</span>
00133 <span class="comment"> * calls expect that they take an opaque handle rather than an fd.</span>
00134 <span class="comment"> */</span>
00135 <span class="keywordtype">void</span>
<a name="l00136"></a><a class="code" href="Xdr__rec_8c.html#a16">00136</a> <a class="code" href="Xdr__rec_8c.html#a16">Xdrrec_create</a>(xdrs, sendsize, recvsize, tcp_handle, readit, writeit)
00137         register XDR *xdrs;
00138         register u_int sendsize;
00139         register u_int recvsize;
00140         caddr_t tcp_handle;
00141         <span class="keywordtype">int</span> (*readit)();  <span class="comment">/* like read, but pass it a tcp_handle, not sock */</span>
00142         <span class="keywordtype">int</span> (*writeit)();  <span class="comment">/* like write, but pass it a tcp_handle, not sock */</span>
00143 {
00144         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm =
00145                 (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)mem_alloc(<span class="keyword">sizeof</span>(<a class="code" href="structrec__strm.html">RECSTREAM</a>));
00146 
00147         <span class="keywordflow">if</span> (rstrm == NULL) {
00148                 FILE * tmplog ;
00149 
00150                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00151                 {
00152                 (void)fprintf(tmplog, <span class="stringliteral">"xdrrec_create: out of memory\n"</span>);
00153                 <span class="comment">/* </span>
00154 <span class="comment">                 *  This is bad.  Should rework xdrrec_create to </span>
00155 <span class="comment">                 *  return a handle, and in this case return NULL</span>
00156 <span class="comment">                 */</span>
00157                 fclose( tmplog ) ;
00158                 }
00159                 <span class="keywordflow">return</span>;
00160         }
00161         <span class="comment">/*</span>
00162 <span class="comment">         * adjust sizes and allocate buffer quad byte aligned</span>
00163 <span class="comment">         */</span>
00164         rstrm-&gt;<a class="code" href="structrec__strm.html#o15">sendsize</a> = sendsize = fix_buf_size(sendsize);
00165         rstrm-&gt;<a class="code" href="structrec__strm.html#o16">recvsize</a> = recvsize = fix_buf_size(recvsize);
00166         rstrm-&gt;<a class="code" href="structrec__strm.html#o1">the_buffer</a> = mem_alloc(sendsize + recvsize + BYTES_PER_XDR_UNIT);
00167         <span class="keywordflow">if</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o1">the_buffer</a> == NULL) {
00168                 FILE * tmplog ;
00169 
00170                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00171                 {
00172                 (void)fprintf(tmplog, <span class="stringliteral">"xdrrec_create: out of memory\n"</span>);
00173                 fclose( tmplog ) ;
00174                 }
00175                 <span class="keywordflow">return</span>;
00176         }
00177         <span class="keywordflow">for</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a> = rstrm-&gt;<a class="code" href="structrec__strm.html#o1">the_buffer</a>;
00178                 (u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a> % BYTES_PER_XDR_UNIT != 0;
00179                 rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a>++);
00180         rstrm-&gt;<a class="code" href="structrec__strm.html#o10">in_base</a> = rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a> + sendsize;
00181         <span class="comment">/*</span>
00182 <span class="comment">         * now the rest ...</span>
00183 <span class="comment">         */</span>
00184         xdrs-&gt;x_ops = &amp;Xdrrec_ops;
00185         xdrs-&gt;x_private = (caddr_t)rstrm;
00186         rstrm-&gt;<a class="code" href="structrec__strm.html#o0">tcp_handle</a> = tcp_handle;
00187         rstrm-&gt;<a class="code" href="structrec__strm.html#o8">readit</a> = readit;
00188         rstrm-&gt;<a class="code" href="structrec__strm.html#o2">writeit</a> = writeit;
00189         rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> = rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a> = rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a>;
00190         rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a> = (u_int32_t *)rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a>;
00191         rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += <span class="keyword">sizeof</span>(u_int32_t);
00192         rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a> += sendsize;
00193         rstrm-&gt;<a class="code" href="structrec__strm.html#o7">frag_sent</a> = FALSE;
00194         rstrm-&gt;<a class="code" href="structrec__strm.html#o9">in_size</a> = recvsize;
00195         rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> = rstrm-&gt;<a class="code" href="structrec__strm.html#o10">in_base</a>;
00196         rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> = (rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> += recvsize);
00197         rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> = 0;
00198         rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a> = TRUE;
00199 }
00200 
00201 
00202 <span class="comment">/*</span>
00203 <span class="comment"> * The reoutines defined below are the xdr ops which will go into the</span>
00204 <span class="comment"> * xdr handle filled in by xdrrec_create.</span>
00205 <span class="comment"> */</span>
00206 
00207 <span class="keyword">static</span> bool_t
00208 Xdrrec_getlong(xdrs, lp)
00209         XDR *xdrs;
00210         <span class="keywordtype">long</span> *lp;
00211 {
00212         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00213         <span class="keyword">register</span> int32_t *buflp = (int32_t *)(rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a>);
00214         int32_t mylong;
00215 
00216         <span class="comment">/* first try the inline, fast case */</span>
00217         <span class="keywordflow">if</span> ((rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> &gt;= <span class="keyword">sizeof</span>(int32_t)) &amp;&amp;
00218                 (((long)rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> - (long)buflp) &gt;= <span class="keyword">sizeof</span>(int32_t))) {
00219                 *lp = (long)ntohl((u_int32_t)(*buflp));
00220                 rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> -= <span class="keyword">sizeof</span>(int32_t);
00221                 rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> += <span class="keyword">sizeof</span>(int32_t);
00222         } <span class="keywordflow">else</span> {
00223                 <span class="keywordflow">if</span> (! Xdrrec_getbytes(xdrs, (caddr_t)&amp;mylong, <span class="keyword">sizeof</span>(int32_t)))
00224                         <span class="keywordflow">return</span> (FALSE);
00225                 *lp = (long)ntohl((u_int32_t)mylong);
00226         }
00227         <span class="keywordflow">return</span> (TRUE);
00228 }
00229 
00230 <span class="keyword">static</span> bool_t
00231 Xdrrec_putlong(xdrs, lp)
00232         XDR *xdrs;
00233         <span class="keywordtype">long</span> *lp;
00234 {
00235         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00236         <span class="keyword">register</span> int32_t *dest_lp = ((int32_t *)(rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>));
00237 
00238         <span class="keywordflow">if</span> ((rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += <span class="keyword">sizeof</span>(int32_t)) &gt; rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a>) {
00239                 <span class="comment">/*</span>
00240 <span class="comment">                 * this case should almost never happen so the code is</span>
00241 <span class="comment">                 * inefficient</span>
00242 <span class="comment">                 */</span>
00243                 rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> -= <span class="keyword">sizeof</span>(int32_t);
00244                 rstrm-&gt;<a class="code" href="structrec__strm.html#o7">frag_sent</a> = TRUE;
00245                 <span class="keywordflow">if</span> (! flush_out(rstrm, FALSE))
00246                         <span class="keywordflow">return</span> (FALSE);
00247                 dest_lp = ((int32_t *)(rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>));
00248                 rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += <span class="keyword">sizeof</span>(int32_t);
00249         }
00250         *dest_lp = (int32_t)htonl((u_int32_t)(*lp));
00251         <span class="keywordflow">return</span> (TRUE);
00252 }
00253 
00254 <span class="keyword">static</span> bool_t  <span class="comment">/* must manage buffers, fragments, and records */</span>
00255 Xdrrec_getbytes(xdrs, addr, len)
00256         XDR *xdrs;
00257         register caddr_t addr;
00258         register u_int len;
00259 {
00260         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00261         <span class="keyword">register</span> <span class="keywordtype">int</span> current;
00262 
00263         <span class="keywordflow">while</span> (len &gt; 0) {
00264                 current = rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a>;
00265                 <span class="keywordflow">if</span> (current == 0) {
00266                         <span class="keywordflow">if</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a>)
00267                                 <span class="keywordflow">return</span> (FALSE);
00268                         <span class="keywordflow">if</span> (! set_input_fragment(rstrm))
00269                                 <span class="keywordflow">return</span> (FALSE);
00270                         <span class="keywordflow">continue</span>;
00271                 }
00272                 current = (len &lt; current) ? len : current;
00273                 <span class="keywordflow">if</span> (! get_input_bytes(rstrm, addr, current))
00274                         <span class="keywordflow">return</span> (FALSE);
00275                 addr += current; 
00276                 rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> -= current;
00277                 len -= current;
00278         }
00279         <span class="keywordflow">return</span> (TRUE);
00280 }
00281 
00282 <span class="keyword">static</span> bool_t
00283 Xdrrec_putbytes(xdrs, addr, len)
00284         XDR *xdrs;
00285         register caddr_t addr;
00286         register u_int len;
00287 {
00288         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00289         <span class="keyword">register</span> <span class="keywordtype">long</span> current;
00290 
00291         <span class="keywordflow">while</span> (len &gt; 0) {
00292                 current = (u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a> -
00293                     (u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>;
00294                 current = (len &lt; current) ? len : current;
00295                 memcpy(rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>, addr, current);
00296                 rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += current;
00297                 addr += current;
00298                 len -= current;
00299                 <span class="keywordflow">if</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> == rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a>) {
00300                         rstrm-&gt;<a class="code" href="structrec__strm.html#o7">frag_sent</a> = TRUE;
00301                         <span class="keywordflow">if</span> (! flush_out(rstrm, FALSE))
00302                                 <span class="keywordflow">return</span> (FALSE);
00303                 }
00304         }
00305         <span class="keywordflow">return</span> (TRUE);
00306 }
00307 
00308 <span class="comment">/*</span>
00309 <span class="comment">  XXX - the lseek() on our tcp_handle never worked anyhow.</span>
00310 <span class="comment">  this is only valid for streams that haven't been flushed.</span>
00311 <span class="comment">*/</span>
00312 <span class="keyword">static</span> u_int
00313 Xdrrec_getpos(xdrs)
00314         register XDR *xdrs;
00315 {
00316         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)xdrs-&gt;x_private;
00317         <span class="keyword">register</span> <span class="keywordtype">long</span> pos = -1;
00318         
00319 
00320         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00321                 
00322         <span class="keywordflow">case</span> XDR_ENCODE:
00323                 pos = rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> - rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a> - <span class="keyword">sizeof</span>(u_int32_t);
00324                 <span class="keywordflow">break</span>;
00325                 
00326         <span class="keywordflow">case</span> XDR_DECODE:
00327                 pos = rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> - rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> - <span class="keyword">sizeof</span>(u_int32_t);
00328                 <span class="keywordflow">break</span>;
00329                 
00330         <span class="keywordflow">default</span>:
00331                 pos = -1;
00332                 <span class="keywordflow">break</span>;
00333         }
00334         <span class="keywordflow">return</span> ((u_int) pos);
00335 }
00336 
00337 <span class="keyword">static</span> bool_t
00338 Xdrrec_setpos(xdrs, pos)
00339         register XDR *xdrs;
00340         u_int pos;
00341 {
00342         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)xdrs-&gt;x_private;
00343         u_int currpos = Xdrrec_getpos(xdrs);
00344         <span class="keywordtype">int</span> delta = currpos - pos;
00345         caddr_t newpos;
00346 
00347         <span class="keywordflow">if</span> ((int)currpos != -1)
00348                 <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00349 
00350                 <span class="keywordflow">case</span> XDR_ENCODE:
00351                         newpos = rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> - delta;
00352                         <span class="keywordflow">if</span> ((newpos &gt; (caddr_t)(rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a>)) &amp;&amp;
00353                                 (newpos &lt; rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a>)) {
00354                                 rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> = newpos;
00355                                 <span class="keywordflow">return</span> (TRUE);
00356                         }
00357                         <span class="keywordflow">break</span>;
00358 
00359                 <span class="keywordflow">case</span> XDR_DECODE:
00360                         newpos = rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> - delta;
00361                         <span class="keywordflow">if</span> ((delta &lt; (int)(rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a>)) &amp;&amp;
00362                                 (newpos &lt;= rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a>) &amp;&amp;
00363                                 (newpos &gt;= rstrm-&gt;<a class="code" href="structrec__strm.html#o10">in_base</a>)) {
00364                                 rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> = newpos;
00365                                 rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> -= delta;
00366                                 <span class="keywordflow">return</span> (TRUE);
00367                         }
00368                         <span class="keywordflow">break</span>;
00369                         
00370                 <span class="keywordflow">default</span>:
00371                         <span class="keywordflow">break</span>;
00372                 }
00373         <span class="keywordflow">return</span> (FALSE);
00374 }
00375 
00376 <span class="keyword">static</span> int32_t *
00377 Xdrrec_inline(xdrs, len)
00378         register XDR *xdrs;
00379         <span class="keywordtype">int</span> len;
00380 {
00381         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)xdrs-&gt;x_private;
00382         int32_t *buf = NULL;
00383 
00384         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00385 
00386         <span class="keywordflow">case</span> XDR_ENCODE:
00387                 <span class="keywordflow">if</span> ((rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> + len) &lt;= rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a>) {
00388                         buf = (int32_t *) rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>;
00389                         rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += len;
00390                 }
00391                 <span class="keywordflow">break</span>;
00392 
00393         <span class="keywordflow">case</span> XDR_DECODE:
00394                 <span class="keywordflow">if</span> ((len &lt;= rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a>) &amp;&amp;
00395                         ((rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> + len) &lt;= rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a>)) {
00396                         buf = (int32_t *) rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a>;
00397                         rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> -= len;
00398                         rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> += len;
00399                 }
00400                 <span class="keywordflow">break</span>;
00401 
00402         <span class="keywordflow">default</span>:
00403                 <span class="keywordflow">break</span>;
00404         }
00405         <span class="keywordflow">return</span> (buf);
00406 }
00407 
00408 <span class="keyword">static</span> <span class="keywordtype">void</span>
00409 Xdrrec_destroy(xdrs)
00410         register XDR *xdrs;
00411 {
00412         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)xdrs-&gt;x_private;
00413 
00414         mem_free(rstrm-&gt;<a class="code" href="structrec__strm.html#o1">the_buffer</a>,
00415                 rstrm-&gt;<a class="code" href="structrec__strm.html#o15">sendsize</a> + rstrm-&gt;<a class="code" href="structrec__strm.html#o16">recvsize</a> + BYTES_PER_XDR_UNIT);
00416         mem_free((caddr_t)rstrm, <span class="keyword">sizeof</span>(<a class="code" href="structrec__strm.html">RECSTREAM</a>));
00417 }
00418 
00419 
00420 <span class="comment">/*</span>
00421 <span class="comment"> * Exported routines to manage xdr records</span>
00422 <span class="comment"> */</span>
00423 
00424 <span class="comment">/*</span>
00425 <span class="comment"> * Before reading (deserializing from the stream, one should always call</span>
00426 <span class="comment"> * this procedure to guarantee proper record alignment.</span>
00427 <span class="comment"> */</span>
00428 bool_t
<a name="l00429"></a><a class="code" href="Xdr__rec_8c.html#a25">00429</a> <a class="code" href="Xdr__rec_8c.html#a25">Xdrrec_skiprecord</a>(xdrs)
00430         XDR *xdrs;
00431 {
00432         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00433 
00434         <span class="keywordflow">while</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> &gt; 0 || (! rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a>)) {
00435                 <span class="keywordflow">if</span> (! skip_input_bytes(rstrm, rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a>))
00436                         <span class="keywordflow">return</span> (FALSE);
00437                 rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> = 0;
00438                 <span class="keywordflow">if</span> ((! rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a>) &amp;&amp; (! set_input_fragment(rstrm)))
00439                         <span class="keywordflow">return</span> (FALSE);
00440         }
00441         rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a> = FALSE;
00442         <span class="keywordflow">return</span> (TRUE);
00443 }
00444 
00445 <span class="comment">/*</span>
00446 <span class="comment"> * Look ahead fuction.</span>
00447 <span class="comment"> * Returns TRUE iff there is no more input in the buffer </span>
00448 <span class="comment"> * after consuming the rest of the current record.</span>
00449 <span class="comment"> */</span>
00450 bool_t
<a name="l00451"></a><a class="code" href="Xdr__rec_8c.html#a26">00451</a> <a class="code" href="Xdr__rec_8c.html#a26">Xdrrec_eof</a>(xdrs)
00452         XDR *xdrs;
00453 {
00454         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00455 
00456         <span class="keywordflow">while</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> &gt; 0 || (! rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a>)) {
00457                 <span class="keywordflow">if</span> (! skip_input_bytes(rstrm, rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a>))
00458                         <span class="keywordflow">return</span> (TRUE);
00459                 rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> = 0;
00460                 <span class="keywordflow">if</span> ((! rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a>) &amp;&amp; (! set_input_fragment(rstrm)))
00461                         <span class="keywordflow">return</span> (TRUE);
00462         }
00463         <span class="keywordflow">if</span> (rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> == rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a>)
00464                 <span class="keywordflow">return</span> (TRUE);
00465         <span class="keywordflow">return</span> (FALSE);
00466 }
00467 
00468 <span class="comment">/*</span>
00469 <span class="comment"> * The client must tell the package when an end-of-record has occurred.</span>
00470 <span class="comment"> * The second paraemters tells whether the record should be flushed to the</span>
00471 <span class="comment"> * (output) tcp stream.  (This let's the package support batched or</span>
00472 <span class="comment"> * pipelined procedure calls.)  TRUE =&gt; immmediate flush to tcp connection.</span>
00473 <span class="comment"> */</span>
00474 bool_t
<a name="l00475"></a><a class="code" href="Xdr__rec_8c.html#a27">00475</a> <a class="code" href="Xdr__rec_8c.html#a27">Xdrrec_endofrecord</a>(xdrs, sendnow)
00476         XDR *xdrs;
00477         bool_t sendnow;
00478 {
00479         <span class="keyword">register</span> <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)(xdrs-&gt;x_private);
00480         <span class="keyword">register</span> u_long len;  <span class="comment">/* fragment length */</span>
00481 
00482         <span class="keywordflow">if</span> (sendnow || rstrm-&gt;<a class="code" href="structrec__strm.html#o7">frag_sent</a> ||
00483                 ((u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> + <span class="keyword">sizeof</span>(u_int32_t) &gt;=
00484                 (u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o5">out_boundry</a>)) {
00485                 rstrm-&gt;<a class="code" href="structrec__strm.html#o7">frag_sent</a> = FALSE;
00486                 <span class="keywordflow">return</span> (flush_out(rstrm, TRUE));
00487         }
00488         len = (u_long)(rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>) - (u_long)(rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a>) -
00489            <span class="keyword">sizeof</span>(u_int32_t);
00490         *(rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a>) = htonl((u_long)len | <a class="code" href="Xdr__rec_8c.html#a0">LAST_FRAG</a>);
00491         rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a> = (u_int32_t *)rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a>;
00492         rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> += <span class="keyword">sizeof</span>(u_int32_t);
00493         <span class="keywordflow">return</span> (TRUE);
00494 }
00495 
00496 
00497 <span class="comment">/*</span>
00498 <span class="comment"> * Internal useful routines</span>
00499 <span class="comment"> */</span>
00500 <span class="keyword">static</span> bool_t
00501 flush_out(rstrm, eor)
00502         register <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm;
00503         bool_t eor;
00504 {
00505         <span class="keyword">register</span> u_long eormask = (eor == TRUE) ? <a class="code" href="Xdr__rec_8c.html#a0">LAST_FRAG</a> : 0;
00506         <span class="keyword">register</span> u_int32_t len = (u_long)(rstrm-&gt;out_finger) - 
00507                 (u_long)(rstrm-&gt;frag_header) - <span class="keyword">sizeof</span>(u_int32_t);
00508 
00509         *(rstrm-&gt;frag_header) = htonl(len | eormask);
00510         len = (u_long)(rstrm-&gt;out_finger) - (u_long)(rstrm-&gt;out_base);
00511         <span class="keywordflow">if</span> ((*(rstrm-&gt;writeit))(rstrm-&gt;tcp_handle, rstrm-&gt;out_base, (int)len)
00512                 != (int)len)
00513                 <span class="keywordflow">return</span> (FALSE);
00514         rstrm-&gt;<a class="code" href="structrec__strm.html#o6">frag_header</a> = (u_int32_t *)rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a>;
00515         rstrm-&gt;<a class="code" href="structrec__strm.html#o4">out_finger</a> = (caddr_t)rstrm-&gt;<a class="code" href="structrec__strm.html#o3">out_base</a> + <span class="keyword">sizeof</span>(u_int32_t);
00516         <span class="keywordflow">return</span> (TRUE);
00517 }
00518 
00519 <span class="keyword">static</span> bool_t  <span class="comment">/* knows nothing about records!  Only about input buffers */</span>
00520 fill_input_buf(rstrm)
00521         register <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm;
00522 {
00523         <span class="keyword">register</span> caddr_t where;
00524         u_long i;
00525         <span class="keyword">register</span> <span class="keywordtype">long</span> len;
00526 
00527         where = rstrm-&gt;<a class="code" href="structrec__strm.html#o10">in_base</a>;
00528         i = (u_long)rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> % BYTES_PER_XDR_UNIT;
00529         where += i;
00530         len = rstrm-&gt;<a class="code" href="structrec__strm.html#o9">in_size</a> - i;
00531         <span class="keywordflow">if</span> ((len = (*(rstrm-&gt;readit))(rstrm-&gt;tcp_handle, where, len)) == -1)
00532                 <span class="keywordflow">return</span> (FALSE);
00533         rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> = where;
00534         where += len;
00535         rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> = where;
00536         <span class="keywordflow">return</span> (TRUE);
00537 }
00538 
00539 <span class="keyword">static</span> bool_t  <span class="comment">/* knows nothing about records!  Only about input buffers */</span>
00540 get_input_bytes(rstrm, addr, len)
00541         register <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm;
00542         register caddr_t addr;
00543         register <span class="keywordtype">int</span> len;
00544 {
00545         <span class="keyword">register</span> <span class="keywordtype">long</span> current;
00546 
00547         <span class="keywordflow">while</span> (len &gt; 0) {
00548                 current = (long)rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> - (long)rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a>;
00549                 <span class="keywordflow">if</span> (current == 0) {
00550                         <span class="keywordflow">if</span> (! fill_input_buf(rstrm))
00551                                 <span class="keywordflow">return</span> (FALSE);
00552                         <span class="keywordflow">continue</span>;
00553                 }
00554                 current = (len &lt; current) ? len : current;
00555                 memcpy(addr, rstrm-&gt;in_finger, current);
00556                 rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> += current;
00557                 addr += current;
00558                 len -= current;
00559         }
00560         <span class="keywordflow">return</span> (TRUE);
00561 }
00562 
00563 <span class="keyword">static</span> bool_t  <span class="comment">/* next four bytes of the input stream are treated as a header */</span>
00564 set_input_fragment(rstrm)
00565         register <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm;
00566 {
00567         u_int32_t header;
00568 
00569         <span class="keywordflow">if</span> (! get_input_bytes(rstrm, (caddr_t)&amp;header, <span class="keyword">sizeof</span>(header)))
00570                 <span class="keywordflow">return</span> (FALSE);
00571         header = (long)ntohl(header);
00572         rstrm-&gt;<a class="code" href="structrec__strm.html#o14">last_frag</a> = ((header &amp; LAST_FRAG) == 0) ? FALSE : TRUE;
00573         <span class="keywordflow">if</span> ((header &amp; (~LAST_FRAG)) == 0)
00574                 <span class="keywordflow">return</span>(FALSE);
00575         rstrm-&gt;<a class="code" href="structrec__strm.html#o13">fbtbc</a> = header &amp; (~LAST_FRAG);
00576         <span class="keywordflow">return</span> (TRUE);
00577 }
00578 
00579 <span class="keyword">static</span> bool_t  <span class="comment">/* consumes input bytes; knows nothing about records! */</span>
00580 skip_input_bytes(rstrm, cnt)
00581         register <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm;
00582         <span class="keywordtype">long</span> cnt;
00583 {
00584         <span class="keyword">register</span> <span class="keywordtype">long</span> current;
00585 
00586         <span class="keywordflow">while</span> (cnt &gt; 0) {
00587                 current = (long)rstrm-&gt;<a class="code" href="structrec__strm.html#o12">in_boundry</a> - (long)rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a>;
00588                 <span class="keywordflow">if</span> (current == 0) {
00589                         <span class="keywordflow">if</span> (! fill_input_buf(rstrm))
00590                                 <span class="keywordflow">return</span> (FALSE);
00591                         <span class="keywordflow">continue</span>;
00592                 }
00593                 current = (cnt &lt; current) ? cnt : current;
00594                 rstrm-&gt;<a class="code" href="structrec__strm.html#o11">in_finger</a> += current;
00595                 cnt -= current;
00596         }
00597         <span class="keywordflow">return</span> (TRUE);
00598 }
00599 
00600 <span class="keyword">static</span> u_int
00601 fix_buf_size(s)
00602         register u_int s;
00603 {
00604 
00605         <span class="keywordflow">if</span> (s &lt; 100)
00606                 s = 4000;
00607         <span class="keywordflow">return</span> (RNDUP(s));
00608 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
