<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Auth_gss.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Auth_gss.c</h1><a href="Auth__gss_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  auth_gss.c</span>
00003 <span class="comment"></span>
00004 <span class="comment">  RPCSEC_GSS client routines.</span>
00005 <span class="comment">  </span>
00006 <span class="comment">  Copyright (c) 2000 The Regents of the University of Michigan.</span>
00007 <span class="comment">  All rights reserved.</span>
00008 <span class="comment"></span>
00009 <span class="comment">  Copyright (c) 2000 Dug Song &lt;dugsong@UMICH.EDU&gt;.</span>
00010 <span class="comment">  All rights reserved, all wrongs reversed.</span>
00011 <span class="comment"></span>
00012 <span class="comment">  Redistribution and use in source and binary forms, with or without</span>
00013 <span class="comment">  modification, are permitted provided that the following conditions</span>
00014 <span class="comment">  are met:</span>
00015 <span class="comment"></span>
00016 <span class="comment">  1. Redistributions of source code must retain the above copyright</span>
00017 <span class="comment">     notice, this list of conditions and the following disclaimer.</span>
00018 <span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span>
00019 <span class="comment">     notice, this list of conditions and the following disclaimer in the</span>
00020 <span class="comment">     documentation and/or other materials provided with the distribution.</span>
00021 <span class="comment">  3. Neither the name of the University nor the names of its</span>
00022 <span class="comment">     contributors may be used to endorse or promote products derived</span>
00023 <span class="comment">     from this software without specific prior written permission.</span>
00024 <span class="comment"></span>
00025 <span class="comment">  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00026 <span class="comment">  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00027 <span class="comment">  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00028 <span class="comment">  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
00029 <span class="comment">  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
00030 <span class="comment">  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
00031 <span class="comment">  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
00032 <span class="comment">  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
00033 <span class="comment">  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
00034 <span class="comment">  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
00035 <span class="comment">  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00036 <span class="comment"></span>
00037 <span class="comment">  $Id: Auth_gss.c,v 1.3 2005/08/12 07:11:15 deniel Exp $</span>
00038 <span class="comment">*/</span>
00039 
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00042 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
00044 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00045 <span class="preprocessor">#include "Types.h"</span>
00046 <span class="preprocessor">#include "Xdr.h"</span>
00047 <span class="preprocessor">#include "Rpc.h"</span>
00048 <span class="preprocessor">#include "Auth.h"</span>
00049 <span class="preprocessor">#include "Auth_gss.h"</span>
00050 <span class="preprocessor">#include "Clnt.h"</span>
00051 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00052 <span class="preprocessor">#ifdef HAVE_KRB5</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssapi/gssapi.h&gt;</span>
00054 <span class="preprocessor">#include &lt;gssapi/gssapi_generic.h&gt;</span>
00055 <span class="preprocessor">#elif HAVE_HEIMDAL</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssapi.h&gt;</span>
00057 <span class="preprocessor">#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#include "Types.h"</span>
00061 <span class="preprocessor">#include "stuff_alloc.h"</span>
00062 
00063 <span class="preprocessor">#ifdef HAVE_KRB5</span>
00064 <span class="preprocessor"></span><span class="comment">/* Krb 5 default mechanism */</span>
00065 <span class="preprocessor">#define KRB5OID  "1.2.840.113554.1.2.2"</span>
00066 <span class="preprocessor"></span>
00067 
00068 gss_OID_desc <a class="code" href="client-gss_8c.html#a13">krb5oid</a> = {
00069         20, <a class="code" href="client-gss_8c.html#a8">KRB5OID</a> 
00070 };
00071 
00072 <span class="preprocessor">#ifdef _WITH_SPKM3</span>
00073 <span class="preprocessor"></span>gss_OID_desc spkm3oid = 
00074    {7, <span class="stringliteral">"\052\006\001\005\005\001\003"</span>};
00075 <span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>
00077 <span class="keyword">struct </span>Rpc_gss_sec krb5mech = {
00078         GSS_QOP_DEFAULT,
00079   (gss_OID)&amp;krb5oid,
00080         RPCSEC_GSS_SVC_NONE
00081 }; 
00082 
00083 
00084 <span class="keyword">static</span> <span class="keywordtype">void</span>     Authgss_nextverf();
00085 <span class="keyword">static</span> bool_t   Authgss_marshal();
00086 <span class="keyword">static</span> bool_t   Authgss_refresh();
00087 <span class="keyword">static</span> bool_t   Authgss_validate();
00088 <span class="keyword">static</span> <span class="keywordtype">void</span>       Authgss_destroy();
00089 <span class="keyword">static</span> <span class="keywordtype">void</span>       Authgss_destroy_context();
00090 <span class="keyword">static</span> bool_t   Authgss_wrap();
00091 <span class="keyword">static</span> bool_t   Authgss_unwrap();
00092 
00093 
00094 <span class="comment">/*</span>
00095 <span class="comment"> * from mit-krb5-1.2.1 mechglue/mglueP.h:</span>
00096 <span class="comment"> * Array of context IDs typed by mechanism OID</span>
00097 <span class="comment"> */</span>
00098 <span class="keyword">typedef</span> <span class="keyword">struct </span>gss_union_ctx_id_t {
00099   gss_OID                  mech_type;
00100   gss_ctx_id_t             internal_ctx_id;
00101 } gss_union_ctx_id_desc, * gss_union_ctx_id_t;
00102 
00103 <span class="keyword">static</span> <span class="keyword">struct </span>Auth_ops Authgss_ops = {
00104         Authgss_nextverf,
00105         Authgss_marshal,
00106         Authgss_validate,
00107         Authgss_refresh,
00108         Authgss_destroy,
00109         Authgss_wrap, 
00110   Authgss_unwrap  
00111 };
00112 
00113 <span class="preprocessor">#ifdef _DEBUG_RPCSEC_GSS</span>
00114 <span class="preprocessor"></span>
00115 <span class="comment">/* useful as i add more mechanisms */</span>
00116 <span class="keywordtype">void</span> print_Rpc_gss_sec( <span class="keyword">struct</span> Rpc_gss_sec * ptr )
00117 {
00118   <span class="keywordtype">int</span> i;
00119   <span class="keywordtype">char</span> *p;
00120   
00121         printf(<span class="stringliteral">"Rpc_gss_sec:\n"</span>);
00122         <span class="keywordflow">if</span>(ptr-&gt;mech == NULL)
00123                 printf(<span class="stringliteral">"NULL gss_OID mech\n"</span>);
00124         <span class="keywordflow">else</span> {
00125                 printf(<span class="stringliteral">"     gss_OID len: %d\n gss_OID elements:"</span>, ptr-&gt;mech-&gt;length);
00126 
00127                 p = (<span class="keywordtype">char</span> *)ptr-&gt;mech-&gt;elements;
00128                 printf(<span class="stringliteral">"     "</span>);
00129                 <span class="keywordflow">for</span>(i=0;i&lt;ptr-&gt;mech-&gt;length;i++)
00130                         printf(<span class="stringliteral">"%c"</span>,*p++);
00131                 printf(<span class="stringliteral">"\n"</span>);
00132         }
00133         printf(<span class="stringliteral">"     qop: %d\n"</span>,ptr-&gt;qop);
00134         printf(<span class="stringliteral">"     service: %d\n"</span>,ptr-&gt;svc);
00135 }
00136 <span class="preprocessor">#endif </span><span class="comment">/*DEBUG*/</span>
00137 
00138 <span class="comment">/* Krb 5 default mechanism oid */</span>
00139 <span class="preprocessor">#define KRB5OID  "1.2.840.113554.1.2.2"</span>
00140 <span class="preprocessor"></span>
00141 <span class="preprocessor">#define g_OID_equal(o1,o2) \</span>
00142 <span class="preprocessor">   (((o1)-&gt;length == (o2)-&gt;length) &amp;&amp; \</span>
00143 <span class="preprocessor">    ((o1)-&gt;elements != 0) &amp;&amp; ((o2)-&gt;elements != 0) &amp;&amp; \</span>
00144 <span class="preprocessor">    (memcmp((o1)-&gt;elements,(o2)-&gt;elements,(int) (o1)-&gt;length) == 0))</span>
00145 <span class="preprocessor"></span>
00146 
00147 
00148 <span class="keyword">struct </span>Rpc_gss_data {
00149         bool_t                           established;   <span class="comment">/* context established */</span>
00150   gss_buffer_desc      gc_wire_verf; <span class="comment">/* save GSS_S_COMPLETE NULL RPC verfier </span>
00151 <span class="comment">                                      * to process at end of context negotiation*/</span>
00152         Client                  *        clnt;          <span class="comment">/* client handle */</span>
00153         gss_name_t                     name;            <span class="comment">/* service name */</span>
00154         <span class="keyword">struct </span>Rpc_gss_sec       sec;           <span class="comment">/* security tuple */</span>
00155         gss_ctx_id_t                 ctx;               <span class="comment">/* context id */</span>
00156         <span class="keyword">struct </span>Rpc_gss_cred      gc;            <span class="comment">/* client credentials */</span>
00157         u_int                              win;         <span class="comment">/* sequence window */</span>
00158 };
00159 
00160 <span class="preprocessor">#define AUTH_PRIVATE(auth)      ((struct Rpc_gss_data *)auth-&gt;ah_private)</span>
00161 <span class="preprocessor"></span>
00162 <span class="keyword">static</span> <span class="keyword">struct </span>timeval AUTH_TIMEOUT = { 25, 0 };
00163 
00164 AUTH * Authgss_create( Client * clnt, gss_name_t name, <span class="keyword">struct</span> Rpc_gss_sec * sec )
00165 {
00166         AUTH                    * auth, * save_auth;
00167         <span class="keyword">struct      </span>Rpc_gss_data        *gd;
00168 
00169         
00170         memset(&amp;rpc_createerr, 0, <span class="keyword">sizeof</span>(rpc_createerr));
00171         
00172         <span class="keywordflow">if</span> ((auth = mem_calloc(<span class="keyword">sizeof</span>(*auth), 1)) == NULL) {
00173                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00174                 rpc_createerr.cf_error.re_errno = ENOMEM;
00175                 <span class="keywordflow">return</span> (NULL);
00176         }
00177         <span class="keywordflow">if</span> ((gd = mem_calloc(<span class="keyword">sizeof</span>(*gd), 1)) == NULL) {
00178                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00179                 rpc_createerr.cf_error.re_errno = ENOMEM;
00180                 Mem_Free(auth);
00181                 <span class="keywordflow">return</span> (NULL);
00182         }
00183         gd-&gt;clnt = clnt;
00184         gd-&gt;name = name;
00185         gd-&gt;ctx = GSS_C_NO_CONTEXT;
00186         gd-&gt;sec = *sec;
00187 
00188         gd-&gt;gc.gc_v = RPCSEC_GSS_VERSION;
00189         gd-&gt;gc.gc_proc = RPCSEC_GSS_INIT;
00190         gd-&gt;gc.gc_svc = gd-&gt;sec.svc;
00191         
00192         auth-&gt;ah_ops = &amp;Authgss_ops;
00193         auth-&gt;ah_private = (caddr_t)gd;
00194         
00195         save_auth = clnt-&gt;cl_auth;
00196         clnt-&gt;cl_auth = auth;
00197 
00198         <span class="keywordflow">if</span> (!Authgss_refresh(auth))
00199                 auth = NULL;
00200         
00201         clnt-&gt;cl_auth = save_auth;
00202         
00203         <span class="keywordflow">return</span> (auth);
00204 }
00205 
00206 AUTH * Authgss_create_default( Client * clnt, <span class="keywordtype">char</span> * service, <span class="keyword">struct</span> Rpc_gss_sec * sec )
00207 {
00208         AUTH                    *     auth;
00209         OM_uint32                   maj_stat = 0, min_stat = 0;
00210         gss_buffer_desc sname;
00211         gss_name_t      name;
00212 
00213         
00214 
00215         <a class="code" href="client-gss_8c.html#a19">sname</a>.value = service;
00216         <a class="code" href="client-gss_8c.html#a19">sname</a>.length = strlen(service) ;
00217   
00218         maj_stat = gss_import_name(&amp;min_stat, &amp;sname,
00219                              (gss_OID)GSS_C_NT_HOSTBASED_SERVICE,
00220                              &amp;name);
00221 
00222         <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE ) 
00223     {
00224       log_status(<span class="stringliteral">"gss_import_name"</span>, maj_stat, min_stat);
00225       rpc_createerr.cf_stat = RPC_AUTHERROR;
00226       <span class="keywordflow">return</span> (NULL);
00227     }
00228   
00229   auth = Authgss_create(clnt, name, sec);
00230     
00231   <span class="keywordflow">if</span>(auth)
00232                 gss_release_name(&amp;min_stat, &amp;name);
00233         
00234   
00235         <span class="keywordflow">return</span> (auth);
00236 }
00237 
00238 <span class="keyword">static</span> <span class="keywordtype">void</span> Authgss_nextverf( AUTH * auth )
00239 {
00240         <span class="comment">/* no action necessary */</span>
00241 }
00242 
00243 <span class="keyword">static</span> bool_t Authgss_marshal( AUTH * auth, XDR *xdrs )
00244 {
00245         XDR                                   tmpxdrs;
00246         <span class="keywordtype">char</span>                                tmp[MAX_AUTH_BYTES];
00247         <span class="keyword">struct </span>Rpc_gss_data     * gd;
00248         gss_buffer_desc             rpcbuf, checksum;
00249         OM_uint32                         maj_stat, min_stat;
00250         bool_t                            xdr_stat;
00251         
00252         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00253 
00254         <span class="keywordflow">if</span> (gd-&gt;established)
00255                 gd-&gt;gc.gc_seq++;
00256         
00257         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;tmpxdrs, tmp, <span class="keyword">sizeof</span>(tmp), XDR_ENCODE);
00258         
00259         <span class="keywordflow">if</span> (!Xdr_Rpc_gss_cred(&amp;tmpxdrs, &amp;gd-&gt;gc)) {
00260                 XDR_DESTROY(&amp;tmpxdrs);
00261                 <span class="keywordflow">return</span> (FALSE);
00262         }
00263         auth-&gt;ah_cred.oa_flavor = RPCSEC_GSS;
00264         auth-&gt;ah_cred.oa_base = tmp;
00265         auth-&gt;ah_cred.oa_length = XDR_GETPOS(&amp;tmpxdrs);
00266         
00267         XDR_DESTROY(&amp;tmpxdrs);
00268         
00269         <span class="keywordflow">if</span> (!<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;auth-&gt;ah_cred))
00270                 <span class="keywordflow">return</span> (FALSE);
00271 
00272         <span class="keywordflow">if</span> (gd-&gt;gc.gc_proc == RPCSEC_GSS_INIT ||
00273             gd-&gt;gc.gc_proc == RPCSEC_GSS_CONTINUE_INIT) {
00274                 <span class="keywordflow">return</span> (<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;_null_auth));
00275         }
00276         <span class="comment">/* Checksum serialized RPC header, up to and including credential. */</span>
00277         rpcbuf.length = XDR_GETPOS(xdrs); 
00278   
00279         XDR_SETPOS(xdrs, 0);
00280         rpcbuf.value = XDR_INLINE(xdrs, rpcbuf.length);
00281         
00282 
00283         maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a2">gss_get_mic</a>( &amp;min_stat, 
00284                           gd-&gt;ctx, 
00285                           gd-&gt;sec.qop, 
00286                           &amp;rpcbuf, 
00287                           &amp;checksum);
00288 
00289 
00290         <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE)
00291     {
00292       <span class="keywordflow">if</span> (maj_stat == GSS_S_CONTEXT_EXPIRED)
00293         {
00294           gd-&gt;established = FALSE;
00295           Authgss_destroy_context(auth);
00296         }
00297       <span class="keywordflow">return</span> (FALSE);
00298     }
00299 
00300         auth-&gt;ah_verf.oa_flavor = RPCSEC_GSS;
00301         auth-&gt;ah_verf.oa_base = checksum.value;
00302         auth-&gt;ah_verf.oa_length = checksum.length;
00303         
00304         xdr_stat = <a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;auth-&gt;ah_verf);
00305         gss_release_buffer(&amp;min_stat, &amp;checksum);
00306         
00307         <span class="keywordflow">return</span> (xdr_stat);
00308 }
00309 
00310 <span class="keyword">static</span> bool_t Authgss_validate( AUTH * auth, <span class="keyword">struct</span> opaque_auth * verf )
00311 {
00312         <span class="keyword">struct </span>Rpc_gss_data     * gd;
00313         u_int                               num, qop_state;
00314         gss_buffer_desc       signbuf, checksum;
00315         OM_uint32                         maj_stat, min_stat;
00316 
00317         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00318 
00319         <span class="keywordflow">if</span> (gd-&gt;established == FALSE) 
00320     {
00321       <span class="comment">/* would like to do this only on NULL rpc - gc-&gt;established is good enough.</span>
00322 <span class="comment">       * save the on the wire verifier to validate last INIT phase packet</span>
00323 <span class="comment">       * after decode if the major status is GSS_S_COMPLETE </span>
00324 <span class="comment">       */</span>
00325       <span class="keywordflow">if</span> ((gd-&gt;gc_wire_verf.value = mem_alloc(verf-&gt;oa_length)) == NULL)
00326         {
00327           FILE * tmplog ;
00328           <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00329             {
00330                 fprintf( tmplog, <span class="stringliteral">"gss_validate: out of memory\n"</span>);
00331                 fclose( tmplog ) ;
00332             }
00333           <span class="keywordflow">return</span> (FALSE);
00334         }
00335       memcpy(gd-&gt;gc_wire_verf.value, verf-&gt;oa_base, verf-&gt;oa_length);
00336       gd-&gt;gc_wire_verf.length = verf-&gt;oa_length;
00337       <span class="keywordflow">return</span> (TRUE);
00338     }
00339 
00340         <span class="keywordflow">if</span> (gd-&gt;gc.gc_proc == RPCSEC_GSS_INIT ||
00341             gd-&gt;gc.gc_proc == RPCSEC_GSS_CONTINUE_INIT)
00342     {
00343       num = htonl(gd-&gt;win);
00344     }
00345         <span class="keywordflow">else</span>
00346     num = htonl(gd-&gt;gc.gc_seq);
00347         
00348         signbuf.value = &amp;num;
00349         signbuf.length = <span class="keyword">sizeof</span>(num);
00350         
00351         checksum.value = verf-&gt;oa_base;
00352         checksum.length = verf-&gt;oa_length;
00353 
00354         maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a3">gss_verify_mic</a>(&amp;min_stat, gd-&gt;ctx, &amp;signbuf,
00355                             &amp;checksum, &amp;qop_state);
00356 
00357         <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE || qop_state != gd-&gt;sec.qop)
00358     {
00359       log_status(<span class="stringliteral">"gss_verify_mic"</span>, maj_stat, min_stat);
00360 
00361       <span class="keywordflow">if</span> (maj_stat == GSS_S_CONTEXT_EXPIRED) 
00362         {
00363           gd-&gt;established = FALSE;
00364           Authgss_destroy_context(auth);
00365         }
00366       <span class="keywordflow">return</span> (FALSE);
00367     }
00368   
00369         <span class="keywordflow">return</span> (TRUE);
00370 }
00371 
00372 <span class="keyword">static</span> bool_t Authgss_refresh( AUTH *auth )
00373 {
00374         <span class="keyword">struct </span>Rpc_gss_data     *    gd;
00375         <span class="keyword">struct </span>Rpc_gss_init_res  gr;
00376         gss_buffer_desc         *      recv_tokenp ;
00377   gss_buffer_desc          send_token;
00378         OM_uint32                            maj_stat, min_stat, call_stat, ret_flags ;
00379   OM_uint32                req_flags=0;
00380   
00381         
00382         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00383         
00384         <span class="keywordflow">if</span> (gd-&gt;established)
00385   <span class="keywordflow">return</span> (TRUE);
00386         
00387         <span class="comment">/* GSS context establishment loop. */</span>
00388         memset(&amp;gr, 0, <span class="keyword">sizeof</span>(gr));
00389         recv_tokenp = GSS_C_NO_BUFFER;
00390         
00391 <span class="preprocessor">#ifdef _DEBUG_RPCSEC_GSS </span>
00392 <span class="preprocessor"></span>        print_Rpc_gss_sec(&amp;gd-&gt;sec);
00393 <span class="preprocessor">#endif </span><span class="comment">/*DEBUG*/</span>
00394 
00395   req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG ;
00396   <span class="keywordflow">if</span>( gd-&gt;sec.mech != GSS_C_NULL_OID )
00397     {
00398       <span class="keywordflow">if</span>(       <a class="code" href="Svc__auth__gss_8c.html#a0">g_OID_equal</a>(gd-&gt;sec.mech,  GSS_C_NT_HOSTBASED_SERVICE ))
00399         {
00400 <span class="preprocessor">#ifdef _DEBUG_RPCSEC_GSS</span>
00401 <span class="preprocessor"></span>          printf( <span class="stringliteral">"Authgss_refresh: Using GSS_C_NT_HOSTBASED_SERVICE\n"</span> ) ; 
00402 <span class="preprocessor">#endif</span>
00403 <span class="preprocessor"></span>          req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG ;
00404         }
00405       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(  <a class="code" href="Svc__auth__gss_8c.html#a0">g_OID_equal</a>(gd-&gt;sec.mech,&amp;krb5oid) )
00406         {
00407 <span class="preprocessor">#ifdef _DEBUG_RPCSEC_GSS</span>
00408 <span class="preprocessor"></span>          printf( <span class="stringliteral">"Authgss_refresh: Using krb5oid\n"</span> ) ; 
00409 <span class="preprocessor">#endif</span>
00410 <span class="preprocessor"></span>          req_flags |= GSS_C_MUTUAL_FLAG;
00411         }
00412 <span class="preprocessor">#ifdef _WITH_SPKM3</span>
00413 <span class="preprocessor"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(  <a class="code" href="Svc__auth__gss_8c.html#a0">g_OID_equal</a>(gd-&gt;sec.mech,&amp;spkm3oid) )
00414         {
00415 <span class="preprocessor">#ifdef _DEBUG_RPCSEC_GSS</span>
00416 <span class="preprocessor"></span>          printf( <span class="stringliteral">"Authgss_refresh: Using spkm3oid\n"</span> ) ; 
00417 <span class="preprocessor">#endif</span>
00418 <span class="preprocessor"></span>          req_flags |= GSS_C_ANON_FLAG;
00419         }
00420 <span class="preprocessor">#endif</span>
00421 <span class="preprocessor"></span>    }
00422   
00423         <span class="keywordflow">for</span> (;;) 
00424     {
00425 
00426       maj_stat = gss_init_sec_context(&amp;min_stat,
00427                                       GSS_C_NO_CREDENTIAL,
00428                                       &amp;gd-&gt;ctx,
00429                                       gd-&gt;name,
00430                                       gd-&gt;sec.mech, 
00431                                       req_flags,
00432                                       0,                <span class="comment">/* time req */</span>
00433                                       GSS_C_NO_CHANNEL_BINDINGS,                <span class="comment">/* channel */</span>
00434                                       recv_tokenp,
00435                                       NULL,             <span class="comment">/* used mech */</span>
00436                                       &amp;send_token,
00437                                       &amp;ret_flags,
00438                                       NULL);            <span class="comment">/* time rec */</span>
00439  
00440                               
00441         <span class="keywordflow">if</span> (recv_tokenp != GSS_C_NO_BUFFER)
00442           {
00443           <a class="code" href="Release__gss__buffer_8c.html#a22">Gss_release_buffer</a>(&amp;min_stat, &amp;gr.gr_token);
00444           recv_tokenp = GSS_C_NO_BUFFER;
00445           }
00446     
00447         <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE &amp;&amp;
00448             maj_stat != GSS_S_CONTINUE_NEEDED)
00449           {
00450           log_status(<span class="stringliteral">"gss_init_sec_context"</span>, maj_stat, min_stat);
00451           <span class="keywordflow">break</span>;
00452           }
00453     
00454         <span class="keywordflow">if</span> (<a class="code" href="server-gss_8c.html#a31">send_token</a>.length != 0)
00455         {
00456         memset(&amp;gr, 0, <span class="keyword">sizeof</span>(gr));
00457         
00458         call_stat = Clnt_call( gd-&gt;clnt, 
00459                                NULLPROC,
00460                                Xdr_Rpc_gss_init_args,(caddr_t)&amp;send_token,
00461                                Xdr_Rpc_gss_init_res, (caddr_t)&amp;gr,
00462                                AUTH_TIMEOUT);
00463         
00464         gss_release_buffer(&amp;min_stat, &amp;send_token);
00465         
00466                                 
00467         <span class="keywordflow">if</span> (call_stat != RPC_SUCCESS ||
00468             (gr.gr_major != GSS_S_COMPLETE &amp;&amp;
00469              gr.gr_major != GSS_S_CONTINUE_NEEDED))
00470           <span class="keywordflow">return</span> FALSE;
00471         
00472         <span class="keywordflow">if</span> (gr.gr_ctx.length != 0)
00473           {
00474             <span class="keywordflow">if</span> (gd-&gt;gc.gc_ctx.value)
00475               gss_release_buffer(&amp;min_stat,
00476                                  &amp;gd-&gt;gc.gc_ctx);
00477             gd-&gt;gc.gc_ctx = gr.gr_ctx;
00478           }
00479         
00480           <span class="keywordflow">if</span> (gr.gr_token.length != 0) 
00481             {
00482               <span class="keywordflow">if</span> (maj_stat != GSS_S_CONTINUE_NEEDED)
00483                 <span class="keywordflow">break</span>;
00484               recv_tokenp = &amp;gr.gr_token;
00485             }
00486           gd-&gt;gc.gc_proc = RPCSEC_GSS_CONTINUE_INIT;
00487           }
00488                 
00489         <span class="comment">/* GSS_S_COMPLETE =&gt; check gss header verifier, usually</span>
00490 <span class="comment">         * checked in gss_validate</span>
00491 <span class="comment">         */</span>
00492         <span class="keywordflow">if</span> (maj_stat == GSS_S_COMPLETE)
00493         {
00494         gss_buffer_desc   bufin;
00495         gss_buffer_desc   bufout;
00496         u_int seq, qop_state = 0;
00497         
00498         seq = htonl(gr.gr_win);
00499         bufin.value = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;seq;
00500         bufin.length = <span class="keyword">sizeof</span>(seq);
00501         bufout.value = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)gd-&gt;gc_wire_verf.value;
00502         bufout.length = gd-&gt;gc_wire_verf.length;
00503 
00504         maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a3">gss_verify_mic</a>(&amp;min_stat,gd-&gt;ctx,
00505                                 &amp;bufin, &amp;bufout, &amp;qop_state);
00506 
00507         <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE
00508                         || qop_state != gd-&gt;sec.qop)
00509             {
00510                 log_status(<span class="stringliteral">"gss_verify_mic"</span>, maj_stat, min_stat);
00511                 <span class="keywordflow">if</span> (maj_stat == GSS_S_CONTEXT_EXPIRED)
00512                    {
00513                         gd-&gt;established = FALSE;
00514                         Authgss_destroy_context(auth);
00515                    }
00516             }
00517 
00518                 gd-&gt;established = TRUE;
00519                 gd-&gt;gc.gc_proc = RPCSEC_GSS_DATA;
00520                 gd-&gt;gc.gc_seq = 0;
00521                 gd-&gt;win = gr.gr_win;
00522                 <span class="keywordflow">break</span>;
00523       }
00524     }
00525         <span class="comment">/* End context negotiation loop. */</span>
00526         <span class="keywordflow">if</span> (gd-&gt;gc.gc_proc != RPCSEC_GSS_DATA)
00527     {
00528       <span class="keywordflow">if</span> (gr.gr_token.length != 0)
00529         gss_release_buffer(&amp;min_stat, &amp;gr.gr_token);
00530       
00531       Authgss_destroy(auth);
00532       auth = NULL;
00533       rpc_createerr.cf_stat = RPC_AUTHERROR;
00534       
00535       <span class="keywordflow">return</span> (FALSE);
00536     }
00537         <span class="keywordflow">return</span> (TRUE);
00538 }
00539 
00540 bool_t Authgss_service( AUTH * auth, <span class="keywordtype">int</span> svc )
00541 {
00542         <span class="keyword">struct </span>Rpc_gss_data     *gd;
00543 
00544 
00545         <span class="keywordflow">if</span> (!auth)
00546                 <span class="keywordflow">return</span>(FALSE);
00547   
00548         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00549         
00550   <span class="keywordflow">if</span> (!gd || !gd-&gt;established)
00551                 <span class="keywordflow">return</span> (FALSE);
00552         
00553   gd-&gt;sec.svc = svc;
00554         gd-&gt;gc.gc_svc = svc;
00555         <span class="keywordflow">return</span> (TRUE);
00556 }
00557 
00558 <span class="keyword">static</span> <span class="keywordtype">void</span> Authgss_destroy_context( AUTH * auth )
00559 {
00560         <span class="keyword">struct </span>Rpc_gss_data     * gd;
00561         OM_uint32                         min_stat;
00562 
00563         
00564         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00565         
00566         <span class="keywordflow">if</span> (gd-&gt;gc.gc_ctx.length != 0)
00567     {
00568       <span class="keywordflow">if</span> (gd-&gt;established)
00569         {
00570           gd-&gt;gc.gc_proc = RPCSEC_GSS_DESTROY;
00571           Clnt_call(gd-&gt;clnt, NULLPROC, Xdr_void, NULL,
00572                     Xdr_void, NULL, AUTH_TIMEOUT);
00573         }
00574       
00575       gss_release_buffer(&amp;min_stat, &amp;gd-&gt;gc.gc_ctx);
00576       <span class="comment">/*XXX ANDROS check size of context  - should be 8 */</span>
00577       memset(&amp;gd-&gt;gc.gc_ctx, 0, <span class="keyword">sizeof</span>(gd-&gt;gc.gc_ctx));
00578     }
00579   
00580         <span class="keywordflow">if</span> (gd-&gt;ctx != GSS_C_NO_CONTEXT)
00581     {
00582       gss_delete_sec_context(&amp;min_stat, &amp;gd-&gt;ctx, NULL);
00583       gd-&gt;ctx = GSS_C_NO_CONTEXT;
00584     }
00585         gd-&gt;established = FALSE;
00586 }
00587 
00588 <span class="keyword">static</span> <span class="keywordtype">void</span> Authgss_destroy( AUTH *auth )
00589 {
00590         <span class="keyword">struct </span>Rpc_gss_data     * gd;
00591         OM_uint32                         min_stat;
00592         
00593         
00594         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00595         
00596         Authgss_destroy_context(auth);
00597         
00598         <span class="keywordflow">if</span> (gd-&gt;name != GSS_C_NO_NAME)
00599                 gss_release_name(&amp;min_stat, &amp;gd-&gt;name);
00600 
00601         Mem_Free(gd);
00602         Mem_Free(auth);
00603 }
00604 
00605 bool_t Authgss_wrap( AUTH * auth, XDR * xdrs, Xdrproc_t xdr_func, caddr_t xdr_ptr )
00606 {
00607         <span class="keyword">struct </span>Rpc_gss_data     * gd;
00608 
00609         
00610         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00611 
00612         <span class="keywordflow">if</span> (!gd-&gt;established || gd-&gt;sec.svc == RPCSEC_GSS_SVC_NONE) 
00613     {
00614       <span class="keywordflow">return</span> ((*xdr_func)(xdrs, xdr_ptr));
00615     }
00616   <span class="keywordflow">return</span> (Xdr_Rpc_gss_data(xdrs, xdr_func, xdr_ptr,
00617                            gd-&gt;ctx, gd-&gt;sec.qop,
00618                            gd-&gt;sec.svc, gd-&gt;gc.gc_seq));
00619 }
00620 
00621 bool_t Authgss_unwrap( AUTH *auth, XDR *xdrs, Xdrproc_t xdr_func, caddr_t xdr_ptr )
00622 {
00623         <span class="keyword">struct </span>Rpc_gss_data     *gd;
00624         
00625         gd = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00626         
00627         <span class="keywordflow">if</span> (!gd-&gt;established || gd-&gt;sec.svc == RPCSEC_GSS_SVC_NONE) {
00628                 <span class="keywordflow">return</span> ((*xdr_func)(xdrs, xdr_ptr));
00629         }
00630         <span class="keywordflow">return</span> (Xdr_Rpc_gss_data(xdrs, xdr_func, xdr_ptr,
00631                            gd-&gt;ctx, gd-&gt;sec.qop,
00632                            gd-&gt;sec.svc, gd-&gt;gc.gc_seq));
00633 }
00634 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
