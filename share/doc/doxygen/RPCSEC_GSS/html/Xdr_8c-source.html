<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Xdr.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Xdr.c</h1><a href="Xdr_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * Xdr.c, Generic XDR routines implementation.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * Copyright (C) 1986, Sun Microsystems, Inc.</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> * These are the "generic" Xdr routines used to serialize and de-serialize</span>
00036 <span class="comment"> * most common data items.  See Xdr.h for more info on the interface to</span>
00037 <span class="comment"> * xdr.</span>
00038 <span class="comment"> */</span>
00039 
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00042 <span class="preprocessor">#include &lt;string.h&gt;</span>
00043 
00044 <span class="preprocessor">#include "Types.h"</span>
00045 <span class="preprocessor">#include "Xdr.h"</span>
00046 
00047 <span class="comment">/*</span>
00048 <span class="comment"> * constants specific to the xdr "protocol"</span>
00049 <span class="comment"> */</span>
<a name="l00050"></a><a class="code" href="Xdr_8c.html#a0">00050</a> <span class="preprocessor">#define XDR_FALSE       ((long) 0)</span>
<a name="l00051"></a><a class="code" href="Xdr_8c.html#a1">00051</a> <span class="preprocessor"></span><span class="preprocessor">#define XDR_TRUE        ((long) 1)</span>
<a name="l00052"></a><a class="code" href="Xdr_8c.html#a2">00052</a> <span class="preprocessor"></span><span class="preprocessor">#define LASTUNSIGNED    ((u_int) 0-1)</span>
00053 <span class="preprocessor"></span>
00054 <span class="comment">/*</span>
00055 <span class="comment"> * for unit alignment</span>
00056 <span class="comment"> */</span>
00057 <span class="keyword">static</span> <span class="keywordtype">char</span> Xdr_zero[BYTES_PER_XDR_UNIT] = { 0, 0, 0, 0 };
00058 
00059 <span class="comment">/*</span>
00060 <span class="comment"> * Free a data structure using XDR</span>
00061 <span class="comment"> * Not a filter, but a convenient utility nonetheless</span>
00062 <span class="comment"> */</span>
00063 <span class="keywordtype">void</span>
<a name="l00064"></a><a class="code" href="Xdr_8c.html#a4">00064</a> <a class="code" href="Xdr_8c.html#a4">Xdr_free</a>(proc, objp)
00065         Xdrproc_t proc;
00066         <span class="keywordtype">char</span> *objp;
00067 {
00068         XDR x;
00069         
00070         x.x_op = XDR_FREE;
00071         (*proc)(&amp;x, objp);
00072 }
00073 
00074 <span class="comment">/*</span>
00075 <span class="comment"> * XDR nothing</span>
00076 <span class="comment"> */</span>
00077 bool_t
<a name="l00078"></a><a class="code" href="Xdr_8c.html#a5">00078</a> <a class="code" href="Xdr_8c.html#a5">Xdr_void</a>(<span class="comment">/* xdrs, addr */</span>)
00079         <span class="comment">/* XDR *xdrs; */</span>
00080         <span class="comment">/* caddr_t addr; */</span>
00081 {
00082 
00083         <span class="keywordflow">return</span> (TRUE);
00084 }
00085 
00086 
00087 <span class="comment">/*</span>
00088 <span class="comment"> * XDR integers</span>
00089 <span class="comment"> */</span>
00090 bool_t
<a name="l00091"></a><a class="code" href="Xdr_8c.html#a6">00091</a> <a class="code" href="Xdr_8c.html#a6">Xdr_int</a>(xdrs, ip)
00092         XDR *xdrs;
00093         <span class="keywordtype">int</span> *ip;
00094 {
00095         <span class="keywordtype">long</span> l;
00096 
00097         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00098 
00099         <span class="keywordflow">case</span> XDR_ENCODE:
00100                 l = (long) *ip;
00101                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;l));
00102 
00103         <span class="keywordflow">case</span> XDR_DECODE:
00104                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, &amp;l)) {
00105                         <span class="keywordflow">return</span> (FALSE);
00106                 }
00107                 *ip = (int) l;
00108                 <span class="keywordflow">return</span> (TRUE);
00109 
00110         <span class="keywordflow">case</span> XDR_FREE:
00111                 <span class="keywordflow">return</span> (TRUE);
00112         }
00113         <span class="keywordflow">return</span> (FALSE);
00114 }
00115 
00116 <span class="comment">/*</span>
00117 <span class="comment"> * XDR unsigned integers</span>
00118 <span class="comment"> */</span>
00119 bool_t
<a name="l00120"></a><a class="code" href="Xdr_8c.html#a7">00120</a> <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, up)
00121         XDR *xdrs;
00122         u_int *up;
00123 {
00124         u_long l;
00125 
00126         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00127 
00128         <span class="keywordflow">case</span> XDR_ENCODE:
00129                 l = (u_long) *up;
00130                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l));
00131 
00132         <span class="keywordflow">case</span> XDR_DECODE:
00133                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l)) {
00134                         <span class="keywordflow">return</span> (FALSE);
00135                 }
00136                 *up = (u_int) l;
00137                 <span class="keywordflow">return</span> (TRUE);
00138 
00139         <span class="keywordflow">case</span> XDR_FREE:
00140                 <span class="keywordflow">return</span> (TRUE);
00141         }
00142         <span class="keywordflow">return</span> (FALSE);
00143 }
00144 
00145 
00146 <span class="comment">/*</span>
00147 <span class="comment"> * XDR long integers</span>
00148 <span class="comment"> * same as Xdr_u_long - open coded to save a proc call!</span>
00149 <span class="comment"> */</span>
00150 bool_t
<a name="l00151"></a><a class="code" href="Xdr_8c.html#a8">00151</a> <a class="code" href="Xdr_8c.html#a8">Xdr_long</a>(xdrs, lp)
00152         register XDR *xdrs;
00153         <span class="keywordtype">long</span> *lp;
00154 {
00155         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00156         <span class="keywordflow">case</span> XDR_ENCODE:
00157                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, lp));
00158         <span class="keywordflow">case</span> XDR_DECODE:
00159                 <span class="keywordflow">return</span> (XDR_GETLONG(xdrs, lp));
00160         <span class="keywordflow">case</span> XDR_FREE:
00161                 <span class="keywordflow">return</span> (TRUE);
00162         }
00163 
00164         <span class="keywordflow">return</span> (FALSE);
00165 }
00166 
00167 <span class="comment">/*</span>
00168 <span class="comment"> * XDR unsigned long integers</span>
00169 <span class="comment"> * same as Xdr_long - open coded to save a proc call!</span>
00170 <span class="comment"> */</span>
00171 bool_t
<a name="l00172"></a><a class="code" href="Xdr_8c.html#a9">00172</a> <a class="code" href="Xdr_8c.html#a9">Xdr_u_long</a>(xdrs, ulp)
00173         register XDR *xdrs;
00174         u_long *ulp;
00175 {
00176         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00177         <span class="keywordflow">case</span> XDR_ENCODE:
00178                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)ulp));
00179         <span class="keywordflow">case</span> XDR_DECODE:
00180                 <span class="keywordflow">return</span> (XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)ulp));
00181         <span class="keywordflow">case</span> XDR_FREE:
00182                 <span class="keywordflow">return</span> (TRUE);
00183         }
00184         <span class="keywordflow">return</span> (FALSE);
00185 }
00186 
00187 
00188 <span class="comment">/*</span>
00189 <span class="comment"> * XDR 32-bit integers</span>
00190 <span class="comment"> * same as Xdr_u_int32_t - open coded to save a proc call!</span>
00191 <span class="comment"> */</span>
00192 bool_t
<a name="l00193"></a><a class="code" href="Xdr_8c.html#a10">00193</a> <a class="code" href="Xdr_8c.html#a10">Xdr_int_32_t</a>(xdrs, int32_p)
00194         register XDR *xdrs;
00195         int32_t *int32_p;
00196 {
00197         <span class="keywordtype">long</span> l;
00198 
00199         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00200 
00201         <span class="keywordflow">case</span> XDR_ENCODE:
00202                 l = (long) *int32_p;
00203                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;l));
00204 
00205         <span class="keywordflow">case</span> XDR_DECODE:
00206                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, &amp;l)) {
00207                         <span class="keywordflow">return</span> (FALSE);
00208                 }
00209                 *int32_p = (int32_t) l;
00210                 <span class="keywordflow">return</span> (TRUE);
00211 
00212         <span class="keywordflow">case</span> XDR_FREE:
00213                 <span class="keywordflow">return</span> (TRUE);
00214         }
00215         <span class="keywordflow">return</span> (FALSE);
00216 }
00217 
00218 <span class="comment">/*</span>
00219 <span class="comment"> * XDR unsigned 32-bit integers</span>
00220 <span class="comment"> * same as Xdr_int32_t - open coded to save a proc call!</span>
00221 <span class="comment"> */</span>
00222 bool_t
<a name="l00223"></a><a class="code" href="Xdr_8c.html#a11">00223</a> <a class="code" href="Xdr_8c.html#a11">Xdr_u_int_32_t</a>(xdrs, u_int32_p)
00224         register XDR *xdrs;
00225         u_int32_t *u_int32_p;
00226 {
00227         u_long l;
00228 
00229         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00230 
00231         <span class="keywordflow">case</span> XDR_ENCODE:
00232                 l = (u_long) *u_int32_p;
00233                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l));
00234 
00235         <span class="keywordflow">case</span> XDR_DECODE:
00236                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l)) {
00237                         <span class="keywordflow">return</span> (FALSE);
00238                 }
00239                 *u_int32_p = (u_int32_t) l;
00240                 <span class="keywordflow">return</span> (TRUE);
00241 
00242         <span class="keywordflow">case</span> XDR_FREE:
00243                 <span class="keywordflow">return</span> (TRUE);
00244         }
00245         <span class="keywordflow">return</span> (FALSE);
00246 }
00247 
00248 
00249 <span class="comment">/*</span>
00250 <span class="comment"> * XDR short integers</span>
00251 <span class="comment"> */</span>
00252 bool_t
<a name="l00253"></a><a class="code" href="Xdr_8c.html#a12">00253</a> <a class="code" href="Xdr_8c.html#a12">Xdr_short</a>(xdrs, sp)
00254         register XDR *xdrs;
00255         <span class="keywordtype">short</span> *sp;
00256 {
00257         <span class="keywordtype">long</span> l;
00258 
00259         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00260 
00261         <span class="keywordflow">case</span> XDR_ENCODE:
00262                 l = (long) *sp;
00263                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;l));
00264 
00265         <span class="keywordflow">case</span> XDR_DECODE:
00266                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, &amp;l)) {
00267                         <span class="keywordflow">return</span> (FALSE);
00268                 }
00269                 *sp = (short) l;
00270                 <span class="keywordflow">return</span> (TRUE);
00271 
00272         <span class="keywordflow">case</span> XDR_FREE:
00273                 <span class="keywordflow">return</span> (TRUE);
00274         }
00275         <span class="keywordflow">return</span> (FALSE);
00276 }
00277 
00278 <span class="comment">/*</span>
00279 <span class="comment"> * XDR unsigned short integers</span>
00280 <span class="comment"> */</span>
00281 bool_t
<a name="l00282"></a><a class="code" href="Xdr_8c.html#a13">00282</a> <a class="code" href="Xdr_8c.html#a13">Xdr_u_short</a>(xdrs, usp)
00283         register XDR *xdrs;
00284         u_short *usp;
00285 {
00286         u_long l;
00287 
00288         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00289 
00290         <span class="keywordflow">case</span> XDR_ENCODE:
00291                 l = (u_long) *usp;
00292                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l));
00293 
00294         <span class="keywordflow">case</span> XDR_DECODE:
00295                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l)) {
00296                         <span class="keywordflow">return</span> (FALSE);
00297                 }
00298                 *usp = (u_short) l;
00299                 <span class="keywordflow">return</span> (TRUE);
00300 
00301         <span class="keywordflow">case</span> XDR_FREE:
00302                 <span class="keywordflow">return</span> (TRUE);
00303         }
00304         <span class="keywordflow">return</span> (FALSE);
00305 }
00306 
00307 
00308 <span class="comment">/*</span>
00309 <span class="comment"> * XDR 16-bit integers</span>
00310 <span class="comment"> */</span>
00311 bool_t
<a name="l00312"></a><a class="code" href="Xdr_8c.html#a14">00312</a> <a class="code" href="Xdr_8c.html#a14">Xdr_int16_t</a>(xdrs, int16_p)
00313         register XDR *xdrs;
00314         int16_t *int16_p;
00315 {
00316         <span class="keywordtype">long</span> l;
00317 
00318         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00319 
00320         <span class="keywordflow">case</span> XDR_ENCODE:
00321                 l = (long) *int16_p;
00322                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;l));
00323 
00324         <span class="keywordflow">case</span> XDR_DECODE:
00325                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, &amp;l)) {
00326                         <span class="keywordflow">return</span> (FALSE);
00327                 }
00328                 *int16_p = (int16_t) l;
00329                 <span class="keywordflow">return</span> (TRUE);
00330 
00331         <span class="keywordflow">case</span> XDR_FREE:
00332                 <span class="keywordflow">return</span> (TRUE);
00333         }
00334         <span class="keywordflow">return</span> (FALSE);
00335 }
00336 
00337 <span class="comment">/*</span>
00338 <span class="comment"> * XDR unsigned 16-bit integers</span>
00339 <span class="comment"> */</span>
00340 bool_t
<a name="l00341"></a><a class="code" href="Xdr_8c.html#a15">00341</a> <a class="code" href="Xdr_8c.html#a15">Xdr_u_int16_t</a>(xdrs, u_int16_p)
00342         register XDR *xdrs;
00343         u_int16_t *u_int16_p;
00344 {
00345         u_long l;
00346 
00347         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00348 
00349         <span class="keywordflow">case</span> XDR_ENCODE:
00350                 l = (u_long) *u_int16_p;
00351                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l));
00352 
00353         <span class="keywordflow">case</span> XDR_DECODE:
00354                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;l)) {
00355                         <span class="keywordflow">return</span> (FALSE);
00356                 }
00357                 *u_int16_p = (u_int16_t) l;
00358                 <span class="keywordflow">return</span> (TRUE);
00359 
00360         <span class="keywordflow">case</span> XDR_FREE:
00361                 <span class="keywordflow">return</span> (TRUE);
00362         }
00363         <span class="keywordflow">return</span> (FALSE);
00364 }
00365 
00366 
00367 <span class="comment">/*</span>
00368 <span class="comment"> * XDR a char</span>
00369 <span class="comment"> */</span>
00370 bool_t
<a name="l00371"></a><a class="code" href="Xdr_8c.html#a16">00371</a> <a class="code" href="Xdr_8c.html#a16">Xdr_char</a>(xdrs, cp)
00372         XDR *xdrs;
00373         <span class="keywordtype">char</span> *cp;
00374 {
00375         <span class="keywordtype">int</span> i;
00376 
00377         i = (*cp);
00378         <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a6">Xdr_int</a>(xdrs, &amp;i)) {
00379                 <span class="keywordflow">return</span> (FALSE);
00380         }
00381         *cp = i;
00382         <span class="keywordflow">return</span> (TRUE);
00383 }
00384 
00385 <span class="comment">/*</span>
00386 <span class="comment"> * XDR an unsigned char</span>
00387 <span class="comment"> */</span>
00388 bool_t
<a name="l00389"></a><a class="code" href="Xdr_8c.html#a17">00389</a> <a class="code" href="Xdr_8c.html#a17">Xdr_u_char</a>(xdrs, cp)
00390         XDR *xdrs;
00391         u_char *cp;
00392 {
00393         u_int u;
00394 
00395         u = (*cp);
00396         <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;u)) {
00397                 <span class="keywordflow">return</span> (FALSE);
00398         }
00399         *cp = u;
00400         <span class="keywordflow">return</span> (TRUE);
00401 }
00402 
00403 <span class="comment">/*</span>
00404 <span class="comment"> * XDR booleans</span>
00405 <span class="comment"> */</span>
00406 bool_t
<a name="l00407"></a><a class="code" href="Xdr_8c.html#a18">00407</a> <a class="code" href="Xdr_8c.html#a18">Xdr_bool</a>(xdrs, bp)
00408         register XDR *xdrs;
00409         bool_t *bp;
00410 {
00411         <span class="keywordtype">long</span> lb;
00412 
00413         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00414 
00415         <span class="keywordflow">case</span> XDR_ENCODE:
00416                 lb = *bp ? <a class="code" href="Xdr_8c.html#a1">XDR_TRUE</a> : XDR_FALSE;
00417                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;lb));
00418 
00419         <span class="keywordflow">case</span> XDR_DECODE:
00420                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, &amp;lb)) {
00421                         <span class="keywordflow">return</span> (FALSE);
00422                 }
00423                 *bp = (lb == XDR_FALSE) ? FALSE : TRUE;
00424                 <span class="keywordflow">return</span> (TRUE);
00425 
00426         <span class="keywordflow">case</span> XDR_FREE:
00427                 <span class="keywordflow">return</span> (TRUE);
00428         }
00429         <span class="keywordflow">return</span> (FALSE);
00430 }
00431 
00432 <span class="comment">/*</span>
00433 <span class="comment"> * XDR enumerations</span>
00434 <span class="comment"> */</span>
00435 bool_t
<a name="l00436"></a><a class="code" href="Xdr_8c.html#a19">00436</a> <a class="code" href="Xdr_8c.html#a19">Xdr_enum</a>(xdrs, ep)
00437         XDR *xdrs;
00438         enum_t *ep;
00439 {
00440 <span class="preprocessor">#ifndef lint</span>
00441 <span class="preprocessor"></span>        <span class="keyword">enum</span> sizecheck { SIZEVAL };     <span class="comment">/* used to find the size of an enum */</span>
00442 
00443         <span class="comment">/*</span>
00444 <span class="comment">         * enums are treated as ints</span>
00445 <span class="comment">         */</span>
00446         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span> (<span class="keyword">enum</span> sizecheck) == <span class="keyword">sizeof</span> (long)) {
00447                 <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a8">Xdr_long</a>(xdrs, (<span class="keywordtype">long</span> *)ep));
00448         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">sizeof</span> (<span class="keyword">enum</span> sizecheck) == <span class="keyword">sizeof</span> (int)) {
00449                 <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a6">Xdr_int</a>(xdrs, (<span class="keywordtype">int</span> *)ep));
00450         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">sizeof</span> (<span class="keyword">enum</span> sizecheck) == <span class="keyword">sizeof</span> (short)) {
00451                 <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a12">Xdr_short</a>(xdrs, (<span class="keywordtype">short</span> *)ep));
00452         } <span class="keywordflow">else</span> {
00453                 <span class="keywordflow">return</span> (FALSE);
00454         }
00455 <span class="preprocessor">#else</span>
00456 <span class="preprocessor"></span>        (void) (<a class="code" href="Xdr_8c.html#a12">Xdr_short</a>(xdrs, (<span class="keywordtype">short</span> *)ep));
00457         (void) (<a class="code" href="Xdr_8c.html#a6">Xdr_int</a>(xdrs, (<span class="keywordtype">int</span> *)ep));
00458         <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a8">Xdr_long</a>(xdrs, (<span class="keywordtype">long</span> *)ep));
00459 <span class="preprocessor">#endif</span>
00460 <span class="preprocessor"></span>}
00461 
00462 <span class="comment">/*</span>
00463 <span class="comment"> * XDR opaque data</span>
00464 <span class="comment"> * Allows the specification of a fixed size sequence of opaque bytes.</span>
00465 <span class="comment"> * cp points to the opaque object and cnt gives the byte length.</span>
00466 <span class="comment"> */</span>
00467 bool_t
<a name="l00468"></a><a class="code" href="Xdr_8c.html#a20">00468</a> <a class="code" href="Xdr_8c.html#a20">Xdr_opaque</a>(xdrs, cp, cnt)
00469         register XDR *xdrs;
00470         caddr_t cp;
00471         register u_int cnt;
00472 {
00473         <span class="keyword">register</span> u_int rndup;
00474         <span class="keyword">static</span> <span class="keywordtype">int</span> crud[BYTES_PER_XDR_UNIT];
00475 
00476         <span class="comment">/*</span>
00477 <span class="comment">         * if no data we are done</span>
00478 <span class="comment">         */</span>
00479         <span class="keywordflow">if</span> (cnt == 0)
00480                 <span class="keywordflow">return</span> (TRUE);
00481 
00482         <span class="comment">/*</span>
00483 <span class="comment">         * round byte count to full xdr units</span>
00484 <span class="comment">         */</span>
00485         rndup = cnt % BYTES_PER_XDR_UNIT;
00486         <span class="keywordflow">if</span> (rndup &gt; 0)
00487                 rndup = BYTES_PER_XDR_UNIT - rndup;
00488 
00489         <span class="keywordflow">if</span> (xdrs-&gt;x_op == XDR_DECODE) 
00490     {
00491       <span class="keywordflow">if</span> (!XDR_GETBYTES(xdrs, cp, cnt)) 
00492         {
00493           <span class="keywordflow">return</span> (FALSE);
00494         }
00495       <span class="keywordflow">if</span> (rndup == 0)
00496         <span class="keywordflow">return</span> (TRUE);
00497 
00498       <span class="keywordflow">return</span> (XDR_GETBYTES(xdrs, (caddr_t)crud, rndup));
00499     }
00500   
00501         <span class="keywordflow">if</span> (xdrs-&gt;x_op == XDR_ENCODE) 
00502     {
00503       <span class="keywordflow">if</span> (!XDR_PUTBYTES(xdrs, cp, cnt))
00504         {
00505           <span class="keywordflow">return</span> (FALSE);
00506         }
00507       <span class="keywordflow">if</span> (rndup == 0)
00508         <span class="keywordflow">return</span> (TRUE);
00509       <span class="keywordflow">return</span> (XDR_PUTBYTES(xdrs, Xdr_zero, rndup));
00510     }
00511   
00512         <span class="keywordflow">if</span> (xdrs-&gt;x_op == XDR_FREE)
00513     {
00514       <span class="keywordflow">return</span> (TRUE);
00515     }
00516   
00517         <span class="keywordflow">return</span> (FALSE);
00518 }
00519 
00520 <span class="comment">/*</span>
00521 <span class="comment"> * XDR counted bytes</span>
00522 <span class="comment"> * *cpp is a pointer to the bytes, *sizep is the count.</span>
00523 <span class="comment"> * If *cpp is NULL maxsize bytes are allocated</span>
00524 <span class="comment"> */</span>
00525 bool_t
<a name="l00526"></a><a class="code" href="Xdr_8c.html#a21">00526</a> <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, cpp, sizep, maxsize)
00527         register XDR *xdrs;
00528         <span class="keywordtype">char</span> **cpp;
00529         register u_int *sizep;
00530         u_int maxsize;
00531 {
00532         <span class="keyword">register</span> <span class="keywordtype">char</span> *sp = *cpp;  <span class="comment">/* sp is the actual string pointer */</span>
00533         <span class="keyword">register</span> u_int nodesize;
00534   
00535         <span class="comment">/*</span>
00536 <span class="comment">         * first deal with the length since xdr bytes are counted</span>
00537 <span class="comment">         */</span>
00538         <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, sizep))
00539     {
00540       <span class="keywordflow">return</span> (FALSE);
00541     }
00542   
00543   nodesize = *sizep;
00544         <span class="keywordflow">if</span> ((nodesize &gt; maxsize) &amp;&amp; (xdrs-&gt;x_op != XDR_FREE))
00545     {
00546       <span class="keywordflow">return</span> (FALSE);
00547     }
00548   
00549         <span class="comment">/*</span>
00550 <span class="comment">         * now deal with the actual bytes</span>
00551 <span class="comment">         */</span>
00552         <span class="keywordflow">switch</span> (xdrs-&gt;x_op)
00553     {
00554       
00555     <span class="keywordflow">case</span> XDR_DECODE:
00556       
00557       <span class="keywordflow">if</span> (nodesize == 0)
00558         {
00559           <span class="keywordflow">return</span> (TRUE);
00560         }
00561       <span class="keywordflow">if</span> (sp == NULL)
00562         {
00563           *cpp = sp = (<span class="keywordtype">char</span> *)mem_alloc(nodesize);
00564         }
00565       <span class="keywordflow">if</span> (sp == NULL) 
00566         {
00567            FILE * tmplog ;
00568 
00569            <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00570            {
00571                 (void) fprintf(tmplog, <span class="stringliteral">"Xdr_bytes: out of memory\n"</span>);
00572                 fclose( tmplog ) ;
00573            }
00574           <span class="keywordflow">return</span> (FALSE);
00575         }
00576       <span class="comment">/* fall into ... */</span>
00577       
00578     <span class="keywordflow">case</span> XDR_ENCODE:
00579       <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a20">Xdr_opaque</a>(xdrs, sp, nodesize));
00580       
00581     <span class="keywordflow">case</span> XDR_FREE:
00582       <span class="keywordflow">if</span> (sp != NULL)
00583         {
00584           mem_free(sp, nodesize);
00585           *cpp = NULL;
00586         }
00587       <span class="keywordflow">return</span> (TRUE);
00588     }
00589         <span class="keywordflow">return</span> (FALSE);
00590 }
00591 
00592 <span class="comment">/*</span>
00593 <span class="comment"> * Implemented here due to commonality of the object.</span>
00594 <span class="comment"> */</span>
00595 bool_t
<a name="l00596"></a><a class="code" href="Xdr_8c.html#a22">00596</a> <a class="code" href="Xdr_8c.html#a22">Xdr_netobj</a>(xdrs, np)
00597         XDR *xdrs;
00598         struct netobj *np;
00599 {
00600 
00601         <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, &amp;np-&gt;n_bytes, &amp;np-&gt;n_len, MAX_NETOBJ_SZ));
00602 }
00603 
00604 <span class="comment">/*</span>
00605 <span class="comment"> * XDR a descriminated union</span>
00606 <span class="comment"> * Support routine for discriminated unions.</span>
00607 <span class="comment"> * You create an array of xdrdiscrim structures, terminated with</span>
00608 <span class="comment"> * an entry with a null procedure pointer.  The routine gets</span>
00609 <span class="comment"> * the discriminant value and then searches the array of xdrdiscrims</span>
00610 <span class="comment"> * looking for that value.  It calls the procedure given in the xdrdiscrim</span>
00611 <span class="comment"> * to handle the discriminant.  If there is no specific routine a default</span>
00612 <span class="comment"> * routine may be called.</span>
00613 <span class="comment"> * If there is no specific or default routine an error is returned.</span>
00614 <span class="comment"> */</span>
00615 bool_t
<a name="l00616"></a><a class="code" href="Xdr_8c.html#a23">00616</a> <a class="code" href="Xdr_8c.html#a23">Xdr_union</a>(xdrs, dscmp, unp, choices, dfault)
00617         register XDR *xdrs;
00618         enum_t *dscmp;          <span class="comment">/* enum to decide which arm to work on */</span>
00619         <span class="keywordtype">char</span> *unp;              <span class="comment">/* the union itself */</span>
00620         struct Xdr_discrim *choices;    <span class="comment">/* [value, xdr proc] for each arm */</span>
00621         Xdrproc_t dfault;       <span class="comment">/* default xdr routine */</span>
00622 {
00623         <span class="keyword">register</span> enum_t dscm;
00624 
00625         <span class="comment">/*</span>
00626 <span class="comment">         * we deal with the discriminator;  it's an enum</span>
00627 <span class="comment">         */</span>
00628         <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a19">Xdr_enum</a>(xdrs, dscmp)) {
00629                 <span class="keywordflow">return</span> (FALSE);
00630         }
00631         dscm = *dscmp;
00632 
00633         <span class="comment">/*</span>
00634 <span class="comment">         * search choices for a value that matches the discriminator.</span>
00635 <span class="comment">         * if we find one, execute the xdr routine for that value.</span>
00636 <span class="comment">         */</span>
00637         <span class="keywordflow">for</span> (; choices-&gt;proc != NULL_Xdrproc_t; choices++) {
00638                 <span class="keywordflow">if</span> (choices-&gt;value == dscm)
00639                         <span class="keywordflow">return</span> ((*(choices-&gt;proc))(xdrs, unp));
00640         }
00641 
00642         <span class="comment">/*</span>
00643 <span class="comment">         * no match - execute the default xdr routine if there is one</span>
00644 <span class="comment">         */</span>
00645         <span class="keywordflow">return</span> ((dfault == NULL_Xdrproc_t) ? FALSE :
00646             (*dfault)(xdrs, unp));
00647 }
00648 
00649 
00650 <span class="comment">/*</span>
00651 <span class="comment"> * Non-portable xdr primitives.</span>
00652 <span class="comment"> * Care should be taken when moving these routines to new architectures.</span>
00653 <span class="comment"> */</span>
00654 
00655 
00656 <span class="comment">/*</span>
00657 <span class="comment"> * XDR null terminated ASCII strings</span>
00658 <span class="comment"> * Xdr_string deals with "C strings" - arrays of bytes that are</span>
00659 <span class="comment"> * terminated by a NULL character.  The parameter cpp references a</span>
00660 <span class="comment"> * pointer to storage; If the pointer is null, then the necessary</span>
00661 <span class="comment"> * storage is allocated.  The last parameter is the max allowed length</span>
00662 <span class="comment"> * of the string as specified by a protocol.</span>
00663 <span class="comment"> */</span>
00664 bool_t
<a name="l00665"></a><a class="code" href="Xdr_8c.html#a24">00665</a> <a class="code" href="Xdr_8c.html#a24">Xdr_string</a>(xdrs, cpp, maxsize)
00666         register XDR *xdrs;
00667         <span class="keywordtype">char</span> **cpp;
00668         u_int maxsize;
00669 {
00670         <span class="keyword">register</span> <span class="keywordtype">char</span> *sp = *cpp;  <span class="comment">/* sp is the actual string pointer */</span>
00671         u_int size;
00672         u_int nodesize;
00673 
00674         <span class="comment">/*</span>
00675 <span class="comment">         * first deal with the length since xdr strings are counted-strings</span>
00676 <span class="comment">         */</span>
00677         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00678         <span class="keywordflow">case</span> XDR_FREE:
00679                 <span class="keywordflow">if</span> (sp == NULL) {
00680                         <span class="keywordflow">return</span>(TRUE);   <span class="comment">/* already free */</span>
00681                 }
00682                 <span class="comment">/* fall through... */</span>
00683         <span class="keywordflow">case</span> XDR_ENCODE:
00684                 size = strlen(sp);
00685                 <span class="keywordflow">break</span>;
00686 
00687         <span class="keywordflow">default</span>:
00688                 <span class="keywordflow">break</span>;
00689         }
00690         <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;size)) {
00691                 <span class="keywordflow">return</span> (FALSE);
00692         }
00693         <span class="keywordflow">if</span> (size &gt; maxsize) {
00694                 <span class="keywordflow">return</span> (FALSE);
00695         }
00696         nodesize = size + 1;
00697 
00698         <span class="comment">/*</span>
00699 <span class="comment">         * now deal with the actual bytes</span>
00700 <span class="comment">         */</span>
00701         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00702 
00703         <span class="keywordflow">case</span> XDR_DECODE:
00704                 <span class="keywordflow">if</span> (nodesize == 0) {
00705                         <span class="keywordflow">return</span> (TRUE);
00706                 }
00707                 <span class="keywordflow">if</span> (sp == NULL)
00708                         *cpp = sp = (<span class="keywordtype">char</span> *)mem_alloc(nodesize);
00709                 <span class="keywordflow">if</span> (sp == NULL) {
00710                         FILE * tmplog ;
00711                         <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00712                         {
00713                         (void) fprintf(tmplog, <span class="stringliteral">"Xdr_string: out of memory\n"</span>);
00714                         fclose( tmplog ) ;
00715                         }
00716                         <span class="keywordflow">return</span> (FALSE);
00717                 }
00718                 sp[size] = 0;
00719                 <span class="comment">/* fall into ... */</span>
00720 
00721         <span class="keywordflow">case</span> XDR_ENCODE:
00722                 <span class="keywordflow">return</span> (<a class="code" href="Xdr_8c.html#a20">Xdr_opaque</a>(xdrs, sp, size));
00723 
00724         <span class="keywordflow">case</span> XDR_FREE:
00725                 mem_free(sp, nodesize);
00726                 *cpp = NULL;
00727                 <span class="keywordflow">return</span> (TRUE);
00728         }
00729         <span class="keywordflow">return</span> (FALSE);
00730 }
00731 
00732 <span class="comment">/* </span>
00733 <span class="comment"> * Wrapper for Xdr_string that can be called directly from </span>
00734 <span class="comment"> * routines like clnt_call</span>
00735 <span class="comment"> */</span>
00736 bool_t
<a name="l00737"></a><a class="code" href="Xdr_8c.html#a25">00737</a> <a class="code" href="Xdr_8c.html#a25">Xdr_wrapstring</a>(xdrs, cpp)
00738         XDR *xdrs;
00739         <span class="keywordtype">char</span> **cpp;
00740 {
00741         <span class="keywordflow">return</span> <a class="code" href="Xdr_8c.html#a24">Xdr_string</a>(xdrs, cpp, <a class="code" href="Xdr_8c.html#a2">LASTUNSIGNED</a>);
00742 }
00743 
00744 bool_t
<a name="l00745"></a><a class="code" href="Xdr_8c.html#a26">00745</a> <a class="code" href="Xdr_8c.html#a26">Xdr_u_longlong_t</a>(<span class="keyword">register</span> XDR   *xdrs,
00746 
00747 u_longlong_t * objp)
00748 {
00749         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   tempo,
00750                         tempo1;
00751 
00752 <span class="preprocessor">#ifdef _USE_XDR_HYPER</span>
00753 <span class="preprocessor"></span>
00754         <span class="keywordflow">return</span> xdr_u_hyper(xdrs, objp);
00755 
00756 <span class="preprocessor">#else</span>
00757 <span class="preprocessor"></span>        <span class="keywordflow">switch</span> (xdrs-&gt;x_op)
00758         {
00759         <span class="keywordflow">case</span> XDR_ENCODE:
00760                 {
00761                         tempo = (ulong) (*objp &gt;&gt; 32);
00762                         <span class="keywordflow">if</span> (!xdr_u_long(xdrs, &amp;tempo))
00763                                 <span class="keywordflow">return</span> (FALSE);
00764 
00765                         tempo = (ulong) (*objp &amp; 0x00000000FFFFFFFF);
00766                         <span class="keywordflow">if</span> (!xdr_u_long(xdrs, &amp;tempo))
00767                                 <span class="keywordflow">return</span> (FALSE);
00768 
00769                         <span class="keywordflow">return</span> (TRUE);
00770                 }
00771         <span class="keywordflow">case</span> XDR_DECODE:
00772                 {
00773                         <span class="keywordflow">if</span> (!xdr_u_long(xdrs, &amp;tempo))
00774                                 <span class="keywordflow">return</span> (FALSE);
00775 
00776                         <span class="keywordflow">if</span> (!xdr_u_long(xdrs, &amp;tempo1))
00777                                 <span class="keywordflow">return</span> (FALSE);
00778 
00779                         *objp = (tempo1 | (tempo &lt;&lt; 32));
00780                         <span class="keywordflow">return</span> (TRUE);
00781                 }
00782         }
00783 <span class="preprocessor">#endif</span>
00784 <span class="preprocessor"></span>}
00785 
00786 bool_t
<a name="l00787"></a><a class="code" href="Xdr_8c.html#a27">00787</a> <a class="code" href="Xdr_8c.html#a27">Xdr_longlong_t</a>(               <span class="keyword">register</span> XDR *xdrs,
00788                                 longlong_t * objp)
00789 {
00790         <span class="keywordflow">return</span> <a class="code" href="Xdr_8c.html#a26">Xdr_u_longlong_t</a>(xdrs, (u_longlong_t *)objp);
00791 }
00792 
00793 
00794 
00795 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
