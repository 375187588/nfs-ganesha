<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Xdr_float.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Xdr_float.c</h1><a href="Xdr__float_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="preprocessor">#if defined(LIBC_SCCS) &amp;&amp; !defined(lint)</span>
00031 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="client-gss_8c.html#a12">rcsid</a> = <span class="stringliteral">"$OpenBSD: xdr_float.c,v 1.8 1998/08/28 20:29:51 mickey Exp $"</span>;
00032 <span class="preprocessor">#endif </span><span class="comment">/* LIBC_SCCS and not lint */</span>
00033 
00034 <span class="comment">/*</span>
00035 <span class="comment"> * xdr_float.c, Generic XDR routines impelmentation.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * These are the "floating point" xdr routines used to (de)serialize</span>
00040 <span class="comment"> * most common data items.  See xdr.h for more info on the interface to</span>
00041 <span class="comment"> * xdr.</span>
00042 <span class="comment"> */</span>
00043 
00044 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00045 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00046 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00047 <span class="preprocessor">#include "Types.h"</span>
00048 <span class="preprocessor">#include "Xdr.h"</span>
00049 
00050 <span class="comment">/*</span>
00051 <span class="comment"> * NB: Not portable.</span>
00052 <span class="comment"> * This routine works on machines with IEEE754 FP and Vaxen.</span>
00053 <span class="comment"> */</span>
00054 
00055 <span class="preprocessor">#if defined(__m68k__) || defined(__sparc__) || defined(__i386__) || \</span>
00056 <span class="preprocessor">    defined(__mips__) || defined(__ns32k__) || defined(__alpha__) || \</span>
00057 <span class="preprocessor">    defined(__arm32__) || defined(__powerpc__) || defined(__m88k__) || \</span>
00058 <span class="preprocessor">    defined(__hppa__)</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#ifdef __linux__</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* linux */</span>
00062 <span class="preprocessor">#define IEEEFP</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#ifdef vax</span>
00066 <span class="preprocessor"></span>
00067 <span class="comment">/* What IEEE single precision floating point looks like on a Vax */</span>
00068 <span class="keyword">struct  </span>ieee_single {
00069         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa: 23;
00070         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    exp     : 8;
00071         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    sign    : 1;
00072 };
00073 
00074 <span class="comment">/* Vax single precision floating point */</span>
00075 <span class="keyword">struct  </span>vax_single {
00076         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa1 : 7;
00077         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    exp       : 8;
00078         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    sign      : 1;
00079         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa2 : 16;
00080 };
00081 
00082 <span class="preprocessor">#define VAX_SNG_BIAS    0x81</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define IEEE_SNG_BIAS   0x7f</span>
00084 <span class="preprocessor"></span>
00085 <span class="keyword">static</span> <span class="keyword">struct </span>sgl_limits {
00086         <span class="keyword">struct </span>vax_single s;
00087         <span class="keyword">struct </span>ieee_single ieee;
00088 } sgl_limits[2] = {
00089         {{ 0x7f, 0xff, 0x0, 0xffff },   <span class="comment">/* Max Vax */</span>
00090         { 0x0, 0xff, 0x0 }},            <span class="comment">/* Max IEEE */</span>
00091         {{ 0x0, 0x0, 0x0, 0x0 },        <span class="comment">/* Min Vax */</span>
00092         { 0x0, 0x0, 0x0 }}              <span class="comment">/* Min IEEE */</span>
00093 };
00094 <span class="preprocessor">#endif </span><span class="comment">/* vax */</span>
00095 
00096 bool_t
<a name="l00097"></a><a class="code" href="Xdr__float_8c.html#a0">00097</a> <a class="code" href="Xdr__float_8c.html#a0">Xdr_float</a>(xdrs, fp)
00098         register XDR *xdrs;
00099         register <span class="keywordtype">float</span> *fp;
00100 {
00101 <span class="preprocessor">#ifdef IEEEFP</span>
00102 <span class="preprocessor"></span>        bool_t rv;
00103         <span class="keywordtype">long</span> tmpl;
00104 <span class="preprocessor">#else</span>
00105 <span class="preprocessor"></span>        <span class="keyword">struct </span>ieee_single is;
00106         <span class="keyword">struct </span>vax_single vs, *vsp;
00107         <span class="keyword">struct </span>sgl_limits *lim;
00108         <span class="keywordtype">int</span> i;
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>        <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00111 
00112         <span class="keywordflow">case</span> XDR_ENCODE:
00113 <span class="preprocessor">#ifdef IEEEFP </span>
00114 <span class="preprocessor"></span>                tmpl = *(int32_t *)fp;
00115                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, &amp;tmpl));
00116 <span class="preprocessor">#else</span>
00117 <span class="preprocessor"></span>                vs = *((<span class="keyword">struct </span>vax_single *)fp);
00118                 <span class="keywordflow">for</span> (i = 0, lim = sgl_limits;
00119                         i &lt; <span class="keyword">sizeof</span>(sgl_limits)/<span class="keyword">sizeof</span>(<span class="keyword">struct </span>sgl_limits);
00120                         i++, lim++) {
00121                         <span class="keywordflow">if</span> ((vs.mantissa2 == lim-&gt;s.mantissa2) &amp;&amp;
00122                                 (vs.exp == lim-&gt;s.exp) &amp;&amp;
00123                                 (vs.mantissa1 == lim-&gt;s.mantissa1)) {
00124                                 is = lim-&gt;ieee;
00125                                 <span class="keywordflow">goto</span> shipit;
00126                         }
00127                 }
00128                 is.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
00129                 is.mantissa = (vs.mantissa1 &lt;&lt; 16) | vs.mantissa2;
00130         shipit:
00131                 is.sign = vs.sign;
00132                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;is));
00133 <span class="preprocessor">#endif</span>
00134 <span class="preprocessor"></span>
00135         <span class="keywordflow">case</span> XDR_DECODE:
00136 <span class="preprocessor">#ifdef IEEEFP</span>
00137 <span class="preprocessor"></span>                rv = XDR_GETLONG(xdrs, &amp;tmpl);
00138                 *(int32_t *)fp = tmpl;
00139                 <span class="keywordflow">return</span> (rv);
00140 <span class="preprocessor">#else</span>
00141 <span class="preprocessor"></span>                vsp = (<span class="keyword">struct </span>vax_single *)fp;
00142                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;is))
00143                         <span class="keywordflow">return</span> (FALSE);
00144                 <span class="keywordflow">for</span> (i = 0, lim = sgl_limits;
00145                         i &lt; <span class="keyword">sizeof</span>(sgl_limits)/<span class="keyword">sizeof</span>(<span class="keyword">struct </span>sgl_limits);
00146                         i++, lim++) {
00147                         <span class="keywordflow">if</span> ((is.exp == lim-&gt;ieee.exp) &amp;&amp;
00148                                 (is.mantissa == lim-&gt;ieee.mantissa)) {
00149                                 *vsp = lim-&gt;s;
00150                                 <span class="keywordflow">goto</span> doneit;
00151                         }
00152                 }
00153                 vsp-&gt;exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
00154                 vsp-&gt;mantissa2 = is.mantissa;
00155                 vsp-&gt;mantissa1 = (is.mantissa &gt;&gt; 16);
00156         doneit:
00157                 vsp-&gt;sign = is.sign;
00158                 <span class="keywordflow">return</span> (TRUE);
00159 <span class="preprocessor">#endif</span>
00160 <span class="preprocessor"></span>
00161         <span class="keywordflow">case</span> XDR_FREE:
00162                 <span class="keywordflow">return</span> (TRUE);
00163         }
00164         <span class="keywordflow">return</span> (FALSE);
00165 }
00166 
00167 <span class="preprocessor">#ifdef vax</span>
00168 <span class="preprocessor"></span><span class="comment">/* What IEEE double precision floating point looks like on a Vax */</span>
00169 <span class="keyword">struct  </span>ieee_double {
00170         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa1 : 20;
00171         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    exp       : 11;
00172         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    sign      : 1;
00173         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa2 : 32;
00174 };
00175 
00176 <span class="comment">/* Vax double precision floating point */</span>
00177 <span class="keyword">struct  </span>vax_double {
00178         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa1 : 7;
00179         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    exp       : 8;
00180         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    sign      : 1;
00181         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa2 : 16;
00182         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa3 : 16;
00183         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mantissa4 : 16;
00184 };
00185 
00186 <span class="preprocessor">#define VAX_DBL_BIAS    0x81</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#define IEEE_DBL_BIAS   0x3ff</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define MASK(nbits)     ((1 &lt;&lt; nbits) - 1)</span>
00189 <span class="preprocessor"></span>
00190 <span class="keyword">static</span> <span class="keyword">struct </span>dbl_limits {
00191         <span class="keyword">struct  </span>vax_double d;
00192         <span class="keyword">struct  </span>ieee_double ieee;
00193 } dbl_limits[2] = {
00194         {{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },   <span class="comment">/* Max Vax */</span>
00195         { 0x0, 0x7ff, 0x0, 0x0 }},                      <span class="comment">/* Max IEEE */</span>
00196         {{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},               <span class="comment">/* Min Vax */</span>
00197         { 0x0, 0x0, 0x0, 0x0 }}                         <span class="comment">/* Min IEEE */</span>
00198 };
00199 
00200 <span class="preprocessor">#endif </span><span class="comment">/* vax */</span>
00201 
00202 
00203 bool_t
<a name="l00204"></a><a class="code" href="Xdr__float_8c.html#a1">00204</a> <a class="code" href="Xdr__float_8c.html#a1">Xdr_double</a>(xdrs, dp)
00205         register XDR *xdrs;
00206         <span class="keywordtype">double</span> *dp;
00207 {
00208 <span class="preprocessor">#ifdef IEEEFP</span>
00209 <span class="preprocessor"></span>        <span class="keyword">register</span> int32_t *i32p;
00210         bool_t rv;
00211         <span class="keywordtype">long</span> tmpl;
00212 <span class="preprocessor">#else</span>
00213 <span class="preprocessor"></span>        <span class="keyword">register</span> <span class="keywordtype">long</span> *lp;
00214         <span class="keyword">struct  </span>ieee_double id;
00215         <span class="keyword">struct  </span>vax_double vd;
00216         <span class="keyword">register</span> <span class="keyword">struct </span>dbl_limits *lim;
00217         <span class="keywordtype">int</span> i;
00218 <span class="preprocessor">#endif</span>
00219 <span class="preprocessor"></span>
00220         <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00221 
00222         <span class="keywordflow">case</span> XDR_ENCODE:
00223 <span class="preprocessor">#ifdef IEEEFP</span>
00224 <span class="preprocessor"></span>                i32p = (int32_t *)dp;
00225 <span class="preprocessor">#if BYTE_ORDER == BIG_ENDIAN</span>
00226 <span class="preprocessor"></span>                tmpl = *i32p++;
00227                 rv = XDR_PUTLONG(xdrs, &amp;tmpl);
00228                 <span class="keywordflow">if</span> (!rv)
00229                         <span class="keywordflow">return</span> (rv);
00230                 tmpl = *i32p;
00231                 rv = XDR_PUTLONG(xdrs, &amp;tmpl);
00232 <span class="preprocessor">#else</span>
00233 <span class="preprocessor"></span>                tmpl = *(i32p+1);
00234                 rv = XDR_PUTLONG(xdrs, &amp;tmpl);
00235                 <span class="keywordflow">if</span> (!rv)
00236                         <span class="keywordflow">return</span> (rv);
00237                 tmpl = *i32p;
00238                 rv = XDR_PUTLONG(xdrs, &amp;tmpl);
00239 <span class="preprocessor">#endif</span>
00240 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (rv);
00241 <span class="preprocessor">#else</span>
00242 <span class="preprocessor"></span>                vd = *((<span class="keyword">struct </span>vax_double *)dp);
00243                 <span class="keywordflow">for</span> (i = 0, lim = dbl_limits;
00244                         i &lt; <span class="keyword">sizeof</span>(dbl_limits)/<span class="keyword">sizeof</span>(<span class="keyword">struct </span>dbl_limits);
00245                         i++, lim++) {
00246                         <span class="keywordflow">if</span> ((vd.mantissa4 == lim-&gt;d.mantissa4) &amp;&amp;
00247                                 (vd.mantissa3 == lim-&gt;d.mantissa3) &amp;&amp;
00248                                 (vd.mantissa2 == lim-&gt;d.mantissa2) &amp;&amp;
00249                                 (vd.mantissa1 == lim-&gt;d.mantissa1) &amp;&amp;
00250                                 (vd.exp == lim-&gt;d.exp)) {
00251                                 <span class="keywordtype">id</span> = lim-&gt;ieee;
00252                                 <span class="keywordflow">goto</span> shipit;
00253                         }
00254                 }
00255                 <span class="keywordtype">id</span>.exp = vd.exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
00256                 <span class="keywordtype">id</span>.mantissa1 = (vd.mantissa1 &lt;&lt; 13) | (vd.mantissa2 &gt;&gt; 3);
00257                 <span class="keywordtype">id</span>.mantissa2 = ((vd.mantissa2 &amp; MASK(3)) &lt;&lt; 29) |
00258                                 (vd.mantissa3 &lt;&lt; 13) |
00259                                 ((vd.mantissa4 &gt;&gt; 3) &amp; MASK(13));
00260         shipit:
00261                 <span class="keywordtype">id</span>.sign = vd.sign;
00262                 lp = (<span class="keywordtype">long</span> *)&amp;id;
00263                 <span class="keywordflow">return</span> (XDR_PUTLONG(xdrs, lp++) &amp;&amp; XDR_PUTLONG(xdrs, lp));
00264 <span class="preprocessor">#endif</span>
00265 <span class="preprocessor"></span>
00266         <span class="keywordflow">case</span> XDR_DECODE:
00267 <span class="preprocessor">#ifdef IEEEFP</span>
00268 <span class="preprocessor"></span>                i32p = (int32_t *)dp;
00269 <span class="preprocessor">#if BYTE_ORDER == BIG_ENDIAN</span>
00270 <span class="preprocessor"></span>                rv = XDR_GETLONG(xdrs, &amp;tmpl);
00271                 *i32p++ = tmpl;
00272                 <span class="keywordflow">if</span> (!rv)
00273                         <span class="keywordflow">return</span> (rv);
00274                 rv = XDR_GETLONG(xdrs, &amp;tmpl);
00275                 *i32p = tmpl;
00276 <span class="preprocessor">#else</span>
00277 <span class="preprocessor"></span>                rv = XDR_GETLONG(xdrs, &amp;tmpl);
00278                 *(i32p+1) = tmpl;
00279                 <span class="keywordflow">if</span> (!rv)
00280                         <span class="keywordflow">return</span> (rv);
00281                 rv = XDR_GETLONG(xdrs, &amp;tmpl);
00282                 *i32p = tmpl;
00283 <span class="preprocessor">#endif</span>
00284 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (rv);
00285 <span class="preprocessor">#else</span>
00286 <span class="preprocessor"></span>                lp = (<span class="keywordtype">long</span> *)&amp;id;
00287                 <span class="keywordflow">if</span> (!XDR_GETLONG(xdrs, lp++) || !XDR_GETLONG(xdrs, lp))
00288                         <span class="keywordflow">return</span> (FALSE);
00289                 <span class="keywordflow">for</span> (i = 0, lim = dbl_limits;
00290                         i &lt; <span class="keyword">sizeof</span>(dbl_limits)/<span class="keyword">sizeof</span>(<span class="keyword">struct </span>dbl_limits);
00291                         i++, lim++) {
00292                         <span class="keywordflow">if</span> ((<span class="keywordtype">id</span>.mantissa2 == lim-&gt;ieee.mantissa2) &amp;&amp;
00293                                 (<span class="keywordtype">id</span>.mantissa1 == lim-&gt;ieee.mantissa1) &amp;&amp;
00294                                 (<span class="keywordtype">id</span>.exp == lim-&gt;ieee.exp)) {
00295                                 vd = lim-&gt;d;
00296                                 <span class="keywordflow">goto</span> doneit;
00297                         }
00298                 }
00299                 vd.exp = <span class="keywordtype">id</span>.exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
00300                 vd.mantissa1 = (<span class="keywordtype">id</span>.mantissa1 &gt;&gt; 13);
00301                 vd.mantissa2 = ((<span class="keywordtype">id</span>.mantissa1 &amp; MASK(13)) &lt;&lt; 3) |
00302                                 (<span class="keywordtype">id</span>.mantissa2 &gt;&gt; 29);
00303                 vd.mantissa3 = (<span class="keywordtype">id</span>.mantissa2 &gt;&gt; 13);
00304                 vd.mantissa4 = (<span class="keywordtype">id</span>.mantissa2 &lt;&lt; 3);
00305         doneit:
00306                 vd.sign = <span class="keywordtype">id</span>.sign;
00307                 *dp = *((<span class="keywordtype">double</span> *)&amp;vd);
00308                 <span class="keywordflow">return</span> (TRUE);
00309 <span class="preprocessor">#endif</span>
00310 <span class="preprocessor"></span>
00311         <span class="keywordflow">case</span> XDR_FREE:
00312                 <span class="keywordflow">return</span> (TRUE);
00313         }
00314         <span class="keywordflow">return</span> (FALSE);
00315 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
