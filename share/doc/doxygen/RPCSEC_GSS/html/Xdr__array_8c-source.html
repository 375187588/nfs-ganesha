<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Xdr_array.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Xdr_array.c</h1><a href="Xdr__array_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="preprocessor">#if defined(LIBC_SCCS) &amp;&amp; !defined(lint)</span>
00031 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="client-gss_8c.html#a12">rcsid</a> = <span class="stringliteral">"$OpenBSD: xdr_array.c,v 1.3 1996/08/19 08:32:02 tholo Exp $"</span>;
00032 <span class="preprocessor">#endif </span><span class="comment">/* LIBC_SCCS and not lint */</span>
00033 
00034 <span class="comment">/*</span>
00035 <span class="comment"> * xdr_array.c, Generic XDR routines impelmentation.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * These are the "non-trivial" xdr primitives used to serialize and de-serialize</span>
00040 <span class="comment"> * arrays.  See xdr.h for more info on the interface to xdr.</span>
00041 <span class="comment"> */</span>
00042 
00043 
00044 
00045 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00046 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00047 <span class="preprocessor">#include &lt;string.h&gt;</span>
00048 <span class="preprocessor">#include "Types.h"</span>
00049 <span class="preprocessor">#include "Xdr.h"</span>
00050 
00051 <span class="comment">/*</span>
00052 <span class="comment"> * XDR an array of arbitrary elements</span>
00053 <span class="comment"> * *addrp is a pointer to the array, *sizep is the number of elements.</span>
00054 <span class="comment"> * If addrp is NULL (*sizep * elsize) bytes are allocated.</span>
00055 <span class="comment"> * elsize is the size (in bytes) of each element, and elproc is the</span>
00056 <span class="comment"> * xdr procedure to call to handle each element of the array.</span>
00057 <span class="comment"> */</span>
00058 bool_t
<a name="l00059"></a><a class="code" href="Xdr__array_8c.html#a0">00059</a> <a class="code" href="Xdr__array_8c.html#a0">Xdr_array</a>(xdrs, addrp, sizep, maxsize, elsize, elproc)
00060         register XDR *xdrs;
00061         caddr_t *addrp;         <span class="comment">/* array pointer */</span>
00062         u_int *sizep;           <span class="comment">/* number of elements */</span>
00063         u_int maxsize;          <span class="comment">/* max numberof elements */</span>
00064         u_int elsize;           <span class="comment">/* size in bytes of each element */</span>
00065         Xdrproc_t elproc;       <span class="comment">/* xdr routine to handle each element */</span>
00066 {
00067         <span class="keyword">register</span> u_int i;
00068         <span class="keyword">register</span> caddr_t target = *addrp;
00069         <span class="keyword">register</span> u_int c;  <span class="comment">/* the actual element count */</span>
00070         <span class="keyword">register</span> bool_t stat = TRUE;
00071         <span class="keyword">register</span> u_int nodesize;
00072 
00073         <span class="comment">/* like strings, arrays are really counted arrays */</span>
00074         <span class="keywordflow">if</span> (! <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, sizep)) {
00075                 <span class="keywordflow">return</span> (FALSE);
00076         }
00077         c = *sizep;
00078         <span class="keywordflow">if</span> ((c &gt; maxsize) &amp;&amp; (xdrs-&gt;x_op != XDR_FREE)) {
00079                 <span class="keywordflow">return</span> (FALSE);
00080         }
00081         nodesize = c * elsize;
00082 
00083         <span class="comment">/*</span>
00084 <span class="comment">         * if we are deserializing, we may need to allocate an array.</span>
00085 <span class="comment">         * We also save time by checking for a null array if we are freeing.</span>
00086 <span class="comment">         */</span>
00087         <span class="keywordflow">if</span> (target == NULL)
00088                 <span class="keywordflow">switch</span> (xdrs-&gt;x_op) {
00089                 <span class="keywordflow">case</span> XDR_DECODE:
00090                         <span class="keywordflow">if</span> (c == 0)
00091                                 <span class="keywordflow">return</span> (TRUE);
00092                         *addrp = target = mem_alloc(nodesize);
00093                         <span class="keywordflow">if</span> (target == NULL) {
00094                                 FILE * tmplog ;
00095 
00096                                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00097                                 {
00098                                 (void) fprintf(tmplog, 
00099                                         <span class="stringliteral">"xdr_array: out of memory\n"</span>);
00100                                 fclose( tmplog ) ;
00101                                 }
00102                                 <span class="keywordflow">return</span> (FALSE);
00103                         }
00104                         memset(target, 0, nodesize);
00105                         <span class="keywordflow">break</span>;
00106 
00107                 <span class="keywordflow">case</span> XDR_FREE:
00108                         <span class="keywordflow">return</span> (TRUE);
00109 
00110                 <span class="keywordflow">default</span>:
00111                         <span class="keywordflow">break</span>;
00112         }
00113         
00114         <span class="comment">/*</span>
00115 <span class="comment">         * now we xdr each element of array</span>
00116 <span class="comment">         */</span>
00117         <span class="keywordflow">for</span> (i = 0; (i &lt; c) &amp;&amp; stat; i++) {
00118                 stat = (*elproc)(xdrs, target);
00119                 target += elsize;
00120         }
00121 
00122         <span class="comment">/*</span>
00123 <span class="comment">         * the array may need freeing</span>
00124 <span class="comment">         */</span>
00125         <span class="keywordflow">if</span> (xdrs-&gt;x_op == XDR_FREE) {
00126                 mem_free(*addrp, nodesize);
00127                 *addrp = NULL;
00128         }
00129         <span class="keywordflow">return</span> (stat);
00130 }
00131 
00132 <span class="comment">/*</span>
00133 <span class="comment"> * xdr_vector():</span>
00134 <span class="comment"> *</span>
00135 <span class="comment"> * XDR a fixed length array. Unlike variable-length arrays,</span>
00136 <span class="comment"> * the storage of fixed length arrays is static and unfreeable.</span>
00137 <span class="comment"> * &gt; basep: base of the array</span>
00138 <span class="comment"> * &gt; size: size of the array</span>
00139 <span class="comment"> * &gt; elemsize: size of each element</span>
00140 <span class="comment"> * &gt; xdr_elem: routine to XDR each element</span>
00141 <span class="comment"> */</span>
00142 bool_t
<a name="l00143"></a><a class="code" href="Xdr__array_8c.html#a1">00143</a> <a class="code" href="Xdr__array_8c.html#a1">Xdr_vector</a>(xdrs, basep, nelem, elemsize, xdr_elem)
00144         register XDR *xdrs;
00145         register <span class="keywordtype">char</span> *basep;
00146         register u_int nelem;
00147         register u_int elemsize;
00148         register Xdrproc_t xdr_elem;    
00149 {
00150         <span class="keyword">register</span> u_int i;
00151         <span class="keyword">register</span> <span class="keywordtype">char</span> *elptr;
00152 
00153         elptr = basep;
00154         <span class="keywordflow">for</span> (i = 0; i &lt; nelem; i++) {
00155                 <span class="keywordflow">if</span> (! (*xdr_elem)(xdrs, elptr)) {
00156                         <span class="keywordflow">return</span>(FALSE);
00157                 }
00158                 elptr += elemsize;
00159         }
00160         <span class="keywordflow">return</span>(TRUE);   
00161 }
00162 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
