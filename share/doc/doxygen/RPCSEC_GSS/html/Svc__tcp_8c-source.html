<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Svc_tcp.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Svc_tcp.c</h1><a href="Svc__tcp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="preprocessor">#include   &lt;sys/types.h&gt;</span> 
00003 <span class="preprocessor">#include   &lt;sys/poll.h&gt;</span>
00004 
00005 <span class="preprocessor">#include   &lt;stdio.h&gt;</span> 
00006 <span class="preprocessor">#include   &lt;stdlib.h&gt;</span>
00007 <span class="preprocessor">#include   &lt;string.h&gt;</span> 
00008 <span class="preprocessor">#include   &lt;unistd.h&gt;</span> 
00009 <span class="preprocessor">#include   "Rpc.h"</span>
00010 <span class="preprocessor">#include   "Clnt.h"</span>
00011 <span class="preprocessor">#include   "Svc.h"</span>
00012 <span class="preprocessor">#include   &lt;sys/socket.h&gt;</span> 
00013 <span class="preprocessor">#include   &lt;errno.h&gt;</span> 
00014 
<a name="l00015"></a><a class="code" href="Svc__tcp_8c.html#a0">00015</a> <span class="preprocessor">#define MAX_CONN 32 </span>
00016 <span class="preprocessor"></span>
00017 <span class="comment">/*</span>
00018 <span class="comment"> * Ops vector for TCP/IP based rpc service handle</span>
00019 <span class="comment"> */</span>
00020 <span class="keyword">static</span> bool_t                 Svctcp_recv();
00021 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat   Svctcp_stat();
00022 <span class="keyword">static</span> bool_t                 Svctcp_getargs();
00023 <span class="keyword">static</span> bool_t                 Svctcp_reply();
00024 <span class="keyword">static</span> bool_t                 Svctcp_freeargs();
00025 <span class="keyword">static</span> <span class="keywordtype">void</span>                     Svctcp_destroy();
00026 
00027 <span class="keyword">static</span> <span class="keyword">struct </span>xp_ops Svctcp_op = {
00028         Svctcp_recv,
00029         Svctcp_stat,
00030         Svctcp_getargs,
00031         Svctcp_reply,
00032         Svctcp_freeargs,
00033         Svctcp_destroy
00034 };
00035 
00036 <span class="comment">/*</span>
00037 <span class="comment"> * Ops vector for TCP/IP rendezvous handler</span>
00038 <span class="comment"> */</span>
00039 <span class="keyword">static</span> bool_t           Rendezvous_request();
00040 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat   Rendezvous_stat();
00041 
00042 <span class="keyword">static</span> <span class="keyword">struct </span>xp_ops Svctcp_rendezvous_op = {
00043         Rendezvous_request,
00044         Rendezvous_stat,
00045         (bool_t (*)())abort,
00046         (bool_t (*)())abort,
00047         (bool_t (*)())abort,
00048         Svctcp_destroy
00049 };
00050 
00051 <span class="keywordtype">int</span> <a class="code" href="Svc__tcp_8c.html#a11">Readtcp</a>(), <a class="code" href="Svc__tcp_8c.html#a12">Writetcp</a>();
00052 <span class="keyword">static</span> SVCXPRT *Makefd_xprt();
00053 
<a name="l00054"></a><a class="code" href="structtcp__rendezvous.html">00054</a> <span class="keyword">struct </span><a class="code" href="structtcp__rendezvous.html">tcp_rendezvous</a> { <span class="comment">/* kept in xprt-&gt;xp_p1 */</span>
<a name="l00055"></a><a class="code" href="structtcp__rendezvous.html#o0">00055</a>         u_int sendsize;
<a name="l00056"></a><a class="code" href="structtcp__rendezvous.html#o1">00056</a>         u_int recvsize;
00057 };
00058 
<a name="l00059"></a><a class="code" href="structtcp__conn.html">00059</a> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> {  <span class="comment">/* kept in xprt-&gt;xp_p1 */</span>
00060         <span class="keyword">enum</span> xprt_stat strm_stat;
<a name="l00061"></a><a class="code" href="structtcp__conn.html#o0">00061</a>         u_long x_id;
<a name="l00062"></a><a class="code" href="structtcp__conn.html#o1">00062</a>         XDR xdrs;
<a name="l00063"></a><a class="code" href="structtcp__conn.html#o2">00063</a>         <span class="keywordtype">char</span> verf_body[MAX_AUTH_BYTES];
00064 };
00065 
00066 <span class="comment">/*</span>
00067 <span class="comment"> * Usage:</span>
00068 <span class="comment"> *      xprt = svctcp_create(sock, send_buf_size, recv_buf_size);</span>
00069 <span class="comment"> *</span>
00070 <span class="comment"> * Creates, registers, and returns a (rpc) tcp based transporter.</span>
00071 <span class="comment"> * Once *xprt is initialized, it is registered as a transporter</span>
00072 <span class="comment"> * see (svc.h, xprt_register).  This routine returns</span>
00073 <span class="comment"> * a NULL if a problem occurred.</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> * If sock&lt;0 then a socket is created, else sock is used.</span>
00076 <span class="comment"> * If the socket, sock is not bound to a port then svctcp_create</span>
00077 <span class="comment"> * binds it to an arbitrary port.  The routine then starts a tcp</span>
00078 <span class="comment"> * listener on the socket's associated port.  In any (successful) case,</span>
00079 <span class="comment"> * xprt-&gt;xp_sock is the registered socket number and xprt-&gt;xp_port is the</span>
00080 <span class="comment"> * associated port number.</span>
00081 <span class="comment"> *</span>
00082 <span class="comment"> * Since tcp streams do buffered io similar to stdio, the caller can specify</span>
00083 <span class="comment"> * how big the send and receive buffers are via the second and third parms;</span>
00084 <span class="comment"> * 0 =&gt; use the system default.</span>
00085 <span class="comment"> */</span>
00086 <span class="comment">/*  */</span>
<a name="l00087"></a><a class="code" href="Svc__tcp_8c.html#a14">00087</a> SVCXPRT * <a class="code" href="Svc__tcp_8c.html#a14">Svctcp_create</a>(<span class="keyword">register</span> <span class="keywordtype">int</span>  sock, u_int sendsize, u_int recvsize)
00088 {
00089         bool_t madesock = FALSE;
00090         <span class="keyword">register</span> SVCXPRT *xprt;
00091         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__rendezvous.html">tcp_rendezvous</a> *r;
00092         <span class="keyword">struct </span>sockaddr_in addr;
00093         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00094 
00095         <span class="keywordflow">if</span> (sock == RPC_ANYSOCK) {
00096                 <span class="keywordflow">if</span> ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
00097                         perror(<span class="stringliteral">"svctcp_.c - udp socket creation problem"</span>);
00098                         <span class="keywordflow">return</span> ((SVCXPRT *)NULL);
00099                 }
00100                 madesock = TRUE;
00101         }
00102         memset(&amp;addr, 0, <span class="keyword">sizeof</span> (addr));
00103         addr.sin_family = AF_INET;
00104         <span class="keywordflow">if</span> (bindresvport(sock, &amp;addr)) {
00105                 addr.sin_port = 0;
00106                 (void)bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, len);
00107         }
00108         <span class="keywordflow">if</span> ((getsockname(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len) != 0)  ||
00109             (listen(sock, <a class="code" href="server-gss_8c.html#a2">MAX_CONN</a>) != 0)) {
00110                 perror(<span class="stringliteral">"svctcp_.c - cannot getsockname or listen"</span>);
00111                 <span class="keywordflow">if</span> (madesock)
00112                        (void)close(sock);
00113                 <span class="keywordflow">return</span> ((SVCXPRT *)NULL);
00114         }
00115         r = (<span class="keyword">struct </span><a class="code" href="structtcp__rendezvous.html">tcp_rendezvous</a> *)mem_alloc(<span class="keyword">sizeof</span>(*r));
00116         <span class="keywordflow">if</span> (r == NULL) {
00117                 FILE * tmplog ;
00118                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00119                 {
00120                 (void) fprintf(tmplog, <span class="stringliteral">"svctcp_create: out of memory\n"</span>);
00121                 fclose( tmplog ) ;
00122                 }
00123                 <span class="keywordflow">return</span> (NULL);
00124         }
00125         r-&gt;<a class="code" href="structtcp__rendezvous.html#o0">sendsize</a> = sendsize;
00126         r-&gt;<a class="code" href="structtcp__rendezvous.html#o1">recvsize</a> = recvsize;
00127         xprt = (SVCXPRT *)mem_alloc(<span class="keyword">sizeof</span>(SVCXPRT));
00128         <span class="keywordflow">if</span> (xprt == NULL) {
00129                 FILE * tmplog ;
00130                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00131                 {
00132                 (void) fprintf(tmplog, <span class="stringliteral">"svctcp_create: out of memory\n"</span>);
00133                 fclose( tmplog ) ;
00134                 }
00135                 <span class="keywordflow">return</span> (NULL);
00136         }
00137         xprt-&gt;xp_auth = NULL ;
00138         xprt-&gt;xp_p2 = NULL;
00139         xprt-&gt;xp_p1 = (caddr_t)r;
00140         xprt-&gt;xp_verf = _null_auth;
00141         xprt-&gt;xp_ops = &amp;Svctcp_rendezvous_op;
00142         xprt-&gt;xp_port = ntohs(addr.sin_port);
00143         xprt-&gt;xp_sock = sock;
00144         <a class="code" href="Svc_8c.html#a8">Xprt_register</a>(xprt);
00145         <span class="keywordflow">return</span> (xprt);
00146 }
00147 
00148 <span class="comment">/*</span>
00149 <span class="comment"> * Like svtcp_create(), except the routine takes any *open* UNIX file</span>
00150 <span class="comment"> * descriptor as its first input.</span>
00151 <span class="comment"> */</span>
00152 <span class="comment">/*  */</span>
<a name="l00153"></a><a class="code" href="Svc__tcp_8c.html#a15">00153</a> SVCXPRT *<a class="code" href="Svc__tcp_8c.html#a15">Svcfd_create</a>( <span class="keywordtype">int</span> fd, u_int sendsize, u_int recvsize)
00154 {
00155 
00156         <span class="keywordflow">return</span> (Makefd_xprt(fd, sendsize, recvsize));
00157 }
00158  
00159 <span class="keyword">static</span> SVCXPRT * Makefd_xprt( <span class="keywordtype">int</span> fd, u_int sendsize, u_int recvsize)
00160 {
00161         <span class="keyword">register</span> SVCXPRT *xprt;
00162         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *cd;
00163  
00164 
00165         xprt = (SVCXPRT *)mem_alloc(<span class="keyword">sizeof</span>(SVCXPRT));
00166         <span class="keywordflow">if</span> (xprt == (SVCXPRT *)NULL) {
00167                 <span class="keywordflow">goto</span> done;
00168         }
00169         cd = (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)mem_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__conn.html">tcp_conn</a>));
00170         <span class="keywordflow">if</span> (cd == (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)NULL) {
00171                 mem_free((<span class="keywordtype">char</span> *) xprt, <span class="keyword">sizeof</span>(SVCXPRT));
00172                 xprt = (SVCXPRT *)NULL;
00173                 <span class="keywordflow">goto</span> done;
00174         }
00175         cd-&gt;strm_stat = XPRT_IDLE;
00176         <a class="code" href="Xdr__rec_8c.html#a16">Xdrrec_create</a>(&amp;(cd-&gt;<a class="code" href="structtcp__conn.html#o1">xdrs</a>), sendsize, recvsize, (caddr_t)xprt, Readtcp, Writetcp);
00177         xprt-&gt;xp_p2 = NULL;
00178         xprt-&gt;xp_p1 = (caddr_t)cd;
00179         xprt-&gt;xp_verf.oa_base = cd-&gt;<a class="code" href="structtcp__conn.html#o2">verf_body</a>;
00180         xprt-&gt;xp_addrlen = 0;
00181         xprt-&gt;xp_ops = &amp;Svctcp_op;  <span class="comment">/* truely deals with calls */</span>
00182         xprt-&gt;xp_port = 0;  <span class="comment">/* this is a connection, not a rendezvouser */</span>
00183         xprt-&gt;xp_sock = fd;
00184         <a class="code" href="Svc_8c.html#a8">Xprt_register</a>(xprt);
00185     done:
00186         <span class="keywordflow">return</span> (xprt);
00187 }
00188 
00189 <span class="keyword">static</span> bool_t Rendezvous_request( <span class="keyword">register</span> SVCXPRT * xprt)
00190 {
00191         <span class="keywordtype">int</span> sock;
00192         <span class="keyword">struct </span><a class="code" href="structtcp__rendezvous.html">tcp_rendezvous</a> *r;
00193         <span class="keyword">struct </span>sockaddr_in addr;
00194         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> len;
00195 
00196         r = (<span class="keyword">struct </span><a class="code" href="structtcp__rendezvous.html">tcp_rendezvous</a> *)xprt-&gt;xp_p1;
00197     again:
00198         len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00199         <span class="keywordflow">if</span> ((sock = accept(xprt-&gt;xp_sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr,
00200             &amp;len)) &lt; 0) {
00201                 <span class="keywordflow">if</span> (errno == EINTR)
00202                         <span class="keywordflow">goto</span> again;
00203                <span class="keywordflow">return</span> (FALSE);
00204         }
00205         <span class="comment">/*</span>
00206 <span class="comment">         * make a new transporter (re-uses xprt)</span>
00207 <span class="comment">         */</span>
00208         xprt = Makefd_xprt(sock, r-&gt;<a class="code" href="structtcp__rendezvous.html#o0">sendsize</a>, r-&gt;<a class="code" href="structtcp__rendezvous.html#o1">recvsize</a>);
00209         memcpy( &amp;(xprt-&gt;xp_raddr), &amp;addr, <span class="keyword">sizeof</span>( addr ) ) ;
00210         xprt-&gt;xp_addrlen = len;
00211         <span class="keywordflow">return</span> (FALSE); <span class="comment">/* there is never an rpc msg to be processed */</span>
00212 }
00213 
00214 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat Rendezvous_stat()
00215 {
00216         <span class="keywordflow">return</span> (XPRT_IDLE);
00217 }
00218 
00219 <span class="keyword">static</span> <span class="keywordtype">void</span> Svctcp_destroy( <span class="keyword">register</span> SVCXPRT * xprt)
00220 {
00221         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *cd = (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)xprt-&gt;xp_p1;
00222 
00223         <a class="code" href="Svc_8c.html#a9">Xprt_unregister</a>(xprt);
00224         (void)close(xprt-&gt;xp_sock);
00225   
00226 
00227         <span class="keywordflow">if</span> (xprt-&gt;xp_port != 0) 
00228     {
00229       <span class="comment">/* a rendezvouser socket */</span>
00230       xprt-&gt;xp_port = 0;
00231     } 
00232   <span class="keywordflow">else</span>
00233     {
00234       <span class="comment">/* an actual connection socket */</span>
00235       XDR_DESTROY(&amp;(cd-&gt;<a class="code" href="structtcp__conn.html#o1">xdrs</a>));
00236     }
00237 
00238   <a class="code" href="Svc__tab__auth_8c.html#a4">Svcauth_gss_tab_creds_free</a>( xprt-&gt;xp_sock ) ;
00239         
00240   mem_free((caddr_t)cd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__conn.html">tcp_conn</a>));
00241         mem_free((caddr_t)xprt, <span class="keyword">sizeof</span>(SVCXPRT));
00242 }
00243 
00244 
00245 <span class="comment">/*</span>
00246 <span class="comment"> * reads data from the tcp conection.</span>
00247 <span class="comment"> * any error is fatal and the connection is closed.</span>
00248 <span class="comment"> * (And a read of zero bytes is a half closed stream =&gt; error.)</span>
00249 <span class="comment"> * All read operations timeout after 35 seconds.  A timeout is</span>
00250 <span class="comment"> * fatal for the connection.</span>
00251 <span class="comment"> */</span>
<a name="l00252"></a><a class="code" href="Svc__tcp_8c.html#a19">00252</a> <span class="keywordtype">int</span> <a class="code" href="Svc__tcp_8c.html#a11">Readtcp</a>( <span class="keyword">register</span> SVCXPRT * xprt, caddr_t buf, <span class="keyword">register</span> <span class="keywordtype">int</span> len)
00253 {
00254         <span class="keyword">register</span> <span class="keywordtype">int</span> sock = xprt-&gt;xp_sock;
00255         <span class="keywordtype">int</span> milliseconds = 35 * 1000;
00256         <span class="keyword">struct </span>pollfd pollfd;
00257 
00258 
00259         <span class="keywordflow">do</span> {
00260                 pollfd.fd = sock;
00261                 pollfd.events = POLLIN;
00262                 <span class="keywordflow">switch</span> (poll(&amp;pollfd, 1, milliseconds)) {
00263                 <span class="keywordflow">case</span> -1:
00264                         <span class="keywordflow">if</span> (errno == EINTR) {
00265                                 <span class="keywordflow">continue</span>;
00266                         }
00267                         <span class="keywordflow">goto</span> fatal_err;
00268 
00269                 <span class="keywordflow">case</span> 0:
00270                         <span class="keywordflow">continue</span>;
00271 
00272                 <span class="keywordflow">default</span>:
00273                         <span class="keywordflow">break</span>;
00274                 }
00275         } <span class="keywordflow">while</span> ((pollfd.revents &amp; POLLIN) == 0);
00276 
00277         <span class="keywordflow">if</span> ((len = read(sock, buf, len)) &gt; 0)
00278           {
00279             <span class="keywordflow">return</span> (len);
00280           }
00281 fatal_err:
00282         ((<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1))-&gt;strm_stat = XPRT_DIED;
00283         <span class="keywordflow">return</span> (-1);
00284 }
00285 
00286 <span class="comment">/*</span>
00287 <span class="comment"> * writes data to the tcp connection.</span>
00288 <span class="comment"> * Any error is fatal and the connection is closed.</span>
00289 <span class="comment"> */</span>
<a name="l00290"></a><a class="code" href="Svc__tcp_8c.html#a20">00290</a> <span class="keywordtype">int</span> <a class="code" href="Svc__tcp_8c.html#a12">Writetcp</a>( <span class="keyword">register</span> SVCXPRT *  xprt, caddr_t buf, <span class="keywordtype">int</span> len)
00291 {
00292         <span class="keyword">register</span> <span class="keywordtype">int</span> i, cnt;
00293 
00294 
00295         <span class="keywordflow">for</span> (cnt = len; cnt &gt; 0; cnt -= i, buf += i) {
00296                 <span class="keywordflow">if</span> ((i = write(xprt-&gt;xp_sock, buf, cnt)) &lt; 0) {
00297                         ((<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1))-&gt;strm_stat =
00298                             XPRT_DIED;
00299                         <span class="keywordflow">return</span> (-1);
00300                 }
00301         }
00302         <span class="keywordflow">return</span> (len);
00303 }
00304 
00305 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat Svctcp_stat( SVCXPRT *  xprt)
00306 {
00307         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *cd =
00308             (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1);
00309 
00310         
00311         <span class="keywordflow">if</span> (cd-&gt;strm_stat == XPRT_DIED)
00312                 <span class="keywordflow">return</span> (XPRT_DIED);
00313         <span class="keywordflow">if</span> (! <a class="code" href="Xdr__rec_8c.html#a26">Xdrrec_eof</a>(&amp;(cd-&gt;<a class="code" href="structtcp__conn.html#o1">xdrs</a>)))
00314                 <span class="keywordflow">return</span> (XPRT_MOREREQS);
00315         <span class="keywordflow">return</span> (XPRT_IDLE);
00316 }
00317 
00318 <span class="keyword">static</span> bool_t Svctcp_recv(SVCXPRT *  xprt, <span class="keyword">register</span> <span class="keyword">struct</span> Rpc_msg * msg)
00319 {
00320         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *cd =
00321             (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1);
00322         <span class="keyword">register</span> XDR *xdrs = &amp;(cd-&gt;<a class="code" href="structtcp__conn.html#o1">xdrs</a>);
00323 
00324 
00325         xdrs-&gt;x_op = XDR_DECODE;
00326         (void)<a class="code" href="Xdr__rec_8c.html#a25">Xdrrec_skiprecord</a>(xdrs);
00327         <span class="keywordflow">if</span> (<a class="code" href="Rpc__cmsg_8c.html#a0">Xdr_callmsg</a>(xdrs, msg)) {
00328                 cd-&gt;<a class="code" href="structtcp__conn.html#o0">x_id</a> = msg-&gt;rm_xid;
00329                 <span class="keywordflow">return</span> (TRUE);
00330         }
00331         <span class="keywordflow">return</span> (FALSE);
00332 }
00333 
00334 <span class="keyword">static</span> bool_t Svctcp_getargs( SVCXPRT * xprt, Xdrproc_t xdr_args, caddr_t args_ptr)
00335 {
00336   <span class="keywordflow">return</span> (SVCAUTH_UNWRAP(xprt-&gt;xp_auth,
00337                          &amp;(((<span class="keyword">struct</span> <a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1))-&gt;xdrs),
00338                          xdr_args, args_ptr));
00339 }
00340 
00341 <span class="keyword">static</span> bool_t Svctcp_freeargs(SVCXPRT * xprt, Xdrproc_t xdr_args, caddr_t args_ptr)
00342 {
00343         <span class="keyword">register</span> XDR *xdrs =
00344             &amp;(((<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1))-&gt;xdrs);
00345 
00346 
00347         xdrs-&gt;x_op = XDR_FREE;
00348         <span class="keywordflow">return</span> ((*xdr_args)(xdrs, args_ptr));
00349 }
00350 
00351 <span class="keyword">static</span> bool_t Svctcp_reply(SVCXPRT * xprt, <span class="keyword">register</span> <span class="keyword">struct</span> Rpc_msg *msg)
00352 {
00353         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *cd =
00354             (<span class="keyword">struct </span><a class="code" href="structtcp__conn.html">tcp_conn</a> *)(xprt-&gt;xp_p1);
00355         <span class="keyword">register</span> XDR *xdrs = &amp;(cd-&gt;<a class="code" href="structtcp__conn.html#o1">xdrs</a>);
00356   Xdrproc_t xdr_proc;
00357   caddr_t xdr_where;
00358  
00359 
00360         xdrs-&gt;x_op = XDR_ENCODE;
00361         msg-&gt;rm_xid = cd-&gt;<a class="code" href="structtcp__conn.html#o0">x_id</a>  ;
00362   <span class="keywordflow">if</span> (msg-&gt;rm_reply.rp_stat == MSG_ACCEPTED &amp;&amp;
00363       msg-&gt;rm_reply.rp_acpt.ar_stat == SUCCESS)
00364     {
00365       xdr_proc = msg-&gt;acpted_rply.ar_results.proc;
00366       xdr_where = msg-&gt;acpted_rply.ar_results.where;
00367       msg-&gt;acpted_rply.ar_results.proc = Xdr_void;
00368       msg-&gt;acpted_rply.ar_results.where = NULL;
00369       
00370       <span class="keywordflow">if</span> (!<a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, msg) ||
00371           !SVCAUTH_WRAP(xprt-&gt;xp_auth, xdrs, xdr_proc, xdr_where))
00372         <span class="keywordflow">return</span> (FALSE);
00373     }
00374   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, msg))
00375     {
00376       <span class="keywordflow">return</span> (FALSE);
00377     }
00378   
00379   (void)<a class="code" href="Xdr__rec_8c.html#a27">Xdrrec_endofrecord</a>(xdrs, TRUE);
00380 
00381   <span class="keywordflow">return</span> (TRUE);
00382 }
00383 
00384 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
