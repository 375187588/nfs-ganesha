<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Svc_udp.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Svc_udp.c</h1><a href="Svc__udp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="preprocessor">#include   &lt;stdio.h&gt;</span> 
00003 <span class="preprocessor">#include   &lt;stdlib.h&gt;</span> 
00004 <span class="preprocessor">#include   &lt;string.h&gt;</span> 
00005 <span class="preprocessor">#include   "Rpc.h"</span>
00006 <span class="preprocessor">#include   "Clnt.h"</span>
00007 <span class="preprocessor">#include   "Svc.h"</span>
00008 <span class="preprocessor">#include   &lt;sys/socket.h&gt;</span> 
00009 <span class="preprocessor">#include   &lt;errno.h&gt;</span> 
00010 
00011 
00012 <span class="preprocessor">#ifndef UDPMSGSIZE</span>
<a name="l00013"></a><a class="code" href="Svc__udp_8c.html#a0">00013</a> <span class="preprocessor"></span><span class="preprocessor">#define UDPMSGSIZE 8800</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
<a name="l00016"></a><a class="code" href="Svc__udp_8c.html#a1">00016</a> <span class="preprocessor">#define rpc_buffer(xprt) ((xprt)-&gt;xp_p1)</span>
00017 <span class="preprocessor"></span>
00018 <span class="keyword">static</span> bool_t           Svcudp_recv();
00019 <span class="keyword">static</span> bool_t           Svcudp_reply();
00020 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat   Svcudp_stat();
00021 <span class="keyword">static</span> bool_t           Svcudp_getargs();
00022 <span class="keyword">static</span> bool_t           Svcudp_freeargs();
00023 <span class="keyword">static</span> <span class="keywordtype">void</span>             Svcudp_destroy();
00024 
00025 
00026 <span class="keyword">static</span> <span class="keyword">struct </span>xp_ops Svcudp_op = {
00027         Svcudp_recv,
00028         Svcudp_stat,
00029         Svcudp_getargs,
00030         Svcudp_reply,
00031         Svcudp_freeargs,
00032         Svcudp_destroy
00033 };
00034 
00035 <span class="comment">/*</span>
00036 <span class="comment"> * kept in xprt-&gt;xp_p2</span>
00037 <span class="comment"> */</span>
<a name="l00038"></a><a class="code" href="structSvcudp__data.html">00038</a> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> {
<a name="l00039"></a><a class="code" href="structSvcudp__data.html#o0">00039</a>         u_int   su_iosz;        <span class="comment">/* byte size of send.recv buffer */</span>
<a name="l00040"></a><a class="code" href="structSvcudp__data.html#o1">00040</a>         u_long  su_xid;         <span class="comment">/* transaction id */</span>
<a name="l00041"></a><a class="code" href="structSvcudp__data.html#o2">00041</a>         XDR     su_xdrs;        <span class="comment">/* XDR handle */</span>
<a name="l00042"></a><a class="code" href="structSvcudp__data.html#o3">00042</a>         <span class="keywordtype">char</span>    su_verfbody[MAX_AUTH_BYTES];    <span class="comment">/* verifier body */</span>
00043 };
<a name="l00044"></a><a class="code" href="Svc__udp_8c.html#a2">00044</a> <span class="preprocessor">#define Su_data(xprt)   ((struct Svcudp_data *)(xprt-&gt;xp_p2))</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">/*</span>
00047 <span class="comment"> * Usage:</span>
00048 <span class="comment"> *      xprt = svcudp_create(sock);</span>
00049 <span class="comment"> *</span>
00050 <span class="comment"> * If sock&lt;0 then a socket is created, else sock is used.</span>
00051 <span class="comment"> * If the socket, sock is not bound to a port then svcudp_create</span>
00052 <span class="comment"> * binds it to an arbitrary port.  In any (successful) case,</span>
00053 <span class="comment"> * xprt-&gt;xp_sock is the registered socket number and xprt-&gt;xp_port is the</span>
00054 <span class="comment"> * associated port number.</span>
00055 <span class="comment"> * Once *xprt is initialized, it is registered as a transporter;</span>
00056 <span class="comment"> * see (svc.h, xprt_register).</span>
00057 <span class="comment"> * The routines returns NULL if a problem occurred.</span>
00058 <span class="comment"> */</span>
00059 
<a name="l00060"></a><a class="code" href="Svc__udp_8c.html#a10">00060</a> SVCXPRT * <a class="code" href="Svc__udp_8c.html#a10">Svcudp_bufcreate</a>(<span class="keyword">register</span> <span class="keywordtype">int</span> sock, u_int sendsz, u_int recvsz)
00061 {
00062         bool_t madesock = FALSE;
00063         <span class="keyword">register</span> SVCXPRT *xprt;
00064         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *su;
00065         <span class="keyword">struct </span>sockaddr_in addr;
00066         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00067 
00068         <span class="keywordflow">if</span> (sock == RPC_ANYSOCK)
00069     {
00070       <span class="keywordflow">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)
00071         {
00072           perror(<span class="stringliteral">"svcudp_create: socket creation problem"</span>);
00073           <span class="keywordflow">return</span> ((SVCXPRT *)NULL);
00074         }
00075       madesock = TRUE;
00076     }
00077   
00078         memset(&amp;addr, 0, <span class="keyword">sizeof</span> (addr));
00079         addr.sin_family = AF_INET;
00080         <span class="keywordflow">if</span> ( bindresvport(sock, &amp;addr) )
00081     {
00082       addr.sin_port = 0;
00083       (void)bind(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, len);
00084     }
00085 
00086         <span class="keywordflow">if</span> (getsockname(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len) != 0)
00087     {
00088       perror(<span class="stringliteral">"svcudp_create - cannot getsockname"</span>);
00089       <span class="keywordflow">if</span> (madesock)
00090         (void)close(sock);
00091       <span class="keywordflow">return</span> ((SVCXPRT *)NULL);
00092     }
00093 
00094         xprt = (SVCXPRT *)mem_alloc(<span class="keyword">sizeof</span>(SVCXPRT));
00095         <span class="keywordflow">if</span> (xprt == NULL) 
00096     {
00097       FILE * tmplog ;
00098       <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00099         {
00100       (void)fprintf(tmplog, <span class="stringliteral">"svcudp_create: out of memory\n"</span>);
00101         fclose( tmplog ) ;
00102         }
00103       <span class="keywordflow">return</span> (NULL);
00104     }
00105 
00106         su = (<span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *)mem_alloc(<span class="keyword">sizeof</span>(*su));
00107   
00108         <span class="keywordflow">if</span> (su == NULL) 
00109     {
00110       FILE * tmplog ;
00111       <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00112         {
00113       (void)fprintf(tmplog, <span class="stringliteral">"svcudp_create: out of memory\n"</span>);
00114         fclose( tmplog ) ;
00115         }
00116       <span class="keywordflow">return</span> (NULL);
00117     }
00118         su-&gt;<a class="code" href="structSvcudp__data.html#o0">su_iosz</a> = ((MAX(sendsz, recvsz) + 3) / 4) * 4;
00119         <span class="keywordflow">if</span> ((<a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt) = mem_alloc(su-&gt;su_iosz)) == NULL)
00120     {
00121       FILE * tmplog ;
00122       <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00123         {
00124       (void)fprintf(tmplog, <span class="stringliteral">"svcudp_create: out of memory\n"</span>);
00125         fclose( tmplog ) ;
00126         }
00127       <span class="keywordflow">return</span> (NULL);
00128     }
00129   
00130         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(  &amp;(su-&gt;su_xdrs), <a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt), su-&gt;su_iosz, XDR_DECODE);
00131         xprt-&gt;xp_p2 = (caddr_t)su;
00132         xprt-&gt;xp_auth = NULL ;
00133         xprt-&gt;xp_verf.oa_base = su-&gt;<a class="code" href="structSvcudp__data.html#o3">su_verfbody</a>;
00134         xprt-&gt;xp_ops = &amp;Svcudp_op;
00135         xprt-&gt;xp_port = ntohs(addr.sin_port);
00136         xprt-&gt;xp_sock = sock;
00137 
00138 
00139   
00140         <a class="code" href="Svc_8c.html#a8">Xprt_register</a>(xprt);
00141 
00142         <span class="keywordflow">return</span> (xprt);
00143 }
00144 
00145 <span class="comment">/*  */</span>
<a name="l00146"></a><a class="code" href="Svc__udp_8c.html#a11">00146</a> SVCXPRT * <a class="code" href="Svc__udp_8c.html#a11">Svcudp_create</a>( <span class="keywordtype">int</span> sock)
00147 {
00148 
00149         <span class="keywordflow">return</span>(<a class="code" href="Svc__udp_8c.html#a10">Svcudp_bufcreate</a>(sock, <a class="code" href="Svc__udp_8c.html#a0">UDPMSGSIZE</a>, <a class="code" href="Svc__udp_8c.html#a0">UDPMSGSIZE</a>));
00150 }
00151 
00152 <span class="keyword">static</span> <span class="keyword">enum</span> xprt_stat Svcudp_stat( SVCXPRT * xprt)
00153 {
00154 
00155         <span class="keywordflow">return</span> (XPRT_IDLE); 
00156 }
00157 
00158 <span class="keyword">static</span> bool_t Svcudp_recv(<span class="keyword">register</span> SVCXPRT * xprt, <span class="keyword">struct</span> Rpc_msg * msg)
00159 {
00160         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *su = <a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt);
00161         <span class="keyword">register</span> XDR *xdrs = &amp;(su-&gt;<a class="code" href="structSvcudp__data.html#o2">su_xdrs</a>);
00162         <span class="keyword">register</span> <span class="keywordtype">int</span> rlen;
00163         <span class="keywordtype">char</span> *reply;
00164         u_long replylen;
00165 
00166   again:
00167         xprt-&gt;xp_addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00168   
00169         rlen = recvfrom(xprt-&gt;xp_sock, <a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt), (<span class="keywordtype">int</span>) su-&gt;<a class="code" href="structSvcudp__data.html#o0">su_iosz</a>,
00170                   0, (<span class="keyword">struct</span> sockaddr *)&amp;(xprt-&gt;xp_raddr), &amp;(xprt-&gt;xp_addrlen));
00171   
00172         <span class="keywordflow">if</span> (rlen == -1 &amp;&amp; errno == EINTR)
00173                 <span class="keywordflow">goto</span> again;
00174   
00175         <span class="keywordflow">if</span> (rlen == -1 || rlen &lt; 4*<span class="keyword">sizeof</span>(u_int32_t))
00176                 <span class="keywordflow">return</span> (FALSE);
00177   
00178         xdrs-&gt;x_op = XDR_DECODE;
00179 
00180         XDR_SETPOS(xdrs, 0);
00181 
00182         <span class="keywordflow">if</span> (!xdr_callmsg(xdrs, msg))
00183                 <span class="keywordflow">return</span> (FALSE);
00184 
00185         su-&gt;<a class="code" href="structSvcudp__data.html#o1">su_xid</a> = msg-&gt;rm_xid;
00186   
00187         <span class="keywordflow">return</span> (TRUE);
00188 }
00189 
00190 <span class="keyword">static</span> bool_t Svcudp_reply( <span class="keyword">register</span> SVCXPRT * xprt, <span class="keyword">struct</span> Rpc_msg* msg)
00191 {
00192         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *su = <a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt);
00193         <span class="keyword">register</span> XDR *xdrs = &amp;(su-&gt;<a class="code" href="structSvcudp__data.html#o2">su_xdrs</a>);
00194         <span class="keyword">register</span> <span class="keywordtype">int</span> slen;
00195         Xdrproc_t xdr_proc;
00196         caddr_t xdr_where;
00197 
00198         xdrs-&gt;x_op = XDR_ENCODE;
00199         XDR_SETPOS(xdrs, 0);
00200         msg-&gt;rm_xid = su-&gt;<a class="code" href="structSvcudp__data.html#o1">su_xid</a>  ;
00201 
00202         <span class="keywordflow">if</span> (msg-&gt;rm_reply.rp_stat == MSG_ACCEPTED &amp;&amp;
00203             msg-&gt;rm_reply.rp_acpt.ar_stat == SUCCESS)
00204           {
00205             xdr_proc = msg-&gt;acpted_rply.ar_results.proc;
00206             xdr_where = msg-&gt;acpted_rply.ar_results.where;
00207             msg-&gt;acpted_rply.ar_results.proc = Xdr_void;
00208             msg-&gt;acpted_rply.ar_results.where = NULL;
00209 
00210             <span class="keywordflow">if</span> (!xdr_replymsg(xdrs, msg) ||
00211                 !SVCAUTH_WRAP(xprt-&gt;xp_auth, xdrs, xdr_proc, xdr_where))
00212               <span class="keywordflow">return</span> (FALSE);
00213           }
00214         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!xdr_replymsg(xdrs, msg))
00215           {
00216             <span class="keywordflow">return</span> (FALSE);
00217           }
00218         slen = (int)XDR_GETPOS(xdrs);
00219 
00220         <span class="keywordflow">if</span> (sendto( xprt-&gt;xp_sock, 
00221                     <a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt),
00222                     slen, 
00223                     0,
00224                    (<span class="keyword">struct</span> sockaddr *)&amp;(xprt-&gt;xp_raddr), 
00225                     xprt-&gt;xp_addrlen) != slen)
00226           {
00227             <span class="keywordflow">return</span> (FALSE);
00228           }
00229         <span class="keywordflow">return</span> (TRUE);
00230 }
00231 
00232 <span class="keyword">static</span> bool_t Svcudp_reply_old( <span class="keyword">register</span> SVCXPRT * xprt, <span class="keyword">struct</span> Rpc_msg* msg)
00233 {
00234         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *su = <a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt);
00235         <span class="keyword">register</span> XDR *xdrs = &amp;(su-&gt;<a class="code" href="structSvcudp__data.html#o2">su_xdrs</a>);
00236         <span class="keyword">register</span> <span class="keywordtype">int</span> slen;
00237         <span class="keyword">register</span> bool_t stat = FALSE;
00238 
00239         xdrs-&gt;x_op = XDR_ENCODE;
00240         XDR_SETPOS(xdrs, 0);
00241         msg-&gt;rm_xid = su-&gt;<a class="code" href="structSvcudp__data.html#o1">su_xid</a>;
00242   
00243         <span class="keywordflow">if</span> (<a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, msg))
00244     {
00245       slen = (int)XDR_GETPOS(xdrs);
00246       <span class="keywordflow">if</span> (sendto(xprt-&gt;xp_sock, <a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt), slen, 0,
00247                  (<span class="keyword">struct</span> sockaddr *)&amp;(xprt-&gt;xp_raddr), xprt-&gt;xp_addrlen)
00248           == slen) {
00249         stat = TRUE;
00250       }
00251     }
00252         <span class="keywordflow">return</span> (stat);
00253 }
00254 
00255 <span class="keyword">static</span> bool_t Svcudp_getargs( SVCXPRT * xprt, Xdrproc_t xdr_args, caddr_t args_ptr)
00256 {
00257   <span class="keywordflow">return</span> (SVCAUTH_UNWRAP(xprt-&gt;xp_auth, &amp;(<a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt)-&gt;su_xdrs),
00258                          xdr_args, args_ptr));
00259 }
00260 
00261 <span class="keyword">static</span> bool_t Svcudp_freeargs( SVCXPRT * xprt, Xdrproc_t xdr_args, caddr_t args_ptr)
00262 {
00263         <span class="keyword">register</span> XDR *xdrs = &amp;(<a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt)-&gt;su_xdrs);
00264 
00265         xdrs-&gt;x_op = XDR_FREE;
00266         <span class="keywordflow">return</span> ((*xdr_args)(xdrs, args_ptr));
00267 }
00268 
00269 <span class="keyword">static</span> <span class="keywordtype">void</span> Svcudp_destroy( <span class="keyword">register</span> SVCXPRT * xprt)
00270 {
00271         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structSvcudp__data.html">Svcudp_data</a> *su = <a class="code" href="Svc__udp_8c.html#a2">Su_data</a>(xprt);
00272 
00273         <a class="code" href="Svc_8c.html#a9">Xprt_unregister</a>(xprt);
00274         (void)close(xprt-&gt;xp_sock);
00275         XDR_DESTROY(&amp;(su-&gt;<a class="code" href="structSvcudp__data.html#o2">su_xdrs</a>));
00276         mem_free(<a class="code" href="Svc__udp_8c.html#a1">rpc_buffer</a>(xprt), su-&gt;<a class="code" href="structSvcudp__data.html#o0">su_iosz</a>);
00277         mem_free((caddr_t)su, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structSvcudp__data.html">Svcudp_data</a>));
00278         mem_free((caddr_t)xprt, <span class="keyword">sizeof</span>(SVCXPRT));
00279 
00280         <a class="code" href="Svc__tab__auth_8c.html#a4">Svcauth_gss_tab_creds_free</a>( xprt-&gt;xp_sock ) ;
00281 }
00282 
00283 
00284 
00285 
00286 
00287 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
