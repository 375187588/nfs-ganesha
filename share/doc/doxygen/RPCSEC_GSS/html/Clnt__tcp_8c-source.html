<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Clnt_tcp.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Clnt_tcp.c</h1><a href="Clnt__tcp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * clnt_tcp.c, Implements a TCP/IP based, client side RPC.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> * TCP based RPC supports 'batched calls'.</span>
00036 <span class="comment"> * A sequence of calls may be batched-up in a send buffer.  The rpc call</span>
00037 <span class="comment"> * return immediately to the client even though the call was not necessarily</span>
00038 <span class="comment"> * sent.  The batching occurs if the results' xdr routine is NULL (0) AND</span>
00039 <span class="comment"> * the rpc timeout value is zero (see clnt.h, rpc).</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> * Clients should NOT casually batch calls that in fact return results; that is,</span>
00042 <span class="comment"> * the server side should be aware that a call is batched and not produce any</span>
00043 <span class="comment"> * return message.  Batched calls that produce many result messages can</span>
00044 <span class="comment"> * deadlock (netlock) the client and the server....</span>
00045 <span class="comment"> *</span>
00046 <span class="comment"> * Now go hang yourself.</span>
00047 <span class="comment"> */</span>
00048 
00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00050 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00051 <span class="preprocessor">#include &lt;string.h&gt;</span>
00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00053 <span class="preprocessor">#include "Rpc.h"</span>
00054 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00055 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00056 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00057 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00058 <span class="comment">/* #include &lt;rpc/pmap_clnt.h&gt; */</span>
00059 
00060 <span class="preprocessor">#include "Types.h"</span>
00061 <span class="preprocessor">#include "stuff_alloc.h"</span>
00062 <span class="preprocessor">#include "Auth.h"</span>
00063 <span class="preprocessor">#include "Auth_none.h"</span>
00064 
00065 <span class="preprocessor">#ifndef NFDBITS</span>
<a name="l00066"></a><a class="code" href="Clnt__tcp_8c.html#a0">00066</a> <span class="preprocessor"></span><span class="preprocessor">#define NFDBITS  (sizeof(long) * 8)    </span><span class="comment">/* bits per mask */</span>
00067 <span class="preprocessor">#endif</span>
00068 <span class="preprocessor"></span>
<a name="l00069"></a><a class="code" href="Clnt__tcp_8c.html#a1">00069</a> <span class="preprocessor">#define MCALL_MSG_SIZE 24</span>
00070 <span class="preprocessor"></span>
00071 <span class="keyword">static</span> <span class="keywordtype">int</span>      <a class="code" href="Svc__tcp_8c.html#a11">Readtcp</a>();
00072 <span class="keyword">static</span> <span class="keywordtype">int</span>      <a class="code" href="Svc__tcp_8c.html#a12">Writetcp</a>();
00073 
00074 <span class="keyword">static</span> <span class="keyword">enum</span>    Clnt_stat        Clnttcp_call();
00075 <span class="keyword">static</span> <span class="keywordtype">void</span>              Clnttcp_abort();
00076 <span class="keyword">static</span> <span class="keywordtype">void</span>              Clnttcp_geterr();
00077 <span class="keyword">static</span> bool_t    Clnttcp_freeres();
00078 <span class="keyword">static</span> bool_t  Clnttcp_control();
00079 <span class="keyword">static</span> <span class="keywordtype">void</span>              Clnttcp_destroy();
00080 
00081 <span class="keyword">static</span> <span class="keyword">struct </span>Clnt_ops Tcp_ops = {
00082         Clnttcp_call,
00083         Clnttcp_abort,
00084         Clnttcp_geterr,
00085         Clnttcp_freeres,
00086         Clnttcp_destroy,
00087         Clnttcp_control
00088 };
00089 
<a name="l00090"></a><a class="code" href="structCt__data.html">00090</a> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> {
<a name="l00091"></a><a class="code" href="structCt__data.html#o0">00091</a>         <span class="keywordtype">int</span>                       ct_sock;
<a name="l00092"></a><a class="code" href="structCt__data.html#o1">00092</a>         bool_t                  ct_closeit;
<a name="l00093"></a><a class="code" href="structCt__data.html#o2">00093</a>         <span class="keyword">struct </span>timeval  ct_wait;
<a name="l00094"></a><a class="code" href="structCt__data.html#o3">00094</a>         bool_t          ct_waitset;       <span class="comment">/* wait set by clnt_control? */</span>
<a name="l00095"></a><a class="code" href="structCt__data.html#o4">00095</a>         <span class="keyword">struct </span>sockaddr_in ct_addr; 
<a name="l00096"></a><a class="code" href="structCt__data.html#o5">00096</a>         <span class="keyword">struct </span>Rpc_err  ct_error;
<a name="l00097"></a><a class="code" href="structCt__data.html#o6">00097</a>         <span class="keywordtype">char</span>                    ct_mcall[MCALL_MSG_SIZE];       <span class="comment">/* marshalled callmsg */</span>
<a name="l00098"></a><a class="code" href="structCt__data.html#o7">00098</a>         u_int                   ct_mpos;                        <span class="comment">/* pos after marshal */</span>
<a name="l00099"></a><a class="code" href="structCt__data.html#o8">00099</a>         XDR                       ct_xdrs;
00100 };
00101 
00102 <span class="comment">/*</span>
00103 <span class="comment"> * Create a client handle for a tcp/ip connection.</span>
00104 <span class="comment"> * If *sockp&lt;0, *sockp is set to a newly created TCP socket and it is</span>
00105 <span class="comment"> * connected to raddr.  If *sockp non-negative then</span>
00106 <span class="comment"> * raddr is ignored.  The rpc/tcp package does buffering</span>
00107 <span class="comment"> * similar to stdio, so the client must pick send and receive buffer sizes,];</span>
00108 <span class="comment"> * 0 =&gt; use the default.</span>
00109 <span class="comment"> * If raddr-&gt;sin_port is 0, then a binder on the remote machine is</span>
00110 <span class="comment"> * consulted for the right port number.</span>
00111 <span class="comment"> * NB: *sockp is copied into a private area.</span>
00112 <span class="comment"> * NB: It is the clients responsibility to close *sockp.</span>
00113 <span class="comment"> * NB: The rpch-&gt;cl_auth is set null authentication.  Caller may wish to set this</span>
00114 <span class="comment"> * something more useful.</span>
00115 <span class="comment"> */</span>
<a name="l00116"></a><a class="code" href="Clnt__tcp_8c.html#a11">00116</a> Client * <a class="code" href="Clnt__tcp_8c.html#a11">Clnttcp_create</a>( <span class="keyword">struct</span> sockaddr_in * raddr, u_long prog, u_long vers, <span class="keyword">register</span> <span class="keywordtype">int</span> * sockp, u_int  sendsz, u_int recvsz)
00117 {
00118         Client *h;
00119         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct = NULL;
00120         <span class="keyword">struct </span>timeval now;
00121         <span class="keyword">struct </span>Rpc_msg call_msg;
00122 
00123         h  = (Client *)mem_alloc(<span class="keyword">sizeof</span>(*h));
00124         <span class="keywordflow">if</span> (h == NULL) {
00125                 FILE * tmplog ;
00126                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00127                 {
00128                 (void)fprintf(tmplog, <span class="stringliteral">"Clnttcp_create: out of memory\n"</span>);
00129                 fclose( tmplog ) ;
00130                 }
00131                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00132                 rpc_createerr.cf_error.re_errno = errno;
00133                 <span class="keywordflow">goto</span> fooy;
00134         }
00135         ct = (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *)mem_alloc(<span class="keyword">sizeof</span>(*ct));
00136         <span class="keywordflow">if</span> (ct == NULL) {
00137                 FILE * tmplog ;
00138                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00139                 {
00140                 (void)fprintf(tmplog, <span class="stringliteral">"Clnttcp_create: out of memory\n"</span>);
00141                 fclose( tmplog ) ;
00142                 }
00143                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00144                 rpc_createerr.cf_error.re_errno = errno;
00145                 <span class="keywordflow">goto</span> fooy;
00146         }
00147 
00148         <span class="comment">/*</span>
00149 <span class="comment">         * If no port number given ask the pmap for one</span>
00150 <span class="comment">         */</span>
00151         <span class="keywordflow">if</span> (raddr-&gt;sin_port == 0) {
00152                 u_short port;
00153                 <span class="keywordflow">if</span> ((port = pmap_getport(raddr, prog, vers, IPPROTO_TCP)) == 0) {
00154                         mem_free((caddr_t)ct, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structCt__data.html">Ct_data</a>));
00155                         mem_free((caddr_t)h, <span class="keyword">sizeof</span>(Client));
00156                         <span class="keywordflow">return</span> ((Client *)NULL);
00157                 }
00158                 raddr-&gt;sin_port = htons(port);
00159         }
00160 
00161         <span class="comment">/*</span>
00162 <span class="comment">         * If no socket given, open one</span>
00163 <span class="comment">         */</span>
00164         <span class="keywordflow">if</span> (*sockp &lt; 0) {
00165                 *sockp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
00166                 (void)bindresvport(*sockp, (<span class="keyword">struct</span> sockaddr_in *)0);
00167                 <span class="keywordflow">if</span> ((*sockp &lt; 0)
00168                     || (connect(*sockp, (<span class="keyword">struct</span> sockaddr *)raddr,
00169                     <span class="keyword">sizeof</span>(*raddr)) &lt; 0)) {
00170                         rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00171                         rpc_createerr.cf_error.re_errno = errno;
00172                         <span class="keywordflow">if</span> (*sockp != -1)
00173                                 (void)close(*sockp);
00174                         <span class="keywordflow">goto</span> fooy;
00175                 }
00176                 ct-&gt;<a class="code" href="structCt__data.html#o1">ct_closeit</a> = TRUE;
00177         } <span class="keywordflow">else</span> {
00178                 ct-&gt;<a class="code" href="structCt__data.html#o1">ct_closeit</a> = FALSE;
00179         }
00180 
00181         <span class="comment">/*</span>
00182 <span class="comment">         * Set up private data struct</span>
00183 <span class="comment">         */</span>
00184         ct-&gt;<a class="code" href="structCt__data.html#o0">ct_sock</a> = *sockp;
00185         ct-&gt;<a class="code" href="structCt__data.html#o2">ct_wait</a>.tv_usec = 0;
00186         ct-&gt;<a class="code" href="structCt__data.html#o3">ct_waitset</a> = FALSE;
00187         ct-&gt;<a class="code" href="structCt__data.html#o4">ct_addr</a> = *raddr;
00188 
00189         <span class="comment">/*</span>
00190 <span class="comment">         * Initialize call message</span>
00191 <span class="comment">         */</span>
00192         (void)gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *)0);
00193         call_msg.rm_xid = getpid() ^ now.tv_sec ^ now.tv_usec;
00194         call_msg.rm_direction = CALL;
00195         call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
00196         call_msg.rm_call.cb_prog = prog;
00197         call_msg.rm_call.cb_vers = vers;
00198 
00199         <span class="comment">/*</span>
00200 <span class="comment">         * pre-serialize the staic part of the call msg and stash it away</span>
00201 <span class="comment">         */</span>
00202         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;(ct-&gt;ct_xdrs), ct-&gt;ct_mcall, <a class="code" href="Clnt__raw_8c.html#a0">MCALL_MSG_SIZE</a>,
00203             XDR_ENCODE);
00204         <span class="keywordflow">if</span> (! <a class="code" href="Rpc__prot_8c.html#a7">Xdr_callhdr</a>(&amp;(ct-&gt;ct_xdrs), &amp;call_msg)) {
00205                 <span class="keywordflow">if</span> (ct-&gt;ct_closeit) {
00206                         (void)close(*sockp);
00207                 }
00208                 <span class="keywordflow">goto</span> fooy;
00209         }
00210         ct-&gt;<a class="code" href="structCt__data.html#o7">ct_mpos</a> = XDR_GETPOS(&amp;(ct-&gt;ct_xdrs));
00211         XDR_DESTROY(&amp;(ct-&gt;ct_xdrs));
00212 
00213         <span class="comment">/*</span>
00214 <span class="comment">         * Create a client handle which uses xdrrec for serialization</span>
00215 <span class="comment">         * and authnone for authentication.</span>
00216 <span class="comment">         */</span>
00217         <a class="code" href="Xdr__rec_8c.html#a16">Xdrrec_create</a>(&amp;(ct-&gt;ct_xdrs), sendsz, recvsz, (caddr_t)ct, Readtcp, Writetcp);
00218 
00219         h-&gt;cl_ops = &amp;Tcp_ops;
00220         h-&gt;cl_private = (caddr_t) ct;
00221         h-&gt;cl_auth = <a class="code" href="Auth__none_8c.html#a10">Authnone_create</a>();
00222         <span class="keywordflow">return</span> (h);
00223 
00224 fooy:
00225         <span class="comment">/*</span>
00226 <span class="comment">         * Something goofed, free stuff and barf</span>
00227 <span class="comment">         */</span>
00228         <span class="keywordflow">if</span> (ct)
00229                 mem_free((caddr_t)ct, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structCt__data.html">Ct_data</a>));
00230         <span class="keywordflow">if</span> (h)
00231                 mem_free((caddr_t)h, <span class="keyword">sizeof</span>(Client));
00232         <span class="keywordflow">return</span> ((Client *)NULL);
00233 }
00234 
00235 <span class="keyword">static</span> <span class="keyword">enum</span> Clnt_stat Clnttcp_call( <span class="keyword">register</span> Client * h, u_long proc, Xdrproc_t xdr_args, caddr_t  args_ptr, 
00236                                     Xdrproc_t xdr_results, caddr_t results_ptr, <span class="keyword">struct</span> timeval timeout)
00237 {
00238         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct = (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *) h-&gt;cl_private;
00239         <span class="keyword">register</span> XDR *xdrs = &amp;(ct-&gt;<a class="code" href="structCt__data.html#o8">ct_xdrs</a>);
00240         <span class="keyword">struct </span>Rpc_msg reply_msg;
00241         u_long x_id;
00242         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *msg_x_id = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)(ct-&gt;<a class="code" href="structCt__data.html#o6">ct_mcall</a>);        <span class="comment">/* yuk */</span>
00243         <span class="keyword">register</span> bool_t shipnow;
00244         <span class="keywordtype">int</span> refreshes = 2;
00245 
00246         <span class="keywordflow">if</span> (!ct-&gt;<a class="code" href="structCt__data.html#o3">ct_waitset</a>) {
00247                 ct-&gt;<a class="code" href="structCt__data.html#o2">ct_wait</a> = timeout;
00248         }
00249 
00250   
00251         shipnow =
00252             (xdr_results == (Xdrproc_t)0 &amp;&amp; timeout.tv_sec == 0
00253             &amp;&amp; timeout.tv_usec == 0) ? FALSE : TRUE;
00254 
00255 call_again:
00256         xdrs-&gt;x_op = XDR_ENCODE;
00257         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_SUCCESS;
00258         x_id = ntohl(--(*msg_x_id));
00259   
00260         <span class="keywordflow">if</span> ((! XDR_PUTBYTES(xdrs, ct-&gt;<a class="code" href="structCt__data.html#o6">ct_mcall</a>, ct-&gt;<a class="code" href="structCt__data.html#o7">ct_mpos</a>)) ||
00261             (! XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;proc)) ||
00262             (! AUTH_MARSHALL(h-&gt;cl_auth, xdrs)) ||
00263             (! AUTH_WRAP(h-&gt;cl_auth, xdrs, xdr_args, args_ptr)))
00264     {
00265       <span class="keywordflow">if</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status == RPC_SUCCESS)
00266         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTENCODEARGS;
00267       (void)<a class="code" href="Xdr__rec_8c.html#a27">Xdrrec_endofrecord</a>(xdrs, TRUE);
00268       <span class="keywordflow">return</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status);
00269     }
00270 
00271         <span class="keywordflow">if</span> (! <a class="code" href="Xdr__rec_8c.html#a27">Xdrrec_endofrecord</a>(xdrs, shipnow))
00272                 <span class="keywordflow">return</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTSEND);
00273 
00274   <span class="keywordflow">if</span> (! shipnow)
00275                 <span class="keywordflow">return</span> (RPC_SUCCESS);
00276         <span class="comment">/*</span>
00277 <span class="comment">         * Hack to provide rpc-based message passing</span>
00278 <span class="comment">         */</span>
00279         <span class="keywordflow">if</span> (timeout.tv_sec == 0 &amp;&amp; timeout.tv_usec == 0) {
00280                 <span class="keywordflow">return</span>(ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_TIMEDOUT);
00281         }
00282 
00283 
00284         <span class="comment">/*</span>
00285 <span class="comment">         * Keep receiving until we get a valid transaction id</span>
00286 <span class="comment">         */</span>
00287         xdrs-&gt;x_op = XDR_DECODE;
00288         <span class="keywordflow">while</span> (TRUE) {
00289                 reply_msg.acpted_rply.ar_verf = _null_auth;
00290                 reply_msg.acpted_rply.ar_results.where = NULL;
00291                 reply_msg.acpted_rply.ar_results.proc = Xdr_void;
00292                 <span class="keywordflow">if</span> (! <a class="code" href="Xdr__rec_8c.html#a25">Xdrrec_skiprecord</a>(xdrs))
00293                         <span class="keywordflow">return</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status);
00294                 <span class="comment">/* now decode and validate the response header */</span>
00295                 <span class="keywordflow">if</span> (! <a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(xdrs, &amp;reply_msg)) {
00296                         <span class="keywordflow">if</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status == RPC_SUCCESS)
00297                                 <span class="keywordflow">continue</span>;
00298                         <span class="keywordflow">return</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status);
00299                 }
00300                 <span class="keywordflow">if</span> (reply_msg.rm_xid == x_id)
00301                         <span class="keywordflow">break</span>;
00302         }
00303 
00304         <span class="comment">/*</span>
00305 <span class="comment">         * process header</span>
00306 <span class="comment">         */</span>
00307         <a class="code" href="Rpc__prot_8c.html#a10">_seterr_reply</a>(&amp;reply_msg, &amp;(ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>));
00308         <span class="keywordflow">if</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status == RPC_SUCCESS)
00309     {
00310       <span class="keywordflow">if</span> (! AUTH_VALIDATE(h-&gt;cl_auth, &amp;reply_msg.acpted_rply.ar_verf)) 
00311         {
00312           ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_AUTHERROR;
00313           ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_why = AUTH_INVALIDRESP;
00314         } 
00315       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! AUTH_UNWRAP(h-&gt;cl_auth, xdrs, xdr_results, results_ptr))
00316         {
00317           <span class="keywordflow">if</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status == RPC_SUCCESS)
00318             ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTDECODERES;
00319         }
00320 
00321       <span class="comment">/* free verifier ... */</span>
00322       <span class="keywordflow">if</span> (reply_msg.acpted_rply.ar_verf.oa_base != NULL) {
00323         xdrs-&gt;x_op = XDR_FREE;
00324         (void)<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;(reply_msg.acpted_rply.ar_verf));
00325       }
00326     }  <span class="comment">/* end successful completion */</span>
00327         <span class="keywordflow">else</span> 
00328     {
00329       <span class="comment">/* maybe our credentials need to be refreshed ... */</span>
00330       <span class="keywordflow">if</span> (refreshes-- &amp;&amp; AUTH_REFRESH(h-&gt;cl_auth))
00331         <span class="keywordflow">goto</span> call_again;
00332     }  <span class="comment">/* end of unsuccessful completion */</span>
00333         <span class="keywordflow">return</span> (ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status);
00334 }
00335 
00336 <span class="keyword">static</span> <span class="keywordtype">void</span> Clnttcp_geterr( Client * h, <span class="keyword">struct</span> Rpc_err * errp)
00337 {
00338         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct =
00339             (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *) h-&gt;cl_private;
00340 
00341         *errp = ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>;
00342 }
00343 
00344 <span class="keyword">static</span> bool_t Clnttcp_freeres( Client * cl, Xdrproc_t xdr_res, caddr_t res_ptr)
00345 {
00346         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct = (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *)cl-&gt;cl_private;
00347         <span class="keyword">register</span> XDR *xdrs = &amp;(ct-&gt;<a class="code" href="structCt__data.html#o8">ct_xdrs</a>);
00348 
00349         xdrs-&gt;x_op = XDR_FREE;
00350         <span class="keywordflow">return</span> ((*xdr_res)(xdrs, res_ptr));
00351 }
00352 
00353 <span class="keyword">static</span> <span class="keywordtype">void</span> Clnttcp_abort()
00354 {
00355 }
00356 
00357 <span class="keyword">static</span> bool_t Clnttcp_control( Client * cl, <span class="keywordtype">int</span> request, <span class="keywordtype">char</span> * info)
00358 {
00359         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct = (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *)cl-&gt;cl_private;
00360 
00361         <span class="keywordflow">switch</span> (request) {
00362         <span class="keywordflow">case</span> CLSET_TIMEOUT:
00363                 ct-&gt;<a class="code" href="structCt__data.html#o2">ct_wait</a> = *(<span class="keyword">struct </span>timeval *)info;
00364                 ct-&gt;<a class="code" href="structCt__data.html#o3">ct_waitset</a> = TRUE;
00365                 <span class="keywordflow">break</span>;
00366         <span class="keywordflow">case</span> CLGET_TIMEOUT:
00367                 *(<span class="keyword">struct </span>timeval *)info = ct-&gt;<a class="code" href="structCt__data.html#o2">ct_wait</a>;
00368                 <span class="keywordflow">break</span>;
00369         <span class="keywordflow">case</span> CLGET_SERVER_ADDR:
00370                 *(<span class="keyword">struct </span>sockaddr_in *)info = ct-&gt;<a class="code" href="structCt__data.html#o4">ct_addr</a>;
00371                 <span class="keywordflow">break</span>;
00372         <span class="keywordflow">default</span>:
00373                 <span class="keywordflow">return</span> (FALSE);
00374         }
00375         <span class="keywordflow">return</span> (TRUE);
00376 }
00377 
00378 
00379 <span class="keyword">static</span> <span class="keywordtype">void</span> Clnttcp_destroy( Client * h )
00380 {
00381         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *ct =
00382             (<span class="keyword">struct </span><a class="code" href="structCt__data.html">Ct_data</a> *) h-&gt;cl_private;
00383 
00384         <span class="keywordflow">if</span> (ct-&gt;<a class="code" href="structCt__data.html#o1">ct_closeit</a>) {
00385                 (void)close(ct-&gt;<a class="code" href="structCt__data.html#o0">ct_sock</a>);
00386         }
00387         XDR_DESTROY(&amp;(ct-&gt;<a class="code" href="structCt__data.html#o8">ct_xdrs</a>));
00388         mem_free((caddr_t)ct, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structCt__data.html">Ct_data</a>));
00389         mem_free((caddr_t)h, <span class="keyword">sizeof</span>(Client));
00390 }
00391 
00392 <span class="comment">/*</span>
00393 <span class="comment"> * Interface between xdr serializer and tcp connection.</span>
00394 <span class="comment"> * Behaves like the system calls, read &amp; write, but keeps some error state</span>
00395 <span class="comment"> * around for the rpc level.</span>
00396 <span class="comment"> */</span>
00397 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="Svc__tcp_8c.html#a11">Readtcp</a>( <span class="keyword">register</span> <span class="keyword">struct</span> <a class="code" href="structCt__data.html">Ct_data</a> * ct, caddr_t buf, <span class="keyword">register</span> <span class="keywordtype">int</span> len)
00398 {
00399         fd_set *fds, readfds;
00400         <span class="keyword">struct </span>timeval start, after, duration, delta, tmp;
00401         <span class="keywordtype">int</span> r, save_errno;
00402         <span class="keyword">register</span> <span class="keywordtype">long</span> fd_mask ;
00403 
00404         <span class="keywordflow">if</span> (len == 0)
00405                 <span class="keywordflow">return</span> (0);
00406 
00407         <span class="keywordflow">if</span> (ct-&gt;ct_sock+1 &gt; FD_SETSIZE) {
00408                 <span class="keywordtype">int</span> bytes = howmany(ct-&gt;ct_sock+1, NFDBITS) * <span class="keyword">sizeof</span>(fd_mask);
00409                 fds = (fd_set *)malloc(bytes);
00410                 <span class="keywordflow">if</span> (fds == NULL)
00411                         <span class="keywordflow">return</span> (-1);
00412                 memset(fds, 0, bytes);
00413         } <span class="keywordflow">else</span> {
00414                 fds = &amp;readfds;
00415                 FD_ZERO(fds);
00416         }
00417 
00418         gettimeofday(&amp;start, NULL);
00419         delta = ct-&gt;<a class="code" href="structCt__data.html#o2">ct_wait</a>;
00420         <span class="keywordflow">while</span> (TRUE) {
00421                 <span class="comment">/* XXX we know the other bits are still clear */</span>
00422                 FD_SET(ct-&gt;ct_sock, fds);
00423                 r = select(ct-&gt;ct_sock+1, fds, NULL, NULL, &amp;delta);
00424                 save_errno = errno;
00425 
00426                 gettimeofday(&amp;after, NULL);
00427                 Timersub(&amp;start, &amp;after, &amp;duration);
00428                 Timersub(&amp;ct-&gt;ct_wait, &amp;duration, &amp;tmp);
00429                 delta = tmp;
00430                 <span class="keywordflow">if</span> (delta.tv_sec &lt; 0 || !Timerisset(&amp;delta))
00431                         r = 0;
00432 
00433                 <span class="keywordflow">switch</span> (r) {
00434                 <span class="keywordflow">case</span> 0:
00435                         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_TIMEDOUT;
00436                         <span class="keywordflow">if</span> (fds != &amp;readfds)
00437                                 Mem_Free(fds);
00438                         <span class="keywordflow">return</span> (-1);
00439                 <span class="keywordflow">case</span> -1:
00440                         <span class="keywordflow">if</span> (errno == EINTR)
00441                                 <span class="keywordflow">continue</span>;
00442                         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTRECV;
00443                         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_errno = save_errno;
00444                         <span class="keywordflow">if</span> (fds != &amp;readfds)
00445                                 Mem_Free(fds);
00446                         <span class="keywordflow">return</span> (-1);
00447                 }
00448                 <span class="keywordflow">break</span>;
00449         }
00450         <span class="keywordflow">if</span> (fds != &amp;readfds)
00451                 Mem_Free(fds);
00452 
00453         <span class="keywordflow">switch</span> (len = read(ct-&gt;ct_sock, buf, len)) {
00454         <span class="keywordflow">case</span> 0:
00455                 <span class="comment">/* premature eof */</span>
00456                 ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_errno = ECONNRESET;
00457                 ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTRECV;
00458                 len = -1;  <span class="comment">/* it's really an error */</span>
00459                 <span class="keywordflow">break</span>;
00460         <span class="keywordflow">case</span> -1:
00461                 ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_errno = errno;
00462                 ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTRECV;
00463                 <span class="keywordflow">break</span>;
00464         }
00465         <span class="keywordflow">return</span> (len);
00466 }
00467 
00468 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="Svc__tcp_8c.html#a12">Writetcp</a>( <span class="keyword">struct</span> <a class="code" href="structCt__data.html">Ct_data</a> * ct, caddr_t buf, <span class="keywordtype">int</span> len)
00469 {
00470         <span class="keyword">register</span> <span class="keywordtype">int</span> i, cnt;
00471 
00472         <span class="keywordflow">for</span> (cnt = len; cnt &gt; 0; cnt -= i, buf += i) {
00473                 <span class="keywordflow">if</span> ((i = write(ct-&gt;<a class="code" href="structCt__data.html#o0">ct_sock</a>, buf, cnt)) == -1) {
00474                         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_errno = errno;
00475                         ct-&gt;<a class="code" href="structCt__data.html#o5">ct_error</a>.re_status = RPC_CANTSEND;
00476                         <span class="keywordflow">return</span> (-1);
00477                 }
00478         }
00479         <span class="keywordflow">return</span> (len);
00480 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
