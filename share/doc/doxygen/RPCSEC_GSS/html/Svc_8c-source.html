<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Svc.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Svc.c</h1><a href="Svc_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="preprocessor">#include   &lt;stdlib.h&gt;</span> 
00003 <span class="preprocessor">#include   &lt;string.h&gt;</span> 
00004 
00005 <span class="preprocessor">#include   &lt;sys/errno.h&gt;</span> 
00006 <span class="preprocessor">#include   "Rpc.h"</span> 
00007 <span class="preprocessor">#include   "Clnt.h"</span>
00008 <span class="preprocessor">#include   "Pmap_clnt.h"</span>
00009 <span class="preprocessor">#include   "Svc.h"</span>
00010 
<a name="l00011"></a><a class="code" href="Svc_8c.html#a3">00011</a> SVCXPRT **Xports;
00012 
<a name="l00013"></a><a class="code" href="Svc_8c.html#a0">00013</a> <span class="preprocessor">#define NULL_SVC ((struct svc_callout *)0)</span>
<a name="l00014"></a><a class="code" href="Svc_8c.html#a1">00014</a> <span class="preprocessor"></span><span class="preprocessor">#define RQCRED_SIZE     400             </span><span class="comment">/* this size is excessive */</span>
00015 
<a name="l00016"></a><a class="code" href="Svc_8c.html#a2">00016</a> <span class="preprocessor">#define max(a, b) (a &gt; b ? a : b)</span>
00017 <span class="preprocessor"></span>
00018 <span class="preprocessor">#ifdef _SunOS_5</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define _authenticate Svc_authenticate</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#ifdef xp_stat</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#undef xp_statv</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span><span class="comment">/*</span>
00026 <span class="comment"> * The services list</span>
00027 <span class="comment"> * Each entry represents a set of procedures (an rpc program).</span>
00028 <span class="comment"> * The dispatch routine takes request structs and runs the</span>
00029 <span class="comment"> * apropriate procedure.</span>
00030 <span class="comment"> */</span>
00031 <span class="keyword">static</span> <span class="keyword">struct </span>svc_callout {
00032         <span class="keyword">struct </span>svc_callout *sc_next;
00033         u_long              sc_prog;
00034         u_long              sc_vers;
00035         void                (*sc_dispatch)();
00036 } *svc_head;
00037 
00038 <span class="keyword">static</span> <span class="keyword">struct </span>svc_callout *Svc_find();
00039 
00040 <span class="comment">/* Un rajout pour voir */</span>
<a name="l00041"></a><a class="code" href="Svc_8c.html#a5">00041</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> svc_maxfd ;
00042 
<a name="l00043"></a><a class="code" href="Svc__run_8c.html#a0">00043</a> fd_set Svc_fdset  ;
00044 
00045 <span class="comment">/* ***************  SVCXPRT related stuff **************** */</span>
00046 
00047 <span class="comment">/*</span>
00048 <span class="comment"> * Activate a transport handle.</span>
00049 <span class="comment"> */</span>
00050 <span class="comment">/*  */</span>
<a name="l00051"></a><a class="code" href="Svc_8c.html#a8">00051</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a8">Xprt_register</a>( SVCXPRT * xprt)
00052 {
00053         <span class="keyword">register</span> <span class="keywordtype">int</span> sock = xprt-&gt;xp_sock;
00054 
00055         <span class="keywordflow">if</span> (<a class="code" href="Svc_8c.html#a3">Xports</a> == NULL)
00056           {
00057             <a class="code" href="Svc_8c.html#a3">Xports</a> = (SVCXPRT **)mem_alloc(FD_SETSIZE * <span class="keyword">sizeof</span>(SVCXPRT *));
00058             memset( <a class="code" href="Svc_8c.html#a3">Xports</a>, <span class="charliteral">'\0'</span>, FD_SETSIZE * <span class="keyword">sizeof</span>(SVCXPRT *));
00059             
00060           }
00061 
00062         <span class="keywordflow">if</span> (sock &lt; FD_SETSIZE)
00063           {
00064             <a class="code" href="Svc_8c.html#a3">Xports</a>[sock] = xprt;
00065             xprt-&gt;xp_auth = NULL ;
00066             FD_SET(sock, &amp;<a class="code" href="Svc_8c.html#a6">Svc_fdset</a>);
00067             <a class="code" href="Svc_8c.html#a5">svc_maxfd</a> = <a class="code" href="Svc_8c.html#a2">max</a>(<a class="code" href="Svc_8c.html#a5">svc_maxfd</a>, sock);
00068 
00069           }
00070 }
00071 
00072 <span class="comment">/*</span>
00073 <span class="comment"> * De-activate a transport handle. </span>
00074 <span class="comment"> */</span>
00075 <span class="comment">/*  */</span>
<a name="l00076"></a><a class="code" href="Svc_8c.html#a9">00076</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a9">Xprt_unregister</a>(SVCXPRT * xprt) 
00077 { 
00078         <span class="keyword">register</span> <span class="keywordtype">int</span> sock = xprt-&gt;xp_sock;
00079 
00080         <span class="keywordflow">if</span> ((sock &lt; FD_SETSIZE) &amp;&amp; (<a class="code" href="Svc_8c.html#a3">Xports</a>[sock] == xprt)) 
00081     {
00082       <a class="code" href="Svc_8c.html#a3">Xports</a>[sock] = (SVCXPRT *)0;
00083       
00084       FD_CLR(sock, &amp;<a class="code" href="Svc_8c.html#a6">Svc_fdset</a>);
00085       <span class="keywordflow">if</span> (sock == svc_maxfd) {
00086         <span class="keywordflow">for</span> (<a class="code" href="Svc_8c.html#a5">svc_maxfd</a>--; <a class="code" href="Svc_8c.html#a5">svc_maxfd</a>&gt;=0; <a class="code" href="Svc_8c.html#a5">svc_maxfd</a>--)
00087           <span class="keywordflow">if</span> (<a class="code" href="Svc_8c.html#a3">Xports</a>[svc_maxfd])
00088             <span class="keywordflow">break</span>;
00089       }
00090     }
00091 }
00092 
00093 
00094 <span class="comment">/* ********************** CALLOUT list related stuff ************* */</span>
00095 
00096 <span class="comment">/*</span>
00097 <span class="comment"> * Add a service program to the callout list.</span>
00098 <span class="comment"> * The dispatch routine will be called when a rpc request for this</span>
00099 <span class="comment"> * program number comes in.</span>
00100 <span class="comment"> */</span>
00101 <span class="comment">/*  */</span>
00102 
<a name="l00103"></a><a class="code" href="Svc_8c.html#a10">00103</a> bool_t <a class="code" href="Svc_8c.html#a10">Svc_register</a>(SVCXPRT * xprt, u_long  prog, u_long  vers, <span class="keywordtype">void</span> (*dispatch)(), <span class="keywordtype">int</span> protocol)
00104 {
00105         <span class="keyword">struct </span>svc_callout *prev;
00106         <span class="keyword">register</span> <span class="keyword">struct </span>svc_callout *s;
00107 
00108         <span class="keywordflow">if</span> ((s = Svc_find(prog, vers, &amp;prev)) != NULL_SVC) {
00109                 <span class="keywordflow">if</span> (s-&gt;sc_dispatch == dispatch)
00110                         <span class="keywordflow">goto</span> pmap_it;  <span class="comment">/* he is registering another xptr */</span>
00111                 <span class="keywordflow">return</span> (FALSE);
00112         }
00113         s = (<span class="keyword">struct </span>svc_callout *)mem_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> svc_callout));
00114         <span class="keywordflow">if</span> (s == (<span class="keyword">struct </span>svc_callout *)0) {
00115                 <span class="keywordflow">return</span> (FALSE);
00116         }
00117         s-&gt;sc_prog = prog;
00118         s-&gt;sc_vers = vers;
00119         s-&gt;sc_dispatch = dispatch;
00120         s-&gt;sc_next = svc_head;
00121         svc_head = s;
00122   pmap_it:
00123         <span class="comment">/* now register the information with the local binder service */</span>
00124         <span class="keywordflow">if</span> (protocol) {
00125                 <span class="keywordflow">return</span> (<a class="code" href="Pmap__clnt_8c.html#a3">Pmap_set</a>(prog, vers, protocol, xprt-&gt;xp_port));
00126         }
00127         <span class="keywordflow">return</span> (TRUE);
00128 }
00129 
00130 <span class="comment">/*</span>
00131 <span class="comment"> * Remove a service program from the callout list.</span>
00132 <span class="comment"> */</span>
00133 <span class="comment">/*  */</span>
<a name="l00134"></a><a class="code" href="Svc_8c.html#a11">00134</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a11">Svc_unregister</a>(u_long prog, u_long vers)
00135 {
00136         <span class="keyword">struct </span>svc_callout *prev;
00137         <span class="keyword">register</span> <span class="keyword">struct </span>svc_callout *s;
00138 
00139         <span class="keywordflow">if</span> ((s = Svc_find(prog, vers, &amp;prev)) == NULL_SVC)
00140                 <span class="keywordflow">return</span>;
00141         <span class="keywordflow">if</span> (prev == NULL_SVC) {
00142                 svc_head = s-&gt;sc_next;
00143         } <span class="keywordflow">else</span> {
00144                 prev-&gt;sc_next = s-&gt;sc_next;
00145         }
00146         s-&gt;sc_next = NULL_SVC;
00147         mem_free((<span class="keywordtype">char</span> *) s, (u_int) <span class="keyword">sizeof</span>(<span class="keyword">struct</span> svc_callout));
00148         <span class="comment">/* now unregister the information with the local binder service */</span>
00149         (void)<a class="code" href="Pmap__clnt_8c.html#a4">Pmap_unset</a>(prog, vers);
00150 }
00151 
00152 <span class="comment">/*</span>
00153 <span class="comment"> * Search the callout list for a program number, return the callout</span>
00154 <span class="comment"> * struct.</span>
00155 <span class="comment"> */</span>
00156 <span class="keyword">static</span> <span class="keyword">struct </span>svc_callout * Svc_find( u_long prog, u_long vers, <span class="keyword">struct</span> svc_callout **prev )
00157 {
00158         <span class="keyword">register</span> <span class="keyword">struct </span>svc_callout *s, *p;
00159 
00160         p = NULL_SVC;
00161         <span class="keywordflow">for</span> (s = svc_head; s != NULL_SVC; s = s-&gt;sc_next) {
00162                 <span class="keywordflow">if</span> ((s-&gt;sc_prog == prog) &amp;&amp; (s-&gt;sc_vers == vers))
00163                         <span class="keywordflow">goto</span> done;
00164                 p = s;
00165         }
00166 done:
00167         *prev = p;
00168         <span class="keywordflow">return</span> (s);
00169 }
00170 
<a name="l00171"></a><a class="code" href="Svc_8c.html#a13">00171</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a13">Svc_getreqset</a>(fd_set * readfds)
00172 {
00173         <span class="keyword">enum</span> xprt_stat stat;
00174         <span class="keyword">struct </span>Rpc_msg msg;
00175         <span class="keywordtype">int</span> prog_found;
00176         u_long low_vers;
00177         u_long high_vers;
00178         <span class="keyword">struct </span>Svc_req r;
00179         <span class="keyword">register</span> SVCXPRT *xprt;
00180         <span class="keyword">register</span> <span class="keywordtype">int</span> bit;
00181   <span class="comment">/*    register u_int32_t mask, *maskp; */</span>
00182         <span class="keyword">register</span> <span class="keywordtype">long</span>  mask, *maskp;
00183         <span class="keyword">register</span> <span class="keywordtype">int</span> sock;
00184         <span class="keywordtype">char</span> cred_area[2*MAX_AUTH_BYTES + RQCRED_SIZE];
00185         msg.rm_call.cb_cred.oa_base = cred_area;
00186 
00187         <span class="comment">/* Set the struct Svc_req r to zero */</span>
00188         memset( &amp;r, 0, <span class="keyword">sizeof</span>( <span class="keyword">struct</span> Svc_req ) ) ;
00189 
00190         msg.rm_call.cb_verf.oa_base = &amp;(cred_area[MAX_AUTH_BYTES]);
00191         r.rq_clntcred = &amp;(cred_area[2*MAX_AUTH_BYTES]);
00192 
00193 <span class="preprocessor">#ifndef _LINUX</span>
00194 <span class="preprocessor"></span>        maskp = readfds-&gt;fds_bits;
00195 <span class="preprocessor">#else</span>
00196 <span class="preprocessor"></span>  maskp = readfds-&gt;__fds_bits ;
00197 <span class="preprocessor">#endif</span>
00198 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (sock = 0; sock &lt; FD_SETSIZE; sock += NFDBITS)
00199     {
00200             <span class="keywordflow">for</span> (mask = *maskp++; bit = ffs(mask); mask ^= (1 &lt;&lt; (bit - 1))) 
00201         {
00202           <span class="comment">/* sock has input waiting */</span>
00203           xprt = <a class="code" href="Svc_8c.html#a3">Xports</a>[sock + bit - 1];
00204           <span class="keywordflow">if</span> (xprt == NULL)
00205             <span class="comment">/* But do we control sock? */</span>
00206             <span class="keywordflow">continue</span>;
00207           <span class="comment">/* now receive msgs from xprtprt (support batch calls) */</span>
00208           <span class="keywordflow">do</span> 
00209             {
00210               <span class="keywordflow">if</span> (SVC_RECV(xprt, &amp;msg)) 
00211                 {
00212                   <span class="comment">/* now find the exported program and call it */</span>
00213                   <span class="keyword">register</span> <span class="keyword">struct </span>svc_callout *s;
00214                   <span class="keyword">enum</span> Auth_stat why;
00215                   
00216                   r.rq_xprt = xprt;
00217                   r.rq_prog = msg.rm_call.cb_prog;
00218                   r.rq_vers = msg.rm_call.cb_vers;
00219                   r.rq_proc = msg.rm_call.cb_proc;
00220                   r.rq_cred = msg.rm_call.cb_cred;
00221 
00222                   <span class="comment">/* first authenticate the message */</span>
00223                   <span class="keywordflow">if</span> ((why= <a class="code" href="Svc__auth_8c.html#a7">Svc_authenticate</a>(&amp;r, &amp;msg)) != AUTH_OK)
00224                     {
00225                       svcerr_auth(xprt, why);
00226                       <span class="keywordflow">goto</span> call_done;
00227                     }
00228                   <span class="comment">/* now match message with a registered service*/</span>
00229                   prog_found = FALSE;
00230                   low_vers = 0 - 1;
00231                   high_vers = 0;
00232                   <span class="keywordflow">for</span> (s = svc_head; s != NULL_SVC; s = s-&gt;sc_next)
00233                     {
00234                       <span class="keywordflow">if</span> (s-&gt;sc_prog == r.rq_prog)
00235                         {
00236                           <span class="keywordflow">if</span> (s-&gt;sc_vers == r.rq_vers)
00237                             {
00238                               (*s-&gt;sc_dispatch)(&amp;r, xprt);
00239                               <span class="keywordflow">goto</span> call_done;
00240                             }  <span class="comment">/* found correct version */</span>
00241                           prog_found = TRUE;
00242                           <span class="keywordflow">if</span> (s-&gt;sc_vers &lt; low_vers)
00243                             low_vers = s-&gt;sc_vers;
00244                           <span class="keywordflow">if</span> (s-&gt;sc_vers &gt; high_vers)
00245                             high_vers = s-&gt;sc_vers;
00246                         }   <span class="comment">/* found correct program */</span>
00247                     }
00248                   <span class="comment">/*</span>
00249 <span class="comment">                   * if we got here, the program or version</span>
00250 <span class="comment">                   * is not served ...</span>
00251 <span class="comment">                   */</span>
00252                   <span class="keywordflow">if</span> (prog_found)
00253                     svcerr_progvers(xprt,
00254                                     low_vers, high_vers);
00255                   <span class="keywordflow">else</span>
00256                     svcerr_noprog(xprt);
00257                   <span class="comment">/* Fall through to ... */</span>
00258                 }
00259               call_done:
00260               <span class="keywordflow">if</span> ((stat = SVC_STAT(xprt)) == XPRT_DIED )
00261                 {
00262                   SVC_DESTROY(xprt);
00263                   <span class="keywordflow">break</span>;
00264                 }
00265             } <span class="keywordflow">while</span> (stat == XPRT_MOREREQS);
00266         }
00267     }
00268 }
00269 
00270 
<a name="l00271"></a><a class="code" href="Svc_8c.html#a14">00271</a> bool_t <a class="code" href="Svc_8c.html#a14">Svc_sendreply</a>( <span class="keyword">register</span> SVCXPRT * xprt, Xdrproc_t xdr_results, caddr_t xdr_location)
00272 {
00273         <span class="keyword">struct </span>Rpc_msg rply;
00274 
00275         rply.rm_direction = REPLY;
00276         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00277         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00278         rply.acpted_rply.ar_stat = SUCCESS;
00279         rply.acpted_rply.ar_results.where = xdr_location;
00280         rply.acpted_rply.ar_results.proc = xdr_results;
00281         <span class="keywordflow">return</span> (SVC_REPLY(xprt, &amp;rply));
00282 }
00283 
00284 <span class="comment">/*</span>
00285 <span class="comment"> * No procedure error reply</span>
00286 <span class="comment"> */</span>
<a name="l00287"></a><a class="code" href="Svc_8c.html#a15">00287</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a15">Svcerr_noproc</a>( <span class="keyword">register</span> SVCXPRT * xprt)
00288 {
00289         <span class="keyword">struct </span>Rpc_msg rply;
00290 
00291         rply.rm_direction = REPLY;
00292         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00293         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00294         rply.acpted_rply.ar_stat = PROC_UNAVAIL;
00295         SVC_REPLY(xprt, &amp;rply);
00296 }
00297 
00298 <span class="comment">/*</span>
00299 <span class="comment"> * Can't decode args error reply</span>
00300 <span class="comment"> */</span>
00301 
<a name="l00302"></a><a class="code" href="Svc_8c.html#a16">00302</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a16">Svcerr_decode</a>( <span class="keyword">register</span> SVCXPRT * xprt)
00303 {
00304         <span class="keyword">struct </span>Rpc_msg rply;
00305 
00306         rply.rm_direction = REPLY;
00307         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00308         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00309         rply.acpted_rply.ar_stat = GARBAGE_ARGS;
00310         SVC_REPLY(xprt, &amp;rply);
00311 }
00312 
00313 <span class="comment">/*</span>
00314 <span class="comment"> * Some system error</span>
00315 <span class="comment"> */</span>
<a name="l00316"></a><a class="code" href="Svc_8c.html#a17">00316</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a17">Svcerr_systemerr</a>(<span class="keyword">register</span> SVCXPRT *  xprt)
00317 {
00318         <span class="keyword">struct </span>Rpc_msg rply;
00319 
00320         rply.rm_direction = REPLY;
00321         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00322         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00323         rply.acpted_rply.ar_stat = SYSTEM_ERR;
00324         SVC_REPLY(xprt, &amp;rply);
00325 }
00326 
00327 <span class="comment">/*</span>
00328 <span class="comment"> * Authentication error reply</span>
00329 <span class="comment"> */</span>
<a name="l00330"></a><a class="code" href="Svc_8c.html#a18">00330</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a18">Svcerr_auth</a>( SVCXPRT * xprt, <span class="keyword">enum</span> Auth_stat why)
00331 {
00332         <span class="keyword">struct </span>Rpc_msg rply;
00333 
00334         rply.rm_direction = REPLY;
00335         rply.rm_reply.rp_stat = MSG_DENIED;
00336         rply.rjcted_rply.rj_stat = AUTH_ERROR;
00337         rply.rjcted_rply.rj_why = why;
00338         SVC_REPLY(xprt, &amp;rply);
00339 }
00340 
00341 <span class="comment">/*</span>
00342 <span class="comment"> * Auth too weak error reply</span>
00343 <span class="comment"> */</span>
<a name="l00344"></a><a class="code" href="Svc_8c.html#a19">00344</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a19">Svcerr_weakauth</a>( SVCXPRT * xprt)
00345 {
00346 
00347         svcerr_auth(xprt, AUTH_TOOWEAK);
00348 }
00349 
00350 <span class="comment">/*</span>
00351 <span class="comment"> * Program unavailable error reply</span>
00352 <span class="comment"> */</span>
<a name="l00353"></a><a class="code" href="Svc_8c.html#a20">00353</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a20">Svcerr_noprog</a>( <span class="keyword">register</span> SVCXPRT * xprt)
00354 {
00355         <span class="keyword">struct </span>Rpc_msg rply;
00356 
00357         rply.rm_direction = REPLY;
00358         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00359         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00360         rply.acpted_rply.ar_stat = PROG_UNAVAIL;
00361         SVC_REPLY(xprt, &amp;rply);
00362 }
00363 
00364 <span class="comment">/*</span>
00365 <span class="comment"> * Program version mismatch error reply</span>
00366 <span class="comment"> */</span>
<a name="l00367"></a><a class="code" href="Svc_8c.html#a21">00367</a> <span class="keywordtype">void</span> <a class="code" href="Svc_8c.html#a21">Svcerr_progvers</a>( <span class="keyword">register</span> SVCXPRT * xprt, u_long low_vers, u_long  high_vers)
00368 {
00369         <span class="keyword">struct </span>Rpc_msg rply;
00370 
00371         rply.rm_direction = REPLY;
00372         rply.rm_reply.rp_stat = MSG_ACCEPTED;
00373         rply.acpted_rply.ar_verf = xprt-&gt;xp_verf;
00374         rply.acpted_rply.ar_stat = PROG_MISMATCH;
00375         rply.acpted_rply.ar_vers.low = low_vers;
00376         rply.acpted_rply.ar_vers.high = high_vers;
00377         SVC_REPLY(xprt, &amp;rply);
00378 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
