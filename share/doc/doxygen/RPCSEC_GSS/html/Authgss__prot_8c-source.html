<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Authgss_prot.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Authgss_prot.c</h1><a href="Authgss__prot_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  authgss_prot.c</span>
00003 <span class="comment">  </span>
00004 <span class="comment">  Copyright (c) 2000 The Regents of the University of Michigan.</span>
00005 <span class="comment">  All rights reserved.</span>
00006 <span class="comment">  </span>
00007 <span class="comment">  Copyright (c) 2000 Dug Song &lt;dugsong@UMICH.EDU&gt;.</span>
00008 <span class="comment">  All rights reserved, all wrongs reversed.</span>
00009 <span class="comment">  </span>
00010 <span class="comment">  Redistribution and use in source and binary forms, with or without</span>
00011 <span class="comment">  modification, are permitted provided that the following conditions</span>
00012 <span class="comment">  are met:</span>
00013 <span class="comment"></span>
00014 <span class="comment">  1. Redistributions of source code must retain the above copyright</span>
00015 <span class="comment">     notice, this list of conditions and the following disclaimer.</span>
00016 <span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span>
00017 <span class="comment">     notice, this list of conditions and the following disclaimer in the</span>
00018 <span class="comment">     documentation and/or other materials provided with the distribution.</span>
00019 <span class="comment">  3. Neither the name of the University nor the names of its</span>
00020 <span class="comment">     contributors may be used to endorse or promote products derived</span>
00021 <span class="comment">     from this software without specific prior written permission.</span>
00022 <span class="comment"></span>
00023 <span class="comment">  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
00024 <span class="comment">  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
00025 <span class="comment">  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00026 <span class="comment">  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
00027 <span class="comment">  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
00028 <span class="comment">  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
00029 <span class="comment">  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
00030 <span class="comment">  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
00031 <span class="comment">  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
00032 <span class="comment">  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
00033 <span class="comment">  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00034 <span class="comment"></span>
00035 <span class="comment">  $Id: Authgss_prot.c,v 1.3 2005/08/12 07:11:16 deniel Exp $</span>
00036 <span class="comment">*/</span>
00037 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00038 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00039 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00040 <span class="preprocessor">#include "Xdr.h"</span>
00041 <span class="preprocessor">#include "Auth.h"</span>
00042 <span class="preprocessor">#include "Auth_gss.h"</span>
00043 <span class="preprocessor">#include "Rpc.h"</span>
00044 <span class="preprocessor">#ifdef HAVE_KRB5</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssapi/gssapi.h&gt;</span>
00046 <span class="preprocessor">#elif HAVE_HEIMDAL</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssapi.h&gt;</span>
00048 <span class="preprocessor">#endif</span>
00049 <span class="preprocessor"></span>
00050 
00051 <span class="preprocessor">#ifdef HAVE_KRB5</span>
00052 <span class="preprocessor"></span>bool_t Xdr_Rpc_gss_cred( XDR * xdrs, <span class="keyword">struct</span> Rpc_gss_cred * p )
00053 {
00054         bool_t xdr_stat;
00055         
00056         xdr_stat = (<a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;p-&gt;gc_v) &amp;&amp;
00057                     <a class="code" href="Xdr_8c.html#a19">Xdr_enum</a>(xdrs, (enum_t *)&amp;p-&gt;gc_proc) &amp;&amp;
00058                     <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;p-&gt;gc_seq) &amp;&amp;
00059                     <a class="code" href="Xdr_8c.html#a19">Xdr_enum</a>(xdrs, (enum_t *)&amp;p-&gt;gc_svc) &amp;&amp;
00060                     <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;p-&gt;gc_ctx.value,
00061                               &amp;p-&gt;gc_ctx.length, MAX_AUTH_BYTES));
00062         
00063         <span class="keywordflow">return</span> (xdr_stat);
00064 }
00065 
00066 bool_t Xdr_Rpc_gss_init_args( XDR * xdrs, gss_buffer_desc * p )
00067 {
00068         bool_t xdr_stat;
00069         
00070         xdr_stat = <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;p-&gt;value,
00071                        &amp;p-&gt;length, MAX_NETOBJ_SZ);
00072   
00073         <span class="keywordflow">return</span> (xdr_stat);
00074 }
00075 
00076 bool_t Xdr_Rpc_gss_init_res( XDR * xdrs, <span class="keyword">struct</span> Rpc_gss_init_res * p )
00077 {
00078         bool_t xdr_stat;
00079         
00080         xdr_stat = (<a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;p-&gt;gr_ctx.value,
00081                         &amp;p-&gt;gr_ctx.length, MAX_NETOBJ_SZ) &amp;&amp;
00082               <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;p-&gt;gr_major) &amp;&amp;
00083               <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;p-&gt;gr_minor) &amp;&amp;
00084               <a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;p-&gt;gr_win) &amp;&amp;
00085               <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;p-&gt;gr_token.value,
00086                         &amp;p-&gt;gr_token.length, MAX_NETOBJ_SZ));
00087   
00088         
00089         <span class="keywordflow">return</span> (xdr_stat);
00090 }
00091 
00092 <span class="keyword">typedef</span> <span class="keyword">struct </span>Rec_strm {
00093         caddr_t tcp_handle;
00094         caddr_t the_buffer;
00095         <span class="comment">/*</span>
00096 <span class="comment">         * out-goung bits</span>
00097 <span class="comment">         */</span>
00098         int (*writeit) (caddr_t, caddr_t, int);
00099         caddr_t out_base;       <span class="comment">/* output buffer (points to frag header) */</span>
00100         caddr_t out_finger;     <span class="comment">/* next output position */</span>
00101         caddr_t out_boundry;    <span class="comment">/* data cannot up to this address */</span>
00102         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *frag_header; <span class="comment">/* beginning of current fragment */</span>
00103         bool_t frag_sent;       <span class="comment">/* true if buffer sent in middle of record */</span>
00104         <span class="comment">/*</span>
00105 <span class="comment">         * in-coming bits</span>
00106 <span class="comment">         */</span>
00107         int (*readit) (caddr_t, caddr_t, int);
00108         u_long in_size; <span class="comment">/* fixed size of the input buffer */</span>
00109         caddr_t in_base;
00110         caddr_t in_finger;      <span class="comment">/* location of next byte to be had */</span>
00111         caddr_t in_boundry;     <span class="comment">/* can read up to this location */</span>
00112         <span class="keywordtype">long</span> fbtbc;             <span class="comment">/* fragment bytes to be consumed */</span>
00113         bool_t last_frag;
00114         u_int sendsize;
00115         u_int recvsize;
00116 } <a class="code" href="structrec__strm.html">RECSTREAM</a>;
00117 
00118 
00119 bool_t Xdr_Rpc_gss_wrap_data( XDR *         xdrs, 
00120                               Xdrproc_t     xdr_func, 
00121                               caddr_t       xdr_ptr,
00122                               gss_ctx_id_t  ctx, 
00123                               gss_qop_t     qop,
00124                               Rpc_gss_svc_t svc, 
00125                               u_int         seq)
00126 {
00127         gss_buffer_desc databuf, wrapbuf;
00128         OM_uint32       maj_stat, min_stat;
00129         size_t  start, end ;
00130   <span class="keywordtype">int</span> conf_state;
00131         bool_t          xdr_stat;
00132   
00133   <a class="code" href="structrec__strm.html">RECSTREAM</a> *rstrm = (<a class="code" href="structrec__strm.html">RECSTREAM</a> *)xdrs-&gt;x_private; ;
00134   
00135   
00136         <span class="comment">/* Skip databody length. */</span>
00137         start = XDR_GETPOS(xdrs); 
00138   
00139         XDR_SETPOS(xdrs, start + 4);
00140 
00141         <span class="comment">/* Marshal Rpc_gss_data_t (sequence number + arguments). */</span>
00142         <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;seq) || !(*xdr_func)(xdrs, xdr_ptr))
00143                 <span class="keywordflow">return</span> (FALSE);
00144         end = XDR_GETPOS(xdrs);
00145 
00146 
00147         <span class="comment">/* Set databuf to marshalled Rpc_gss_data_t. */</span>
00148         databuf.length = end - start - 4;
00149         XDR_SETPOS(xdrs, start + 4);
00150         databuf.value = XDR_INLINE(xdrs, databuf.length);
00151 
00152         xdr_stat = FALSE;
00153         
00154         <span class="keywordflow">if</span> (svc == RPCSEC_GSS_SVC_INTEGRITY)
00155     {
00156       
00157       <span class="comment">/* Marshal databody_integ length. */</span>
00158       XDR_SETPOS(xdrs, start);
00159       <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(xdrs, &amp;databuf.length))
00160         <span class="keywordflow">return</span> (FALSE);
00161       
00162       
00163       <span class="comment">/* Checksum Rpc_gss_data_t. */</span>
00164       maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a2">gss_get_mic</a>(&amp;min_stat, 
00165                              ctx, 
00166                              qop,
00167                              &amp;databuf, 
00168                              &amp;wrapbuf);
00169       <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE)
00170         {
00171           <span class="keywordflow">return</span> (FALSE);
00172         }
00173       <span class="comment">/* Marshal checksum. */</span>
00174       XDR_SETPOS(xdrs, end);
00175       
00176       xdr_stat = <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;wrapbuf.value,
00177                            &amp;wrapbuf.length, MAX_NETOBJ_SZ);
00178       gss_release_buffer(&amp;min_stat, &amp;wrapbuf);
00179     }           
00180         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (svc == RPCSEC_GSS_SVC_PRIVACY) 
00181     {
00182       
00183 
00184       <span class="comment">/* Encrypt Rpc_gss_data_t. */</span>
00185       maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a0">gss_wrap</a>(&amp;min_stat, ctx, TRUE, qop, &amp;databuf,
00186                           &amp;conf_state, &amp;wrapbuf);
00187       <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE) {
00188         log_status(<span class="stringliteral">"gss_wrap"</span>, maj_stat, min_stat);
00189         <span class="keywordflow">return</span> (FALSE);
00190       }
00191       <span class="comment">/* Marshal databody_priv. */</span>
00192       XDR_SETPOS(xdrs, start);
00193       xdr_stat = <a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;wrapbuf.value,
00194                            &amp;wrapbuf.length, MAX_NETOBJ_SZ);
00195       gss_release_buffer(&amp;min_stat, &amp;wrapbuf);
00196     }
00197         <span class="keywordflow">return</span> (xdr_stat);
00198 }
00199 
00200 bool_t Xdr_Rpc_gss_unwrap_data( XDR *         xdrs,
00201                                 Xdrproc_t     xdr_func,
00202                                 caddr_t       xdr_ptr,
00203                                 gss_ctx_id_t  ctx,
00204                                 gss_qop_t     qop,
00205                                 Rpc_gss_svc_t svc,
00206                                 u_int         seq)
00207 {
00208         XDR             tmpxdrs;
00209         gss_buffer_desc databuf, wrapbuf;
00210         OM_uint32       maj_stat, min_stat;
00211         u_int           seq_num,  qop_state;
00212         <span class="keywordtype">int</span>             conf_state ;
00213         bool_t          xdr_stat;
00214 
00215 
00216         <span class="keywordflow">if</span> (xdr_func == <a class="code" href="Xdr_8c.html#a5">Xdr_void</a> || xdr_ptr == NULL)
00217                 <span class="keywordflow">return</span> (TRUE);
00218         
00219         memset(&amp;databuf, 0, <span class="keyword">sizeof</span>(databuf));
00220         memset(&amp;wrapbuf, 0, <span class="keyword">sizeof</span>(wrapbuf));
00221         
00222   
00223         <span class="keywordflow">if</span> (svc == RPCSEC_GSS_SVC_INTEGRITY)
00224     {
00225       
00226       <span class="comment">/* Decode databody_integ. */</span>
00227       <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;databuf.value, &amp;databuf.length,
00228                      MAX_NETOBJ_SZ)) 
00229         {
00230           <span class="keywordflow">return</span> (FALSE);
00231         }
00232 
00233       <span class="comment">/* Decode checksum. */</span>
00234       <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;wrapbuf.value, &amp;wrapbuf.length,
00235                      MAX_NETOBJ_SZ))
00236         {
00237           gss_release_buffer(&amp;min_stat, &amp;databuf);
00238           <span class="keywordflow">return</span> (FALSE);
00239 
00240         }
00241 
00242       <span class="comment">/* Verify checksum and QOP. */</span>
00243       maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a3">gss_verify_mic</a>(&amp;min_stat, ctx, &amp;databuf,
00244                                 &amp;wrapbuf, &amp;qop_state);
00245       gss_release_buffer(&amp;min_stat, &amp;wrapbuf);
00246       
00247       <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE || qop_state != qop)
00248         {
00249           gss_release_buffer(&amp;min_stat, &amp;databuf);
00250           log_status(<span class="stringliteral">"gss_verify_mic"</span>, maj_stat, min_stat);
00251           <span class="keywordflow">return</span> (FALSE);
00252         }
00253     } <span class="comment">/* if (svc == RPCSEC_GSS_SVC_INTEGRITY) */</span>
00254   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (svc == RPCSEC_GSS_SVC_PRIVACY)
00255     {
00256 
00257       <span class="comment">/* Decode databody_priv. */</span>
00258       <span class="keywordflow">if</span> (!<a class="code" href="Xdr_8c.html#a21">Xdr_bytes</a>(xdrs, (<span class="keywordtype">char</span> **)&amp;wrapbuf.value, &amp;wrapbuf.length,
00259                      MAX_NETOBJ_SZ))
00260         {
00261           <span class="keywordflow">return</span> (FALSE);
00262         }
00263 
00264       <span class="comment">/* Decrypt databody. */</span>
00265       maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a1">gss_unwrap</a>(&amp;min_stat, ctx, &amp;wrapbuf, &amp;databuf,
00266                             &amp;conf_state, &amp;qop_state);
00267       
00268       <a class="code" href="Release__gss__buffer_8c.html#a22">Gss_release_buffer</a>(&amp;min_stat, &amp;wrapbuf);
00269       
00270       <span class="comment">/* Verify encryption and QOP. */</span>
00271       <span class="keywordflow">if</span> (maj_stat != GSS_S_COMPLETE || qop_state != qop ||
00272           conf_state != TRUE) 
00273         {
00274           gss_release_buffer(&amp;min_stat, &amp;databuf);
00275           log_status(<span class="stringliteral">"gss_unwrap"</span>, maj_stat, min_stat);
00276           <span class="keywordflow">return</span> (FALSE);
00277         }
00278     }
00279         <span class="comment">/* Decode Rpc_gss_data_t (sequence number + arguments). */</span>
00280         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;tmpxdrs, databuf.value, databuf.length, XDR_DECODE);
00281         xdr_stat = (<a class="code" href="Xdr_8c.html#a7">Xdr_u_int</a>(&amp;tmpxdrs, &amp;seq_num) &amp;&amp;
00282               (*xdr_func)(&amp;tmpxdrs, xdr_ptr));
00283         XDR_DESTROY(&amp;tmpxdrs);
00284         gss_release_buffer(&amp;min_stat, &amp;databuf);
00285         
00286   <span class="comment">/* Verify sequence number. */</span>
00287         <span class="keywordflow">if</span> (xdr_stat == TRUE &amp;&amp; seq_num != seq)
00288     {
00289       <span class="keywordflow">return</span> (FALSE);
00290     }
00291         <span class="keywordflow">return</span> (xdr_stat);
00292 }
00293 
00294 bool_t Xdr_Rpc_gss_data( XDR *         xdrs, 
00295                          Xdrproc_t     xdr_func,
00296                          caddr_t       xdr_ptr,
00297                          gss_ctx_id_t  ctx, 
00298                          gss_qop_t     qop,
00299                          Rpc_gss_svc_t svc, 
00300                          u_int         seq)
00301 {
00302         <span class="keywordflow">switch</span> (xdrs-&gt;x_op)
00303     {
00304     <span class="keywordflow">case</span> XDR_ENCODE:
00305       <span class="keywordflow">return</span> (Xdr_Rpc_gss_wrap_data(xdrs, xdr_func, xdr_ptr,
00306                                               ctx, qop, svc, seq));
00307     <span class="keywordflow">case</span> XDR_DECODE:
00308       <span class="keywordflow">return</span> (Xdr_Rpc_gss_unwrap_data(xdrs, xdr_func, xdr_ptr,
00309                                       ctx, qop,svc, seq));
00310     <span class="keywordflow">case</span> XDR_FREE:
00311       <span class="keywordflow">return</span> (TRUE);
00312     }
00313         <span class="keywordflow">return</span> (FALSE);
00314 }
00315 
00316 <span class="comment">/* </span>
00317 <span class="comment"> * convertir une erreur GSSAPI Major/Minor en un message lisible </span>
00318 <span class="comment"> */</span>
00319 
00320 <span class="keywordtype">void</span> <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( <span class="keywordtype">char</span> * str, OM_uint32 code, <span class="keywordtype">int</span> type )
00321 {
00322   gss_buffer_desc  msg = GSS_C_EMPTY_BUFFER  ;
00323   OM_uint32 msg_ctx   ;
00324   OM_uint32 maj_stat, min_stat ;
00325   
00326   msg_ctx = 0 ;
00327   <span class="keywordflow">while</span> ( 1 ) 
00328     {
00329       <span class="keywordflow">if</span>( ( maj_stat = gss_display_status( &amp;min_stat, code, type, GSS_C_NULL_OID, &amp;msg_ctx, &amp;msg ) ) != GSS_S_COMPLETE )
00330         {
00331           sprintf( str, <span class="stringliteral">"Erreur %d intraduisible par gss_display_status: code retour = %d.%d"</span>, 
00332                    code, maj_stat, min_stat ) ;
00333           break ;
00334         }
00335       <span class="keywordflow">else</span>
00336         sprintf( str, <span class="stringliteral">"GSSAPI-ERROR %d = %s"</span>, code, (<span class="keywordtype">char</span> *)msg.value ) ;
00337       
00338       <span class="keywordflow">if</span>( msg.length != 0 )
00339         gss_release_buffer( &amp;min_stat, &amp;msg ) ;
00340       
00341       <span class="keywordflow">if</span>( !msg_ctx )
00342         break ;
00343     }     
00344 }  <span class="comment">/* sperror_gss_1 */</span>
00345 
00346 <span class="keywordtype">void</span> <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( <span class="keywordtype">char</span> * str, OM_uint32 maj_stat, OM_uint32 min_stat )
00347 {
00348   <span class="keywordtype">char</span> str1[256] ;
00349   <span class="keywordtype">char</span> str2[256] ;
00350   <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( str1, maj_stat, GSS_C_GSS_CODE ) ;
00351   <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( str2, min_stat, GSS_C_MECH_CODE ) ;
00352   
00353   sprintf( str, <span class="stringliteral">"%s ; %s"</span>, str1, str2 ) ;
00354   
00355 }  <span class="comment">/* sperror_gss */</span>
00356 
00357 <span class="preprocessor">#ifdef DEBUG</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ctype.h&gt;</span>
00359 
00360 <span class="keywordtype">void</span> log_status( <span class="keywordtype">char</span> *m, OM_uint32 maj_stat, OM_uint32 min_stat)
00361 {
00362         OM_uint32 min;
00363         gss_buffer_desc msg;
00364         <span class="keywordtype">int</span> msg_ctx = 0;
00365         FILE * tmplog ;
00366 
00367         <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00368         {
00369         fprintf(tmplog, <span class="stringliteral">"Rpcsec_gss: %s: "</span>, m);
00370         
00371         gss_display_status(&amp;min, maj_stat, GSS_C_GSS_CODE, GSS_C_NULL_OID,
00372                            &amp;msg_ctx, &amp;msg);
00373         fprintf(tmplog, <span class="stringliteral">"%s - "</span>, (<span class="keywordtype">char</span> *)msg.value);
00374         gss_release_buffer(&amp;min, &amp;msg);
00375 
00376         gss_display_status(&amp;min, min_stat, GSS_C_MECH_CODE, GSS_C_NULL_OID, &amp;msg_ctx, &amp;msg);
00377         fprintf(tmplog, <span class="stringliteral">"%s\n"</span>, (<span class="keywordtype">char</span> *)msg.value);
00378         gss_release_buffer(&amp;min, &amp;msg);
00379 
00380         fclose( tmplog ) ;
00381         }
00382 }
00383 
00384 <span class="keywordtype">void</span> log_hexdump(<span class="keyword">const</span> u_char *buf, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> offset)
00385 {
00386         u_int i, j, jm;
00387         <span class="keywordtype">int</span> c;
00388         FILE * tmplog ;
00389 
00390         <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00391         {       
00392         fprintf(tmplog, <span class="stringliteral">"\n"</span>);
00393         <span class="keywordflow">for</span> (i = 0; i &lt; len; i += 0x10) {
00394                 fprintf(tmplog, <span class="stringliteral">"  %04x: "</span>, (u_int)(i + offset));
00395                 jm = len - i;
00396                 jm = jm &gt; 16 ? 16 : jm;
00397                 
00398                 <span class="keywordflow">for</span> (j = 0; j &lt; jm; j++) {
00399                         <span class="keywordflow">if</span> ((j % 2) == 1)
00400                                 fprintf(tmplog, <span class="stringliteral">"%02x "</span>, (u_int) buf[i+j]);
00401                         <span class="keywordflow">else</span>
00402                                 fprintf(tmplog, <span class="stringliteral">"%02x"</span>, (u_int) buf[i+j]);
00403                 }
00404                 <span class="keywordflow">for</span> (; j &lt; 16; j++) {
00405                         <span class="keywordflow">if</span> ((j % 2) == 1) printf(<span class="stringliteral">"   "</span>);
00406                         <span class="keywordflow">else</span> fprintf(tmplog, <span class="stringliteral">"  "</span>);
00407                 }
00408                 fprintf(tmplog, <span class="stringliteral">" "</span>);
00409                 
00410                 <span class="keywordflow">for</span> (j = 0; j &lt; jm; j++) {
00411                         c = buf[i+j];
00412                         c = isprint(c) ? c : <span class="charliteral">'.'</span>;
00413                         fprintf(tmplog, <span class="stringliteral">"%c"</span>, c);
00414                 }
00415                 fprintf(tmplog, <span class="stringliteral">"\n"</span>);
00416         }
00417         fclose( tmplog ) ;
00418         }
00419 }
00420 
00421 <span class="preprocessor">#else</span>
00422 <span class="preprocessor"></span>
00423 <span class="keywordtype">void</span> log_status(<span class="keywordtype">char</span> *m, OM_uint32 maj_stat, OM_uint32 min_stat)
00424 {
00425 }
00426 
00427 <span class="keywordtype">void</span> log_hexdump(<span class="keyword">const</span> u_char *buf, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> offset)
00428 {
00429 }
00430 
00431 <span class="preprocessor">#endif</span>
00432 <span class="preprocessor"></span>
00433 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
