<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Xdr_mem.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Xdr_mem.c</h1><a href="Xdr__mem_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="preprocessor">#if defined(LIBC_SCCS) &amp;&amp; !defined(lint)</span>
00031 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="client-gss_8c.html#a12">rcsid</a> = <span class="stringliteral">"$OpenBSD: xdr_mem.c,v 1.6 1996/11/14 06:33:13 etheisen Exp $"</span>;
00032 <span class="preprocessor">#endif </span><span class="comment">/* LIBC_SCCS and not lint */</span>
00033 
00034 <span class="comment">/*</span>
00035 <span class="comment"> * xdr_mem.h, XDR implementation using memory buffers.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * If you have some data to be interpreted as external data representation</span>
00040 <span class="comment"> * or to be converted to external data representation in a memory buffer,</span>
00041 <span class="comment"> * then this is the package for you.</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> */</span>
00044 
00045 <span class="preprocessor">#include &lt;string.h&gt;</span>
00046 
00047 <span class="preprocessor">#include "Types.h"</span>
00048 <span class="preprocessor">#include "Xdr.h"</span>
00049 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00050 
00051 <span class="keyword">static</span> bool_t   Xdrmem_getlong_aligned();
00052 <span class="keyword">static</span> bool_t   Xdrmem_putlong_aligned();
00053 <span class="keyword">static</span> bool_t   Xdrmem_getlong_unaligned();
00054 <span class="keyword">static</span> bool_t   Xdrmem_putlong_unaligned();
00055 <span class="keyword">static</span> bool_t   Xdrmem_getbytes();
00056 <span class="keyword">static</span> bool_t   Xdrmem_putbytes();
00057 <span class="keyword">static</span> u_int    Xdrmem_getpos(); <span class="comment">/* XXX w/64-bit pointers, u_int not enough! */</span>
00058 <span class="keyword">static</span> bool_t   Xdrmem_setpos();
00059 <span class="keyword">static</span> int32_t *Xdrmem_inline_aligned();
00060 <span class="keyword">static</span> int32_t *Xdrmem_inline_unaligned();
00061 <span class="keyword">static</span> <span class="keywordtype">void</span>     Xdrmem_destroy();
00062 
00063 <span class="keyword">static</span> <span class="keyword">struct   </span>Xdr_ops Xdrmem_ops_aligned = {
00064         Xdrmem_getlong_aligned,
00065         Xdrmem_putlong_aligned,
00066         Xdrmem_getbytes,
00067         Xdrmem_putbytes,
00068         Xdrmem_getpos,
00069         Xdrmem_setpos,
00070         Xdrmem_inline_aligned,
00071         Xdrmem_destroy
00072 };
00073 
00074 <span class="keyword">static</span> <span class="keyword">struct   </span>Xdr_ops Xdrmem_ops_unaligned = {
00075         Xdrmem_getlong_unaligned,
00076         Xdrmem_putlong_unaligned,
00077         Xdrmem_getbytes,
00078         Xdrmem_putbytes,
00079         Xdrmem_getpos,
00080         Xdrmem_setpos,
00081         Xdrmem_inline_unaligned,
00082         Xdrmem_destroy
00083 };
00084 
00085 <span class="comment">/*</span>
00086 <span class="comment"> * The procedure Xdrmem_create initializes a stream descriptor for a</span>
00087 <span class="comment"> * memory buffer.  </span>
00088 <span class="comment"> */</span>
00089 <span class="keywordtype">void</span>
<a name="l00090"></a><a class="code" href="Xdr__mem_8c.html#a13">00090</a> <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(xdrs, addr, size, op)
00091         register XDR *xdrs;
00092         caddr_t addr;
00093         u_int size;
00094         enum Xdr_op op;
00095 {
00096 
00097   
00098         xdrs-&gt;x_op = op;
00099         xdrs-&gt;x_ops = ((size_t)addr &amp; (<span class="keyword">sizeof</span>(int32_t) - 1)) ? &amp;Xdrmem_ops_unaligned : &amp;Xdrmem_ops_aligned;
00100         xdrs-&gt;x_private = xdrs-&gt;x_base = addr;
00101         xdrs-&gt;x_handy = size;
00102 }
00103 
00104 <span class="keyword">static</span> <span class="keywordtype">void</span>
00105 Xdrmem_destroy(<span class="comment">/*xdrs*/</span>)
00106         <span class="comment">/*XDR *xdrs;*/</span>
00107 {
00108 
00109 }
00110 
00111 <span class="keyword">static</span> bool_t
00112 Xdrmem_getlong_aligned(xdrs, lp)
00113         register XDR *xdrs;
00114         <span class="keywordtype">long</span> *lp;
00115 {
00116 
00117         <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= <span class="keyword">sizeof</span>(int32_t)) &lt; 0)
00118                 <span class="keywordflow">return</span> (FALSE);
00119         *lp = ntohl(*(int32_t *)xdrs-&gt;x_private);
00120         xdrs-&gt;x_private += <span class="keyword">sizeof</span>(int32_t);
00121         <span class="keywordflow">return</span> (TRUE);
00122 }
00123 
00124 <span class="keyword">static</span> bool_t
00125 Xdrmem_putlong_aligned(xdrs, lp)
00126         register XDR *xdrs;
00127         <span class="keywordtype">long</span> *lp;
00128 {
00129 
00130         <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= <span class="keyword">sizeof</span>(int32_t)) &lt; 0)
00131                 <span class="keywordflow">return</span> (FALSE);
00132         *(int32_t *)xdrs-&gt;x_private = htonl(*lp);
00133         xdrs-&gt;x_private += <span class="keyword">sizeof</span>(int32_t);
00134         <span class="keywordflow">return</span> (TRUE);
00135 }
00136 
00137 <span class="keyword">static</span> bool_t
00138 Xdrmem_getlong_unaligned(xdrs, lp)
00139         register XDR *xdrs;
00140         <span class="keywordtype">long</span> *lp;
00141 {
00142         int32_t l;
00143 
00144         <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= <span class="keyword">sizeof</span>(int32_t)) &lt; 0)
00145                 <span class="keywordflow">return</span> (FALSE);
00146         memcpy(&amp;l, xdrs-&gt;x_private, <span class="keyword">sizeof</span>(int32_t));
00147         *lp = ntohl(l);
00148         xdrs-&gt;x_private += <span class="keyword">sizeof</span>(int32_t);
00149         <span class="keywordflow">return</span> (TRUE);
00150 }
00151 
00152 <span class="keyword">static</span> bool_t
00153 Xdrmem_putlong_unaligned(xdrs, lp)
00154         register XDR *xdrs;
00155         <span class="keywordtype">long</span> *lp;
00156 {
00157         int32_t l;
00158 
00159         <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= <span class="keyword">sizeof</span>(int32_t)) &lt; 0)
00160                 <span class="keywordflow">return</span> (FALSE);
00161         l = htonl(*lp);
00162         memcpy(xdrs-&gt;x_private, &amp;l, <span class="keyword">sizeof</span>(int32_t));
00163         xdrs-&gt;x_private += <span class="keyword">sizeof</span>(int32_t);
00164         <span class="keywordflow">return</span> (TRUE);
00165 }
00166 
00167 <span class="keyword">static</span> bool_t
00168 Xdrmem_getbytes(xdrs, addr, len)
00169         register XDR *xdrs;
00170         caddr_t addr;
00171         register u_int len;
00172 {
00173   <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= len) &lt; 0)
00174     <span class="keywordflow">return</span> (FALSE);
00175     
00176         memcpy(addr, xdrs-&gt;x_private, len);
00177         xdrs-&gt;x_private += len;
00178         <span class="keywordflow">return</span> (TRUE);
00179 }
00180 
00181 <span class="keyword">static</span> bool_t
00182 Xdrmem_putbytes(xdrs, addr, len)
00183         register XDR *xdrs;
00184         caddr_t addr;
00185         register u_int len;
00186 {
00187 
00188         <span class="keywordflow">if</span> ((xdrs-&gt;x_handy -= len) &lt; 0)
00189                 <span class="keywordflow">return</span> (FALSE);
00190         memcpy(xdrs-&gt;x_private, addr, len);
00191         xdrs-&gt;x_private += len;
00192         <span class="keywordflow">return</span> (TRUE);
00193 }
00194 
00195 <span class="keyword">static</span> u_int
00196 Xdrmem_getpos(xdrs)
00197         register XDR *xdrs;
00198 {
00199 
00200         <span class="comment">/* XXX w/64-bit pointers, u_int not enough! */</span>
00201         <span class="keywordflow">return</span> ((u_long)xdrs-&gt;x_private - (u_long)xdrs-&gt;x_base);
00202 }
00203 
00204 <span class="keyword">static</span> bool_t
00205 Xdrmem_setpos(xdrs, pos)
00206         register XDR *xdrs;
00207         u_int pos;
00208 {
00209         <span class="keyword">register</span> caddr_t newaddr = xdrs-&gt;x_base + pos;
00210         <span class="keyword">register</span> caddr_t lastaddr = xdrs-&gt;x_private + xdrs-&gt;x_handy;
00211 
00212         <span class="keywordflow">if</span> ((long)newaddr &gt; (long)lastaddr)
00213                 <span class="keywordflow">return</span> (FALSE);
00214         xdrs-&gt;x_private = newaddr;
00215         xdrs-&gt;x_handy = (long)lastaddr - (long)newaddr;
00216         <span class="keywordflow">return</span> (TRUE);
00217 }
00218 
00219 <span class="keyword">static</span> int32_t *
00220 Xdrmem_inline_aligned(xdrs, len)
00221         register XDR *xdrs;
00222         <span class="keywordtype">int</span> len;
00223 {
00224         int32_t *buf = 0;
00225 
00226         <span class="keywordflow">if</span> (xdrs-&gt;x_handy &gt;= len) {
00227                 xdrs-&gt;x_handy -= len;
00228                 buf = (int32_t *)xdrs-&gt;x_private;
00229                 xdrs-&gt;x_private += len;
00230         }
00231         <span class="keywordflow">return</span> (buf);
00232 }
00233 
00234 <span class="comment">/* ARGSUSED */</span>
00235 <span class="keyword">static</span> int32_t *
00236 Xdrmem_inline_unaligned(xdrs, len)
00237         register XDR *xdrs;
00238         <span class="keywordtype">int</span> len;
00239 {
00240 
00241         <span class="keywordflow">return</span> (0);
00242 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
