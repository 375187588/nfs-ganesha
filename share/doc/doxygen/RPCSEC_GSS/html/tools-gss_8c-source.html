<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: tools-gss.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>tools-gss.c</h1><a href="tools-gss_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *</span>
00003 <span class="comment"> * Une boite a outils pour utiliser la GSSAPI </span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> */</span>
00006 
<a name="l00007"></a><a class="code" href="tools-gss_8c.html#a21">00007</a> <span class="keywordtype">char</span> <a class="code" href="Release__gss__buffer_8c.html#a21">rcsid_tools</a>[] = <span class="stringliteral">"$Id: tools-gss.c,v 1.1 2005/04/13 13:45:49 deniel Exp $"</span> ;
00008 
00009 <span class="comment">/* Un tas d'include pour avoir les bindings standards */</span>
00010 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00011 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00013 <span class="preprocessor">#include &lt;string.h&gt;</span>
00014 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00015 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00016 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00017 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00018 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00019 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00020 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00021 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00022 <span class="preprocessor">#include &lt;netinet/tcp.h&gt;</span>
00023 
00024 <span class="preprocessor">#include &lt;gssapi/gssapi.h&gt;</span>  <span class="comment">/* Header de la gssapi */</span>
00025 <span class="preprocessor">#include &lt;gssapi/gssapi_generic.h&gt;</span>
00026 
<a name="l00027"></a><a class="code" href="tools-gss_8c.html#a0">00027</a> <span class="preprocessor">#define gss_wrap gss_seal</span>
<a name="l00028"></a><a class="code" href="tools-gss_8c.html#a1">00028</a> <span class="preprocessor"></span><span class="preprocessor">#define gss_unwrap gss_unseal </span>
<a name="l00029"></a><a class="code" href="tools-gss_8c.html#a2">00029</a> <span class="preprocessor"></span><span class="preprocessor">#define gss_get_mic gss_sign </span>
<a name="l00030"></a><a class="code" href="tools-gss_8c.html#a3">00030</a> <span class="preprocessor"></span><span class="preprocessor">#define gss_verify_mic gss_verify</span>
<a name="l00031"></a><a class="code" href="tools-gss_8c.html#a4">00031</a> <span class="preprocessor"></span><span class="preprocessor">#define gss_qop_t OM_uint32 </span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#define TOKEN_NOOP              (1&lt;&lt;0)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_CONTEXT           (1&lt;&lt;1)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_DATA              (1&lt;&lt;2)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_MIC               (1&lt;&lt;3)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_CONTEXT_NEXT      (1&lt;&lt;4)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_WRAPPED           (1&lt;&lt;5)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_ENCRYPTED         (1&lt;&lt;6)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_SEND_MIC          (1&lt;&lt;7)</span>
<a name="l00041"></a><a class="code" href="tools-gss_8c.html#a13">00041</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_NOOP              (1&lt;&lt;0)</span>
<a name="l00042"></a><a class="code" href="tools-gss_8c.html#a14">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_CONTEXT           (1&lt;&lt;1)</span>
<a name="l00043"></a><a class="code" href="tools-gss_8c.html#a15">00043</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_DATA              (1&lt;&lt;2)</span>
<a name="l00044"></a><a class="code" href="tools-gss_8c.html#a16">00044</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_MIC               (1&lt;&lt;3)</span>
<a name="l00045"></a><a class="code" href="tools-gss_8c.html#a17">00045</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_CONTEXT_NEXT      (1&lt;&lt;4)</span>
<a name="l00046"></a><a class="code" href="tools-gss_8c.html#a18">00046</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_WRAPPED           (1&lt;&lt;5)</span>
<a name="l00047"></a><a class="code" href="tools-gss_8c.html#a19">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_ENCRYPTED         (1&lt;&lt;6)</span>
<a name="l00048"></a><a class="code" href="tools-gss_8c.html#a20">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_SEND_MIC          (1&lt;&lt;7)</span>
00049 <span class="preprocessor"></span>
00050 <span class="comment">/* </span>
00051 <span class="comment"> * convertir une erreur GSSAPI Major/Minor en un message lisible </span>
00052 <span class="comment"> */</span>
00053 
<a name="l00054"></a><a class="code" href="tools-gss_8c.html#a22">00054</a> <span class="keywordtype">void</span> <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( <span class="keywordtype">char</span> * str, OM_uint32 code, <span class="keywordtype">int</span> type )
00055 {
00056   gss_buffer_desc  msg = GSS_C_EMPTY_BUFFER  ;
00057   OM_uint32 msg_ctx   ;
00058   OM_uint32 maj_stat, min_stat ;
00059   
00060   msg_ctx = 0 ;
00061   <span class="keywordflow">while</span> ( 1 ) 
00062     {
00063       <span class="keywordflow">if</span>( ( maj_stat = gss_display_status( &amp;min_stat, code, type, GSS_C_NULL_OID, &amp;msg_ctx, &amp;msg ) ) != GSS_S_COMPLETE )
00064         {
00065           sprintf( str, <span class="stringliteral">"Erreur %d intraduisible par gss_display_status: code retour = %d.%d"</span>, 
00066                    code, maj_stat, min_stat ) ;
00067           break ;
00068         }
00069       <span class="keywordflow">else</span>
00070         sprintf( str, <span class="stringliteral">"GSSAPI-ERROR %d = %s"</span>, code, (<span class="keywordtype">char</span> *)msg.value ) ;
00071       
00072       <span class="keywordflow">if</span>( msg.length != 0 )
00073         gss_release_buffer( &amp;min_stat, &amp;msg ) ;
00074       
00075       <span class="keywordflow">if</span>( !msg_ctx )
00076         break ;
00077     }     
00078 }  <span class="comment">/* sperror_gss_1 */</span>
00079 
<a name="l00080"></a><a class="code" href="tools-gss_8h.html#a16">00080</a> <span class="keywordtype">void</span> <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( <span class="keywordtype">char</span> * str, OM_uint32 maj_stat, OM_uint32 min_stat )
00081 {
00082   <span class="keywordtype">char</span> str1[256] ;
00083   <span class="keywordtype">char</span> str2[256] ;
00084   <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( str1, maj_stat, GSS_C_GSS_CODE ) ;
00085   <a class="code" href="tools-gss_8c.html#a22">sperror_gss_1</a>( str2, min_stat, GSS_C_MECH_CODE ) ;
00086   
00087   sprintf( str, <span class="stringliteral">"%s ; %s"</span>, str1, str2 ) ;
00088   
00089 }  <span class="comment">/* sperror_gss */</span>
00090 <span class="keyword">static</span> <span class="keywordtype">int</span> write_all(<span class="keywordtype">int</span> fildes, <span class="keywordtype">char</span> *buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbyte)
00091 {
00092      <span class="keywordtype">int</span> ret;
00093      <span class="keywordtype">char</span> *ptr;
00094 
00095      <span class="keywordflow">for</span> (ptr = buf; nbyte; ptr += ret, nbyte -= ret) {
00096           ret = send(fildes, ptr, nbyte, 0);
00097           <span class="keywordflow">if</span> (ret &lt; 0) {
00098                <span class="keywordflow">if</span> (errno == EINTR)
00099                     <span class="keywordflow">continue</span>;
00100                <span class="keywordflow">return</span>(ret);
00101           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret == 0) {
00102                <span class="keywordflow">return</span>(ptr-buf);
00103           }
00104      }
00105 
00106      <span class="keywordflow">return</span>(ptr-buf);
00107 }
00108 
00109 <span class="keyword">static</span> <span class="keywordtype">int</span> read_all(<span class="keywordtype">int</span> fildes, <span class="keywordtype">char</span> *buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbyte)
00110 {
00111      <span class="keywordtype">int</span> ret;
00112      <span class="keywordtype">char</span> *ptr;
00113 
00114      <span class="keywordflow">for</span> (ptr = buf; nbyte; ptr += ret, nbyte -= ret) {
00115           ret = recv(fildes, ptr, nbyte, 0);
00116           <span class="keywordflow">if</span> (ret &lt; 0) {
00117                <span class="keywordflow">if</span> (errno == EINTR)
00118                     <span class="keywordflow">continue</span>;
00119                <span class="keywordflow">return</span>(ret);
00120           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret == 0) {
00121                <span class="keywordflow">return</span>(ptr-buf);
00122           }
00123      }
00124 
00125      <span class="keywordflow">return</span>(ptr-buf);
00126 }
00127 
00128 <span class="comment">/*</span>
00129 <span class="comment"> * Function: send_token</span>
00130 <span class="comment"> *</span>
00131 <span class="comment"> * Purpose: Writes a token to a file descriptor.</span>
00132 <span class="comment"> *</span>
00133 <span class="comment"> * Arguments:</span>
00134 <span class="comment"> *</span>
00135 <span class="comment"> *      s               (r) an open file descriptor</span>
00136 <span class="comment"> *      flags           (r) the flags to write</span>
00137 <span class="comment"> *      tok             (r) the token to write</span>
00138 <span class="comment"> *</span>
00139 <span class="comment"> * Returns: 0 on success, -1 on failure</span>
00140 <span class="comment"> *</span>
00141 <span class="comment"> * Effects:</span>
00142 <span class="comment"> *</span>
00143 <span class="comment"> * send_token writes the token flags (a single byte, even though</span>
00144 <span class="comment"> * they're passed in in an integer), then the token length (as a</span>
00145 <span class="comment"> * network long) and then the token data to the file descriptor s.  It</span>
00146 <span class="comment"> * returns 0 on success, and -1 if an error occurs or if it could not</span>
00147 <span class="comment"> * write all the data.</span>
00148 <span class="comment"> */</span>
<a name="l00149"></a><a class="code" href="tools-gss_8c.html#a26">00149</a> <span class="keywordtype">int</span> <a class="code" href="tools-gss_8c.html#a26">send_token</a>(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> flags, gss_buffer_t tok)
00150 {
00151   <span class="keywordtype">int</span> len, ret;
00152   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> char_flags = (<span class="keywordtype">unsigned</span> char) flags;
00153   
00154   ret = write_all(s, (<span class="keywordtype">char</span> *)&amp;char_flags, 1);
00155   <span class="keywordflow">if</span> (ret != 1) {
00156     perror(<span class="stringliteral">"sending token flags"</span>);
00157     <span class="keywordflow">return</span> -1;
00158   }
00159   
00160   len = htonl(tok-&gt;length);
00161 
00162   ret = write_all(s, (<span class="keywordtype">char</span> *) &amp;len, 4);
00163   <span class="keywordflow">if</span> (ret &lt; 0)
00164     {
00165       perror(<span class="stringliteral">"sending token length"</span>);
00166       <span class="keywordflow">return</span> -1;
00167     } 
00168   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != 4)
00169     {
00170       <span class="keywordflow">if</span> (stderr)
00171         fprintf(stderr,<span class="stringliteral">"sending token length: %d of %d bytes written\n"</span>, 
00172                 ret, 4);
00173       <span class="keywordflow">return</span> -1;
00174     }
00175   
00176   printf( <span class="stringliteral">"send_token   tok-&gt;length = %d\n"</span>, tok-&gt;length ) ;
00177 
00178   ret = write_all(s, tok-&gt;value, tok-&gt;length);
00179   <span class="keywordflow">if</span> (ret &lt; 0) 
00180     {
00181       perror(<span class="stringliteral">"sending token data"</span>);
00182       <span class="keywordflow">return</span> -1;
00183     } 
00184   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != tok-&gt;length) 
00185     {
00186       <span class="keywordflow">if</span> (stderr)
00187         fprintf( stderr, <span class="stringliteral">"sending token data: %d of %d bytes written\n"</span>, 
00188                  ret, tok-&gt;length);
00189       <span class="keywordflow">return</span> -1;
00190     }
00191   
00192   <span class="keywordflow">return</span> 0;
00193 }
00194 
00195 <span class="comment">/*</span>
00196 <span class="comment"> * Function: recv_token</span>
00197 <span class="comment"> *</span>
00198 <span class="comment"> * Purpose: Reads a token from a file descriptor.</span>
00199 <span class="comment"> *</span>
00200 <span class="comment"> * Arguments:</span>
00201 <span class="comment"> *</span>
00202 <span class="comment"> *      s               (r) an open file descriptor</span>
00203 <span class="comment"> *      flags           (w) the read flags</span>
00204 <span class="comment"> *      tok             (w) the read token</span>
00205 <span class="comment"> *</span>
00206 <span class="comment"> * Returns: 0 on success, -1 on failure</span>
00207 <span class="comment"> *</span>
00208 <span class="comment"> * Effects:</span>
00209 <span class="comment"> * </span>
00210 <span class="comment"> * recv_token reads the token flags (a single byte, even though</span>
00211 <span class="comment"> * they're stored into an integer, then reads the token length (as a</span>
00212 <span class="comment"> * network long), allocates memory to hold the data, and then reads</span>
00213 <span class="comment"> * the token data from the file descriptor s.  It blocks to read the</span>
00214 <span class="comment"> * length and data, if necessary.  On a successful return, the token</span>
00215 <span class="comment"> * should be freed with gss_release_buffer.  It returns 0 on success,</span>
00216 <span class="comment"> * and -1 if an error occurs or if it could not read all the data.</span>
00217 <span class="comment"> */</span>
<a name="l00218"></a><a class="code" href="tools-gss_8h.html#a21">00218</a> <span class="keywordtype">int</span> <a class="code" href="tools-gss_8h.html#a21">recv_token</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> * flags, gss_buffer_t tok)
00219 {
00220      <span class="keywordtype">int</span> ret;
00221      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> char_flags;
00222 
00223      ret = read_all(s, (<span class="keywordtype">char</span> *) &amp;char_flags, 1);
00224      <span class="keywordflow">if</span> (ret &lt; 0)
00225        {
00226          perror(<span class="stringliteral">"reading token flags"</span>);
00227          <span class="keywordflow">return</span> -1;
00228        } 
00229      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! ret)
00230        {
00231          <span class="keywordflow">if</span> (stderr)
00232            fputs(<span class="stringliteral">"reading token flags: 0 bytes read\n"</span>, stderr);
00233          <span class="keywordflow">return</span> -1;
00234        } 
00235      <span class="keywordflow">else</span> 
00236        {
00237          *flags = (int) char_flags;
00238        }
00239 
00240      ret = read_all(s, (<span class="keywordtype">char</span> *) &amp;tok-&gt;length, 4);
00241      <span class="keywordflow">if</span> (ret &lt; 0)
00242        {
00243          perror(<span class="stringliteral">"reading token length"</span>);
00244          <span class="keywordflow">return</span> -1;
00245        } 
00246      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != 4)
00247        {
00248          <span class="keywordflow">if</span> (stderr)
00249            fprintf(stderr, 
00250                    <span class="stringliteral">"reading token length: %d of %d bytes read\n"</span>, 
00251                    ret, 4);
00252          <span class="keywordflow">return</span> -1;
00253        }
00254      
00255      tok-&gt;length = ntohl(tok-&gt;length);
00256      tok-&gt;value = (<span class="keywordtype">char</span> *) malloc(tok-&gt;length); 
00257      <span class="keywordflow">if</span> (tok-&gt;length &amp;&amp; tok-&gt;value == NULL)
00258        {
00259          <span class="keywordflow">if</span> (stderr)
00260            fprintf(stderr, 
00261                    <span class="stringliteral">"Out of memory allocating token data\n"</span>);
00262          <span class="keywordflow">return</span> -1;
00263        }
00264 
00265      printf( <span class="stringliteral">"recv_token   tok-&gt;length = %d\n"</span>, tok-&gt;length ) ;
00266 
00267      ret = read_all(s, (<span class="keywordtype">char</span> *) tok-&gt;value, tok-&gt;length);
00268      <span class="keywordflow">if</span> (ret &lt; 0)
00269        {
00270          perror(<span class="stringliteral">"reading token data"</span>);
00271          free( tok-&gt;value ) ;
00272          <span class="keywordflow">return</span> -1;
00273        } 
00274      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != tok-&gt;length)
00275        {
00276          fprintf(stderr, <span class="stringliteral">"sending token data: %d of %d bytes written\n"</span>, 
00277                  ret, tok-&gt;length);
00278          free(tok-&gt;value);
00279          <span class="keywordflow">return</span> -1;
00280        }
00281      
00282      <span class="keywordflow">return</span> 0;
00283 }
00284 
<a name="l00285"></a><a class="code" href="tools-gss_8h.html#a20">00285</a> <span class="keywordtype">int</span> <a class="code" href="tools-gss_8h.html#a20">send_msg</a>( <span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> * msg, gss_ctx_id_t context, <span class="keywordtype">char</span> * errbuff )
00286 {
00287   gss_buffer_desc clear_buf ;
00288   gss_buffer_desc code_buf ;
00289   gss_buffer_desc mic_buf ;
00290   OM_uint32       maj_stat, min_stat ;
00291   <span class="keywordtype">int</span>             encrypt_flag = 1 ;
00292   <span class="keywordtype">int</span>             state ;
00293   <span class="keywordtype">int</span>             tok_flags ;
00294   <a class="code" href="Release__gss__buffer_8c.html#a4">gss_qop_t</a>                 qop_state;
00295   
00296   clear_buf.value = msg ;
00297   clear_buf.length = strlen( msg ) +1  ; <span class="comment">/* pour garder le \0 final */</span>
00298 
00299   <span class="comment">/* Wrapping du message */</span>
00300   <span class="keywordflow">if</span>( ( maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a0">gss_wrap</a>( &amp;min_stat, 
00301                              context, 
00302                              encrypt_flag, 
00303                              GSS_C_QOP_DEFAULT,
00304                              &amp;clear_buf, 
00305                              &amp;state, 
00306                              &amp;code_buf ) ) != GSS_S_COMPLETE )
00307     {
00308       <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( errbuff, maj_stat, min_stat ) ;
00309       printf( <span class="stringliteral">"erreur gss_wrap \n"</span> ) ;
00310       <span class="keywordflow">return</span> -1 ;
00311     }
00312 
00313   <span class="keywordflow">if</span>( !state )
00314     {
00315       sprintf( errbuff, <span class="stringliteral">"buffer non encode !!"</span> ) ;
00316       <span class="keywordflow">return</span> -1 ;
00317     }
00318 
00319   <span class="comment">/* Envoi de la chose encode */</span>
00320   <span class="keywordflow">if</span>( <a class="code" href="tools-gss_8c.html#a26">send_token</a>( fd, (<a class="code" href="client-gss_8c.html#a2">TOKEN_DATA</a>|<a class="code" href="client-gss_8c.html#a5">TOKEN_WRAPPED</a>|<a class="code" href="client-gss_8c.html#a6">TOKEN_ENCRYPTED</a>), &amp;code_buf ) &lt; 0 )
00321     {
00322       sprintf( errbuff, <span class="stringliteral">"pb dans send_token"</span> ) ;
00323       <span class="keywordflow">return</span> -1 ;
00324     }
00325   
00326   <span class="comment">/* reception de la mic */</span>
00327   <span class="keywordflow">if</span>( <a class="code" href="tools-gss_8h.html#a21">recv_token</a>( fd, &amp;tok_flags, &amp;mic_buf ) )
00328     {
00329       sprintf( errbuff, <span class="stringliteral">"pb dans recv_token"</span> ) ;
00330       <span class="keywordflow">return</span> -1 ;
00331     }
00332 
00333   <span class="comment">/* Verification de la mic */</span>
00334   <span class="keywordflow">if</span>( ( maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a3">gss_verify_mic</a>( &amp;min_stat, 
00335                                    context, 
00336                                    &amp;clear_buf,
00337                                    &amp;mic_buf , 
00338                                    &amp;qop_state ) ) != GSS_S_COMPLETE )
00339     {
00340       <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( errbuff, maj_stat, min_stat ) ;
00341       printf( <span class="stringliteral">"Erreur gss_verify_mic\n"</span> ) ;
00342       <span class="keywordflow">return</span> -1 ;
00343     }
00344   
00345   <span class="keywordflow">return</span> 0 ;
00346 }
00347 
<a name="l00348"></a><a class="code" href="tools-gss_8h.html#a19">00348</a> <span class="keywordtype">int</span> <a class="code" href="tools-gss_8h.html#a19">recv_msg</a>( <span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> * msg, gss_ctx_id_t context, <span class="keywordtype">char</span> * errbuff ) 
00349 {
00350   gss_buffer_desc code_buf ;
00351   gss_buffer_desc clear_buf ;
00352   gss_buffer_desc mic_buf ;
00353   <span class="keywordtype">int</span>             ret_flags ;
00354   <span class="keywordtype">int</span>             conf_state ;
00355   OM_uint32       maj_stat, min_stat ;
00356   
00357   <span class="keywordflow">if</span>( <a class="code" href="tools-gss_8h.html#a21">recv_token</a>( fd, &amp;ret_flags, &amp;code_buf ) &lt; 0 )
00358     {
00359       sprintf( errbuff, <span class="stringliteral">"erreur dans recv_token"</span> ) ;
00360       <span class="keywordflow">return</span> -1 ;
00361     }
00362   
00363   <span class="comment">/* Unwrapping du message */</span>
00364   <span class="keywordflow">if</span>( ( maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a1">gss_unwrap</a>( &amp;min_stat, 
00365                                context, 
00366                                &amp;code_buf,
00367                                &amp;clear_buf, 
00368                                &amp;conf_state, 
00369                                (OM_uint32 *)NULL ) ) != GSS_S_COMPLETE )
00370     {
00371       <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( errbuff, maj_stat, min_stat ) ;
00372       <span class="keywordflow">return</span> -1 ;
00373     }
00374 
00375   <span class="keywordflow">if</span>( !conf_state )
00376     {
00377       sprintf( errbuff, <span class="stringliteral">"message non encrypte"</span> ) ;
00378     }
00379 
00380   <span class="comment">/* Calcul de la mic */</span>
00381   <span class="keywordflow">if</span>( ( maj_stat = <a class="code" href="Release__gss__buffer_8c.html#a2">gss_get_mic</a>( &amp;min_stat, 
00382                                 context, 
00383                                 GSS_C_QOP_DEFAULT, 
00384                                 &amp;clear_buf, 
00385                                 &amp;mic_buf ) ) != GSS_S_COMPLETE )
00386     {
00387       <a class="code" href="tools-gss_8h.html#a16">sperror_gss</a>( errbuff, maj_stat, min_stat ) ;
00388       <span class="keywordflow">return</span> -1 ;
00389     }
00390   
00391   <span class="keywordflow">if</span>( <a class="code" href="tools-gss_8c.html#a26">send_token</a>( fd, <a class="code" href="client-gss_8c.html#a3">TOKEN_MIC</a>, &amp;mic_buf ) &lt; 0 )
00392     {
00393       sprintf( errbuff, <span class="stringliteral">"erreur dans send_token"</span> ) ;
00394       <span class="keywordflow">return</span> -1 ;
00395     } 
00396 
00397   strncpy( msg, clear_buf.value, clear_buf.length ) ;
00398   
00399   <span class="keywordflow">return</span> 0;
00400 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
