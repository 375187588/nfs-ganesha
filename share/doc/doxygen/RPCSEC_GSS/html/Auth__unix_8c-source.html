<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Auth_unix.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Auth_unix.c</h1><a href="Auth__unix_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 Paul Ashley</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> * </span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00007 <span class="comment"> * are met:</span>
00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00009 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00011 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
00012 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
00013 <span class="comment"> * 3. All advertising materials mentioning features or use of this software</span>
00014 <span class="comment"> *    must display the following acknowledgement:</span>
00015 <span class="comment"> *      This product includes software developed by Paul Ashley while in</span>
00016 <span class="comment"> *      the employ of the Queensland University of Technology.</span>
00017 <span class="comment"> * 4. The name of the author may not be used to endorse or promote products</span>
00018 <span class="comment"> *    derived from this software without specific prior written permission.</span>
00019 <span class="comment"> * </span>
00020 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</span>
00021 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00022 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
00023 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
00024 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00025 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
00029 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> */</span>
00031 <span class="comment">/* @(#)auth_unix.c      2.2 88/08/01 4.0 RPCSRC */</span>
00032 <span class="comment">/*</span>
00033 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00034 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00035 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00036 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00037 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00038 <span class="comment"> * program developed by the user.</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00041 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00042 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00045 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00046 <span class="comment"> * modification or enhancement.</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00049 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00050 <span class="comment"> * OR ANY PART THEREOF.</span>
00051 <span class="comment"> *</span>
00052 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00053 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00054 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00055 <span class="comment"> *</span>
00056 <span class="comment"> * Sun Microsystems, Inc.</span>
00057 <span class="comment"> * 2550 Garcia Avenue</span>
00058 <span class="comment"> * Mountain View, California  94043</span>
00059 <span class="comment"> */</span>
00060 
00061 <span class="comment">/*</span>
00062 <span class="comment"> * auth_unix.c, Implements UNIX style authentication parameters.</span>
00063 <span class="comment"> *</span>
00064 <span class="comment"> * Copyright (C) 1984, Sun Microsystems, Inc.</span>
00065 <span class="comment"> *</span>
00066 <span class="comment"> * The system is very weak.  The client uses no encryption for it's</span>
00067 <span class="comment"> * credentials and only sends null verifiers.  The server sends backs</span>
00068 <span class="comment"> * null verifiers or optionally a verifier that suggests a new short hand</span>
00069 <span class="comment"> * for the credentials.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> */</span>
00072 
00073 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00074 <span class="preprocessor">#include "Auth.h"</span>
00075 <span class="preprocessor">#include "Auth_unix.h"</span>
00076 
00077 <span class="comment">/*</span>
00078 <span class="comment"> * Unix authenticator operations vector</span>
00079 <span class="comment"> */</span>
00080 <span class="keyword">static</span> <span class="keywordtype">void</span>       Authunix_nextverf();
00081 <span class="keyword">static</span> bool_t   Authunix_marshal();
00082 <span class="keyword">static</span> bool_t   Authunix_validate();
00083 <span class="keyword">static</span> bool_t   Authunix_refresh();
00084 <span class="keyword">static</span> <span class="keywordtype">void</span>       Authunix_destroy();
00085 <span class="keyword">static</span> bool_t Authunix_wrap() ;
00086 <span class="keyword">static</span> bool_t Authunix_unwrap() ;
00087 
00088 <span class="keyword">static</span> <span class="keyword">struct </span>Auth_ops auth_unix_ops = {
00089         Authunix_nextverf,
00090         Authunix_marshal,
00091         Authunix_validate,
00092         Authunix_refresh,
00093         Authunix_destroy,
00094   Authunix_wrap, 
00095   Authunix_unwrap
00096 };
00097 
00098 <span class="comment">/*</span>
00099 <span class="comment"> * This struct is pointed to by the ah_private field of an auth_handle.</span>
00100 <span class="comment"> */</span>
<a name="l00101"></a><a class="code" href="structAudata.html">00101</a> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> {
<a name="l00102"></a><a class="code" href="structAudata.html#o0">00102</a>         <span class="keyword">struct </span>opaque_auth      au_origcred;    <span class="comment">/* original credentials */</span>
<a name="l00103"></a><a class="code" href="structAudata.html#o1">00103</a>         <span class="keyword">struct </span>opaque_auth      au_shcred;      <span class="comment">/* short hand cred */</span>
<a name="l00104"></a><a class="code" href="structAudata.html#o2">00104</a>         u_long                  au_shfaults;    <span class="comment">/* short hand cache faults */</span>
<a name="l00105"></a><a class="code" href="structAudata.html#o3">00105</a>         <span class="keywordtype">char</span>                    au_marshed[MAX_AUTH_BYTES];
<a name="l00106"></a><a class="code" href="structAudata.html#o4">00106</a>         u_int                   au_mpos;        <span class="comment">/* xdr pos at end of marshed */</span>
00107 };
<a name="l00108"></a><a class="code" href="Auth__unix_8c.html#a0">00108</a> <span class="preprocessor">#define AUTH_PRIVATE(auth)      ((struct Audata *)auth-&gt;ah_private)</span>
00109 <span class="preprocessor"></span>
00110 <span class="keyword">static</span> bool_t marshal_new_auth();
00111 
00112 
00113 <span class="comment">/*</span>
00114 <span class="comment"> * Create a unix style authenticator.</span>
00115 <span class="comment"> * Returns an auth handle with the given stuff in it.</span>
00116 <span class="comment"> */</span>
<a name="l00117"></a><a class="code" href="Auth__unix_8c.html#a10">00117</a> AUTH * <a class="code" href="Auth__unix_8c.html#a10">Authunix_create</a>( <span class="keywordtype">char</span> *  machname, uid_t uid, gid_t gid, <span class="keywordtype">int</span> len, gid_t * aup_gids)
00118 {
00119         <span class="keyword">struct </span>Authunix_parms aup;
00120         <span class="keywordtype">char</span> mymem[MAX_AUTH_BYTES];
00121         <span class="keyword">struct </span>timeval now;
00122         XDR xdrs;
00123         <span class="keyword">register</span> AUTH *auth;
00124         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au;
00125         FILE * tmplog ;
00126 
00127 
00128         <span class="comment">/*</span>
00129 <span class="comment">         * Allocate and set up auth handle</span>
00130 <span class="comment">         */</span>
00131         auth = (AUTH *)mem_alloc(<span class="keyword">sizeof</span>(*auth));
00132         <span class="keywordflow">if</span> (auth == NULL) {
00133                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00134                    {
00135                         (void)fprintf(tmplog, <span class="stringliteral">"Authunix_create: out of memory\n"</span>);
00136                         fclose( tmplog ) ;
00137                    }
00138                 <span class="keywordflow">return</span> (NULL);
00139         }
00140 
00141         au = (<span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *)mem_alloc(<span class="keyword">sizeof</span>(*au));
00142 
00143         <span class="keywordflow">if</span> (au == NULL) {
00144                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00145                   {
00146                         (void)fprintf(tmplog, <span class="stringliteral">"Authunix_create: out of memory\n"</span>);
00147                         fclose( tmplog ) ;
00148                   }
00149                 <span class="keywordflow">return</span> (NULL);
00150         }
00151 
00152         auth-&gt;ah_ops = &amp;auth_unix_ops;
00153         auth-&gt;ah_private = (caddr_t)au;
00154         auth-&gt;ah_verf = au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a> = _null_auth;
00155         au-&gt;<a class="code" href="structAudata.html#o2">au_shfaults</a> = 0;
00156 
00157         <span class="comment">/*</span>
00158 <span class="comment">         * fill in param struct from the given params</span>
00159 <span class="comment">         */</span>
00160         (void)gettimeofday(&amp;now,  (<span class="keyword">struct</span> timezone *)0);
00161         aup.aup_time = now.tv_sec;
00162         aup.aup_machname = machname;
00163         aup.aup_uid = uid;
00164         aup.aup_gid = gid;
00165         aup.aup_len = (u_int)len;
00166         aup.aup_gids = (u_int *)aup_gids;
00167 
00168         <span class="comment">/*</span>
00169 <span class="comment">         * Serialize the parameters into origcred</span>
00170 <span class="comment">         */</span>
00171         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;xdrs, mymem, MAX_AUTH_BYTES, XDR_ENCODE);
00172         <span class="keywordflow">if</span> (! <a class="code" href="Authuxprot_8c.html#a0">Xdr_Authunix_parms</a>(&amp;xdrs, &amp;aup))
00173                 abort();
00174         au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_length = len = XDR_GETPOS(&amp;xdrs);
00175         au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_flavor = AUTH_UNIX;
00176 
00177         <span class="keywordflow">if</span>( ( au-&gt;au_origcred.oa_base = (caddr_t)mem_alloc( (u_int)len ) ) == NULL) 
00178     {
00179         <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00180            {
00181                 (void)fprintf(tmplog, <span class="stringliteral">"Authunix_create: out of memory\n"</span>);
00182                 fclose( tmplog ) ;
00183            }
00184       <span class="keywordflow">return</span> (NULL);
00185     }
00186 
00187         bcopy(mymem, au-&gt;au_origcred.oa_base, (u_int)len);
00188 
00189         <span class="comment">/*</span>
00190 <span class="comment">         * set auth handle to reflect new cred.</span>
00191 <span class="comment">         */</span>
00192         auth-&gt;ah_cred = au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>;
00193         marshal_new_auth(auth);
00194         <span class="keywordflow">return</span> (auth);
00195 }
00196 
00197 <span class="comment">/*</span>
00198 <span class="comment"> * Returns an auth handle with parameters determined by doing lots of</span>
00199 <span class="comment"> * syscalls.</span>
00200 <span class="comment"> */</span>
<a name="l00201"></a><a class="code" href="Auth__unix_8c.html#a11">00201</a> AUTH * <a class="code" href="Auth__unix_8c.html#a11">Authunix_create_default</a>()
00202 {
00203         <span class="keyword">register</span> <span class="keywordtype">int</span> len;
00204         <span class="keywordtype">char</span> machname[MAX_MACHINE_NAME + 1];
00205         <span class="keyword">register</span> uid_t uid;
00206         <span class="keyword">register</span> gid_t gid;
00207         <span class="keywordtype">int</span> max_nr_groups = NGRPS;
00208         gid_t gids[NGRPS];
00209 
00210         <span class="keywordflow">if</span> (gethostname(machname, MAX_MACHINE_NAME) == -1)
00211                 abort();
00212         machname[MAX_MACHINE_NAME] = 0;
00213         uid = geteuid();
00214         gid = getegid();
00215 
00216         <span class="keywordflow">if</span> ((len = getgroups(max_nr_groups, gids)) &lt; 0)
00217                 abort();
00218         <span class="comment">/* This braindamaged Sun code forces us here to truncate the</span>
00219 <span class="comment">           list of groups to NGRPS members since the code in</span>
00220 <span class="comment">           authuxprot.c transforms a fixed array.  Grrr.  */</span>
00221         <span class="keywordflow">return</span> (<a class="code" href="Auth__unix_8c.html#a10">Authunix_create</a>(machname, uid, gid, MIN (NGRPS, len), gids));
00222 }
00223 
00224 <span class="comment">/*</span>
00225 <span class="comment"> * Authunix operations</span>
00226 <span class="comment"> */</span>
00227 
00228 <span class="keyword">static</span> <span class="keywordtype">void</span> Authunix_nextverf( AUTH * auth)
00229 {
00230         <span class="comment">/* no action necessary */</span>
00231 }
00232 
00233 <span class="keyword">static</span> bool_t Authunix_marshal( AUTH * auth, XDR * xdrs)
00234 {
00235         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00236 
00237         <span class="keywordflow">return</span> (XDR_PUTBYTES(xdrs, au-&gt;<a class="code" href="structAudata.html#o3">au_marshed</a>, au-&gt;<a class="code" href="structAudata.html#o4">au_mpos</a>));
00238 }
00239 
00240 <span class="keyword">static</span> bool_t Authunix_validate( AUTH * auth, <span class="keyword">struct</span> opaque_auth * verf)
00241 {
00242         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au;
00243         XDR xdrs;
00244 
00245         <span class="keywordflow">if</span> (verf-&gt;oa_flavor == AUTH_SHORT) {
00246                 au = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00247                 <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;xdrs, verf-&gt;oa_base, verf-&gt;oa_length,
00248                               XDR_DECODE);
00249 
00250                 <span class="keywordflow">if</span> (au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base != NULL) {
00251                         mem_free(au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base,
00252                             au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_length);
00253                         au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base = NULL;
00254                 }
00255                 <span class="keywordflow">if</span> (<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(&amp;xdrs, &amp;au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>)) {
00256                         auth-&gt;ah_cred = au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>;
00257                 } <span class="keywordflow">else</span> {
00258                         xdrs.x_op = XDR_FREE;
00259                         (void)<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(&amp;xdrs, &amp;au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>);
00260                         au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base = NULL;
00261                         auth-&gt;ah_cred = au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>;
00262                 }
00263                 marshal_new_auth(auth);
00264         }
00265         <span class="keywordflow">return</span> (TRUE);
00266 }
00267 
00268 <span class="keyword">static</span> bool_t Authunix_refresh( AUTH * auth)
00269 {
00270         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00271         <span class="keyword">struct </span>Authunix_parms aup;
00272         <span class="keyword">struct </span>timeval now;
00273         XDR xdrs;
00274         <span class="keyword">register</span> <span class="keywordtype">int</span> stat;
00275 
00276         <span class="keywordflow">if</span> (auth-&gt;ah_cred.oa_base == au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_base) {
00277                 <span class="comment">/* there is no hope.  Punt */</span>
00278                 <span class="keywordflow">return</span> (FALSE);
00279         }
00280         au-&gt;<a class="code" href="structAudata.html#o2">au_shfaults</a> ++;
00281 
00282         <span class="comment">/* first deserialize the creds back into a struct Authunix_parms */</span>
00283         aup.aup_machname = NULL;
00284         aup.aup_gids = (u_int *)NULL;
00285         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;xdrs, au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_base,
00286             au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_length, XDR_DECODE);
00287         stat = <a class="code" href="Authuxprot_8c.html#a0">Xdr_Authunix_parms</a>(&amp;xdrs, &amp;aup);
00288         <span class="keywordflow">if</span> (! stat)
00289                 <span class="keywordflow">goto</span> done;
00290 
00291         <span class="comment">/* update the time and serialize in place */</span>
00292         (void)gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *)0);
00293         aup.aup_time = now.tv_sec;
00294         xdrs.x_op = XDR_ENCODE;
00295         XDR_SETPOS(&amp;xdrs, 0);
00296         stat = <a class="code" href="Authuxprot_8c.html#a0">Xdr_Authunix_parms</a>(&amp;xdrs, &amp;aup);
00297         <span class="keywordflow">if</span> (! stat)
00298                 <span class="keywordflow">goto</span> done;
00299         auth-&gt;ah_cred = au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>;
00300         marshal_new_auth(auth);
00301 done:
00302         <span class="comment">/* free the struct Authunix_parms created by deserializing */</span>
00303         xdrs.x_op = XDR_FREE;
00304         (void)<a class="code" href="Authuxprot_8c.html#a0">Xdr_Authunix_parms</a>(&amp;xdrs, &amp;aup);
00305         XDR_DESTROY(&amp;xdrs);
00306         <span class="keywordflow">return</span> (stat);
00307 }
00308 
00309 <span class="keyword">static</span> <span class="keywordtype">void</span> Authunix_destroy( AUTH * auth)
00310 {
00311         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00312 
00313         mem_free(au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_base, au-&gt;<a class="code" href="structAudata.html#o0">au_origcred</a>.oa_length);
00314 
00315         <span class="keywordflow">if</span> (au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base != NULL)
00316                 mem_free(au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_base, au-&gt;<a class="code" href="structAudata.html#o1">au_shcred</a>.oa_length);
00317 
00318         mem_free(auth-&gt;ah_private, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structAudata.html">Audata</a>));
00319 
00320         <span class="keywordflow">if</span> (auth-&gt;ah_verf.oa_base != NULL)
00321                 mem_free(auth-&gt;ah_verf.oa_base, auth-&gt;ah_verf.oa_length);
00322 
00323         mem_free((caddr_t)auth, <span class="keyword">sizeof</span>(*auth));
00324 }
00325 
00326 <span class="keyword">static</span> bool_t Authunix_wrap( AUTH * auth, XDR * xdrs, Xdrproc_t xdr_func, caddr_t xdr_ptr )
00327 {
00328   <span class="keywordflow">return</span> ((*xdr_func)(xdrs, xdr_ptr));
00329 } 
00330 
00331 <span class="keyword">static</span> bool_t Authunix_unwrap( AUTH * auth, XDR * xdrs, Xdrproc_t xdr_func, caddr_t xdr_ptr )
00332 {
00333   <span class="keywordflow">return</span> ((*xdr_func)(xdrs, xdr_ptr));
00334 }
00335 
00336 
00337 <span class="comment">/*</span>
00338 <span class="comment"> * Marshals (pre-serializes) an auth struct.</span>
00339 <span class="comment"> * sets private data, au_marshed and au_mpos</span>
00340 <span class="comment"> */</span>
00341 <span class="keyword">static</span> bool_t marshal_new_auth( AUTH * auth)
00342 {
00343         XDR             xdr_stream;
00344         <span class="keyword">register</span> XDR    *xdrs = &amp;xdr_stream;
00345         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structAudata.html">Audata</a> *au = <a class="code" href="Auth__unix_8c.html#a0">AUTH_PRIVATE</a>(auth);
00346 
00347         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(xdrs, au-&gt;<a class="code" href="structAudata.html#o3">au_marshed</a>, MAX_AUTH_BYTES, XDR_ENCODE);
00348         <span class="keywordflow">if</span> ((! <a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;(auth-&gt;ah_cred))) ||
00349             (! <a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs, &amp;(auth-&gt;ah_verf))))
00350     {
00351       FILE * tmplog ;
00352 
00353        <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00354         {
00355         fprintf( tmplog, <span class="stringliteral">"auth_none.c - Fatal marshalling problem"</span>) ;
00356         fclose( tmplog ) ;
00357         }
00358     } 
00359   <span class="keywordflow">else</span>
00360     {
00361       au-&gt;<a class="code" href="structAudata.html#o4">au_mpos</a> = XDR_GETPOS(xdrs);
00362     }
00363         XDR_DESTROY(xdrs);
00364 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
