<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RPCSEC_GSS Library: Clnt_udp.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Clnt_udp.c</h1><a href="Clnt__udp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Sun RPC is a product of Sun Microsystems, Inc. and is provided for</span>
00003 <span class="comment"> * unrestricted use provided that this legend is included on all tape</span>
00004 <span class="comment"> * media and as a part of the software program in whole or part.  Users</span>
00005 <span class="comment"> * may copy or modify Sun RPC without charge, but are not authorized</span>
00006 <span class="comment"> * to license or distribute it to anyone else except as part of a product or</span>
00007 <span class="comment"> * program developed by the user.</span>
00008 <span class="comment"> * </span>
00009 <span class="comment"> * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE</span>
00010 <span class="comment"> * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR</span>
00011 <span class="comment"> * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * Sun RPC is provided with no support and without any obligation on the</span>
00014 <span class="comment"> * part of Sun Microsystems, Inc. to assist in its use, correction,</span>
00015 <span class="comment"> * modification or enhancement.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE</span>
00018 <span class="comment"> * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC</span>
00019 <span class="comment"> * OR ANY PART THEREOF.</span>
00020 <span class="comment"> * </span>
00021 <span class="comment"> * In no event will Sun Microsystems, Inc. be liable for any lost revenue</span>
00022 <span class="comment"> * or profits or other special, indirect and consequential damages, even if</span>
00023 <span class="comment"> * Sun has been advised of the possibility of such damages.</span>
00024 <span class="comment"> * </span>
00025 <span class="comment"> * Sun Microsystems, Inc.</span>
00026 <span class="comment"> * 2550 Garcia Avenue</span>
00027 <span class="comment"> * Mountain View, California  94043</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * clnt_udp.c, Implements a UDP/IP based, client side RPC.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> */</span>
00034 
00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00036 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00037 <span class="preprocessor">#include &lt;string.h&gt;</span>
00038 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00039 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00040 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00041 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
00042 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00043 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00044 <span class="preprocessor">#include "Rpc.h"</span>
00045 <span class="preprocessor">#include "Clnt.h"</span>
00046 
00047 <span class="comment">/* #include &lt;rpc/pmap_clnt.h&gt; */</span>
00048 <span class="preprocessor">#include "Types.h"</span>
00049 <span class="preprocessor">#include "stuff_alloc.h"</span>
00050 
00051 <span class="preprocessor">#include "Auth.h"</span>
00052 <span class="preprocessor">#include "Auth_none.h"</span>
00053 
00054 <span class="preprocessor">#ifndef NFDBITS</span>
<a name="l00055"></a><a class="code" href="Clnt__udp_8c.html#a0">00055</a> <span class="preprocessor"></span><span class="preprocessor">#define NFDBITS  (sizeof(long) * 8)    </span><span class="comment">/* bits per mask */</span>
00056 <span class="preprocessor">#endif</span>
00057 <span class="preprocessor"></span>
00058 <span class="comment">/*</span>
00059 <span class="comment"> * UDP bases client side rpc operations</span>
00060 <span class="comment"> */</span>
00061 <span class="keyword">static</span> <span class="keyword">enum</span> Clnt_stat   Clntudp_call();
00062 <span class="keyword">static</span> <span class="keywordtype">void</span>                     Clntudp_abort();
00063 <span class="keyword">static</span> <span class="keywordtype">void</span>                     Clntudp_geterr();
00064 <span class="keyword">static</span> bool_t                 Clntudp_freeres();
00065 <span class="keyword">static</span> bool_t         Clntudp_control();
00066 <span class="keyword">static</span> <span class="keywordtype">void</span>                     Clntudp_destroy();
00067 
00068 <span class="keyword">static</span> <span class="keyword">struct </span>Clnt_ops Udp_ops = {
00069         Clntudp_call,
00070         Clntudp_abort,
00071         Clntudp_geterr,
00072         Clntudp_freeres,
00073         Clntudp_destroy,
00074         Clntudp_control
00075 };
00076 
00077 <span class="comment">/* </span>
00078 <span class="comment"> * Private data kept per client handle</span>
00079 <span class="comment"> */</span>
<a name="l00080"></a><a class="code" href="structCu__data.html">00080</a> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> {
<a name="l00081"></a><a class="code" href="structCu__data.html#o0">00081</a>         <span class="keywordtype">int</span>                cu_sock;
<a name="l00082"></a><a class="code" href="structCu__data.html#o1">00082</a>         bool_t             cu_closeit;
<a name="l00083"></a><a class="code" href="structCu__data.html#o2">00083</a>         <span class="keyword">struct </span>sockaddr_in cu_raddr;
<a name="l00084"></a><a class="code" href="structCu__data.html#o3">00084</a>         <span class="keywordtype">int</span>                cu_rlen;
<a name="l00085"></a><a class="code" href="structCu__data.html#o4">00085</a>         <span class="keyword">struct </span>timeval     cu_wait;
<a name="l00086"></a><a class="code" href="structCu__data.html#o5">00086</a>         <span class="keyword">struct </span>timeval     cu_total;
<a name="l00087"></a><a class="code" href="structCu__data.html#o6">00087</a>         <span class="keyword">struct </span>Rpc_err     cu_error;
<a name="l00088"></a><a class="code" href="structCu__data.html#o7">00088</a>         XDR                cu_outxdrs;
<a name="l00089"></a><a class="code" href="structCu__data.html#o8">00089</a>         u_int              cu_xdrpos;
<a name="l00090"></a><a class="code" href="structCu__data.html#o9">00090</a>         u_int              cu_sendsz;
<a name="l00091"></a><a class="code" href="structCu__data.html#o10">00091</a>         <span class="keywordtype">char</span>            *  cu_outbuf;
<a name="l00092"></a><a class="code" href="structCu__data.html#o11">00092</a>         u_int              cu_recvsz;
<a name="l00093"></a><a class="code" href="structCu__data.html#o12">00093</a>         <span class="keywordtype">char</span>               cu_inbuf[1];
00094 };
00095 
00096 <span class="comment">/*</span>
00097 <span class="comment"> * Create a UDP based client handle.</span>
00098 <span class="comment"> * If *sockp&lt;0, *sockp is set to a newly created UPD socket.</span>
00099 <span class="comment"> * If raddr-&gt;sin_port is 0 a binder on the remote machine</span>
00100 <span class="comment"> * is consulted for the correct port number.</span>
00101 <span class="comment"> * NB: It is the clients responsibility to close *sockp.</span>
00102 <span class="comment"> * NB: The rpch-&gt;cl_auth is initialized to null authentication.</span>
00103 <span class="comment"> *     Caller may wish to set this something more useful.</span>
00104 <span class="comment"> *</span>
00105 <span class="comment"> * wait is the amount of time used between retransmitting a call if</span>
00106 <span class="comment"> * no response has been heard;  retransmition occurs until the actual</span>
00107 <span class="comment"> * rpc call times out.</span>
00108 <span class="comment"> *</span>
00109 <span class="comment"> * sendsz and recvsz are the maximum allowable packet sizes that can be</span>
00110 <span class="comment"> * sent and received.</span>
00111 <span class="comment"> */</span>
<a name="l00112"></a><a class="code" href="Clnt__udp_8c.html#a8">00112</a> Client * <a class="code" href="Clnt__udp_8c.html#a8">Clntudp_bufcreate</a>( <span class="keyword">struct</span> sockaddr_in * raddr, 
00113                             u_long program, 
00114                             u_long version, 
00115                             <span class="keyword">struct</span> timeval wait, 
00116                             <span class="keyword">register</span> <span class="keywordtype">int</span> * sockp, 
00117                             u_int sendsz, 
00118                             u_int recvsz)
00119 {
00120         Client *cl;
00121         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = NULL;
00122         <span class="keyword">struct </span>timeval now;
00123         <span class="keyword">struct </span>Rpc_msg call_msg;
00124 
00125         cl = (Client *)mem_alloc(<span class="keyword">sizeof</span>(Client));
00126         <span class="keywordflow">if</span> (cl == NULL) {
00127                 FILE * tmplog ;
00128                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00129                 {
00130                 (void) fprintf(tmplog, <span class="stringliteral">"clntudp_create: out of memory\n"</span>);
00131                 fclose( tmplog ) ;
00132                 }
00133                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00134                 rpc_createerr.cf_error.re_errno = errno;
00135                 <span class="keywordflow">goto</span> fooy;
00136         }
00137         sendsz = ((sendsz + 3) / 4) * 4;
00138         recvsz = ((recvsz + 3) / 4) * 4;
00139         cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)mem_alloc(<span class="keyword">sizeof</span>(*cu) + sendsz + recvsz);
00140         <span class="keywordflow">if</span> (cu == NULL) {
00141                 FILE * tmplog ;
00142                 <span class="keywordflow">if</span>( ( tmplog = fopen( RPCSEC_GSS_LOG, <span class="stringliteral">"a"</span> ) ) != NULL )
00143                 {
00144                 (void) fprintf(tmplog, <span class="stringliteral">"clntudp_create: out of memory\n"</span>);
00145                 fclose( tmplog ) ;
00146                 }
00147                 rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00148                 rpc_createerr.cf_error.re_errno = errno;
00149                 <span class="keywordflow">goto</span> fooy;
00150         }
00151         cu-&gt;<a class="code" href="structCu__data.html#o10">cu_outbuf</a> = &amp;cu-&gt;<a class="code" href="structCu__data.html#o12">cu_inbuf</a>[recvsz];
00152 
00153         (void)gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *)0);
00154         <span class="keywordflow">if</span> (raddr-&gt;sin_port == 0) {
00155                 u_short port;
00156                 <span class="keywordflow">if</span> ((port =
00157                     pmap_getport(raddr, program, version, IPPROTO_UDP)) == 0) {
00158                         <span class="keywordflow">goto</span> fooy;
00159                 }
00160                 raddr-&gt;sin_port = htons(port);
00161         }
00162         cl-&gt;cl_ops = &amp;Udp_ops;
00163         cl-&gt;cl_private = (caddr_t)cu;
00164         cu-&gt;<a class="code" href="structCu__data.html#o2">cu_raddr</a> = *raddr;
00165         cu-&gt;<a class="code" href="structCu__data.html#o3">cu_rlen</a> = <span class="keyword">sizeof</span> (cu-&gt;cu_raddr);
00166         cu-&gt;<a class="code" href="structCu__data.html#o4">cu_wait</a> = wait;
00167         cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a>.tv_sec = -1;
00168         cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a>.tv_usec = -1;
00169         cu-&gt;<a class="code" href="structCu__data.html#o9">cu_sendsz</a> = sendsz;
00170         cu-&gt;<a class="code" href="structCu__data.html#o11">cu_recvsz</a> = recvsz;
00171         call_msg.rm_xid = getpid() ^ now.tv_sec ^ now.tv_usec;
00172         call_msg.rm_direction = CALL;
00173         call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
00174         call_msg.rm_call.cb_prog = program;
00175         call_msg.rm_call.cb_vers = version;
00176 
00177   
00178         <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;(cu-&gt;cu_outxdrs), cu-&gt;cu_outbuf, sendsz, XDR_ENCODE);
00179 
00180         <span class="keywordflow">if</span> (!<a class="code" href="Rpc__prot_8c.html#a7">Xdr_callhdr</a>(&amp;(cu-&gt;cu_outxdrs), &amp;call_msg)) {
00181                 <span class="keywordflow">goto</span> fooy;
00182         }
00183         cu-&gt;<a class="code" href="structCu__data.html#o8">cu_xdrpos</a> = XDR_GETPOS(&amp;(cu-&gt;cu_outxdrs));
00184         <span class="keywordflow">if</span> (*sockp &lt; 0) {
00185                 <span class="keywordtype">int</span> dontblock = 1;
00186 
00187                 *sockp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
00188                 <span class="keywordflow">if</span> (*sockp &lt; 0) {
00189                         rpc_createerr.cf_stat = RPC_SYSTEMERROR;
00190                         rpc_createerr.cf_error.re_errno = errno;
00191                         <span class="keywordflow">goto</span> fooy;
00192                 }
00193                 <span class="comment">/* attempt to bind to priv port */</span>
00194                 (void)bindresvport(*sockp, (<span class="keyword">struct</span> sockaddr_in *)0);
00195                 <span class="comment">/* the sockets rpc controls are non-blocking */</span>
00196                 cu-&gt;<a class="code" href="structCu__data.html#o1">cu_closeit</a> = TRUE;
00197         } <span class="keywordflow">else</span> {
00198                 cu-&gt;<a class="code" href="structCu__data.html#o1">cu_closeit</a> = FALSE;
00199         }
00200         cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a> = *sockp;
00201         cl-&gt;cl_auth = <a class="code" href="Auth__none_8c.html#a10">Authnone_create</a>();
00202         <span class="keywordflow">return</span> (cl);
00203 fooy:
00204         <span class="keywordflow">if</span> (cu)
00205                 mem_free((caddr_t)cu, <span class="keyword">sizeof</span>(*cu) + sendsz + recvsz);
00206         <span class="keywordflow">if</span> (cl)
00207                 mem_free((caddr_t)cl, <span class="keyword">sizeof</span>(Client));
00208         <span class="keywordflow">return</span> ((Client *)NULL);
00209 }
00210 
<a name="l00211"></a><a class="code" href="Clnt__udp_8c.html#a9">00211</a> Client * <a class="code" href="Clnt__udp_8c.html#a9">Clntudp_create</a>( <span class="keyword">struct</span> sockaddr_in * raddr,
00212                          u_long program, 
00213                          u_long version, 
00214                          <span class="keyword">struct</span> timeval wait, 
00215                          <span class="keyword">register</span> <span class="keywordtype">int</span> * sockp)
00216 {
00217 
00218         <span class="keywordflow">return</span>( <a class="code" href="Clnt__udp_8c.html#a8">Clntudp_bufcreate</a>( raddr, program, version, wait, sockp,
00219                            <a class="code" href="Svc__udp_8c.html#a0">UDPMSGSIZE</a>, <a class="code" href="Svc__udp_8c.html#a0">UDPMSGSIZE</a>));
00220 }
00221 
00222 <span class="keyword">static</span> <span class="keyword">enum</span> Clnt_stat Clntudp_call( <span class="keyword">register</span> Client     * cl, 
00223                                     u_long      proc, 
00224                                     Xdrproc_t xargs, 
00225                                     caddr_t      argsp, 
00226                                     Xdrproc_t  xresults,
00227                                     caddr_t      resultsp,
00228                                     <span class="keyword">struct</span> timeval      utimeout)
00229 {
00230         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)cl-&gt;cl_private;
00231         <span class="keyword">register</span> XDR *xdrs;
00232         <span class="keyword">register</span> <span class="keywordtype">int</span> outlen;
00233         <span class="keyword">register</span> <span class="keywordtype">int</span> inlen;
00234         <span class="keywordtype">int</span> fromlen;
00235         fd_set *fds, readfds;
00236         <span class="keyword">struct </span>sockaddr_in from;
00237         <span class="keyword">struct </span>Rpc_msg reply_msg;
00238         XDR reply_xdrs;
00239         <span class="keyword">struct </span>timeval time_waited, start, after, tmp1, tmp2, tmp3;
00240         bool_t ok;
00241         <span class="keywordtype">int</span> nrefreshes = 2;     <span class="comment">/* number of times to refresh cred */</span>
00242         <span class="keyword">struct </span>timeval timeout, seltimeout;
00243         <span class="keyword">register</span> <span class="keywordtype">long</span> fd_mask ;
00244 
00245         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a>.tv_usec == -1)
00246                 timeout = utimeout;     <span class="comment">/* use supplied timeout */</span>
00247         <span class="keywordflow">else</span>
00248                 timeout = cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a>; <span class="comment">/* use default timeout */</span>
00249 
00250         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>+1 &gt; FD_SETSIZE) {
00251                 <span class="keywordtype">int</span> bytes = howmany(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>+1, NFDBITS) * <span class="keyword">sizeof</span>(fd_mask);
00252                 fds = (fd_set *)malloc(bytes);
00253                 <span class="keywordflow">if</span> (fds == NULL)
00254                         <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTSEND);
00255                 memset(fds, 0, bytes);
00256         } <span class="keywordflow">else</span> {
00257                 fds = &amp;readfds;
00258                 FD_ZERO(fds);
00259         }
00260 
00261         Timerclear(&amp;time_waited);
00262 call_again:
00263         xdrs = &amp;(cu-&gt;<a class="code" href="structCu__data.html#o7">cu_outxdrs</a>);
00264         xdrs-&gt;x_op = XDR_ENCODE;
00265         XDR_SETPOS(xdrs, cu-&gt;<a class="code" href="structCu__data.html#o8">cu_xdrpos</a>);
00266         <span class="comment">/*</span>
00267 <span class="comment">         * the transaction is the first thing in the out buffer</span>
00268 <span class="comment">         */</span>
00269         (*(u_short *)(cu-&gt;<a class="code" href="structCu__data.html#o10">cu_outbuf</a>))++;
00270         <span class="keywordflow">if</span> (!XDR_PUTLONG(xdrs, (<span class="keywordtype">long</span> *)&amp;proc) ||
00271             !AUTH_MARSHALL(cl-&gt;cl_auth, xdrs) ||
00272             !AUTH_WRAP(cl-&gt;cl_auth, xdrs, xargs, argsp)) {
00273                 <span class="keywordflow">if</span> (fds != &amp;readfds)
00274                         Mem_Free(fds);
00275                 <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTENCODEARGS);
00276         }
00277         outlen = (int)XDR_GETPOS(xdrs);
00278 
00279 send_again:
00280         <span class="keywordflow">if</span> (sendto(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>, cu-&gt;<a class="code" href="structCu__data.html#o10">cu_outbuf</a>, outlen, 0,
00281             (<span class="keyword">struct</span> sockaddr *)&amp;(cu-&gt;<a class="code" href="structCu__data.html#o2">cu_raddr</a>), cu-&gt;<a class="code" href="structCu__data.html#o3">cu_rlen</a>) != outlen) {
00282                 cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_errno = errno;
00283                 <span class="keywordflow">if</span> (fds != &amp;readfds)
00284                         Mem_Free(fds);
00285                 <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTSEND);
00286         }
00287 
00288         <span class="comment">/*</span>
00289 <span class="comment">         * Hack to provide rpc-based message passing</span>
00290 <span class="comment">         */</span>
00291         <span class="keywordflow">if</span> (!Timerisset(&amp;timeout)) {
00292                 <span class="keywordflow">if</span> (fds != &amp;readfds)
00293                         Mem_Free(fds);
00294                 <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_TIMEDOUT);
00295         }
00296 
00297         <span class="comment">/*</span>
00298 <span class="comment">         * sub-optimal code appears here because we have</span>
00299 <span class="comment">         * some clock time to spare while the packets are in flight.</span>
00300 <span class="comment">         * (We assume that this is actually only executed once.)</span>
00301 <span class="comment">         */</span>
00302         reply_msg.acpted_rply.ar_verf = _null_auth;
00303         reply_msg.acpted_rply.ar_results.where = NULL;
00304         reply_msg.acpted_rply.ar_results.proc = Xdr_void;
00305 
00306         gettimeofday(&amp;start, NULL);
00307         <span class="keywordflow">for</span> (;;) {
00308                 <span class="comment">/* XXX we know the other bits are still clear */</span>
00309                 FD_SET(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>, fds);
00310                 seltimeout = cu-&gt;<a class="code" href="structCu__data.html#o4">cu_wait</a>;
00311                 <span class="keywordflow">switch</span> (select(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>+1, fds, NULL, NULL, &amp;seltimeout)) {
00312                 <span class="keywordflow">case</span> 0:
00313                         Timeradd(&amp;time_waited, &amp;cu-&gt;<a class="code" href="structCu__data.html#o4">cu_wait</a>, &amp;tmp1);
00314                         time_waited = tmp1;
00315                         <span class="keywordflow">if</span> (Timercmp(&amp;time_waited, &amp;timeout, &lt;))
00316                                 <span class="keywordflow">goto</span> send_again;
00317                         <span class="keywordflow">if</span> (fds != &amp;readfds)
00318                                 Mem_Free(fds);
00319                         <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_TIMEDOUT);
00320                 <span class="keywordflow">case</span> -1:
00321                         <span class="keywordflow">if</span> (errno == EINTR) {
00322                                 gettimeofday(&amp;after, NULL);
00323                                 Timersub(&amp;after, &amp;start, &amp;tmp1);
00324                                 Timeradd(&amp;time_waited, &amp;tmp1, &amp;tmp2);
00325                                 time_waited = tmp2;
00326                                 <span class="keywordflow">if</span> (Timercmp(&amp;time_waited, &amp;timeout, &lt;))
00327                                         <span class="keywordflow">continue</span>;
00328                                 <span class="keywordflow">if</span> (fds != &amp;readfds)
00329                                         Mem_Free(fds);
00330                                 <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_TIMEDOUT);
00331                         }
00332                         cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_errno = errno;
00333                         <span class="keywordflow">if</span> (fds != &amp;readfds)
00334                                 Mem_Free(fds);
00335                         <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTRECV);
00336                 }
00337 
00338                 <span class="keywordflow">do</span>
00339       {
00340         fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00341         inlen = recvfrom(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>, cu-&gt;<a class="code" href="structCu__data.html#o12">cu_inbuf</a>, 
00342                          (<span class="keywordtype">int</span>) cu-&gt;<a class="code" href="structCu__data.html#o11">cu_recvsz</a>, 0,
00343                          (<span class="keyword">struct</span> sockaddr *)&amp;from, &amp;fromlen);
00344       } <span class="keywordflow">while</span> (inlen &lt; 0 &amp;&amp; errno == EINTR);
00345     
00346 
00347     
00348                 <span class="keywordflow">if</span> (inlen &lt; 0) 
00349       {
00350         <span class="keywordflow">if</span> (errno == EWOULDBLOCK)
00351           <span class="keywordflow">continue</span>;
00352         cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_errno = errno;
00353         <span class="keywordflow">if</span> (fds != &amp;readfds)
00354           Mem_Free(fds);
00355         <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTRECV);
00356       }
00357                 <span class="keywordflow">if</span> (inlen &lt; <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int))
00358                         <span class="keywordflow">continue</span>;       
00359 
00360 
00361                 <span class="comment">/* see if reply transaction id matches sent id */</span>
00362                 <span class="keywordflow">if</span> (((<span class="keyword">struct </span>Rpc_msg *)(cu-&gt;<a class="code" href="structCu__data.html#o12">cu_inbuf</a>))-&gt;rm_xid !=
00363                     ((<span class="keyword">struct </span>Rpc_msg *)(cu-&gt;<a class="code" href="structCu__data.html#o10">cu_outbuf</a>))-&gt;rm_xid)
00364                         <span class="keywordflow">continue</span>;
00365                 <span class="comment">/* we now assume we have the proper reply */</span>
00366                 <span class="keywordflow">break</span>;
00367         }
00368 
00369         <span class="comment">/*</span>
00370 <span class="comment">         * now decode and validate the response</span>
00371 <span class="comment">         */</span>
00372         
00373   <a class="code" href="Xdr__mem_8c.html#a13">Xdrmem_create</a>(&amp;reply_xdrs, cu-&gt;<a class="code" href="structCu__data.html#o12">cu_inbuf</a>, (u_int)inlen, XDR_DECODE);
00374   
00375         ok = <a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(&amp;reply_xdrs, &amp;reply_msg);
00376         <span class="comment">/* XDR_DESTROY(&amp;reply_xdrs);  save a few cycles on noop destroy */</span>
00377         <span class="keywordflow">if</span> (ok) {
00378 <span class="preprocessor">#if 0</span>
00379 <span class="preprocessor"></span>                <span class="comment">/*</span>
00380 <span class="comment">                 * XXX Would like to check these, but call_msg is not</span>
00381 <span class="comment">                 * around.</span>
00382 <span class="comment">                 */</span>
00383                 <span class="keywordflow">if</span> (reply_msg.rm_call.cb_prog != call_msg.rm_call.cb_prog ||
00384                     reply_msg.rm_call.cb_vers != call_msg.rm_call.cb_vers ||
00385                     reply_msg.rm_call.cb_proc != call_msg.rm_call.cb_proc) {
00386                         <span class="keywordflow">goto</span> call_again;        <span class="comment">/* XXX spin? */</span>
00387                 }
00388 <span class="preprocessor">#endif</span>
00389 <span class="preprocessor"></span>
00390                 <a class="code" href="Rpc__prot_8c.html#a10">_seterr_reply</a>(&amp;reply_msg, &amp;(cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>));
00391                 <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status == RPC_SUCCESS)
00392       {
00393         <span class="keywordflow">if</span> (!AUTH_VALIDATE(cl-&gt;cl_auth,
00394                            &amp;reply_msg.acpted_rply.ar_verf)) 
00395           {
00396             cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_AUTHERROR;
00397             cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_why = AUTH_INVALIDRESP;
00398           }
00399         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! AUTH_UNWRAP( cl-&gt;cl_auth, &amp;reply_xdrs, xresults, resultsp))
00400           {
00401             <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status == RPC_SUCCESS)
00402               cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTDECODERES;
00403           }
00404         
00405         <span class="keywordflow">if</span> (reply_msg.acpted_rply.ar_verf.oa_base != NULL) {
00406           xdrs-&gt;x_op = XDR_FREE;
00407           (void)<a class="code" href="Rpc__prot_8c.html#a2">Xdr_opaque_auth</a>(xdrs,
00408                                 &amp;(reply_msg.acpted_rply.ar_verf));
00409         } 
00410                 } 
00411     <span class="keywordflow">else</span>
00412       {
00413         <span class="comment">/* maybe our credentials need to be refreshed ... */</span>
00414         <span class="keywordflow">if</span> (nrefreshes &gt; 0 &amp;&amp; AUTH_REFRESH(cl-&gt;cl_auth)) {
00415           nrefreshes--;
00416           <span class="keywordflow">goto</span> call_again;
00417         }
00418                 }
00419         } 
00420   <span class="keywordflow">else</span>
00421     {
00422       <span class="comment">/* xdr_replymsg() may have left some things allocated */</span>
00423       <span class="keywordtype">int</span> op = reply_xdrs.x_op;
00424       reply_xdrs.x_op = XDR_FREE;
00425       <a class="code" href="Rpc__prot_8c.html#a6">Xdr_replymsg</a>(&amp;reply_xdrs, &amp;reply_msg);
00426       reply_xdrs.x_op = op;
00427       cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status = RPC_CANTDECODERES;
00428     }
00429   
00430         <span class="keywordflow">if</span> (fds != &amp;readfds)
00431                 Mem_Free(fds);
00432         <span class="keywordflow">return</span> (cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>.re_status);
00433 }
00434 
00435 <span class="keyword">static</span> <span class="keywordtype">void</span> Clntudp_geterr( Client * cl, <span class="keyword">struct</span> Rpc_err * errp)
00436 {
00437         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)cl-&gt;cl_private;
00438 
00439         *errp = cu-&gt;<a class="code" href="structCu__data.html#o6">cu_error</a>;
00440 }
00441 
00442 
00443 <span class="keyword">static</span> bool_t Clntudp_freeres( Client * cl, Xdrproc_t xdr_res, caddr_t res_ptr)
00444 {
00445         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)cl-&gt;cl_private;
00446         <span class="keyword">register</span> XDR *xdrs = &amp;(cu-&gt;<a class="code" href="structCu__data.html#o7">cu_outxdrs</a>);
00447 
00448         xdrs-&gt;x_op = XDR_FREE;
00449         <span class="keywordflow">return</span> ((*xdr_res)(xdrs, res_ptr));
00450 }
00451 
00452 <span class="keyword">static</span> <span class="keywordtype">void</span> Clntudp_abort( <span class="keywordtype">void</span> )
00453 {
00454 }
00455 
00456 <span class="keyword">static</span> bool_t Clntudp_control( Client * cl, <span class="keywordtype">int</span> request, <span class="keywordtype">char</span> * info)
00457 {
00458         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)cl-&gt;cl_private;
00459 
00460         <span class="keywordflow">switch</span> (request) {
00461         <span class="keywordflow">case</span> CLSET_TIMEOUT:
00462                 cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a> = *(<span class="keyword">struct </span>timeval *)info;
00463                 <span class="keywordflow">break</span>;
00464         <span class="keywordflow">case</span> CLGET_TIMEOUT:
00465                 *(<span class="keyword">struct </span>timeval *)info = cu-&gt;<a class="code" href="structCu__data.html#o5">cu_total</a>;
00466                 <span class="keywordflow">break</span>;
00467         <span class="keywordflow">case</span> CLSET_RETRY_TIMEOUT:
00468                 cu-&gt;<a class="code" href="structCu__data.html#o4">cu_wait</a> = *(<span class="keyword">struct </span>timeval *)info;
00469                 <span class="keywordflow">break</span>;
00470         <span class="keywordflow">case</span> CLGET_RETRY_TIMEOUT:
00471                 *(<span class="keyword">struct </span>timeval *)info = cu-&gt;<a class="code" href="structCu__data.html#o4">cu_wait</a>;
00472                 <span class="keywordflow">break</span>;
00473         <span class="keywordflow">case</span> CLGET_SERVER_ADDR:
00474                 *(<span class="keyword">struct </span>sockaddr_in *)info = cu-&gt;<a class="code" href="structCu__data.html#o2">cu_raddr</a>;
00475                 <span class="keywordflow">break</span>;
00476         <span class="keywordflow">default</span>:
00477                 <span class="keywordflow">return</span> (FALSE);
00478         }
00479         <span class="keywordflow">return</span> (TRUE);
00480 }
00481         
00482 <span class="keyword">static</span> <span class="keywordtype">void</span> Clntudp_destroy( Client *cl )
00483 {
00484         <span class="keyword">register</span> <span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *cu = (<span class="keyword">struct </span><a class="code" href="structCu__data.html">Cu_data</a> *)cl-&gt;cl_private;
00485 
00486         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structCu__data.html#o1">cu_closeit</a>) {
00487                 (void)close(cu-&gt;<a class="code" href="structCu__data.html#o0">cu_sock</a>);
00488         }
00489         XDR_DESTROY(&amp;(cu-&gt;<a class="code" href="structCu__data.html#o7">cu_outxdrs</a>));
00490         mem_free((caddr_t)cu, (<span class="keyword">sizeof</span>(*cu) + cu-&gt;cu_sendsz + cu-&gt;cu_recvsz));
00491         mem_free((caddr_t)cl, <span class="keyword">sizeof</span>(Client));
00492 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Dec 22 14:15:35 2006 for RPCSEC_GSS Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
