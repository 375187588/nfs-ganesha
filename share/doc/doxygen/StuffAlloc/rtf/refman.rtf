{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\comment Begining font list}
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\comment begin colors}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\comment Beginning style list}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Stuff Allocator {\comment startProjectNumber }
 {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0.1 \par
}{\comment endProjectNumber }
}Stuff Allocator}
{\comment Generated byDoxgyen. }
{\creatim \yr2010\mo9\dy15\hr16\min4\sec54}
}{\comment end of infoblock}
\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
{\comment begin title page}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 0.1\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page{\comment End title page}
{\comment Table of contents}
\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
{\comment Beginning Body of RTF Document}
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
{\comment begin include files.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List{\comment endTitleHead}
\par \pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:{\comment endTextBlock}
}
{\comment (startIndexList)}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexKey)}
{\b {\b stuff_alloc.h}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stuff allocators macros }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (endIndexList)}
\par}{\comment endFile}
{\comment end include files.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
{\comment begin include stuff__alloc_8h.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
stuff_alloc.h File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v stuff_alloc.h}
{\xe \v stuff_alloc.h}
{\comment writeAnchor (stuff__alloc_8h)}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stuff allocators macros. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}{\comment (lineBreak)}
\par
{\f2 #include "BuddyMalloc.h"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Mem_Alloc}(a)\~ BuddyMallocExit( a ){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Mem_Calloc}(s1, s2)\~ BuddyCalloc( s1, s2 ){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Mem_Realloc}(p, s)\~ BuddyRealloc( (caddr_t)(p), s ){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Mem_Free}(a)\~ BuddyFree((caddr_t) (a)){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Mem_Errno}\~ BuddyErrno{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GetPreferedPool}(_n, _s)\~ BuddyPreferedPoolCount( _n, _s){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STUFF_PREALLOC}(_pool, _nb, _type, _name_next){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET_PREALLOC}(_entry, _pool, _nb, _type, _name_next){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RELEASE_PREALLOC}(_entry, _pool, _name_next){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STUFF_PREALLOC_CONSTRUCT}(_pool, _nb, _type, _name_next, _construct){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET_PREALLOC_CONSTRUCT}(_entry, _pool, _nb, _type, _name_next, _construct){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RELEASE_PREALLOC_DESTRUCT}(entry, pool, name_next, destruct){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stuff allocators macros. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid leibovic \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 2006/01/24 15:06:30 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Revision\par
}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1.18 \par
}{\b stuff_alloc.h} : Stuff allocators macros. \par
}{\comment startParagraph}
{
Definition in file {\b stuff_alloc.h}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v GET_PREALLOC\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:GET_PREALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET_PREALLOC({\comment (startParameterList)}
_entry, {\comment (startParameterList)}
  _pool, {\comment (startParameterList)}
  _nb, {\comment (startParameterList)}
  _type, {\comment (startParameterList)}
  _name_next){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                        \\{\comment (lineBreak)}
\par
\{                                                                         \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
  if( ( _pool == NULL ) && ( _nb != 0 ) )                                 \\{\comment (lineBreak)}
\par
    STUFF_PREALLOC( _pool, _nb, _type, _name_next ) ;                     \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
  if( _pool != NULL )                                                     \\{\comment (lineBreak)}
\par
    \{                                                                     \\{\comment (lineBreak)}
\par
      _entry = _pool ;                                                    \\{\comment (lineBreak)}
\par
      _pool = _entry->_name_next ;                                        \\{\comment (lineBreak)}
\par
    \}                                                                     \\{\comment (lineBreak)}
\par
  else                                                                    \\{\comment (lineBreak)}
\par
   _entry = NULL ;                                                        \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GET_PREALLOC: Gets an entry in a preallocated pool.\par
This macro is used to get an entry from a pre-allocated pool. If the pool is empty, the macro STUFF_PREALLOC will be called with the same last four arguments to extend the pool. If nb is set to zero during this call, STUFF_PREALLOC is not called and no entry is get from the pool that is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i entry} the entry we need. \par
{\i pool} the preallocted pool that we want to init. \par
{\i nb} the number of entries to be allocated. \par
{\i type} the type of the entries to be allocated. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry.\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro), but entry will be NULL if an error occures. \par
}}{\comment startParagraph}
{
Definition at line 137 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v GET_PREALLOC_CONSTRUCT\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:GET_PREALLOC_CONSTRUCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET_PREALLOC_CONSTRUCT({\comment (startParameterList)}
_entry, {\comment (startParameterList)}
  _pool, {\comment (startParameterList)}
  _nb, {\comment (startParameterList)}
  _type, {\comment (startParameterList)}
  _name_next, {\comment (startParameterList)}
  _construct){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                             \\{\comment (lineBreak)}
\par
\{                                                                              \\{\comment (lineBreak)}
\par
  if( ( _pool == NULL ) && ( _nb != 0 ) )                                      \\{\comment (lineBreak)}
\par
    STUFF_PREALLOC_CONSTRUCT( _pool, _nb, _type, _name_next, _construct ) ;    \\{\comment (lineBreak)}
\par
                                                                               \\{\comment (lineBreak)}
\par
  if( _pool != NULL )                                                          \\{\comment (lineBreak)}
\par
    \{                                                                          \\{\comment (lineBreak)}
\par
      _entry = _pool ;                                                         \\{\comment (lineBreak)}
\par
      _pool = _entry->_name_next ;                                             \\{\comment (lineBreak)}
\par
    \}                                                                          \\{\comment (lineBreak)}
\par
  else                                                                         \\{\comment (lineBreak)}
\par
   _entry = NULL ;                                                             \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GET_PREALLOC_CONSTRUCT: Gets an entry in a preallocated pool.\par
This macro is used to get an entry from a pre-allocated pool. If the pool is empty, the macro STUFF_PREALLOC will be called with the same last four arguments to extend the pool. If nb is set to zero during this call, STUFF_PREALLOC is not called and no entry is get from the pool that is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i entry} the entry we need. \par
{\i pool} the preallocted pool that we want to init. \par
{\i nb} the number of entries to be allocated. \par
{\i type} the type of the entries to be allocated. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry. \par
{\i construct} the constructor for the object: takes a pointer to void as argument and returns void\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro), but entry will be NULL if an error occures. \par
}}{\comment startParagraph}
{
Definition at line 241 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v GetPreferedPool\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:GetPreferedPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GetPreferedPool({\comment (startParameterList)}
_n, {\comment (startParameterList)}
  _s)\~ BuddyPreferedPoolCount( _n, _s){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 72 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v Mem_Alloc\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:Mem_Alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Mem_Alloc({\comment (startParameterList)}
a)\~ BuddyMallocExit( a ){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 64 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v Mem_Calloc\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:Mem_Calloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Mem_Calloc({\comment (startParameterList)}
s1, {\comment (startParameterList)}
  s2)\~ BuddyCalloc( s1, s2 ){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 65 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v Mem_Errno\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:Mem_Errno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Mem_Errno\~ BuddyErrno{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 70 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v Mem_Free\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:Mem_Free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Mem_Free({\comment (startParameterList)}
a)\~ BuddyFree((caddr_t) (a)){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 69 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v Mem_Realloc\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:Mem_Realloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Mem_Realloc({\comment (startParameterList)}
p, {\comment (startParameterList)}
  s)\~ BuddyRealloc( (caddr_t)(p), s ){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 66 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v RELEASE_PREALLOC\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:RELEASE_PREALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RELEASE_PREALLOC({\comment (startParameterList)}
_entry, {\comment (startParameterList)}
  _pool, {\comment (startParameterList)}
  _name_next){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                        \\{\comment (lineBreak)}
\par
\{                                                                         \\{\comment (lineBreak)}
\par
  _entry->_name_next = _pool ;                                            \\{\comment (lineBreak)}
\par
  _pool = _entry ;                                                        \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
RELEASE_PREALLOC: Releases an entry and puts it back to the pool.\par
When an entry is no used any more, this macro is used to put it back to the pool, so that it could be reuse later. The released entry is chained to the pool, through the 'name_next' field.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i entry} the entry to be released. \par
{\i pool} the pool to which the entry belongs. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry.\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro). \par
}}{\comment startParagraph}
{
Definition at line 168 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v RELEASE_PREALLOC_DESTRUCT\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:RELEASE_PREALLOC_DESTRUCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RELEASE_PREALLOC_DESTRUCT({\comment (startParameterList)}
entry, {\comment (startParameterList)}
  pool, {\comment (startParameterList)}
  name_next, {\comment (startParameterList)}
  destruct){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                        \\{\comment (lineBreak)}
\par
\{                                                                         \\{\comment (lineBreak)}
\par
  destruct( (void *)entry ) ;                                             \\{\comment (lineBreak)}
\par
  entry->name_next = pool ;                                               \\{\comment (lineBreak)}
\par
  pool = entry ;                                                          \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
RELEASE_PREALLOC_DESTRUCT: Releases an entry and puts it back to the pool with a destructor.\par
When an entry is no used any more, this macro is used to put it back to the pool, so that it could be reuse later. The released entry is chained to the pool, through the 'name_next' field.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i entry} the entry to be released. \par
{\i pool} the pool to which the entry belongs. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry. \par
{\i destruct} the destructor for the object: takes a pointer to void as argument and returns void\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro). \par
}}{\comment startParagraph}
{
Definition at line 272 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v STUFF_PREALLOC\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:STUFF_PREALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STUFF_PREALLOC({\comment (startParameterList)}
_pool, {\comment (startParameterList)}
  _nb, {\comment (startParameterList)}
  _type, {\comment (startParameterList)}
  _name_next){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                            \\{\comment (lineBreak)}
\par
\{                                                                             \\{\comment (lineBreak)}
\par
  unsigned int _i = 0 ;                                                       \\{\comment (lineBreak)}
\par
  unsigned int _prefered = 0 ;                                                \\{\comment (lineBreak)}
\par
                                                                              \\{\comment (lineBreak)}
\par
  _prefered = GetPreferedPool( _nb, sizeof(_type) );                          \\{\comment (lineBreak)}
\par
  _pool= NULL ;                                                               \\{\comment (lineBreak)}
\par
                                                                              \\{\comment (lineBreak)}
\par
  if( ( _pool = ( _type *)Mem_Alloc( sizeof( _type ) * _prefered ) ) != NULL ) \\{\comment (lineBreak)}
\par
    \{                                                                         \\{\comment (lineBreak)}
\par
      for( _i = 0 ; _i < ( unsigned int)_prefered ; _i++ )                    \\{\comment (lineBreak)}
\par
        \{                                                                     \\{\comment (lineBreak)}
\par
          if( _i != _prefered -1 )                                            \\{\comment (lineBreak)}
\par
            _pool[_i]._name_next = &(_pool[_i+1]) ;                           \\{\comment (lineBreak)}
\par
          else                                                                \\{\comment (lineBreak)}
\par
            _pool[_i]._name_next = NULL ;                                     \\{\comment (lineBreak)}
\par
        \}                                                                     \\{\comment (lineBreak)}
\par
    \}                                                                         \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STUFF_PREALLOC: Allocates a pool of pre-allocated entries.\par
This macro Allocates a pool of pre-allocated entries. It calls malloc to get the spool as an arry and then chains all the entries together. Each entry is supposed to have a specific 'next' field, a pointer to an object of its own type, to be used as a pointer to the next entry in the pool.\par
If BuddyMalloc is used, it is supposed to be already initialised.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i pool} the preallocted pool that we want to init. \par
{\i nb} the number of entries to be allocated. \par
{\i type} the type of the entries to be allocated. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry.\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro), but pool will be NULL if an error occures. \par
}}{\comment startParagraph}
{
Definition at line 98 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v STUFF_PREALLOC_CONSTRUCT\:stuff_alloc.h}
{\xe \v stuff_alloc.h\:STUFF_PREALLOC_CONSTRUCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STUFF_PREALLOC_CONSTRUCT({\comment (startParameterList)}
_pool, {\comment (startParameterList)}
  _nb, {\comment (startParameterList)}
  _type, {\comment (startParameterList)}
  _name_next, {\comment (startParameterList)}
  _construct){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do                                                                        \\{\comment (lineBreak)}
\par
\{                                                                         \\{\comment (lineBreak)}
\par
  unsigned int _i = 0 ;                                                   \\{\comment (lineBreak)}
\par
  unsigned int _prefered = 0 ;                                            \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
  _prefered = GetPreferedPool( _nb, sizeof(_type) );                       \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
  _pool = ( _type *)Mem_Calloc( _prefered, sizeof( _type ) ) ;            \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
  if( _pool != NULL )                                                     \\{\comment (lineBreak)}
\par
    \{                                                                     \\{\comment (lineBreak)}
\par
      for( _i = 0 ; _i < _prefered ; _i++ )                               \\{\comment (lineBreak)}
\par
        \{                                                                 \\{\comment (lineBreak)}
\par
          if( _i != _prefered -1 )                                        \\{\comment (lineBreak)}
\par
            _pool[_i]._name_next = &(_pool[_i+1]) ;                       \\{\comment (lineBreak)}
\par
          else                                                            \\{\comment (lineBreak)}
\par
            _pool[_i]._name_next = NULL ;                                 \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
          if( _construct != NULL )                                        \\{\comment (lineBreak)}
\par
            _construct( (void *)&(_pool[_i]) )  ;                         \\{\comment (lineBreak)}
\par
                                                                          \\{\comment (lineBreak)}
\par
        \}                                                                 \\{\comment (lineBreak)}
\par
    \}                                                                     \\{\comment (lineBreak)}
\par
\} while( 0 ){\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STUFF_PREALLOC_CONSTRUCT: Allocates a pool of pre-allocated entries with a call to a constructor.\par
This macro Allocates a pool of pre-allocated entries. It calls malloc to get the spool as an arry and then chains all the entries together. Each entry is supposed to have a specific 'next' field, a pointer to an object of its own type, to be used as a pointer to the next entry in the pool.\par
If BuddyMalloc is used, it is supposed to be already initialised.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i pool} the preallocted pool that we want to init. \par
{\i nb} the number of entries to be allocated. \par
{\i type} the type of the entries to be allocated. \par
{\i name_next} the name of the field, in structure of type 'type' which pointer to the next entry. \par
{\i construct} the constructor for the object: takes a pointer to void as argument and returns void\par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid nothing (this is a macro), but pool will be NULL if an error occures. \par
}}{\comment startParagraph}
{
Definition at line 196 of file stuff_alloc.h.{\comment endParagraph}
}\par
}
{\comment endFile}
{\comment end include stuff__alloc_8h.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
{\comment endFile}
}