<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NFS and Mount protocols layer: nfs3_Readdirplus.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>nfs3_Readdirplus.c</h1><a href="nfs3__Readdirplus_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00087 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 
00092 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00093 <span class="preprocessor">#include &lt;string.h&gt;</span>
00094 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00095 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00096 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>  <span class="comment">/* for having FNDELAY */</span>
00097 <span class="preprocessor">#include "HashData.h"</span>
00098 <span class="preprocessor">#include "HashTable.h"</span>
00099 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00101 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00102 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00103 <span class="preprocessor">#include &lt;gssrpc/pmap_clnt.h&gt;</span>
00104 <span class="preprocessor">#else</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00106 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00107 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00108 <span class="preprocessor">#include &lt;rpc/pmap_clnt.h&gt;</span>
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>
00111 <span class="preprocessor">#include "log_functions.h"</span>
00112 <span class="preprocessor">#include "stuff_alloc.h"</span>
00113 <span class="preprocessor">#include "nfs23.h"</span>
00114 <span class="preprocessor">#include "nfs4.h"</span>
00115 <span class="preprocessor">#include "mount.h"</span>
00116 <span class="preprocessor">#include "nfs_core.h"</span>
00117 <span class="preprocessor">#include "cache_inode.h"</span>
00118 <span class="preprocessor">#include "cache_content.h"</span>
00119 <span class="preprocessor">#include "nfs_exports.h"</span>
00120 <span class="preprocessor">#include "nfs_creds.h"</span>
00121 <span class="preprocessor">#include "nfs_proto_functions.h"</span>
00122 <span class="preprocessor">#include "nfs_tools.h"</span>
00123 <span class="preprocessor">#include "nfs_file_handle.h"</span>
00124 <span class="preprocessor">#include "nfs_proto_tools.h"</span>
00125 
00126 
<a name="l00147"></a><a class="code" href="nfs3__Readdirplus_8c.html#a2">00147</a> <span class="keywordtype">int</span> <a class="code" href="nfs3__Readdirplus_8c.html#a2">nfs3_Readdirplus</a>( nfs_arg_t               * parg,    
00148                       exportlist_t            * pexport, 
00149                       fsal_op_context_t       * pcontext,   
00150                       cache_inode_client_t    * pclient,
00151                       hash_table_t            * ht,
00152                       <span class="keyword">struct</span> svc_req          * preq,    
00153                       nfs_res_t               * pres )
00154 {
00155         <span class="keyword">static</span> <span class="keywordtype">char</span>     funcName[] = <span class="stringliteral">"nfs3_Readdirplus"</span>;
00156 
00157   <span class="keyword">typedef</span> <span class="keywordtype">char</span>    entry_name_array_item_t[FSAL_MAX_NAME_LEN] ;
00158   <span class="keyword">typedef</span> <span class="keywordtype">char</span>    fh3_buffer_item_t[NFS3_FHSIZE] ;
00159   
00160   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 delta = 0                ;
00161   cache_entry_t             * dir_pentry     = NULL    ;
00162   cache_entry_t             * pentry_dot_dot = NULL    ;
00163   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               count                  ;
00164   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               dircount                 ;
00165   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               maxcount                 ;
00166   fsal_attrib_list_t          dir_attr                 ;
00167   fsal_attrib_list_t          entry_attr               ;
00168   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                begin_cookie           ;
00169   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                end_cookie               ;
00170   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                cache_inode_cookie       ;
00171   cache_inode_dir_entry_t   * dirent_array = NULL    ;
00172   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              * cookie_array = NULL      ;
00173         cookieverf3                 cookie_verifier        ;
00174   <span class="keywordtype">int</span>                         rc                       ;
00175   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i = 0                    ;
00176   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                num_entries              ;
00177   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               space_used               ;
00178   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               estimated_num_entries    ;
00179   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               asked_num_entries        ;
00180   cache_inode_file_type_t     dir_filetype             ;
00181   cache_inode_endofdir_t      eod_met = UNASSIGNED_EOD ;
00182   cache_inode_status_t        cache_status             ;
00183   cache_inode_status_t        cache_status_gethandle   ;
00184   fsal_handle_t             * pfsal_handle = NULL      ;
00185   entry_name_array_item_t   * entry_name_array = NULL  ;
00186   fh3_buffer_item_t         * fh3_array = NULL         ;
00187   
00188         <span class="comment">/* to avoid setting it on each error case */</span>
00189         pres-&gt;res_readdir3.READDIR3res_u.resfail.dir_attributes.attributes_follow = FALSE;
00190 
00191         dircount              = parg-&gt;arg_readdirplus3.dircount;
00192         maxcount              = parg-&gt;arg_readdirplus3.maxcount;
00193         begin_cookie          = (<span class="keywordtype">unsigned</span> int)parg-&gt;arg_readdirplus3.cookie;
00194         space_used            = <span class="keyword">sizeof</span>(READDIRPLUS3resok);
00195         estimated_num_entries = dircount / <span class="keyword">sizeof</span>(entryplus3);
00196 
00197 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00198 <span class="preprocessor"></span>  printf( <span class="stringliteral">"---&gt; nfs3_Readdirplus: dircount=%d  maxcount=%d  begin_cookie=%d  space_used=%d  estimated_num_entries=%d\n"</span>, 
00199           dircount, maxcount, begin_cookie, space_used, estimated_num_entries ) ;
00200 <span class="preprocessor">#endif</span>
00201 <span class="preprocessor"></span>  
00202   <span class="comment">/* Convert file handle into a vnode */</span> 
00203   <span class="comment">/* BUGAZOMEU : rajouter acces direct au DIR_CONTINUE */</span>
00204   <span class="keywordflow">if</span>( ( dir_pentry = <a class="code" href="nfs__proto__tools_8c.html#a1">nfs_FhandleToCache</a>( preq-&gt;rq_vers, 
00205                                          NULL,
00206                                          &amp;(parg-&gt;arg_readdirplus3.dir),
00207                                          NULL, 
00208                                          NULL,
00209                                          &amp;(pres-&gt;res_readdirplus3.status),
00210                                          NULL, 
00211                                          &amp;dir_attr,
00212                                          pcontext, 
00213                                          pclient, 
00214                                          ht, 
00215                                          &amp;rc ) ) == NULL )
00216     {
00217       <span class="comment">/* return NFS_REQ_DROP ; */</span>
00218      <span class="keywordflow">return</span> rc ;
00219     }
00220 
00221   <span class="comment">/* Extract the filetype */</span>
00222   dir_filetype = cache_inode_fsal_type_convert( dir_attr.type ) ;
00223   
00224         <span class="comment">/* Sanity checks -- must be a directory */</span>
00225 
00226   <span class="keywordflow">if</span>( ( dir_filetype != DIR_BEGINNING ) &amp;&amp; ( dir_filetype != DIR_CONTINUE ) )
00227     {
00228       pres-&gt;res_readdirplus3.status = NFS3ERR_NOTDIR;
00229       <span class="keywordflow">return</span> NFS_REQ_OK;
00230     } <span class="comment">/* switch */</span>
00231   
00232 
00233 
00234   memset(cookie_verifier, 0, <span class="keyword">sizeof</span>(cookieverf3));
00235 
00236   <span class="comment">/*</span>
00237 <span class="comment">   * If cookie verifier is used, then an non-trivial value is</span>
00238 <span class="comment">   * returned to the client         This value is the mtime of</span>
00239 <span class="comment">   * the directory. If verifier is unused (as in many NFS</span>
00240 <span class="comment">   * Servers) then only a set of zeros is returned (trivial</span>
00241 <span class="comment">   * value) </span>
00242 <span class="comment">   */</span>
00243   
00244   <span class="keywordflow">if</span>( pexport-&gt;UseCookieVerifier )
00245     memcpy( cookie_verifier, &amp;(dir_attr.mtime), <span class="keyword">sizeof</span>( dir_attr.mtime ) );
00246   
00247   <span class="comment">/*</span>
00248 <span class="comment">   * nothing to do if != 0 because the area is already full of</span>
00249 <span class="comment">   * zero </span>
00250 <span class="comment">   */</span>
00251   
00252   <span class="keywordflow">if</span>( pexport-&gt;UseCookieVerifier &amp;&amp; ( begin_cookie != 0 ) )
00253                 {
00254                         <span class="comment">/*</span>
00255 <span class="comment">                         * Not the first call, so we have to check the cookie</span>
00256 <span class="comment">                         * verifier </span>
00257 <span class="comment">                         */</span>
00258                         <span class="keywordflow">if</span> (memcmp(cookie_verifier, parg-&gt;arg_readdirplus3.cookieverf, NFS3_COOKIEVERFSIZE) != 0)
00259         {
00260           pres-&gt;res_readdirplus3.status = NFS3ERR_BAD_COOKIE;
00261           
00262           <span class="keywordflow">return</span> NFS_REQ_OK ;
00263         }
00264                 }
00265 
00266 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00267 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00268   BuddySetDebugLabel( <span class="stringliteral">"cache_inode_dir_entry_t in nfs3_Readdirplus"</span> ) ;
00269 <span class="preprocessor">#endif </span>
00270 <span class="preprocessor"></span>
00271         <span class="keywordflow">if</span>( ( dirent_array = (cache_inode_dir_entry_t *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>( cache_inode_dir_entry_t ) ) ) == NULL )
00272     {
00273       pres-&gt;res_readdirplus3.status = NFS3ERR_IO ;
00274       <span class="keywordflow">return</span> NFS_REQ_DROP ;
00275     }
00276 
00277 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00278 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00279   BuddySetDebugLabel( <span class="stringliteral">"cookie array in nfs3_Readdirplus"</span> ) ;
00280 <span class="preprocessor">#endif</span>
00281 <span class="preprocessor"></span>
00282   <span class="keywordflow">if</span>( ( cookie_array = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ) ) ) == NULL )
00283     {
00284       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00285       pres-&gt;res_readdirplus3.status = NFS3ERR_IO ;
00286       <span class="keywordflow">return</span> NFS_REQ_DROP ;
00287     }
00288   
00289   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries = NULL;
00290   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.eof     = FALSE;
00291 
00292   <span class="comment">/* How many entries will we retry from cache_inode ? */</span>
00293   <span class="keywordflow">if</span>( begin_cookie &gt; 1 )
00294     {
00295       asked_num_entries  = estimated_num_entries ;
00296       cache_inode_cookie = begin_cookie - 2 ;
00297     }
00298   <span class="keywordflow">else</span>
00299     {
00300       asked_num_entries  = ( ( estimated_num_entries &gt; 2 ) ? estimated_num_entries - 2 : 0 ) ; <span class="comment">/* Keep space for '.' and '..' */</span>
00301       cache_inode_cookie = 0 ;
00302     }
00303   
00304   <span class="comment">/* A definition that will be very useful to avoid very long names for variables */</span>
00305 <span class="preprocessor">#define RES_READDIRPLUS_REPLY pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply</span>
00306 <span class="preprocessor"></span>  
00307   <span class="comment">/* Call readdir */</span>
00308   <span class="keywordflow">if</span>( cache_inode_readdir( dir_pentry, 
00309                            cache_inode_cookie,
00310                            asked_num_entries, 
00311                            &amp;num_entries, 
00312                            &amp;end_cookie,
00313                            &amp;eod_met, 
00314                            dirent_array, 
00315                            cookie_array,
00316                            ht, 
00317                            pclient, 
00318                            pcontext, 
00319                            &amp;cache_status ) == CACHE_INODE_SUCCESS )
00320     {
00321 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00322 <span class="preprocessor"></span>      printf( <span class="stringliteral">"-- Readdirplus3 -&gt; Call to cache_inode_readdir( cookie=%d, asked=%d ) -&gt; num_entries = %d\n"</span>, 
00323          cache_inode_cookie, asked_num_entries, num_entries ) ; 
00324       
00325       <span class="keywordflow">if</span>( eod_met == END_OF_DIR )
00326         {
00327           printf( <span class="stringliteral">"+++++++++++++++++++++++++++++++++++++++++&gt; EOD MET \n"</span> ) ;
00328         }
00329 <span class="preprocessor">#endif</span>
00330 <span class="preprocessor"></span>      
00331       <span class="comment">/* If nothing was found, return nothing, but if cookie=0, we should return . and .. */</span>
00332       <span class="keywordflow">if</span>( ( num_entries == 0 ) &amp;&amp; ( asked_num_entries != 0 ) &amp;&amp; ( begin_cookie &gt; 1  ) )
00333         {
00334           pres-&gt;res_readdirplus3.status                                = NFS3_OK;
00335           pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries = NULL;
00336           pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.eof     = TRUE;
00337     
00338           <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00339                              dir_pentry, 
00340                              NULL,
00341                              &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.dir_attributes) );
00342           
00343           memcpy( pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.cookieverf, 
00344                   cookie_verifier, 
00345                   <span class="keyword">sizeof</span>( cookieverf3 ) );
00346         }
00347       <span class="keywordflow">else</span>
00348         {
00349 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00350 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00351           BuddySetDebugLabel( <span class="stringliteral">"entry_name_array in nfs3_Readdirplus"</span> );
00352 <span class="preprocessor">#endif   </span>
00353 <span class="preprocessor"></span>          <span class="comment">/* Allocation of the structure for reply */</span>
00354           entry_name_array = (entry_name_array_item_t  *)Mem_Alloc( estimated_num_entries * ( FSAL_MAX_NAME_LEN + 1));
00355           
00356           <span class="keywordflow">if</span>( entry_name_array == NULL )
00357             {
00358               Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00359               Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00360               <span class="keywordflow">return</span> NFS_REQ_DROP;
00361             }
00362 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00363 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00364           BuddySetDebugLabel( <span class="stringliteral">"READDIRPLUS3res_u.resok.reply.entries"</span> ) ;
00365 <span class="preprocessor">#endif  </span>
00366 <span class="preprocessor"></span>          pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries = (entryplus3 *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>(entryplus3));
00367 
00368           
00369           <span class="keywordflow">if</span>( pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries == NULL )
00370             {
00371               Mem_Free( (<span class="keywordtype">char</span> *)dirent_array );
00372               Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00373               Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00374               <span class="keywordflow">return</span> NFS_REQ_DROP;
00375             }
00376 
00377           <span class="comment">/* Allocation of the file handles */</span>
00378 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00379 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00380           BuddySetDebugLabel( <span class="stringliteral">"Filehandle V3 in nfs3_Readdirplus"</span> ) ;
00381 <span class="preprocessor">#endif   </span>
00382 <span class="preprocessor"></span>          fh3_array = (fh3_buffer_item_t *)Mem_Alloc( estimated_num_entries * NFS3_FHSIZE ) ;
00383 
00384 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00385 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00386           BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00387 <span class="preprocessor">#endif   </span>
00388 <span class="preprocessor"></span>        
00389           <span class="keywordflow">if</span>( fh3_array == NULL )
00390             {
00391               Mem_Free( (<span class="keywordtype">char</span> *)dirent_array );
00392               Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00393               Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00394 
00395               <span class="keywordflow">return</span> NFS_REQ_DROP;
00396             }
00397 
00398           delta = 0 ;
00399 
00400           <span class="comment">/* manage . and .. */</span>
00401           <span class="keywordflow">if</span>( begin_cookie == 0 )
00402             {
00403               <span class="comment">/* Fill in '.' */</span>
00404               <span class="keywordflow">if</span>( estimated_num_entries &gt; 0 )
00405                 {
00406                   <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( dir_pentry, 
00407                                                                     &amp;cache_status_gethandle ) ) == NULL )
00408                     {
00409                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00410                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00411                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00412                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00413 
00414                       pres-&gt;res_readdirplus3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00415                       <span class="keywordflow">return</span> NFS_REQ_OK ;
00416                     }
00417                   
00418                   FSAL_DigestHandle( pcontext-&gt;export_context,
00419                                      FSAL_DIGEST_FILEID3, 
00420                                      pfsal_handle,
00421                                      (caddr_t)&amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].fileid) ) ;
00422 
00423                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].name = entry_name_array[0] ;
00424                   strcpy( <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].name, <span class="stringliteral">"."</span> ) ;
00425 
00426                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].cookie = 1 ;
00427 
00428                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_handle.post_op_fh3_u.handle.data.data_val  
00429                     = (<span class="keywordtype">char</span> *)fh3_array[0] ;
00430                   
00431                   <span class="keywordflow">if</span>( nfs3_FSALToFhandle( &amp;pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_handle.post_op_fh3_u.handle,  
00432                                           pfsal_handle,
00433                                           pexport ) == 0  )
00434                     {
00435                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00436                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00437                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00438                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00439 
00440                       pres-&gt;res_readdirplus3.status = NFS3ERR_BADHANDLE ;
00441                       <span class="keywordflow">return</span> NFS_REQ_OK ;
00442                     }
00443 
00444     
00445                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].name_attributes.attributes_follow = FALSE;
00446                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].name_handle.handle_follows = FALSE;
00447                   
00448                   cache_inode_get_attributes(  dir_pentry, &amp;entry_attr ) ;
00449                   
00450                   <span class="comment">/* Set PostPoFh3 structure */</span>
00451                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_handle.handle_follows = TRUE ;
00452                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_handle.post_op_fh3_u.handle.data.data_len =
00453                     <span class="keyword">sizeof</span>( file_handle_v3_t ) ;
00454                   
00455                   <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00456                                      dir_pentry,
00457                                      &amp;entry_attr,
00458                                      &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_attributes));
00459 
00460                   delta += 1;
00461                 }
00462               
00463             }
00464               
00465               <span class="comment">/* Fill in '..' */</span>
00466           <span class="keywordflow">if</span>( begin_cookie &lt;= 1 )
00467             {
00468               <span class="keywordflow">if</span>( estimated_num_entries &gt; delta ) 
00469                 {
00470                   <span class="keywordflow">if</span>( ( pentry_dot_dot = cache_inode_lookupp( dir_pentry, 
00471                                                               ht, 
00472                                                               pclient, 
00473                                                               pcontext, 
00474                                                               &amp;cache_status_gethandle ) ) == NULL )
00475                     {
00476                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00477                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00478                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00479                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00480 
00481                       pres-&gt;res_readdirplus3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00482                       <span class="keywordflow">return</span> NFS_REQ_OK ;
00483                     }
00484                   
00485                   <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( pentry_dot_dot,
00486                                                                     &amp;cache_status_gethandle ) ) == NULL )
00487                     {
00488                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00489                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00490                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00491                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00492 
00493                       pres-&gt;res_readdirplus3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00494                       <span class="keywordflow">return</span> NFS_REQ_OK ;
00495                     }
00496                   
00497                   FSAL_DigestHandle( pcontext-&gt;export_context,
00498                                      FSAL_DIGEST_FILEID3,
00499                                      pfsal_handle,
00500                                      (caddr_t)&amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].fileid) ) ;
00501 
00502                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].name = entry_name_array[delta] ;
00503                   strcpy( <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].name, <span class="stringliteral">".."</span> ) ;
00504 
00505                   <span class="comment">/* Getting a file handle */</span>
00506                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[delta].name_handle.post_op_fh3_u.handle.data.data_val  =
00507                     (<span class="keywordtype">char</span> *)fh3_array[delta] ;
00508                   
00509                   <span class="keywordflow">if</span>( nfs3_FSALToFhandle( &amp;pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[0].name_handle.post_op_fh3_u.handle,
00510                                           pfsal_handle,
00511                                           pexport ) == 0  )
00512                     {
00513                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00514                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00515                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00516                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00517 
00518                       pres-&gt;res_readdirplus3.status = NFS3ERR_BADHANDLE ;
00519                       <span class="keywordflow">return</span> NFS_REQ_OK ;
00520                     }
00521                   
00522                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].cookie = 2 ;
00523 
00524                       
00525                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].name_attributes.attributes_follow = FALSE;
00526                   <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].name_handle.handle_follows = FALSE;
00527 
00528                   cache_inode_get_attributes(  pentry_dot_dot, &amp;entry_attr ) ;
00529 
00530                   <span class="comment">/* Set PostPoFh3 structure */</span>
00531                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[delta].name_handle.handle_follows = TRUE ;
00532                   pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[delta].name_handle.post_op_fh3_u.handle.data.data_len =
00533                     <span class="keyword">sizeof</span>( file_handle_v3_t ) ;
00534                   
00535                   <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00536                                      pentry_dot_dot,
00537                                      &amp;entry_attr,
00538                                      &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[delta].name_attributes));
00539                   
00540                   
00541                   
00542                 }
00543               <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[0].nextentry = &amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta]) ;
00544 
00545               <span class="keywordflow">if</span>( num_entries &gt; delta + 1  ) <span class="comment">/* not 0 ??? */</span>
00546                 <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].nextentry = &amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta+1]) ;
00547               <span class="keywordflow">else</span>
00548                 <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[delta].nextentry = NULL ;
00549               
00550               delta += 1 ;
00551             } <span class="comment">/* if( begin_cookie == 0 ) */</span>
00552       
00553           <span class="keywordflow">for</span>( i = delta; i &lt; num_entries + delta ; i++ )
00554             {
00555               <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   needed;
00556 
00557               <span class="comment">/* dircount is the size without the FH and attributes overhead, so entry3 is used intead of entryplus3 */</span>
00558               needed = <span class="keyword">sizeof</span>(entry3) + ( ( strlen( dirent_array[i-delta].name.name) + 3) &amp; ~3) ;
00559 
00560 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00561 <span class="preprocessor"></span>              <span class="comment">/* printf( "==============&gt; i=%d sizeof(entryplus3)=%d needed=%d space_used=%d maxcount=%d num_entries=%d asked_num_entries=%d\n",</span>
00562 <span class="comment">                 i, sizeof( entryplus3 ), needed, space_used, maxcount, num_entries, asked_num_entries ) ; */</span>
00563 <span class="preprocessor">#endif              </span>
00564 <span class="preprocessor"></span>              <span class="keywordflow">if</span>( ( space_used += needed ) &gt; maxcount )
00565                 {
00566                   <span class="keywordflow">if</span>( i == delta )
00567                     {
00568                       <span class="comment">/*</span>
00569 <span class="comment">                       * Not enough room to make even a single reply </span>
00570 <span class="comment">                       */</span>
00571                       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00572                       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00573                       Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array );     
00574                       Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00575 
00576                       pres-&gt;res_readdirplus3.status = NFS3ERR_TOOSMALL;
00577 
00578                       <span class="keywordflow">return</span> NFS_REQ_OK;
00579                     }
00580                   break ; <span class="comment">/* Make post traitement */</span>
00581                 }
00582               
00583               <span class="comment">/*</span>
00584 <span class="comment">               * Get information specific to this entry</span>
00585 <span class="comment">               */</span>
00586               <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( dirent_array[i-delta].pentry, 
00587                                                                 &amp;cache_status_gethandle ) ) == NULL )
00588                 {
00589                   Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00590                   Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00591                   Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array ); 
00592                   Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00593                   
00594                   pres-&gt;res_readdirplus3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00595                   <span class="keywordflow">return</span> NFS_REQ_OK ;
00596                 }
00597 
00598               <span class="comment">/* Now fill in the replyed entryplus3 list */</span>
00599               FSAL_DigestHandle( pcontext-&gt;export_context,
00600                                  FSAL_DIGEST_FILEID3, 
00601                                  pfsal_handle,
00602                                  (caddr_t)&amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].fileid) ) ;
00603               
00604               FSAL_name2str(  &amp;dirent_array[i-delta].name, entry_name_array[i], FSAL_MAX_NAME_LEN ) ;
00605               <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].name = entry_name_array[i];
00606 
00607               <span class="keywordflow">if</span>( i != num_entries + delta - 1 )
00608                 <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].cookie = cookie_array[i+1-delta]+2;
00609               <span class="keywordflow">else</span>
00610                 <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].cookie = end_cookie+2 ;
00611               
00612               <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].name_attributes.attributes_follow = FALSE;
00613               <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].name_handle.handle_follows = FALSE;
00614 
00615               cache_inode_get_attributes( dirent_array[i-delta].pentry, &amp;entry_attr ) ;
00616               
00617               pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[i].name_handle.post_op_fh3_u.handle.data.data_val  = 
00618                 (<span class="keywordtype">char</span> *)fh3_array[i] ;
00619 
00620               <span class="comment">/* Compute the NFSv3 file handle */</span>
00621               <span class="keywordflow">if</span>( nfs3_FSALToFhandle( &amp;pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[i].name_handle.post_op_fh3_u.handle,
00622                                       pfsal_handle,
00623                                       pexport ) == 0  )
00624                 {
00625                   Mem_Free( (<span class="keywordtype">char</span> *)dirent_array ) ;
00626                   Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00627                   Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array ); 
00628                   Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00629                   
00630                   pres-&gt;res_readdirplus3.status = NFS3ERR_BADHANDLE ;
00631                   <span class="keywordflow">return</span> NFS_REQ_OK ;
00632                 }
00633               
00634 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00635 <span class="preprocessor"></span>              printf( <span class="stringliteral">"-- Readdirplus3 -&gt; i=%d num_entries=%d needed=%d space_used=%lu maxcount=%lu Name=%s FileId=%llu Cookie=%llu\n"</span>, 
00636                       i, num_entries, needed, space_used, maxcount, dirent_array[i-delta].name.name, 
00637                       <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].fileid, <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].cookie ) ;
00638 <span class="preprocessor">#endif</span>
00639 <span class="preprocessor"></span>              
00640               <span class="comment">/* Set PostPoFh3 structure */</span>
00641               pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[i].name_handle.handle_follows = TRUE ;
00642               pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[i].name_handle.post_op_fh3_u.handle.data.data_len =
00643                 <span class="keyword">sizeof</span>( file_handle_v3_t ) ;
00644 
00645               <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00646                                  dirent_array[i-delta].pentry,
00647                                  &amp;entry_attr,
00648                                  &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.entries[i].name_attributes));
00649               
00650               <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i].nextentry = NULL;
00651               <span class="keywordflow">if</span> (i != 0)
00652                 <a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i - 1].nextentry = &amp;(<a class="code" href="nfs3__Readdirplus_8c.html#a0">RES_READDIRPLUS_REPLY</a>.entries[i]);
00653             }
00654           
00655           pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.eof = FALSE;
00656         }
00657       
00658       
00659       <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext,  
00660                          pexport,
00661                          dir_pentry,
00662                          &amp;dir_attr,
00663                          &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.dir_attributes));
00664       
00665       memcpy(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.cookieverf,
00666              cookie_verifier, <span class="keyword">sizeof</span>(cookieverf3));
00667       
00668       pres-&gt;res_readdirplus3.status = NFS3_OK;
00669       
00670       <span class="keywordflow">if</span>( ( eod_met == END_OF_DIR ) &amp;&amp; ( i == num_entries + delta ) )
00671         {
00672           <span class="comment">/* End of directory */</span>
00673 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00674 <span class="preprocessor"></span>          printf( <span class="stringliteral">"============================================================&gt; EOD MET !!!!!!\n"</span> ) ;
00675 <span class="preprocessor">#endif</span>
00676 <span class="preprocessor"></span>          pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.eof = TRUE ;
00677         }
00678       <span class="keywordflow">else</span>
00679         pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply.eof = FALSE ;
00680       
00681       <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00682                          dir_pentry, 
00683                          &amp;dir_attr,
00684                          &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.dir_attributes ) );
00685       memcpy(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.cookieverf, cookie_verifier, <span class="keyword">sizeof</span>(cookieverf3));
00686       
00687 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00688 <span class="preprocessor"></span>      printf( <span class="stringliteral">"============================================================\n"</span> ) ;
00689 <span class="preprocessor">#endif</span>
00690 <span class="preprocessor"></span> 
00691       <span class="comment">/* Free the memory */</span>
00692       Mem_Free( (<span class="keywordtype">char</span> *)dirent_array );
00693       Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00694 
00695       <span class="keywordflow">return</span> NFS_REQ_OK;
00696     }
00697   
00698   <span class="comment">/* If we are here, there was an error */</span>
00699 
00700   <span class="comment">/* Free the memory */</span>
00701   Mem_Free( (<span class="keywordtype">char</span> *)dirent_array );
00702   Mem_Free( (<span class="keywordtype">char</span> *)cookie_array ) ;
00703   Mem_Free( (<span class="keywordtype">char</span> *)entry_name_array ); 
00704   Mem_Free( (<span class="keywordtype">char</span> *)fh3_array ) ;
00705 
00706         <span class="comment">/* Is this a retryable error */</span>
00707         <span class="keywordflow">if</span>( <a class="code" href="nfs__proto__tools_8c.html#a5">nfs_RetryableError</a>( cache_status ) )
00708                 <span class="keywordflow">return</span> NFS_REQ_DROP;
00709   
00710   <span class="comment">/* Set failed status */</span>
00711         <a class="code" href="nfs__proto__tools_8c.html#a6">nfs_SetFailedStatus</a>( pcontext, pexport,
00712                        NFS_V3, 
00713                        cache_status,
00714                        NULL,
00715                        &amp;pres-&gt;res_readdirplus3.status,
00716                        dir_pentry,
00717                        &amp;(pres-&gt;res_readdirplus3.READDIRPLUS3res_u.resfail.dir_attributes),
00718                        NULL, NULL, NULL,
00719                        NULL, NULL, NULL);
00720   
00721         <span class="keywordflow">return</span> NFS_REQ_OK;
00722 } <span class="comment">/* nfs3_Readdirplus */</span>
00723 
<a name="l00732"></a><a class="code" href="nfs3__Readdirplus_8c.html#a3">00732</a> <span class="keywordtype">void</span> <a class="code" href="nfs3__Readdirplus_8c.html#a3">nfs3_Readdirplus_Free</a>(nfs_res_t * resp)
00733 {
00734   entryplus3 *readdir_entry;
00735   
00736 <span class="preprocessor">#define PRESREADDIRPLUSREPLY resp-&gt;res_readdirplus3.READDIRPLUS3res_u.resok.reply</span>
00737 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( (resp-&gt;res_readdirplus3.status == NFS3_OK) &amp;&amp;
00738       (<a class="code" href="nfs3__Readdirplus_8c.html#a1">PRESREADDIRPLUSREPLY</a>.entries != NULL) )
00739     {
00740       <span class="comment">/* All is allocated as a single array */</span>
00741       Mem_Free( <a class="code" href="nfs3__Readdirplus_8c.html#a1">PRESREADDIRPLUSREPLY</a>.entries[0].name ) ; 
00742       Mem_Free( <a class="code" href="nfs3__Readdirplus_8c.html#a1">PRESREADDIRPLUSREPLY</a>.entries[0].name_handle.post_op_fh3_u.handle.data.data_val ) ;
00743       Mem_Free( <a class="code" href="nfs3__Readdirplus_8c.html#a1">PRESREADDIRPLUSREPLY</a>.entries);      
00744     }
00745 } <span class="comment">/*  nfs3_Readdirplus_Free */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:28 2008 for NFS and Mount protocols layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
