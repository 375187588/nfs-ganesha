<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NFS and Mount protocols layer: nfs_proto_tools.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>nfs_proto_tools.c</h1><a href="nfs__proto__tools_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00087 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 
00092 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00093 <span class="preprocessor">#include &lt;string.h&gt;</span>
00094 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00095 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00096 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>  <span class="comment">/* for having FNDELAY */</span>
00097 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00098 <span class="preprocessor">#include &lt;grp.h&gt;</span>
00099 <span class="preprocessor">#include "HashData.h"</span>
00100 <span class="preprocessor">#include "HashTable.h"</span>
00101 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00103 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00104 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00105 <span class="preprocessor">#include &lt;gssrpc/pmap_clnt.h&gt;</span>
00106 <span class="preprocessor">#else</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00108 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00109 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00110 <span class="preprocessor">#include &lt;rpc/pmap_clnt.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 <span class="preprocessor"></span>
00113 <span class="preprocessor">#include "log_functions.h"</span>
00114 <span class="preprocessor">#include "stuff_alloc.h"</span>
00115 <span class="preprocessor">#include "nfs23.h"</span>
00116 <span class="preprocessor">#include "nfs4.h"</span>
00117 <span class="preprocessor">#include "mount.h"</span>
00118 <span class="preprocessor">#include "nfs_core.h"</span>
00119 <span class="preprocessor">#include "cache_inode.h"</span>
00120 <span class="preprocessor">#include "cache_content.h"</span>
00121 <span class="preprocessor">#include "nfs_exports.h"</span>
00122 <span class="preprocessor">#include "nfs_creds.h"</span>
00123 <span class="preprocessor">#include "nfs_proto_functions.h"</span>
00124 <span class="preprocessor">#include "nfs_tools.h"</span>
00125 <span class="preprocessor">#include "nfs_file_handle.h"</span>
00126 <span class="preprocessor">#include "nfs_proto_tools.h"</span>
00127 
00128 <span class="keyword">extern</span> nfs_parameter_t nfs_param ;
00129 
00130 
<a name="l00153"></a><a class="code" href="nfs__proto__tools_8c.html#a1">00153</a> cache_entry_t * <a class="code" href="nfs__proto__tools_8c.html#a1">nfs_FhandleToCache</a>(  u_long                 rq_vers, 
00154                                      fhandle2             * pfh2, 
00155                                      nfs_fh3              * pfh3,
00156                                      nfs_fh4              * pfh4,
00157                                      nfsstat2             * pstatus2,
00158                                      nfsstat3             * pstatus3, 
00159                                      nfsstat4             * pstatus4,
00160                                      fsal_attrib_list_t   * pattr, 
00161                                      fsal_op_context_t    * pcontext,   
00162                                      cache_inode_client_t * pclient,
00163                                      hash_table_t         * ht, 
00164                                      <span class="keywordtype">int</span>                  * prc )
00165 {
00166   cache_inode_fsal_data_t   fsal_data ;
00167   cache_inode_status_t      cache_status ;
00168   cache_entry_t           * pentry = NULL ;
00169   fsal_attrib_list_t        attr ;
00170   <span class="keywordtype">short</span>                     exportid ;
00171 
00172   <span class="comment">/* Default behaviour */</span> 
00173   *prc = NFS_REQ_OK ; 
00174  
00175   <span class="keywordflow">switch</span>( rq_vers )
00176     {
00177     <span class="keywordflow">case</span> NFS_V4:
00178       <span class="keywordflow">if</span>( !nfs4_FhandleToFSAL( pfh4, &amp;fsal_data.handle, pcontext ) )
00179         {
00180           *prc      = NFS_REQ_DROP ;
00181           *pstatus4 = NFS4ERR_BADHANDLE ;
00182           <span class="keywordflow">return</span> NULL ;
00183         }
00184       exportid = nfs4_FhandleToExportId( pfh4 ) ;
00185       break ;
00186       
00187     <span class="keywordflow">case</span> NFS_V3:
00188       <span class="keywordflow">if</span>( !nfs3_FhandleToFSAL( pfh3, &amp;fsal_data.handle, pcontext ) )
00189         {
00190           *prc      = NFS_REQ_DROP ;
00191           *pstatus3 = NFS3ERR_BADHANDLE ;
00192           <span class="keywordflow">return</span> NULL ;
00193         }
00194       exportid = nfs3_FhandleToExportId( pfh3 ) ;
00195       break ;
00196       
00197     <span class="keywordflow">case</span> NFS_V2:
00198       <span class="keywordflow">if</span>( !nfs2_FhandleToFSAL( pfh2, &amp;fsal_data.handle, pcontext ) )
00199         {
00200           *prc      = NFS_REQ_DROP ;
00201           *pstatus2 = NFSERR_STALE ;
00202           <span class="keywordflow">return</span> NULL ;
00203         }
00204       exportid = nfs2_FhandleToExportId( pfh2 ) ;
00205       break ;
00206     }
00207   fsal_data.cookie = DIR_START ;
00208 <span class="preprocessor">#ifdef _DEBUG_FILEHANDLE</span>
00209 <span class="preprocessor"></span>  print_buff( (<span class="keywordtype">char</span> *)&amp;fsal_data.handle, <span class="keyword">sizeof</span>( fsal_data.handle ) ) ;
00210 <span class="preprocessor">#endif</span>
00211 <span class="preprocessor"></span>
00212   <span class="keywordflow">if</span>( ( pentry = cache_inode_get( &amp;fsal_data, 
00213                                   &amp;attr, 
00214                                   ht, 
00215                                   pclient, 
00216                                   pcontext, 
00217                                   &amp;cache_status ) ) == NULL )
00218     {
00219       <span class="keywordflow">switch</span>( rq_vers )
00220         {
00221         <span class="keywordflow">case</span> NFS_V4:
00222           *pstatus4 = NFS4ERR_STALE ;
00223           break ;
00224           
00225         <span class="keywordflow">case</span> NFS_V3:
00226           *pstatus3 = NFS3ERR_STALE ;
00227           break ;
00228           
00229         <span class="keywordflow">case</span> NFS_V2:
00230           *pstatus2 = NFSERR_STALE ;
00231           break ;
00232         }
00233       *prc = NFS_REQ_OK ;
00234       <span class="keywordflow">return</span> NULL ;
00235     }
00236   
00237   <span class="keywordflow">if</span>( pattr != NULL )
00238     *pattr = attr ;
00239 
00240   <span class="keywordflow">return</span> pentry ;
00241 } <span class="comment">/* nfs_FhandleToCache */</span>
00242 
00243 
00244 
<a name="l00258"></a><a class="code" href="nfs__proto__tools_8c.html#a2">00258</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>(fsal_op_context_t  * pcontext,
00259                       exportlist_t       * pexport,
00260                       cache_entry_t      * pentry,
00261                       fsal_attrib_list_t * pfsal_attr,
00262                       post_op_attr       * presult )
00263 {
00264   <span class="keywordflow">if</span>( pentry == NULL )
00265     {
00266       presult-&gt;attributes_follow = FALSE;
00267       <span class="keywordflow">return</span> 0 ;
00268     }
00269   
00270   <span class="keywordflow">if</span>( pfsal_attr == NULL )
00271     {
00272       presult-&gt;attributes_follow = FALSE;
00273       <span class="keywordflow">return</span> 0 ;
00274     }
00275 
00276   <span class="keywordflow">if</span>( <a class="code" href="nfs__proto__tools_8c.html#a18">nfs3_FSALattr_To_Fattr</a>( pexport, pfsal_attr , &amp;(presult-&gt;post_op_attr_u.attributes) ) == 0 )
00277     presult-&gt;attributes_follow = FALSE;
00278   <span class="keywordflow">else</span>
00279     presult-&gt;attributes_follow = TRUE ;
00280   
00281   <span class="keywordflow">return</span> 0;
00282 } <span class="comment">/* nfs_SetPostOpAttr */</span>
00283 
00284 
<a name="l00297"></a><a class="code" href="nfs__proto__tools_8c.html#a3">00297</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a3">nfs_SetPreOpAttr</a>( fsal_attrib_list_t * pfsal_attr,
00298                        pre_op_attr        * pattr )
00299 {
00300   <span class="keywordflow">if</span>( pfsal_attr == NULL)
00301     {
00302       pattr-&gt;attributes_follow = FALSE;
00303     } 
00304   <span class="keywordflow">else</span>
00305     {
00306       pattr-&gt;pre_op_attr_u.attributes.size = pfsal_attr-&gt;filesize ;
00307             
00308       pattr-&gt;pre_op_attr_u.attributes.mtime.seconds   = pfsal_attr-&gt;mtime.seconds ;
00309       pattr-&gt;pre_op_attr_u.attributes.mtime.nseconds =  pfsal_attr-&gt;mtime.nseconds ;
00310 
00311       pattr-&gt;pre_op_attr_u.attributes.ctime.seconds  = pfsal_attr-&gt;ctime.seconds ;
00312       pattr-&gt;pre_op_attr_u.attributes.ctime.nseconds = pfsal_attr-&gt;ctime.nseconds ;
00313 
00314       pattr-&gt;attributes_follow = TRUE;
00315     }
00316 } <span class="comment">/* nfs_SetPreOpAttr */</span>
00317 
00318 
00319 
<a name="l00335"></a><a class="code" href="nfs__proto__tools_8c.html#a4">00335</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a4">nfs_SetWccData</a>( fsal_op_context_t  * pcontext, 
00336                      exportlist_t       * pexport,
00337                      cache_entry_t      * pentry, 
00338                      fsal_attrib_list_t * pbefore_attr,
00339                      fsal_attrib_list_t * pafter_attr,
00340                      wcc_data           * pwcc_data )
00341 {
00342   <span class="comment">/* Build directory pre operation attributes */</span>
00343   <a class="code" href="nfs__proto__tools_8c.html#a3">nfs_SetPreOpAttr</a>( pbefore_attr, 
00344                     &amp;(pwcc_data-&gt;before) );
00345   
00346   <span class="comment">/* Build directory post operation attributes */</span>
00347   <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext,
00348                      pexport, 
00349                      pentry, 
00350                      pafter_attr,
00351                      &amp;(pwcc_data-&gt;after) );
00352 
00353   return ;
00354 } <span class="comment">/* nfs_SetWccData */</span>
00355 
<a name="l00369"></a><a class="code" href="nfs__proto__tools_8c.html#a5">00369</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a5">nfs_RetryableError</a>( cache_inode_status_t cache_status )
00370 {
00371   <span class="keywordflow">switch</span>( cache_status )
00372    {
00373       <span class="keywordflow">case</span> CACHE_INODE_IO_ERROR :
00374       <span class="keywordflow">if</span>( <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.core_param.drop_io_errors ) 
00375       {
00376         <span class="comment">/* Drop the request */</span>
00377         <span class="keywordflow">return</span> TRUE ;
00378       }
00379       <span class="keywordflow">else</span>
00380       {
00381         <span class="comment">/* Propagate error to the client */</span>
00382         <span class="keywordflow">return</span> FALSE ;
00383       } 
00384       break ;
00385 
00386       <span class="keywordflow">case</span> CACHE_INODE_INVALID_ARGUMENT     :
00387       <span class="keywordflow">if</span>( <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.core_param.drop_inval_errors ) 
00388       {
00389         <span class="comment">/* Drop the request */</span>
00390         <span class="keywordflow">return</span> TRUE ;
00391       }
00392       <span class="keywordflow">else</span>
00393       {
00394         <span class="comment">/* Propagate error to the client */</span>
00395         <span class="keywordflow">return</span> FALSE ;
00396       } 
00397       break ;
00398        
00399        
00400        <span class="keywordflow">case</span> CACHE_INODE_SUCCESS:
00401            <span class="comment">/* DisplayLog( "Possible implementation error: CACHE_INODE_SUCCESS managed as an error" ) ; */</span>
00402            <span class="keywordflow">return</span> FALSE ;
00403            break ;
00404  
00405        <span class="keywordflow">case</span> CACHE_INODE_MALLOC_ERROR         :
00406        <span class="keywordflow">case</span> CACHE_INODE_POOL_MUTEX_INIT_ERROR:
00407        <span class="keywordflow">case</span> CACHE_INODE_GET_NEW_LRU_ENTRY    :
00408        <span class="keywordflow">case</span> CACHE_INODE_UNAPPROPRIATED_KEY   :
00409        <span class="keywordflow">case</span> CACHE_INODE_INIT_ENTRY_FAILED    :
00410        <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERROR           :
00411        <span class="keywordflow">case</span> CACHE_INODE_LRU_ERROR            :
00412        <span class="keywordflow">case</span> CACHE_INODE_HASH_SET_ERROR       :
00413        <span class="keywordflow">case</span> CACHE_INODE_INCONSISTENT_ENTRY   :
00414        <span class="keywordflow">case</span> CACHE_INODE_HASH_TABLE_ERROR     :
00415        <span class="keywordflow">case</span> CACHE_INODE_INSERT_ERROR         :
00416            <span class="comment">/* Internal error, should be dropped and retryed */</span>
00417            <span class="keywordflow">return</span> TRUE ;
00418            break ;
00419  
00420        <span class="keywordflow">case</span> CACHE_INODE_NOT_A_DIRECTORY       :
00421        <span class="keywordflow">case</span> CACHE_INODE_BAD_TYPE              :
00422        <span class="keywordflow">case</span> CACHE_INODE_ENTRY_EXISTS          :
00423        <span class="keywordflow">case</span> CACHE_INODE_DIR_NOT_EMPTY         : 
00424        <span class="keywordflow">case</span> CACHE_INODE_NOT_FOUND             :
00425        <span class="keywordflow">case</span> CACHE_INODE_FSAL_EACCESS          :
00426        <span class="keywordflow">case</span> CACHE_INODE_IS_A_DIRECTORY        :
00427        <span class="keywordflow">case</span> CACHE_INODE_FSAL_EPERM            :
00428        <span class="keywordflow">case</span> CACHE_INODE_NO_SPACE_LEFT         :
00429        <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_ERROR   :
00430        <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EXISTS  :
00431        <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EMPTY   :
00432        <span class="keywordflow">case</span> CACHE_INODE_READ_ONLY_FS          : 
00433        <span class="keywordflow">case</span> CACHE_INODE_FSAL_ESTALE           :
00434        <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERR_SEC          :
00435        <span class="keywordflow">case</span> CACHE_INODE_QUOTA_EXCEEDED        :
00436            <span class="comment">/* Non retryable error, return error to client */</span>
00437            <span class="keywordflow">return</span> FALSE ;       
00438            break ;
00439     
00440        <span class="keywordflow">default</span>:
00441            <span class="comment">/* Management of this value was forgotten */</span>
00442            DisplayLog( <span class="stringliteral">"cache_inode_status=%u not managed properly in nfs_RetryableError, not retryable"</span>, cache_status ) ;  
00443            <span class="keywordflow">return</span> FALSE ;
00444      }
00445 
00446   <span class="comment">/* Should never reach this */</span>
00447   DisplayLog( <span class="stringliteral">"cache_inode_status=%u not managed properly in nfs_RetryableError, line %u should never be reached"</span>, cache_status, __LINE__ ) ;
00448   <span class="keywordflow">return</span> FALSE   ;
00449 }
00450  
<a name="l00451"></a><a class="code" href="nfs__proto__tools_8c.html#a6">00451</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a6">nfs_SetFailedStatus</a>( fsal_op_context_t      * pcontext,
00452                           exportlist_t           * pexport,
00453                           <span class="keywordtype">int</span>                      version,
00454                           cache_inode_status_t     status,
00455                           nfsstat2               * pstatus2,
00456                           nfsstat3               * pstatus3,
00457                           cache_entry_t          * pentry0,
00458                           post_op_attr           * ppost_op_attr,
00459                           cache_entry_t          * pentry1,
00460                           fsal_attrib_list_t     * ppre_vattr1,
00461                           wcc_data               * pwcc_data1,
00462                           cache_entry_t          * pentry2,
00463                           fsal_attrib_list_t     * ppre_vattr2,
00464                           wcc_data               * pwcc_data2)
00465 {
00466   <span class="keywordflow">switch</span> (version)
00467     {
00468     <span class="keywordflow">case</span> NFS_V2:
00469       <span class="keywordflow">if</span>( status != CACHE_INODE_SUCCESS ) <span class="comment">/* Should not use success to address a failed status */</span>
00470         *pstatus2 = <a class="code" href="nfs__proto__tools_8c.html#a28">nfs2_Errno</a>( status );
00471       <span class="keywordflow">break</span>;
00472       
00473     <span class="keywordflow">case</span> NFS_V3:
00474       <span class="keywordflow">if</span>( status != CACHE_INODE_SUCCESS ) <span class="comment">/* Should not use success to address a failed status */</span>
00475         *pstatus3 = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( status );
00476       
00477       <span class="keywordflow">if</span>( ppost_op_attr != NULL )
00478         <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport, pentry0, NULL, ppost_op_attr);
00479       
00480       <span class="keywordflow">if</span>( pwcc_data1 != NULL )
00481         <a class="code" href="nfs__proto__tools_8c.html#a4">nfs_SetWccData</a>( pcontext, pexport, pentry1, ppre_vattr1, NULL, pwcc_data1 );
00482       
00483       <span class="keywordflow">if</span>( pwcc_data2 != NULL)
00484         <a class="code" href="nfs__proto__tools_8c.html#a4">nfs_SetWccData</a>( pcontext, pexport, pentry2, ppre_vattr2, NULL, pwcc_data2 );
00485       break ;
00486       
00487     }
00488 }
00489 
<a name="l00505"></a><a class="code" href="nfs__proto__tools_8c.html#a7">00505</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a7">nfs4_FSALattr_To_Fattr</a>( exportlist_t       * pexport,
00506                             fsal_attrib_list_t * pattr, 
00507                             fattr4             * Fattr, 
00508                             compound_data_t    * data, 
00509                             nfs_fh4            * objFH,
00510                             bitmap4            * Bitmap) 
00511 {
00512   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>        file_used64 ;
00513   fattr4_type               file_type ;
00514   fattr4_link_support       link_support ;
00515   fattr4_symlink_support    symlink_support ;
00516   fattr4_fh_expire_type     expire_type ;
00517   fattr4_named_attr         named_attr ;
00518   fattr4_unique_handles     unique_handles ;
00519   fattr4_archive            archive ;
00520   fattr4_cansettime         cansettime ;
00521   fattr4_case_insensitive   case_insensitive ;
00522   fattr4_case_preserving    case_preserving ;
00523   fattr4_chown_restricted   chown_restricted ;
00524   fattr4_hidden             hidden ;
00525   fattr4_mode               file_mode ;
00526   fattr4_no_trunc           no_trunc ;
00527   fattr4_numlinks           file_numlinks ;
00528   fattr4_rawdev             rawdev ;
00529   fattr4_system             system ;
00530   fattr4_size               file_size ;
00531   fattr4_space_used         file_space_used ;
00532   fattr4_fsid               fsid ;
00533   fattr4_time_access        time_access ;
00534   fattr4_time_modify        time_modify ;
00535   fattr4_time_metadata      time_metadata ;
00536   fattr4_time_delta         time_delta ;
00537   fattr4_change             file_change ;
00538   fattr4_fileid             file_id ;
00539   fattr4_owner              file_owner ;
00540   fattr4_owner_group        file_owner_group ;
00541   fattr4_space_avail        space_avail ;
00542   fattr4_space_free         space_free ;
00543   fattr4_space_total        space_total ;
00544   fattr4_files_avail        files_avail ;
00545   fattr4_files_free         files_free ;
00546   fattr4_files_total        files_total ;
00547   fattr4_lease_time         lease_time ;
00548   fattr4_time_backup        time_backup ;
00549   fattr4_time_create        time_create ;
00550   fattr4_maxfilesize        max_filesize ;
00551   fattr4_supported_attrs    supported_attrs ;
00552   fattr4_fs_locations       fs_locations ;
00553   fattr4_maxread            maxread ;
00554   fattr4_maxwrite           maxwrite ;
00555   fattr4_maxname            maxname ;
00556   fattr4_maxlink            maxlink ;
00557   fattr4_homogeneous        homogeneous ;
00558   fattr4_aclsupport         aclsupport ;
00559   fattr4_acl                acl ;
00560   fattr4_mimetype           mimetype ;
00561   fattr4_mounted_on_fileid  mounted_on_fileid ;
00562   fattr4_rdattr_error       rdattr_error ;
00563   fattr4_quota_avail_hard   quota_avail_hard ;
00564   fattr4_quota_avail_soft   quota_avail_soft ;
00565   fattr4_quota_used         quota_used ;
00566   fattr4_time_modify_set    time_modify_set ;
00567   fattr4_time_access_set    time_access_set ;
00568   uint32_t attribute_to_set = 0 ; 
00569 
00570   u_int    fhandle_len = 0 ; 
00571   uint32_t supported_attrs_len ;
00572   uint32_t supported_attrs_val ;
00573   u_int    LastOffset ;
00574   u_int    len = 0 , off = 0 ; <span class="comment">/* Use for XDR alignment */</span>
00575   <span class="keywordtype">int</span>      op_attr_success = 0 ;
00576   <span class="keywordtype">char</span>     funcname[] = <span class="stringliteral">"nfs4_FSALattr_To_Fattr"</span> ;
00577 
00578   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> attrvalslist_supported[FATTR4_MOUNTED_ON_FILEID] ;
00579   uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
00580   uint32_t attrmasklen = 0 ;
00581   uint32_t attrvalslist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
00582   <span class="keywordtype">char</span> attrvalsBuffer[ ATTRVALS_BUFFLEN] ;
00583   
00584   uint_t i      = 0 ;
00585   uint_t j      = 0 ;
00586   uint_t k      = 0 ;
00587   uint_t c      = 0 ;
00588 
00589   <span class="keywordtype">int</span>            status = 0 ;
00590   cache_inode_status_t cache_status ;
00591   
00592   <span class="keywordtype">int</span> statfscalled = 0 ;
00593   fsal_staticfsinfo_t  staticinfo ;
00594   fsal_dynamicfsinfo_t dynamicinfo ;
00595   
00596   fsal_handle_t mounted_on_fsal_handle ;
00597   fsal_status_t fsal_status ;
00598 
00599   <span class="comment">/* basic init */</span>
00600   memset( attrvalsBuffer, 0, NFS4_ATTRVALS_BUFFLEN ) ;
00601   memset( (uint32_t *)attrmasklist, 0, FATTR4_MOUNTED_ON_FILEID * <span class="keyword">sizeof</span>( uint32_t ) ) ;
00602   memset( (uint32_t *)attrvalslist, 0, FATTR4_MOUNTED_ON_FILEID * <span class="keyword">sizeof</span>( uint32_t ) ) ;
00603   
00604   <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
00605   <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( Bitmap, &amp;attrmasklen, attrmasklist ) ;
00606 
00607   <span class="comment">/* Once the bitmap has been converted to a list of attribute, manage each attribute */</span>
00608   Fattr-&gt;attr_vals.attrlist4_len = 0 ;
00609   LastOffset  = 0 ; 
00610   j=0 ;
00611 
00612 
00613   <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen ; i++ )
00614     {
00615       attribute_to_set = attrmasklist[i] ;
00616 
00617       <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
00618         {
00619           <span class="comment">/* Erroneous value... skip */</span>
00620           continue ;
00621         }
00622   
00623 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
00624 <span class="preprocessor"></span>      DisplayLogLevel( NIV_FULL_DEBUG,
00625                        <span class="stringliteral">"Flag for Operation (Regular) = %d|%d is ON,  name  = %s  reply_size = %d"</span>,
00626                        attrmasklist[i], 
00627                        fattr4tab[attribute_to_set].val, 
00628                        fattr4tab[attribute_to_set].name, 
00629                        fattr4tab[attribute_to_set].size_fattr4 ) ;
00630 <span class="preprocessor">#endif</span>
00631 <span class="preprocessor"></span>
00632       op_attr_success = 0 ;
00633       
00634       <span class="comment">/* compute the new size for the fattr4 reply */</span>
00635       <span class="comment">/* This space is to be filled below in the big switch/case statement */</span>
00636       <span class="keywordflow">switch</span>( attribute_to_set )
00637         {
00638         <span class="keywordflow">case</span> FATTR4_SUPPORTED_ATTRS:              
00639           <span class="comment">/* The supported attributes have field ',supported' set in tab fattr4tab, I will proceed in 2 pass </span>
00640 <span class="comment">           * 1st: compute the number of supported attributes</span>
00641 <span class="comment">           * 2nd: allocate the replyed bitmap and fill it</span>
00642 <span class="comment">           *</span>
00643 <span class="comment">           * I do not set a #define to keep the number of supported attributes because I want this parameter</span>
00644 <span class="comment">           * to be a consequence of fattr4tab and avoid incoherency */</span>
00645           
00646           <span class="comment">/* How many supported attributes ? Compute the result in variable named c */</span>
00647           c = 0 ;
00648           <span class="keywordflow">for</span>( k = FATTR4_SUPPORTED_ATTRS ; k &lt;= FATTR4_MOUNTED_ON_FILEID ; k++ )
00649             {
00650               <span class="keywordflow">if</span>( fattr4tab[k].supported )
00651                 {
00652                   attrvalslist_supported[c++] = k ;
00653                 }
00654             }
00655           
00656           <span class="comment">/* Let set the reply bitmap */</span>
00657           <span class="keywordflow">if</span>( ( supported_attrs.bitmap4_val = (uint32_t *)Mem_Alloc(  2*<span class="keyword">sizeof</span>( uint32_t ) ) ) == NULL )
00658                 <span class="keywordflow">return</span> -1 ;
00659           memset( supported_attrs.bitmap4_val, 0,  2*<span class="keyword">sizeof</span>( uint32_t ) ) ;
00660 
00661           <a class="code" href="nfs__proto__tools_8c.html#a17">nfs4_list_to_bitmap4</a>( &amp;supported_attrs, &amp;c, attrvalslist_supported ) ;
00662 
00663 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
00664 <span class="preprocessor"></span>          DisplayLogLevel( NIV_FULL_DEBUG, <span class="stringliteral">"Fattr (regular) supported_attrs(len)=%u -&gt; %u|%u"</span>, 
00665                            supported_attrs.bitmap4_len, supported_attrs.bitmap4_val[0],
00666                            supported_attrs.bitmap4_val[1] ) ;
00667 <span class="preprocessor">#endif</span>
00668 <span class="preprocessor"></span>
00669           <span class="comment">/* This kind of operation is always a success */</span>
00670           op_attr_success = 1 ; 
00671 
00672           <span class="comment">/* we store the index */</span>
00673           supported_attrs_len = htonl( supported_attrs.bitmap4_len ) ; 
00674           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;supported_attrs_len, <span class="keyword">sizeof</span>( uint32_t ) ) ; 
00675           LastOffset += <span class="keyword">sizeof</span>( uint32_t ) ;   
00676 
00677           <span class="comment">/* And then the data */</span>
00678           <span class="keywordflow">for</span>( k = 0 ; k &lt;  supported_attrs.bitmap4_len ; k++ )
00679             {
00680               supported_attrs_val = htonl( supported_attrs.bitmap4_val[k] );
00681               memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;supported_attrs_val, <span class="keyword">sizeof</span>( uint32_t ) ) ;
00682               LastOffset += <span class="keyword">sizeof</span>( uint32_t ) ;
00683             }
00684           break ; 
00685               
00686                
00687         <span class="keywordflow">case</span> FATTR4_TYPE:
00688           <span class="keywordflow">switch</span>( pattr-&gt;type )
00689             {
00690             <span class="keywordflow">case</span> FSAL_TYPE_FILE:
00691               file_type = htonl( NF4REG ) ; <span class="comment">/* Regular file */</span>
00692               break ;
00693                   
00694             <span class="keywordflow">case</span> FSAL_TYPE_DIR:
00695               file_type = htonl( NF4DIR ); <span class="comment">/* Directory */</span>
00696               break ;
00697 
00698             <span class="keywordflow">case</span> FSAL_TYPE_BLK:
00699               file_type = htonl( NF4BLK ); <span class="comment">/* Special File - block device */</span>
00700               break ;
00701                   
00702             <span class="keywordflow">case</span> FSAL_TYPE_CHR:
00703               file_type = htonl( NF4CHR ) ; <span class="comment">/* Special File - character device */</span>
00704               break ;
00705                   
00706             <span class="keywordflow">case</span> FSAL_TYPE_LNK:
00707               file_type = htonl( NF4LNK ) ; <span class="comment">/* Symbolic Link */</span>
00708               break ;
00709 
00710             <span class="keywordflow">case</span> FSAL_TYPE_SOCK:
00711               file_type = htonl( NF4SOCK ) ; <span class="comment">/* Special File - socket */</span>
00712               break ;
00713                   
00714             <span class="keywordflow">case</span> FSAL_TYPE_FIFO :
00715               file_type = htonl( NF4FIFO ) ; <span class="comment">/* Special File - fifo */</span>
00716               break ;
00717               
00718             <span class="keywordflow">default</span>: <span class="comment">/* For wanting of a better solution */</span>
00719               file_type =  0 ;
00720               op_attr_success =0 ; <span class="comment">/* This was no success */</span>
00721               break ;
00722             } <span class="comment">/* switch( pattr-&gt;type ) */</span>
00723 
00724           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;file_type, <span class="keyword">sizeof</span>( fattr4_type ) ) ;
00725           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00726           op_attr_success = 1 ;
00727           break ;
00728               
00729         <span class="keywordflow">case</span> FATTR4_FH_EXPIRE_TYPE:
00730           <span class="comment">/* For the moment, we handle only the persistent filehandle */</span>
00731           <span class="keywordflow">if</span>( <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.nfsv4_param.fh_expire == TRUE )
00732                 expire_type = htonl( FH4_VOLATILE_ANY ) ;
00733           <span class="keywordflow">else</span>
00734                 expire_type = htonl( FH4_PERSISTENT ) ; 
00735           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;expire_type, <span class="keyword">sizeof</span>( expire_type ) ) ;
00736           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00737           op_attr_success = 1 ;
00738           break ;
00739               
00740         <span class="keywordflow">case</span> FATTR4_CHANGE:
00741           <span class="comment">/* a value that change when the object change. I use the file's mtime */</span>
00742           memset( &amp;file_change, 0, <span class="keyword">sizeof</span>( changeid4 ) ) ;
00743           file_change = nfs_htonl64( (changeid4)pattr-&gt;chgtime.seconds );
00744 
00745           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;file_change, <span class="keyword">sizeof</span>(  fattr4_change ) ) ;
00746           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00747           op_attr_success = 1 ;
00748           break ;
00749               
00750         <span class="keywordflow">case</span> FATTR4_SIZE:
00751           file_size =  nfs_htonl64( (fattr4_size)pattr-&gt;filesize ) ;
00752           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;file_size, <span class="keyword">sizeof</span>(  fattr4_size ) ) ;
00753           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00754           op_attr_success = 1 ;
00755           break ;
00756               
00757         <span class="keywordflow">case</span> FATTR4_LINK_SUPPORT:
00758           <span class="comment">/* HPSS NameSpace support hard link */</span>
00759           link_support = htonl( TRUE ) ;
00760           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;link_support, <span class="keyword">sizeof</span>( fattr4_link_support )) ; 
00761           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00762           op_attr_success = 1 ;
00763           break ;
00764               
00765         <span class="keywordflow">case</span> FATTR4_SYMLINK_SUPPORT:
00766           <span class="comment">/* HPSS NameSpace support symbolic link */</span>
00767           symlink_support = htonl( TRUE ) ;
00768           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;symlink_support, <span class="keyword">sizeof</span>( fattr4_symlink_support )) ; 
00769           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00770           op_attr_success = 1 ;
00771           break ;
00772               
00773         <span class="keywordflow">case</span> FATTR4_NAMED_ATTR:
00774           <span class="comment">/* For this version of the binary, named attributes is not supported */</span>
00775           named_attr = htonl( FALSE );
00776           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;named_attr, <span class="keyword">sizeof</span>( fattr4_named_attr )) ;
00777           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00778           op_attr_success = 1 ;
00779           break ;
00780               
00781         <span class="keywordflow">case</span> FATTR4_FSID:
00782           <span class="comment">/* The file system id (taken from the configuration file) */</span>
00783           fsid.major = nfs_htonl64( (uint64_t)pexport-&gt;filesystem_id.major );
00784           fsid.minor = nfs_htonl64( (uint64_t)pexport-&gt;filesystem_id.minor ) ;
00785           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;fsid, <span class="keyword">sizeof</span>( fattr4_fsid) ) ;
00786           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00787           op_attr_success = 1 ;
00788           break ;
00789               
00790         <span class="keywordflow">case</span> FATTR4_UNIQUE_HANDLES:
00791           <span class="comment">/* Filehandles are unique */</span>
00792           unique_handles = htonl( TRUE );
00793           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;unique_handles, <span class="keyword">sizeof</span>( fattr4_unique_handles) ) ;
00794           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00795           op_attr_success = 1 ;
00796           break ;
00797               
00798         <span class="keywordflow">case</span> FATTR4_LEASE_TIME:
00799           <span class="keywordflow">if</span>( !statfscalled )
00800             {
00801               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00802                                                        &amp;staticinfo, 
00803                                                        &amp;dynamicinfo, 
00804                                                        data-&gt;pcontext,
00805                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00806                 {
00807                   op_attr_success = 0 ;
00808                   break ;
00809                 }
00810               <span class="keywordflow">else</span>
00811                 statfscalled = 1 ;
00812             }
00813           <span class="comment">/* lease_time = htonl( (fattr4_lease_time)staticinfo.lease_time.seconds ) ; */</span>
00814           lease_time = htonl( <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.nfsv4_param.lease_lifetime ) ;
00815           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;lease_time, <span class="keyword">sizeof</span>( fattr4_lease_time ) ) ;
00816           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00817           op_attr_success = 1 ;
00818           break ;
00819               
00820         <span class="keywordflow">case</span> FATTR4_RDATTR_ERROR:
00821           rdattr_error = htonl( NFS4_OK ) ; <span class="comment">/* By default, READDIR call may use a different value */</span>
00822           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;rdattr_error, <span class="keyword">sizeof</span>( fattr4_rdattr_error ) );
00823           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00824           op_attr_success = 1 ;
00825           break ;
00826               
00827         <span class="keywordflow">case</span> FATTR4_ACL:
00828           acl.fattr4_acl_len = htonl( 0 ); <span class="comment">/* NOT IMPLEMENTED YET, BUT WILL BE, no ACL for the moment */</span>
00829           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;acl, <span class="keyword">sizeof</span>( fattr4_acl ) ) ;
00830           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00831           op_attr_success = 1 ;
00832           break ;
00833               
00834         <span class="keywordflow">case</span> FATTR4_ACLSUPPORT:
00835           <span class="comment">/* aclsupport = htonl( ACL4_SUPPORT_DENY_ACL ); */</span> <span class="comment">/* temporary, wanting for houston to give me information to implemente ACL's support */</span>
00836           aclsupport = htonl( 0 ); 
00837           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;aclsupport, <span class="keyword">sizeof</span>( fattr4_aclsupport ) ) ;
00838           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00839           op_attr_success = 1 ;
00840           break ;
00841               
00842         <span class="keywordflow">case</span> FATTR4_ARCHIVE:
00843           <span class="comment">/* Archive flag is not supported */</span>
00844           archive = htonl( FALSE ) ;
00845           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;archive,<span class="keyword">sizeof</span>( fattr4_archive ) ); 
00846           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00847           op_attr_success = 1 ;
00848           break ;
00849               
00850         <span class="keywordflow">case</span> FATTR4_CANSETTIME:
00851           <span class="comment">/* The time can be set on files */</span>
00852           cansettime = htonl( TRUE ) ;
00853           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;cansettime, <span class="keyword">sizeof</span>( fattr4_cansettime ) ) ;
00854           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00855           op_attr_success = 1 ;
00856           break ;
00857               
00858         <span class="keywordflow">case</span> FATTR4_CASE_INSENSITIVE:
00859           <span class="keywordflow">if</span>( !statfscalled )
00860             {
00861               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00862                                                        &amp;staticinfo, 
00863                                                        &amp;dynamicinfo, 
00864                                                        data-&gt;pcontext,
00865                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00866                 {
00867                   op_attr_success = 0 ;
00868                   break ;
00869                 }
00870               <span class="keywordflow">else</span>
00871                 statfscalled = 1 ;
00872             }
00873           case_insensitive = htonl( staticinfo.case_insensitive );
00874           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;case_insensitive, <span class="keyword">sizeof</span>( fattr4_case_insensitive ) ) ;
00875           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00876           op_attr_success = 1 ;
00877           break ;
00878               
00879         <span class="keywordflow">case</span> FATTR4_CASE_PRESERVING:
00880           <span class="comment">/* HPSS is case preserving */</span>
00881            <span class="keywordflow">if</span>( !statfscalled )
00882             {
00883               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00884                                                        &amp;staticinfo, 
00885                                                        &amp;dynamicinfo, 
00886                                                        data-&gt;pcontext,
00887                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00888                 {
00889                   op_attr_success = 0 ;
00890                   break ;
00891                 }
00892               <span class="keywordflow">else</span>
00893                 statfscalled = 1 ;
00894             }
00895            case_preserving = htonl( staticinfo.case_preserving );
00896            memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;case_preserving, <span class="keyword">sizeof</span>( fattr4_case_preserving ) );
00897            LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00898            op_attr_success = 1 ;
00899            break ;
00900            
00901         <span class="keywordflow">case</span> FATTR4_CHOWN_RESTRICTED :
00902           <span class="comment">/* chown is restricted to root */</span>
00903           <span class="keywordflow">if</span>( !statfscalled )
00904             {
00905               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00906                                                        &amp;staticinfo, 
00907                                                        &amp;dynamicinfo,
00908                                                        data-&gt;pcontext,
00909                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00910                 {
00911                   op_attr_success = 0 ;
00912                   break ;
00913                 }
00914               <span class="keywordflow">else</span>
00915                 statfscalled = 1 ;
00916             }
00917           chown_restricted = htonl( staticinfo.chown_restricted );
00918           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;chown_restricted, <span class="keyword">sizeof</span>( fattr4_chown_restricted ) ) ; 
00919           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00920           op_attr_success = 1 ;
00921           break ;
00922               
00923         <span class="keywordflow">case</span> FATTR4_FILEHANDLE:
00924           <span class="comment">/* Return the file handle */</span>
00925           fhandle_len = htonl( objFH-&gt;nfs_fh4_len) ;
00926           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  
00927                   &amp;fhandle_len, 
00928                   <span class="keyword">sizeof</span>( u_int ) ) ; 
00929           LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
00930 
00931           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), 
00932                   objFH-&gt;nfs_fh4_val, 
00933                   objFH-&gt;nfs_fh4_len );
00934           LastOffset +=  objFH-&gt;nfs_fh4_len ;
00935           
00936           <span class="comment">/* XDR's special stuff for 32-bit alignment */</span>
00937           len = objFH-&gt;nfs_fh4_len ;
00938           off = 0 ;
00939           <span class="keywordflow">while</span>( ( len + off ) %4 != 0 )
00940             {
00941               <span class="keywordtype">char</span> c = <span class="charliteral">'\0'</span> ;
00942               
00943               off += 1 ;
00944               memset( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), (<span class="keywordtype">int</span>)c, 1 );
00945               LastOffset += 1 ;
00946             }
00947           
00948           op_attr_success = 1 ;
00949           break ;
00950               
00951         <span class="keywordflow">case</span> FATTR4_FILEID:
00952           <span class="comment">/* The analog to the inode number. RFC3530 says "a number uniquely identifying the file within the filesystem" </span>
00953 <span class="comment">           * I use hpss_GetObjId to extract this information from the Name Server's handle */</span>
00954           file_id = nfs_htonl64( pattr-&gt;fileid ) ;
00955           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;file_id, <span class="keyword">sizeof</span>( fattr4_fileid ) ) ; 
00956           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00957           op_attr_success = 1 ; 
00958           break ;
00959               
00960         <span class="keywordflow">case</span> FATTR4_FILES_AVAIL :
00961           <span class="keywordflow">if</span>( !statfscalled )
00962             {
00963               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00964                                                        &amp;staticinfo, 
00965                                                        &amp;dynamicinfo, 
00966                                                        data-&gt;pcontext,
00967                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00968                 {
00969                   op_attr_success = 0 ;
00970                   break ;
00971                 }
00972               <span class="keywordflow">else</span>
00973                 statfscalled = 1 ;
00974             }
00975           files_avail =  nfs_htonl64( (fattr4_files_avail)dynamicinfo.avail_files );
00976           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;files_avail, <span class="keyword">sizeof</span>( fattr4_files_avail ) ) ;
00977           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00978           op_attr_success = 1 ;
00979           break ;
00980               
00981         <span class="keywordflow">case</span> FATTR4_FILES_FREE  :
00982           <span class="keywordflow">if</span>( !statfscalled )
00983             {
00984               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
00985                                                        &amp;staticinfo, 
00986                                                        &amp;dynamicinfo, 
00987                                                        data-&gt;pcontext,
00988                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
00989                 {
00990                   op_attr_success = 0 ;
00991                   break ;
00992                 }
00993               <span class="keywordflow">else</span>
00994                 statfscalled = 1 ;
00995             }
00996           files_free = nfs_htonl64( (fattr4_files_avail)dynamicinfo.free_files );
00997           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;files_free, <span class="keyword">sizeof</span>( fattr4_files_free ) ) ;
00998           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
00999           op_attr_success = 1 ;
01000           break ;
01001               
01002         <span class="keywordflow">case</span> FATTR4_FILES_TOTAL :
01003           <span class="keywordflow">if</span>( !statfscalled )
01004             {
01005               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs(  data-&gt;current_entry, 
01006                                                         &amp;staticinfo, 
01007                                                         &amp;dynamicinfo, 
01008                                                         data-&gt;pcontext,
01009                                                         &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01010                 {
01011                   op_attr_success = 0 ;
01012                   break ;
01013                 }
01014               <span class="keywordflow">else</span>
01015                 statfscalled = 1 ;
01016             }
01017           files_total = nfs_htonl64( (fattr4_files_avail)dynamicinfo.total_files );
01018           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;files_total, <span class="keyword">sizeof</span>( fattr4_files_total ) ) ;
01019           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01020           op_attr_success = 1 ;
01021           break ;
01022           
01023         <span class="keywordflow">case</span> FATTR4_FS_LOCATIONS:
01024           fs_locations.fs_root.pathname4_len = htonl( 0 ) ;
01025           fs_locations.locations.locations_len = htonl( 0 ) ; <span class="comment">/* No FS_LOCATIONS no now */</span>
01026           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01027           op_attr_success = 1 ;
01028           break ;
01029               
01030         <span class="keywordflow">case</span> FATTR4_HIDDEN :
01031           <span class="comment">/* There are no hidden file in HPSS */</span>
01032           hidden = htonl( FALSE );
01033           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;hidden, <span class="keyword">sizeof</span>( fattr4_hidden ) );
01034           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01035           op_attr_success = 1 ;
01036           break ;
01037               
01038         <span class="keywordflow">case</span> FATTR4_HOMOGENEOUS:
01039           <span class="comment">/* Unix semantic is homogeneous (all objects have the same kind of attributes) */</span>
01040           homogeneous = htonl( TRUE );
01041           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;homogeneous, <span class="keyword">sizeof</span>( fattr4_homogeneous ) );
01042           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01043           op_attr_success = 1 ;
01044           break ;
01045               
01046         <span class="keywordflow">case</span> FATTR4_MAXFILESIZE :
01047           max_filesize = nfs_htonl64( (fattr4_maxfilesize)FSINFO_MAX_FILESIZE );
01048           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;max_filesize, <span class="keyword">sizeof</span>( fattr4_maxfilesize ) );
01049           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01050           op_attr_success = 1 ;
01051           break ;
01052               
01053         <span class="keywordflow">case</span> FATTR4_MAXLINK:
01054           <span class="keywordflow">if</span>( !statfscalled )
01055             {
01056               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01057                                                        &amp;staticinfo, 
01058                                                        &amp;dynamicinfo, 
01059                                                        data-&gt;pcontext,
01060                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01061                 {
01062                   op_attr_success = 0 ;
01063                   break ;
01064                 }
01065               <span class="keywordflow">else</span>
01066                 statfscalled = 1 ;
01067             }
01068           maxlink = htonl( staticinfo.maxlink );
01069           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;maxlink, <span class="keyword">sizeof</span>( fattr4_maxlink ) );
01070           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01071           op_attr_success = 1 ;
01072           break ;
01073               
01074         <span class="keywordflow">case</span> FATTR4_MAXNAME :
01075           <span class="keywordflow">if</span>( !statfscalled )
01076             {
01077               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01078                                                        &amp;staticinfo, 
01079                                                        &amp;dynamicinfo, 
01080                                                        data-&gt;pcontext,
01081                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01082                 {
01083                   op_attr_success = 0 ;
01084                   break ;
01085                 }
01086               <span class="keywordflow">else</span>
01087                 statfscalled = 1 ;
01088             }
01089           maxname = htonl( (fattr4_maxname)staticinfo.maxnamelen ) ;
01090           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;maxname, <span class="keyword">sizeof</span>( fattr4_maxname ) );
01091           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01092           op_attr_success = 1 ;
01093           break ;
01094           
01095         <span class="keywordflow">case</span> FATTR4_MAXREAD :
01096           <span class="keywordflow">if</span>( !statfscalled )
01097             {
01098               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry,
01099                                                        &amp;staticinfo, 
01100                                                        &amp;dynamicinfo, 
01101                                                        data-&gt;pcontext,
01102                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01103                 {
01104                   op_attr_success = 0 ;
01105                   break ;
01106                 }
01107               <span class="keywordflow">else</span>
01108                 statfscalled = 1 ;
01109             }
01110           maxread = nfs_htonl64( (fattr4_maxread)staticinfo.maxread );
01111           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;maxread, <span class="keyword">sizeof</span>( fattr4_maxread ) );
01112           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01113           op_attr_success = 1 ;
01114           break ;
01115               
01116         <span class="keywordflow">case</span>  FATTR4_MAXWRITE:
01117           <span class="keywordflow">if</span>( !statfscalled )
01118             {
01119               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01120                                                        &amp;staticinfo, 
01121                                                        &amp;dynamicinfo, 
01122                                                        data-&gt;pcontext,
01123                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01124                 {
01125                   op_attr_success = 0 ;
01126                   break ;
01127                 }
01128               <span class="keywordflow">else</span>
01129                 statfscalled = 1 ;
01130             }
01131           maxwrite = nfs_htonl64( (fattr4_maxwrite)staticinfo.maxwrite );
01132           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;maxwrite, <span class="keyword">sizeof</span>( fattr4_maxwrite ) );
01133           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01134           op_attr_success = 1 ;
01135           break ;
01136               
01137         <span class="keywordflow">case</span> FATTR4_MIMETYPE :
01138           mimetype.utf8string_len = htonl( 0 ) ; 
01139           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;mimetype, <span class="keyword">sizeof</span>( fattr4_mimetype )) ;
01140           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01141           op_attr_success = 1 ; <span class="comment">/* No supported for the moment */</span>
01142           break ;
01143               
01144         <span class="keywordflow">case</span> FATTR4_MODE :
01145           <span class="comment">/* file_mode = (fattr4_mode) htonl(fsal2unix_mode(pattr-&gt;mode)) ; */</span>
01146           file_mode = htonl( (fattr4_mode) fsal2unix_mode(pattr-&gt;mode) ); 
01147           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;file_mode, <span class="keyword">sizeof</span>( fattr4_mode )) ;              
01148           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01149           op_attr_success = 1 ;
01150           break ;
01151               
01152         <span class="keywordflow">case</span>  FATTR4_NO_TRUNC:
01153           <span class="comment">/* File's names are not truncated, an error is returned is name is too long */</span>
01154           <span class="keywordflow">if</span>( !statfscalled )
01155             {
01156               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01157                                                        &amp;staticinfo, 
01158                                                        &amp;dynamicinfo, 
01159                                                        data-&gt;pcontext,
01160                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01161                 {
01162                   op_attr_success = 0 ;
01163                   break ;
01164                 }
01165               <span class="keywordflow">else</span>
01166                 statfscalled = 1 ;
01167             }
01168           no_trunc = htonl( staticinfo.no_trunc );
01169           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;no_trunc, <span class="keyword">sizeof</span>( fattr4_no_trunc ) ) ;
01170           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01171           op_attr_success = 1 ;
01172           break ;
01173               
01174         <span class="keywordflow">case</span>  FATTR4_NUMLINKS:
01175           <span class="comment">/* Reply the number of links found in vattr structure */</span>
01176           file_numlinks = htonl( (fattr4_numlinks)pattr-&gt;numlinks );
01177           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;file_numlinks, <span class="keyword">sizeof</span>( fattr4_numlinks ) ) ;
01178           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01179           op_attr_success = 1 ;
01180           break ;
01181               
01182         <span class="keywordflow">case</span>  FATTR4_OWNER:
01183           <span class="comment">/* Return the uid as a human readable utf8 string */</span>
01184           <span class="keywordflow">if</span>( uid2utf8( pattr-&gt;owner, &amp;file_owner ) == 0 )
01185             {
01186               u_int utf8len = htonl( file_owner.utf8string_len) ;
01187 
01188               memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), 
01189                       &amp;utf8len, 
01190                       <span class="keyword">sizeof</span>( u_int ) ) ;
01191               LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
01192                   
01193               memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), 
01194                       file_owner.utf8string_val, 
01195                       file_owner.utf8string_len ) ;
01196               LastOffset += file_owner.utf8string_len ;
01197 
01198               op_attr_success = 1 ;
01199                   
01200             }
01201           <span class="keywordflow">else</span>
01202             op_attr_success = 0 ;
01203           break ;
01204               
01205         <span class="keywordflow">case</span>  FATTR4_OWNER_GROUP :
01206           <span class="comment">/* Return the gid as a human-readable utf8 string */</span>
01207           <span class="keywordflow">if</span>( gid2utf8( pattr-&gt;group, &amp;file_owner_group ) == 0 )
01208             {
01209               u_int utf8len = htonl( file_owner_group.utf8string_len) ;
01210 
01211               memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), 
01212                       &amp;utf8len,
01213                       <span class="keyword">sizeof</span>( u_int ) ) ;
01214               LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
01215 
01216               memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), 
01217                       file_owner_group.utf8string_val, 
01218                       file_owner_group.utf8string_len ) ;
01219               LastOffset += file_owner_group.utf8string_len ;
01220 
01221               op_attr_success = 1 ;
01222                   
01223             }
01224           <span class="keywordflow">else</span>
01225             op_attr_success = 0 ;
01226           break ;
01227               
01228         <span class="keywordflow">case</span>  FATTR4_QUOTA_AVAIL_HARD:
01229           quota_avail_hard =  nfs_htonl64( (fattr4_quota_avail_hard)NFS_V4_MAX_QUOTA_HARD ) ; 
01230           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;quota_avail_hard, <span class="keyword">sizeof</span>( fattr4_quota_avail_hard ) );
01231           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01232           op_attr_success = 1 ;
01233           break ;
01234               
01235         <span class="keywordflow">case</span> FATTR4_QUOTA_AVAIL_SOFT :
01236           quota_avail_soft =  nfs_htonl64( (fattr4_quota_avail_soft)NFS_V4_MAX_QUOTA_SOFT ) ; 
01237           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;quota_avail_soft, <span class="keyword">sizeof</span>( fattr4_quota_avail_soft ) );
01238           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01239           op_attr_success = 1 ;
01240           break ;
01241               
01242         <span class="keywordflow">case</span>  FATTR4_QUOTA_USED:
01243           quota_used =  nfs_htonl64( (fattr4_quota_used)pattr-&gt;filesize ) ;
01244           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;quota_used, <span class="keyword">sizeof</span>( fattr4_quota_used ) );
01245           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01246           op_attr_success = 1 ;
01247           break ;
01248 
01249         <span class="keywordflow">case</span>  FATTR4_RAWDEV:
01250           rawdev.specdata1 = htonl( pattr-&gt;rawdev.major ) ;
01251           rawdev.specdata2 = htonl( pattr-&gt;rawdev.minor ) ;
01252           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;rawdev, <span class="keyword">sizeof</span>( fattr4_rawdev ) ) ;
01253           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01254           op_attr_success = 1 ;
01255           break ;
01256           
01257         <span class="keywordflow">case</span> FATTR4_SPACE_AVAIL :
01258           <span class="keywordflow">if</span>( !statfscalled )
01259             {
01260               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01261                                                        &amp;staticinfo, 
01262                                                        &amp;dynamicinfo, 
01263                                                        data-&gt;pcontext,
01264                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01265                 {
01266                   op_attr_success = 0 ;
01267                   break ;
01268                 }
01269               <span class="keywordflow">else</span>
01270                 statfscalled = 1 ;
01271             }
01272           space_avail = nfs_htonl64( (fattr4_space_avail) dynamicinfo.avail_bytes );
01273           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;space_avail, <span class="keyword">sizeof</span>( fattr4_space_avail ) ) ;
01274           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01275           op_attr_success = 1 ;
01276           break ;
01277           
01278         <span class="keywordflow">case</span> FATTR4_SPACE_FREE :
01279           <span class="keywordflow">if</span>( !statfscalled )
01280             {
01281               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01282                                                        &amp;staticinfo, 
01283                                                        &amp;dynamicinfo, 
01284                                                        data-&gt;pcontext,
01285                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01286                 {
01287                   op_attr_success = 0 ;
01288                   break ;
01289                 }
01290               <span class="keywordflow">else</span>
01291                 statfscalled = 1 ;
01292             }
01293           space_free = nfs_htonl64( (fattr4_space_free)dynamicinfo.free_bytes );
01294           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;space_free, <span class="keyword">sizeof</span>( fattr4_space_free ) ) ;
01295           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01296           op_attr_success = 1 ;
01297           break ;
01298               
01299         <span class="keywordflow">case</span> FATTR4_SPACE_TOTAL :
01300           <span class="keywordflow">if</span>( !statfscalled )
01301             {
01302               <span class="keywordflow">if</span>( ( cache_status = cache_inode_statfs( data-&gt;current_entry, 
01303                                                        &amp;staticinfo, 
01304                                                        &amp;dynamicinfo, 
01305                                                        data-&gt;pcontext,
01306                                                        &amp;cache_status ) ) != CACHE_INODE_SUCCESS )
01307                   {
01308                     op_attr_success = 0 ;
01309                     break ;
01310                   }
01311                     <span class="keywordflow">else</span>
01312                     statfscalled = 1 ;
01313             }
01314           space_total = nfs_htonl64( (fattr4_space_total)dynamicinfo.total_bytes );
01315           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;space_total, <span class="keyword">sizeof</span>( fattr4_space_total ) ) ;
01316           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01317           op_attr_success = 1 ;
01318           break ;
01319               
01320         <span class="keywordflow">case</span> FATTR4_SPACE_USED:
01321           <span class="comment">/* the number of bytes on the filesystem used by the object, which is slightly different </span>
01322 <span class="comment">           * from the file's size (there can be hole in the file) */</span>
01323           file_space_used = nfs_htonl64( (fattr4_space_used)pattr-&gt;spaceused );
01324           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;file_space_used, <span class="keyword">sizeof</span>( fattr4_space_used ) ) ;
01325           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01326           op_attr_success = 1 ;
01327           break ;
01328               
01329         <span class="keywordflow">case</span> FATTR4_SYSTEM:
01330           <span class="comment">/* This is not a windows system File-System with respect to the regarding API */</span>
01331           system = htonl( FALSE );
01332           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;system, <span class="keyword">sizeof</span>( fattr4_system ) ) ;
01333           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01334           op_attr_success = 1 ;
01335           break ;
01336               
01337         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS:
01338           <span class="comment">/* This will contain the object's time os last access, the 'atime' in the Unix semantic */</span>
01339           memset( &amp;(time_access.seconds), 0, <span class="keyword">sizeof</span>( int64_t ) ) ;
01340           time_access.seconds  = nfs_htonl64( (int64_t)pattr-&gt;atime.seconds );
01341           time_access.nseconds = htonl( (uint32_t)pattr-&gt;atime.nseconds );
01342           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_access, fattr4tab[attribute_to_set].size_fattr4 ) ;
01343           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01344           op_attr_success = 1 ;
01345           break ;
01346           
01347         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS_SET:
01348 <span class="preprocessor">#ifndef _USE_PROXY</span>
01349 <span class="preprocessor"></span>          op_attr_success = 0 ; <span class="comment">/* should never be used here outside FSAL_PROXY */</span>
01350 <span class="preprocessor">#else</span>
01351 <span class="preprocessor"></span>          time_access_set.set_it = htonl( SET_TO_CLIENT_TIME4 ) ;
01352           time_access_set.settime4_u.time.seconds  = nfs_htonl64( (int64_t)pattr-&gt;atime.seconds ) ;
01353           time_access_set.settime4_u.time.nseconds = htonl( pattr-&gt;atime.nseconds ) ;
01354 
01355           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_access_set, fattr4tab[attribute_to_set].size_fattr4 ) ;
01356           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01357           op_attr_success = 1 ;
01358 <span class="preprocessor">#endif</span>
01359 <span class="preprocessor"></span>          break ;
01360           
01361         <span class="keywordflow">case</span> FATTR4_TIME_BACKUP :
01362           <span class="comment">/* No time backup, return unix's beginning of time */</span>
01363           time_backup.seconds  = nfs_htonl64( 0LL ) ;
01364           time_backup.nseconds = htonl( 0 ) ;
01365           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_backup, fattr4tab[attribute_to_set].size_fattr4 ) ;
01366           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01367           op_attr_success = 1 ;
01368           break ;
01369           
01370         <span class="keywordflow">case</span> FATTR4_TIME_CREATE :
01371           <span class="comment">/* No time create, return unix's beginning of time */</span>
01372           time_create.seconds  = nfs_htonl64( 0LL ) ;
01373           time_create.nseconds = htonl( 0 ) ;
01374           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_create, fattr4tab[attribute_to_set].size_fattr4 ) ;
01375           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01376           op_attr_success = 1 ;
01377           break ;
01378           
01379         <span class="keywordflow">case</span>  FATTR4_TIME_DELTA:
01380           <span class="comment">/* According to RFC3530, this is "the smallest usefull server time granularity", I set this to 1s */</span>
01381           time_delta.seconds  = nfs_htonl64( 1LL );
01382           time_delta.nseconds = htonl( 0 );
01383           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_delta, fattr4tab[attribute_to_set].size_fattr4 ) ;
01384           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01385           op_attr_success = 1 ;
01386           break ;
01387           
01388         <span class="keywordflow">case</span> FATTR4_TIME_METADATA :
01389           <span class="comment">/* The time for the last metadata operation, the ctime in the unix's semantic */</span>
01390           memset( &amp;(time_metadata.seconds), 0, <span class="keyword">sizeof</span>( int64_t ) ) ;
01391           time_metadata.seconds  = nfs_htonl64( (int64_t)pattr-&gt;ctime.seconds );
01392           time_metadata.nseconds = htonl( pattr-&gt;ctime.nseconds );
01393           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_metadata, fattr4tab[attribute_to_set].size_fattr4 ) ;
01394           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01395           op_attr_success = 1 ;
01396           break ;
01397           
01398         <span class="keywordflow">case</span> FATTR4_TIME_MODIFY :
01399           <span class="comment">/* The time for the last modify operation, the mtime in the unix's semantic */</span>
01400           memset( &amp;(time_modify.seconds), 0, <span class="keyword">sizeof</span>( int64_t ) ) ;
01401           time_modify.seconds  = nfs_htonl64( (int64_t)pattr-&gt;mtime.seconds );
01402           time_modify.nseconds = htonl( pattr-&gt;mtime.nseconds );
01403           
01404           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_modify, fattr4tab[attribute_to_set].size_fattr4 ) ;
01405           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01406           op_attr_success = 1 ;
01407           break ;
01408           
01409         <span class="keywordflow">case</span> FATTR4_TIME_MODIFY_SET:
01410 <span class="preprocessor">#ifndef _USE_PROXY</span>
01411 <span class="preprocessor"></span>          op_attr_success = 0 ; <span class="comment">/* should never be used here outside FSAL_PROXY */</span>
01412 <span class="preprocessor">#else</span>
01413 <span class="preprocessor"></span>          time_modify_set.set_it = htonl( SET_TO_CLIENT_TIME4 ) ;
01414           time_modify_set.settime4_u.time.seconds  = nfs_htonl64( (int64_t)pattr-&gt;mtime.seconds ) ;
01415           time_modify_set.settime4_u.time.nseconds = htonl( pattr-&gt;mtime.nseconds ) ;
01416 
01417           memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset), &amp;time_modify_set, fattr4tab[attribute_to_set].size_fattr4 ) ;
01418           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01419           op_attr_success = 1 ;
01420 <span class="preprocessor">#endif</span>
01421 <span class="preprocessor"></span>          break ;
01422           
01423         <span class="keywordflow">case</span> FATTR4_MOUNTED_ON_FILEID :
01424           <span class="comment">/* The analog to the inode number. RFC3530 says "a number uniquely identifying the file within the filesystem" </span>
01425 <span class="comment">           * I use hpss_GetObjId to extract this information from the Name Server's handle */</span>
01426           <span class="comment">/* Here, the filehandle used is the "mouted on FH" kept in compound_data_t */</span>
01427           <span class="keywordflow">if</span>( !nfs4_FhandleToFSAL( &amp;data-&gt;mounted_on_FH, &amp;mounted_on_fsal_handle, data-&gt;pcontext ) )
01428             {
01429               <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status = FSAL_DigestHandle( data-&gt;pcontext-&gt;export_context,
01430                                                                   FSAL_DIGEST_FILEID4 , 
01431                                                                   &amp;mounted_on_fsal_handle,
01432                                                                   (caddr_t)&amp;mounted_on_fileid ) ) )  
01433                 {
01434                   op_attr_success = 0 ;
01435                 }
01436               <span class="keywordflow">else</span>
01437                 { 
01438                   mounted_on_fileid = nfs_htonl64( mounted_on_fileid ) ;
01439                   memcpy( (<span class="keywordtype">char</span> *)(attrvalsBuffer + LastOffset),  &amp;mounted_on_fileid, <span class="keyword">sizeof</span>( fattr4_mounted_on_fileid ) ) ; 
01440                   LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
01441                   op_attr_success = 1 ; 
01442                 }
01443             }
01444           <span class="keywordflow">else</span>
01445             op_attr_success = 0 ;
01446           break ;
01447           
01448         <span class="keywordflow">default</span>:
01449 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
01450 <span class="preprocessor"></span>          printf( <span class="stringliteral">" unsupported value for attributes bitamp = %u\n"</span>, attribute_to_set ) ;
01451 <span class="preprocessor">#endif</span>
01452 <span class="preprocessor"></span>         op_attr_success = 0 ; 
01453           break ;
01454         } <span class="comment">/* switch( attribute_to_set ) */</span>
01455       
01456       <span class="comment">/* Increase the Offset for the next operation if this was a success*/</span>
01457       <span class="keywordflow">if</span>( op_attr_success )
01458         {
01459           <span class="comment">/* Set the returned bitmask */</span>
01460           attrvalslist[j] = attribute_to_set ;
01461           j += 1 ;
01462 
01463           <span class="comment">/* Be carefull not to get out of attrvalsBuffer */</span>
01464           <span class="keywordflow">if</span>( LastOffset &gt; ATTRVALS_BUFFLEN )
01465             <span class="keywordflow">return</span> -1 ;
01466         }
01467       
01468     } <span class="comment">/* for i */</span>
01469   
01470   <span class="comment">/* Set the bitmap for result */</span>
01471   <span class="keywordflow">if</span>( ( Fattr-&gt;attrmask.bitmap4_val = (uint32_t *)Mem_Alloc( 2*<span class="keyword">sizeof</span>( uint32_t ) ) ) == NULL )
01472         <span class="keywordflow">return</span> -1 ;
01473   memset( (<span class="keywordtype">char</span> *)Fattr-&gt;attrmask.bitmap4_val, 0, 2*<span class="keyword">sizeof</span>( uint32_t ) ) ;
01474 
01475   <a class="code" href="nfs__proto__tools_8c.html#a17">nfs4_list_to_bitmap4</a>( &amp;(Fattr-&gt;attrmask), &amp;j, attrvalslist ) ;
01476 
01477   <span class="comment">/* Set the attrlist4 */</span>
01478   Fattr-&gt;attr_vals.attrlist4_len = LastOffset ;
01479   <span class="keywordflow">if</span>( LastOffset != 0 ) <span class="comment">/* No need to allocate an empty buffer */</span>
01480     {
01481      <span class="keywordflow">if</span>( ( Fattr-&gt;attr_vals.attrlist4_val = Mem_Alloc( Fattr-&gt;attr_vals.attrlist4_len ) ) == NULL )
01482          <span class="keywordflow">return</span> -1 ;
01483      memset( (<span class="keywordtype">char</span> *)Fattr-&gt;attr_vals.attrlist4_val, 0, Fattr-&gt;attr_vals.attrlist4_len ) ;
01484      memcpy( Fattr-&gt;attr_vals.attrlist4_val, attrvalsBuffer, Fattr-&gt;attr_vals.attrlist4_len );
01485     }
01486   <span class="comment">/* LastOffset contains the length of the attrvalsBuffer usefull data */</span>
01487 
01488 
01489   <span class="keywordflow">return</span> 0;
01490 } <span class="comment">/* nfs4_FSALattr_To_Fattr */</span>
01491 
01492 
01493 
<a name="l01506"></a><a class="code" href="nfs__proto__tools_8c.html#a8">01506</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a8">nfs3_Sattr_To_FSALattr</a>( fsal_attrib_list_t * pFSAL_attr,  <span class="comment">/* Out: file attributes */</span>
01507                             sattr3             * psattr )     <span class="comment">/* In: file attributes  */</span>
01508 {
01509   <span class="keyword">struct </span>timeval t ;
01510   
01511   <span class="keywordflow">if</span>( pFSAL_attr == NULL || psattr == NULL ) 
01512     <span class="keywordflow">return</span> 0 ;
01513 
01514   pFSAL_attr-&gt;asked_attributes = 0 ;
01515 
01516   <span class="keywordflow">if</span>( psattr-&gt;mode.set_it == TRUE )
01517     {
01518 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01519 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: mode = %o\n"</span>, psattr-&gt;mode.set_mode3_u.mode ) ;
01520 <span class="preprocessor">#endif</span>
01521 <span class="preprocessor"></span>      pFSAL_attr-&gt;mode = unix2fsal_mode( psattr-&gt;mode.set_mode3_u.mode ) ;
01522       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_MODE ;
01523     }
01524   
01525   <span class="keywordflow">if</span>( psattr-&gt;uid.set_it == TRUE )
01526     {
01527 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01528 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: uid = %d\n"</span>, psattr-&gt;uid.set_uid3_u.uid ) ;
01529 <span class="preprocessor">#endif</span>
01530 <span class="preprocessor"></span>      pFSAL_attr-&gt;owner = psattr-&gt;uid.set_uid3_u.uid ;
01531       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_OWNER ;
01532     }
01533   
01534   <span class="keywordflow">if</span>( psattr-&gt;gid.set_it == TRUE )
01535     {
01536 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01537 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: gid = %d\n"</span>, psattr-&gt;gid.set_gid3_u.gid ) ;
01538 <span class="preprocessor">#endif</span>
01539 <span class="preprocessor"></span>      pFSAL_attr-&gt;group = psattr-&gt;gid.set_gid3_u.gid ;
01540       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_GROUP ;
01541     }
01542 
01543   <span class="keywordflow">if</span>( psattr-&gt;size.set_it == TRUE )
01544     {
01545 <span class="preprocessor">#ifdef  _DEBUG_NFSPROTO</span>
01546 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: size = %lld\n"</span>, psattr-&gt;size.set_size3_u.size ) ;
01547 <span class="preprocessor">#endif</span>
01548 <span class="preprocessor"></span>      pFSAL_attr-&gt;filesize  = (fsal_size_t)psattr-&gt;size.set_size3_u.size ;
01549       pFSAL_attr-&gt;spaceused = (fsal_size_t)psattr-&gt;size.set_size3_u.size ; 
01550       <span class="comment">/* Both FSAL_ATTR_SIZE and FSAL_ATTR_SPACEUSED are to be managed */</span>
01551       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_SIZE  ;
01552       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_SPACEUSED ;
01553     }
01554   
01555   <span class="keywordflow">if</span>( psattr-&gt;atime.set_it != DONT_CHANGE )
01556     {
01557 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01558 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: set=%d atime = %d,%d\n"</span>,  
01559               psattr-&gt;atime.set_it, psattr-&gt;atime.set_atime_u.atime.seconds, psattr-&gt;atime.set_atime_u.atime.nseconds ) ;
01560 <span class="preprocessor">#endif</span>
01561 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( psattr-&gt;atime.set_it == SET_TO_CLIENT_TIME )
01562         {
01563           pFSAL_attr-&gt;atime.seconds  = psattr-&gt;atime.set_atime_u.atime.seconds ;
01564           pFSAL_attr-&gt;atime.nseconds = psattr-&gt;atime.set_atime_u.atime.nseconds ;
01565         }
01566       <span class="keywordflow">else</span>
01567         {
01568           <span class="comment">/* Use the server's current time */</span>
01569           gettimeofday( &amp;t, NULL ) ;
01570           
01571           pFSAL_attr-&gt;atime.seconds  = t.tv_sec  ;
01572           pFSAL_attr-&gt;atime.nseconds  = t.tv_usec * 1000 ;
01573         }
01574       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_ATIME ;
01575     } 
01576   
01577   <span class="keywordflow">if</span>( psattr-&gt;mtime.set_it != DONT_CHANGE )
01578     {
01579 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01580 <span class="preprocessor"></span>      printf( <span class="stringliteral">"nfs3_Sattr_To_FSALattr: set=%d mtime = %d,%d\n"</span>,  
01581               psattr-&gt;atime.set_it, psattr-&gt;mtime.set_mtime_u.mtime.seconds, psattr-&gt;mtime.set_mtime_u.mtime.nseconds ) ;
01582 <span class="preprocessor">#endif</span>
01583 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( psattr-&gt;mtime.set_it  == SET_TO_CLIENT_TIME ) 
01584         {
01585           pFSAL_attr-&gt;mtime.seconds  = psattr-&gt;mtime.set_mtime_u.mtime.seconds ;
01586           pFSAL_attr-&gt;mtime.nseconds = psattr-&gt;mtime.set_mtime_u.mtime.nseconds ;
01587         }
01588       <span class="keywordflow">else</span>
01589         {
01590           <span class="comment">/* Use the server's current time */</span>
01591           gettimeofday( &amp;t, NULL ) ;
01592           pFSAL_attr-&gt;mtime.seconds  = t.tv_sec ;
01593           pFSAL_attr-&gt;mtime.nseconds = t.tv_usec * 1000 ;
01594         }
01595       pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_MTIME ;
01596     }
01597    
01598   <span class="keywordflow">return</span> 1 ;
01599 } <span class="comment">/* nfs3_Sattr_To_FSALattr */</span> 
01600 
<a name="l01614"></a><a class="code" href="nfs__proto__tools_8c.html#a9">01614</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a9">nfs2_FSALattr_To_Fattr</a>( exportlist_t       * pexport,     <span class="comment">/* In: the related export entry */</span>
01615                             fsal_attrib_list_t * pFSAL_attr,  <span class="comment">/* In: file attributes  */</span>
01616                             fattr2             * pFattr )     <span class="comment">/* Out: file attributes */</span>
01617 {      
01618   <span class="comment">/* Badly formed arguments */</span>
01619   <span class="keywordflow">if</span>( pFSAL_attr == NULL || pFattr == NULL )
01620     <span class="keywordflow">return</span> 0 ;
01621   
01622   <span class="comment">/* @todo BUGAZOMEU: sanity check on attribute mask (does the FSAL support the attributes required to support NFSv2 ? */</span>
01623 
01624   <span class="comment">/* initialize mode */</span>
01625   pFattr-&gt;mode = 0;
01626 
01627   <span class="keywordflow">switch</span>( pFSAL_attr-&gt;type )
01628     {
01629     <span class="keywordflow">case</span> FSAL_TYPE_FILE:
01630       pFattr-&gt;type = NFREG ;
01631       pFattr-&gt;mode = NFS2_MODE_NFREG;
01632       break ;
01633       
01634     <span class="keywordflow">case</span> FSAL_TYPE_DIR:
01635       pFattr-&gt;type = NFDIR ;
01636       pFattr-&gt;mode = NFS2_MODE_NFDIR;
01637       break ;
01638       
01639     <span class="keywordflow">case</span> FSAL_TYPE_BLK:
01640       pFattr-&gt;type = NFBLK ;
01641       pFattr-&gt;mode = NFS2_MODE_NFBLK;
01642       break ;
01643       
01644     <span class="keywordflow">case</span> FSAL_TYPE_CHR:
01645       pFattr-&gt;type = NFCHR ;
01646       pFattr-&gt;mode = NFS2_MODE_NFCHR;
01647       break ;
01648       
01649     <span class="keywordflow">case</span> FSAL_TYPE_FIFO:
01650       pFattr-&gt;type = NFFIFO ;
01652       break ;
01653       
01654     <span class="keywordflow">case</span> FSAL_TYPE_LNK:
01655       pFattr-&gt;type = NFLNK ;
01656       pFattr-&gt;mode = NFS2_MODE_NFLNK;
01657       break ;
01658       
01659     <span class="keywordflow">case</span> FSAL_TYPE_SOCK:
01660       pFattr-&gt;type = NFSOCK ;
01663     <span class="keywordflow">default</span>:
01664       pFattr-&gt;type = NFBAD ;
01665     }
01666   
01667   pFattr-&gt;mode  |= fsal2unix_mode( pFSAL_attr-&gt;mode );
01668   pFattr-&gt;nlink = pFSAL_attr-&gt;numlinks ;
01669   pFattr-&gt;uid   = pFSAL_attr-&gt;owner ;
01670   pFattr-&gt;gid   = pFSAL_attr-&gt;group ;
01671   
01672   <span class="comment">/* in NFSv2, it only keeps fsid.major, casted into an into an int32 */</span>
01673   pFattr-&gt;fsid = (u_int)(pexport-&gt;filesystem_id.major &amp; 0xFFFFFFFFLL) ;
01674   
01675 <span class="preprocessor">#ifdef  _DEBUG_NFSPROTO  </span>
01676 <span class="preprocessor"></span>  printf( <span class="stringliteral">"nfs2_FSALattr_To_Fattr: fsid.major = %#llX (%llu), fsid.minor = %#llX (%llu), nfs2_fsid = %#X (%u)\n"</span>,
01677           pexport-&gt;filesystem_id.major, pexport-&gt;filesystem_id.major,
01678           pexport-&gt;filesystem_id.minor, pexport-&gt;filesystem_id.minor,
01679           pFattr-&gt;fsid, pFattr-&gt;fsid );
01680 <span class="preprocessor">#endif  </span>
01681 <span class="preprocessor"></span>  
01682   <span class="keywordflow">if</span>( pFSAL_attr-&gt;filesize &gt; NFS2_MAX_FILESIZE )
01683     pFattr-&gt;size = NFS2_MAX_FILESIZE ;
01684   <span class="keywordflow">else</span>
01685     pFattr-&gt;size = pFSAL_attr-&gt;filesize ;
01686   
01687   pFattr-&gt;blocksize      = DEV_BSIZE;
01688   
01689   pFattr-&gt;blocks         = pFattr-&gt;size &gt;&gt; 9 ; <span class="comment">/* dividing by 512 */</span>
01690   <span class="keywordflow">if</span> ( pFattr-&gt;size % DEV_BSIZE != 0 ) pFattr-&gt;blocks += 1;
01691   
01692   <span class="keywordflow">if</span> ( pFSAL_attr-&gt;type == FSAL_TYPE_CHR
01693       || pFSAL_attr-&gt;type == FSAL_TYPE_BLK )
01694     pFattr-&gt;rdev           = pFSAL_attr-&gt;rawdev.major ;
01695   <span class="keywordflow">else</span>
01696     pFattr-&gt;rdev = 0;  
01697   
01698   pFattr-&gt;atime.seconds  = pFSAL_attr-&gt;atime.seconds;
01699   pFattr-&gt;atime.useconds = pFSAL_attr-&gt;atime.nseconds/1000;
01700   pFattr-&gt;mtime.seconds  = pFSAL_attr-&gt;mtime.seconds ;
01701   pFattr-&gt;mtime.useconds = pFSAL_attr-&gt;mtime.nseconds/1000 ;
01702   pFattr-&gt;ctime.seconds  = pFSAL_attr-&gt;ctime.seconds ;
01703   pFattr-&gt;ctime.useconds = pFSAL_attr-&gt;ctime.nseconds/1000 ;
01704   pFattr-&gt;fileid         = pFSAL_attr-&gt;fileid ;
01705                                       
01706   <span class="keywordflow">return</span> 1 ;
01707 } <span class="comment">/*  nfs2_FSALattr_To_Fattr */</span>
01708 
<a name="l01721"></a><a class="code" href="nfs__proto__tools_8c.html#a10">01721</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a10">nfs4_SetCompoundExport</a>( compound_data_t * data )
01722 {
01723   <span class="keywordtype">short</span>            exportid ;
01724   exportlist_t   * pexport = NULL ;
01725   
01726 
01727   <span class="comment">/* This routine is not related to pseudo fs file handle, do not handle them */</span>
01728   <span class="keywordflow">if</span>( nfs4_Is_Fh_Pseudo( &amp;(data-&gt;currentFH) ) )
01729     <span class="keywordflow">return</span> NFS4_OK ;
01730   
01731   <span class="comment">/* Get the export id */</span>
01732   <span class="keywordflow">if</span>( ( exportid = nfs4_FhandleToExportId( &amp;(data-&gt;currentFH) ) ) == 0 )
01733     <span class="keywordflow">return</span> NFS4ERR_BADHANDLE ;
01734 
01735   <span class="keywordflow">if</span>( ( data-&gt;pexport = nfs_Get_export_by_id( data-&gt;pfullexportlist, exportid ) ) == NULL )
01736     <span class="keywordflow">return</span> NFS4ERR_BADHANDLE ;
01737 
01738   <span class="keywordflow">if</span>( <a class="code" href="nfs__proto__tools_8c.html#a30">nfs4_MakeCred</a>( data ) != NFS4_OK )
01739     <span class="keywordflow">return</span> NFS4ERR_WRONGSEC ;
01740 
01741   <span class="keywordflow">return</span> NFS4_OK ;
01742 } <span class="comment">/* nfs4_SetCompoundExport */</span>
01743 
01744 
01745 
<a name="l01758"></a><a class="code" href="nfs__proto__tools_8c.html#a11">01758</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a11">nfs4_FhandleToExId</a>( nfs_fh4 * fh4p, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> * ExIdp )
01759 {
01760   file_handle_v4_t * pfhandle4;
01761 
01762   <span class="comment">/* Map the filehandle to the correct structure */</span>
01763   pfhandle4 = (file_handle_v4_t *)(fh4p-&gt;nfs_fh4_val) ;
01764   
01765   <span class="comment">/* The function should not be used on a pseudo fhandle */</span>
01766   <span class="keywordflow">if</span>( pfhandle4-&gt;pseudofs_flag == TRUE)
01767     <span class="keywordflow">return</span> FALSE ;
01768 
01769   *ExIdp = pfhandle4-&gt;exportid ;
01770   <span class="keywordflow">return</span> TRUE ;
01771 } <span class="comment">/* nfs4_FhandleToExId */</span>
01772 
01773 
01774 
01775 <span class="comment">/**** Glue related functions ****/</span>
01776 
<a name="l01790"></a><a class="code" href="nfs__proto__tools_8c.html#a12">01790</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a12">nfs4_stringid_split</a>( <span class="keywordtype">char</span> * buff, <span class="keywordtype">char</span> * uidname, <span class="keywordtype">char</span> * domainname )
01791 {
01792   <span class="keywordtype">char</span> *c = NULL ;
01793   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
01794 
01795   <span class="keywordflow">for</span>( c = buff, i=0  ; *c != <span class="charliteral">'\0'</span> ; c++, i++ )
01796     <span class="keywordflow">if</span>( *c == <span class="charliteral">'@'</span> )
01797       break ;
01798   
01799   strcpy( uidname, buff ) ;
01800   uidname[i]=<span class="charliteral">'\0'</span> ;
01801   strcpy( domainname, c ) ;
01802 
01803 <span class="preprocessor">#ifdef _NFSV4_DEBUG</span>
01804 <span class="preprocessor"></span>  printf( <span class="stringliteral">"buff = #%s#    uid = #%s#   domain = #%s#\n"</span>, buff, uidname, domainname ) ;
01805 <span class="preprocessor">#endif</span>
01806 <span class="preprocessor"></span>} <span class="comment">/* nfs4_stringid_split */</span>
01807 
01808 
<a name="l01821"></a><a class="code" href="nfs__proto__tools_8c.html#a13">01821</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a13">utf82str</a>( <span class="keywordtype">char</span> * str, utf8string * utf8str )
01822 {
01823   <span class="keywordflow">if</span>( utf8str == NULL || utf8str-&gt;utf8string_len == 0 )
01824     <span class="keywordflow">return</span> -1 ;
01825   
01826   <span class="comment">/* BUGAZOMEU: TO BE DONE: use STUFF ALLOCATOR here */</span>
01827   <span class="keywordflow">if</span>( str == NULL )
01828     {
01829       <span class="keywordflow">if</span>( ( str = (<span class="keywordtype">char</span> *)Mem_Alloc( utf8str-&gt;utf8string_len + 1 ) ) == NULL )
01830         <span class="keywordflow">return</span> NFS4ERR_SERVERFAULT ;
01831     }
01832   
01833   strncpy( str, utf8str-&gt;utf8string_val, utf8str-&gt;utf8string_len );
01834   str[utf8str-&gt;utf8string_len ] = <span class="charliteral">'\0'</span> ;
01835   
01836   <span class="keywordflow">return</span> 0;
01837 } <span class="comment">/* uft82str */</span>
01838 
01839 
<a name="l01852"></a><a class="code" href="nfs__proto__tools_8c.html#a14">01852</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a14">str2utf8</a>( <span class="keywordtype">char</span> * str, utf8string * utf8str )
01853 {
01854   uint_t off, len ;
01855   <span class="keywordtype">char</span> buff[MAXNAMLEN] ;
01856   
01857   <span class="comment">/* The uft8 will probably be sent over XDR, for this reason, its size MUST be a multiple of 32 bits = 4 bytes */</span>
01858   strcpy( buff, str ) ;
01859   len = strlen( buff ) ;
01860   off = 0 ;
01861   <span class="keywordflow">while</span>( ( ( len + off ) % 4 ) != 0 )
01862     {
01863       off += 1 ;
01864       buff[len+off] = <span class="charliteral">'\0'</span> ;   <span class="comment">/* padding with 0 for alignment */</span>
01865     }
01866 
01867   <span class="comment">/* BUGAZOMEU: TO BE DONE: use STUFF ALLOCATOR here */</span>
01868   <span class="keywordflow">if</span>( ( utf8str-&gt;utf8string_val = (<span class="keywordtype">char</span> *)Mem_Alloc( len + off  ) ) == NULL )
01869     <span class="keywordflow">return</span> -1 ;
01870   
01871    utf8str-&gt;utf8string_len = len + off ; 
01872   memcpy( utf8str-&gt;utf8string_val, buff, utf8str-&gt;utf8string_len ) ; 
01873   <span class="keywordflow">return</span> 0 ;
01874 } <span class="comment">/* str2utf8 */</span>
01875 
01876 
01877 
01878 
01879 
<a name="l01892"></a><a class="code" href="nfs__proto__tools_8c.html#a15">01892</a> seqid4  <a class="code" href="nfs__proto__tools_8c.html#a15">nfs4_NextSeqId</a>( seqid4 seqid )
01893 {
01894   <span class="keywordflow">return</span> ( ( seqid +1 ) % 0xFFFFFFFF ) ;
01895 } <span class="comment">/* nfs4_NextSeqId */</span>
01896 
01911 <span class="comment">/*</span>
01912 <span class="comment"> * bitmap is usually 2 x uint32_t which makes a uint64_t </span>
01913 <span class="comment"> *</span>
01914 <span class="comment"> * Structure of the bitmap is as follow</span>
01915 <span class="comment"> *</span>
01916 <span class="comment"> *                  0         1</span>
01917 <span class="comment"> *    +-------+---------+----------+-</span>
01918 <span class="comment"> *    | count | 31 .. 0 | 63 .. 32 | </span>
01919 <span class="comment"> *    +-------+---------+----------+-</span>
01920 <span class="comment"> *</span>
01921 <span class="comment"> * One bit is set for every possible attributes. The bits are packed together in a uint32_T (XDR alignment reason probably)</span>
01922 <span class="comment"> * As said in the RFC3530, the n-th bit is with the uint32_t #(n/32), and its position with the uint32_t is n % 32</span>
01923 <span class="comment"> * Example</span>
01924 <span class="comment"> *     1st bit = FATTR4_TYPE            = 1</span>
01925 <span class="comment"> *     2nd bit = FATTR4_LINK_SUPPORT    = 5</span>
01926 <span class="comment"> *     3rd bit = FATTR4_SYMLINK_SUPPORT = 6</span>
01927 <span class="comment"> *</span>
01928 <span class="comment"> *     Juste one uint32_t is necessay: 2**1 + 2**5 + 2**6 = 2 + 32 + 64 = 98</span>
01929 <span class="comment"> *   +---+----+</span>
01930 <span class="comment"> *   | 1 | 98 |</span>
01931 <span class="comment"> *   +---+----+</span>
01932 <span class="comment"> *</span>
01933 <span class="comment"> * Other Example</span>
01934 <span class="comment"> *</span>
01935 <span class="comment"> *     1st bit = FATTR4_LINK_SUPPORT    = 5</span>
01936 <span class="comment"> *     2nd bit = FATTR4_SYMLINK_SUPPORT = 6</span>
01937 <span class="comment"> *     3rd bit = FATTR4_MODE            = 33</span>
01938 <span class="comment"> *     4th bit = FATTR4_OWNER           = 36</span>
01939 <span class="comment"> *</span>
01940 <span class="comment"> *     Two uint32_t will be necessary there:</span>
01941 <span class="comment"> *            #1 = 2**5 + 2**6 = 32 + 64 = 96</span>
01942 <span class="comment"> #            #2 = 2**(33-32) + 2**(36-32) = 2**1 + 2**4 = 2 + 16 = 18 </span>
01943 <span class="comment"> *   +---+----+----+</span>
01944 <span class="comment"> *   | 2 | 98 | 18 |</span>
01945 <span class="comment"> *   +---+----+----+</span>
01946 <span class="comment"> *</span>
01947 <span class="comment"> */</span>
01948 
<a name="l01949"></a><a class="code" href="nfs__proto__tools_8c.html#a16">01949</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( bitmap4 * b, uint_t * plen, uint32_t * pval )
01950 {
01951   uint_t i      = 0 ;
01952   uint_t val    = 0 ;
01953   uint_t index  = 0 ;
01954   uint_t offset = 0 ;
01955 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
01956 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( b-&gt;bitmap4_len &gt; 0 )
01957         printf( <span class="stringliteral">"Bitmap: Len = %u Val = %u|%u\n"</span>,  b-&gt;bitmap4_len, b-&gt;bitmap4_val[0], b-&gt;bitmap4_val[1] ) ;
01958   <span class="keywordflow">else</span>
01959         printf( <span class="stringliteral">"Bitmap: Len = %u ... \n"</span>, b-&gt;bitmap4_len ) ;
01960 <span class="preprocessor">#endif</span>
01961 <span class="preprocessor"></span>
01962   <span class="keywordflow">for</span>( offset = 0 ; offset &lt; b-&gt;bitmap4_len ; offset ++ )
01963     {
01964       <span class="keywordflow">for</span>( i = 0 ; i &lt; 32 ; i++ )
01965         {
01966           val = 1 &lt;&lt; i ; <span class="comment">/* Compute 2**i */</span>
01967           <span class="keywordflow">if</span>( b-&gt;bitmap4_val[offset] &amp; val )
01968             pval[index++] = i + 32 * offset ;
01969         }
01970     }
01971   *plen = index ;
01972 } <span class="comment">/* nfs4_bitmap4_to_list */</span>
01973 
01988 <span class="comment">/* bitmap is usually 2 x uint32_t which makes a uint64_t </span>
01989 <span class="comment"> * bitmap4_len is the number of uint32_t required to keep the bitmap value </span>
01990 <span class="comment"> *</span>
01991 <span class="comment"> * Structure of the bitmap is as follow</span>
01992 <span class="comment"> *</span>
01993 <span class="comment"> *                  0         1</span>
01994 <span class="comment"> *    +-------+---------+----------+-</span>
01995 <span class="comment"> *    | count | 31 .. 0 | 63 .. 32 | </span>
01996 <span class="comment"> *    +-------+---------+----------+-</span>
01997 <span class="comment"> *</span>
01998 <span class="comment"> * One bit is set for every possible attributes. The bits are packed together in a uint32_T (XDR alignment reason probably)</span>
01999 <span class="comment"> * As said in the RFC3530, the n-th bit is with the uint32_t #(n/32), and its position with the uint32_t is n % 32</span>
02000 <span class="comment"> * Example</span>
02001 <span class="comment"> *     1st bit = FATTR4_TYPE            = 1</span>
02002 <span class="comment"> *     2nd bit = FATTR4_LINK_SUPPORT    = 5</span>
02003 <span class="comment"> *     3rd bit = FATTR4_SYMLINK_SUPPORT = 6</span>
02004 <span class="comment"> *</span>
02005 <span class="comment"> *     Juste one uint32_t is necessay: 2**1 + 2**5 + 2**6 = 2 + 32 + 64 = 98</span>
02006 <span class="comment"> *   +---+----+</span>
02007 <span class="comment"> *   | 1 | 98 |</span>
02008 <span class="comment"> *   +---+----+</span>
02009 <span class="comment"> *</span>
02010 <span class="comment"> * Other Example</span>
02011 <span class="comment"> *</span>
02012 <span class="comment"> *     1st bit = FATTR4_LINK_SUPPORT    = 5</span>
02013 <span class="comment"> *     2nd bit = FATTR4_SYMLINK_SUPPORT = 6</span>
02014 <span class="comment"> *     3rd bit = FATTR4_MODE            = 33</span>
02015 <span class="comment"> *     4th bit = FATTR4_OWNER           = 36</span>
02016 <span class="comment"> *</span>
02017 <span class="comment"> *     Two uint32_t will be necessary there:</span>
02018 <span class="comment"> *            #1 = 2**5 + 2**6 = 32 + 64 = 96</span>
02019 <span class="comment"> #            #2 = 2**(33-32) + 2**(36-32) = 2**1 + 2**4 = 2 + 16 = 18 </span>
02020 <span class="comment"> *   +---+----+----+</span>
02021 <span class="comment"> *   | 2 | 98 | 18 |</span>
02022 <span class="comment"> *   +---+----+----+</span>
02023 <span class="comment"> *</span>
02024 <span class="comment"> */</span>
02025 
02026 <span class="comment">/* This function converts a list of attributes to a bitmap4 structure */</span>
<a name="l02027"></a><a class="code" href="nfs__proto__tools_8c.html#a17">02027</a> <span class="keywordtype">void</span> <a class="code" href="nfs__proto__tools_8c.html#a17">nfs4_list_to_bitmap4</a>( bitmap4 * b, uint_t * plen, uint32_t * pval )
02028 {
02029   uint_t  i ;
02030   uint_t  intpos = 0 ;
02031   uint_t  bitpos = 0 ;
02032   uint_t  val    = 0 ;
02033   <span class="comment">/* Both uint32 int the bitmap MUST be allocated */</span>
02034   b-&gt;bitmap4_val[0] = 0 ;
02035   b-&gt;bitmap4_val[1] = 0 ;
02036   
02037   b-&gt;bitmap4_len = 1 ;
02038   <span class="keywordflow">for</span>( i = 0 ; i &lt; *plen ; i++ )
02039     {
02040       intpos = pval[i] / 32 ;
02041       bitpos = pval[i] % 32 ;
02042       val = 1 &lt;&lt; bitpos ;
02043       b-&gt;bitmap4_val[intpos] |= val ;
02044       
02045       <span class="keywordflow">if</span>( intpos  != 0 )
02046         b-&gt;bitmap4_len = 2 ;
02047     } 
02048 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02049 <span class="preprocessor"></span>  printf( <span class="stringliteral">"Bitmap: Len = %u   Val = %u|%u\n"</span>, b-&gt;bitmap4_len, 
02050                                               b-&gt;bitmap4_len &gt;= 1 ? b-&gt;bitmap4_val[0] : 0, 
02051                                               b-&gt;bitmap4_len &gt;= 2 ? b-&gt;bitmap4_val[1] : 0) ;
02052 <span class="preprocessor">#endif</span>
02053 <span class="preprocessor"></span>} <span class="comment">/* nfs4_list_to_bitmap4 */</span>
02054 
02055 <span class="comment">/* </span>
02056 <span class="comment"> * Conversion of attributes </span>
02057 <span class="comment">*/</span>
02058 
<a name="l02072"></a><a class="code" href="nfs__proto__tools_8c.html#a18">02072</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a18">nfs3_FSALattr_To_Fattr</a>( exportlist_t       * pexport,    <span class="comment">/* In: the related export entry */</span>
02073                             fsal_attrib_list_t * FSAL_attr,  <span class="comment">/* In: file attributes */</span>
02074                             fattr3             * Fattr)      <span class="comment">/* Out: file attributes */</span>
02075 {
02076   <span class="keywordflow">if</span>( FSAL_attr == NULL || Fattr == NULL ) 
02077     <span class="keywordflow">return</span> 0 ;
02078 
02079   <span class="keywordflow">switch</span>( FSAL_attr-&gt;type )
02080     {
02081     <span class="keywordflow">case</span> FSAL_TYPE_FIFO:
02082       Fattr-&gt;type = NF3FIFO;
02083       break ;
02084       
02085     <span class="keywordflow">case</span> FSAL_TYPE_CHR:
02086       Fattr-&gt;type = NF3CHR ;
02087       break ;
02088       
02089     <span class="keywordflow">case</span> FSAL_TYPE_DIR:
02090       Fattr-&gt;type = NF3DIR ;
02091       break ;
02092       
02093     <span class="keywordflow">case</span> FSAL_TYPE_BLK:
02094       Fattr-&gt;type = NF3BLK ;
02095       break ;
02096       
02097     <span class="keywordflow">case</span> FSAL_TYPE_FILE:
02098       Fattr-&gt;type = NF3REG ;
02099       break ;
02100       
02101     <span class="keywordflow">case</span> FSAL_TYPE_LNK:
02102       Fattr-&gt;type = NF3LNK ;
02103       break ;
02104       
02105     <span class="keywordflow">case</span> FSAL_TYPE_SOCK:
02106       Fattr-&gt;type = NF3SOCK ;
02107       break ;
02108 
02109     <span class="keywordflow">default</span>: <span class="comment">/* Should not occur */</span>
02110       Fattr-&gt;type = 0 ;
02111       <span class="keywordflow">return</span> 0 ;
02112     }
02113   
02114   
02115     Fattr-&gt;mode           = fsal2unix_mode( FSAL_attr-&gt;mode ) ;
02116     Fattr-&gt;nlink          = FSAL_attr-&gt;numlinks ;
02117     Fattr-&gt;uid            = FSAL_attr-&gt;owner ;
02118     Fattr-&gt;gid            = FSAL_attr-&gt;group ;
02119     Fattr-&gt;size           = FSAL_attr-&gt;filesize;
02120     Fattr-&gt;used           = FSAL_attr-&gt;spaceused ;
02121     
02122     <span class="keywordflow">if</span> ( FSAL_attr-&gt;type == FSAL_TYPE_CHR
02123         || FSAL_attr-&gt;type == FSAL_TYPE_BLK )
02124     {
02125       Fattr-&gt;rdev.specdata1 = FSAL_attr-&gt;rawdev.major ;
02126       Fattr-&gt;rdev.specdata2 = FSAL_attr-&gt;rawdev.minor ;
02127     }
02128     <span class="keywordflow">else</span>
02129     {
02130       Fattr-&gt;rdev.specdata1 = 0 ;
02131       Fattr-&gt;rdev.specdata2 = 0 ;
02132     }    
02133         
02134     <span class="comment">/* in NFSv3, we only keeps fsid.major, casted into an nfs_uint64 */</span>
02135     Fattr-&gt;fsid = (nfs3_uint64)pexport-&gt;filesystem_id.major;
02136 
02137 <span class="preprocessor">#ifdef  _DEBUG_NFSPROTO        </span>
02138 <span class="preprocessor"></span>    printf( <span class="stringliteral">"nfs3_FSALattr_To_Fattr: fsid.major = %#llX (%llu), fsid.minor = %#llX (%llu), nfs3_fsid = %#llX (%llu)\n"</span>,
02139             pexport-&gt;filesystem_id.major, pexport-&gt;filesystem_id.major,
02140             pexport-&gt;filesystem_id.minor, pexport-&gt;filesystem_id.minor,
02141             Fattr-&gt;fsid, Fattr-&gt;fsid );
02142 <span class="preprocessor">#endif</span>
02143 <span class="preprocessor"></span>     
02144     
02145     Fattr-&gt;fileid         = FSAL_attr-&gt;fileid ;
02146     Fattr-&gt;atime.seconds  = FSAL_attr-&gt;atime.seconds ;
02147     Fattr-&gt;atime.nseconds = FSAL_attr-&gt;atime.nseconds ;
02148     Fattr-&gt;mtime.seconds  = FSAL_attr-&gt;mtime.seconds ;
02149     Fattr-&gt;mtime.nseconds = FSAL_attr-&gt;mtime.nseconds ;
02150     Fattr-&gt;ctime.seconds  = FSAL_attr-&gt;ctime.seconds ;
02151     Fattr-&gt;ctime.nseconds = FSAL_attr-&gt;ctime.nseconds ;
02152 
02153   <span class="keywordflow">return</span> 1 ;
02154 } <span class="comment">/* nfs3_FSALattr_To_Fattr */</span>
02155 
<a name="l02168"></a><a class="code" href="nfs__proto__tools_8c.html#a19">02168</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a19">nfs2_Sattr_To_FSALattr</a>( fsal_attrib_list_t * pFSAL_attr,  <span class="comment">/* Out: file attributes */</span>
02169                             sattr2             * Fattr)      <span class="comment">/* In: file attributes */</span>
02170 {
02171   <span class="keyword">struct </span>timeval t ;
02172   
02173   FSAL_CLEAR_MASK( pFSAL_attr-&gt;asked_attributes );
02174   
02175   <span class="keywordflow">if</span> ( Fattr-&gt;mode != (<span class="keywordtype">unsigned</span> int)-1 )
02176   {
02177     pFSAL_attr-&gt;mode = unix2fsal_mode( Fattr-&gt;mode );
02178     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_MODE );
02179   }
02180   
02181   <span class="keywordflow">if</span> ( Fattr-&gt;uid != (<span class="keywordtype">unsigned</span> int)-1 )
02182   {
02183     pFSAL_attr-&gt;owner = Fattr-&gt;uid ;
02184     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_OWNER );
02185   }
02186   
02187   <span class="keywordflow">if</span> ( Fattr-&gt;gid != (<span class="keywordtype">unsigned</span> int)-1 )
02188   {
02189     pFSAL_attr-&gt;group = Fattr-&gt;gid ;
02190     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_GROUP );
02191   }
02192   
02193   <span class="keywordflow">if</span> ( Fattr-&gt;size != (<span class="keywordtype">unsigned</span> int)-1 )
02194   {
02195     <span class="comment">/* Both FSAL_ATTR_SIZE and FSAL_ATTR_SPACEUSED are to be managed */</span>    
02196     pFSAL_attr-&gt;filesize = (fsal_size_t) Fattr-&gt;size;
02197     pFSAL_attr-&gt;spaceused = (fsal_size_t) Fattr-&gt;size;    
02198     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_SIZE );
02199     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_SPACEUSED );    
02200   }
02201   
02202   
02203   <span class="comment">/* if mtime.useconds == 1 millions,</span>
02204 <span class="comment">   * this means we must set atime and mtime</span>
02205 <span class="comment">   * to server time (NFS Illustrated p. 98)</span>
02206 <span class="comment">   */</span>  
02207   <span class="keywordflow">if</span> ( Fattr-&gt;mtime.useconds == 1000000 )
02208   {
02209     gettimeofday( &amp;t, NULL ) ;
02210     
02211     pFSAL_attr-&gt;atime.seconds  = pFSAL_attr-&gt;mtime.seconds  = t.tv_sec ;
02212     pFSAL_attr-&gt;atime.nseconds = pFSAL_attr-&gt;mtime.nseconds = t.tv_usec * 1000 ;
02213     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_ATIME );
02214     FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_MTIME );    
02215   }
02216   <span class="keywordflow">else</span>
02217   {
02218      <span class="comment">/* set atime to client */</span>
02219     
02220     <span class="keywordflow">if</span> ( Fattr-&gt;atime.seconds != (<span class="keywordtype">unsigned</span> int)-1 )
02221     {
02222       pFSAL_attr-&gt;atime.seconds =  Fattr-&gt;atime.seconds;
02223       
02224       <span class="keywordflow">if</span> (  Fattr-&gt;atime.seconds != (<span class="keywordtype">unsigned</span> int)-1 )
02225         pFSAL_attr-&gt;atime.nseconds = Fattr-&gt;atime.useconds * 1000;
02226       <span class="keywordflow">else</span>
02227         pFSAL_attr-&gt;atime.nseconds = 0; <span class="comment">/* ignored */</span>
02228 
02229       FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_ATIME );
02230     }
02231     
02232      <span class="comment">/* set mtime to client */</span>
02233     
02234     <span class="keywordflow">if</span> ( Fattr-&gt;mtime.seconds != (<span class="keywordtype">unsigned</span> int)-1 )
02235     {
02236       pFSAL_attr-&gt;mtime.seconds =  Fattr-&gt;mtime.seconds;
02237       
02238       <span class="keywordflow">if</span> (  Fattr-&gt;mtime.seconds != (<span class="keywordtype">unsigned</span> int)-1 )
02239         pFSAL_attr-&gt;mtime.nseconds = Fattr-&gt;mtime.useconds * 1000;
02240       <span class="keywordflow">else</span>
02241         pFSAL_attr-&gt;mtime.nseconds = 0; <span class="comment">/* ignored */</span>
02242 
02243       
02244       FSAL_SET_MASK( pFSAL_attr-&gt;asked_attributes , FSAL_ATTR_MTIME );    
02245     }
02246   }
02247   
02248   <span class="keywordflow">return</span> 1 ;
02249 } <span class="comment">/* nfs2_Sattr_To_FSALattr */</span>
02250 
<a name="l02264"></a><a class="code" href="nfs__proto__tools_8c.html#a20">02264</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a20">nfs4_Fattr_Check_Access</a>( fattr4 * Fattr,
02265                              <span class="keywordtype">int</span>      access )
02266 {
02267    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
02268 
02269    uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02270    uint32_t attrmasklen = 0 ;
02271 
02272    <span class="comment">/* Parameter sanity check */</span>
02273    <span class="keywordflow">if</span>( Fattr == NULL ) 
02274         <span class="keywordflow">return</span> 0 ;
02275 
02276    <span class="keywordflow">if</span>( access != FATTR4_ATTR_READ &amp;&amp;  access != FATTR4_ATTR_WRITE ) 
02277         <span class="keywordflow">return</span> 0 ;
02278 
02279     <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02280     <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( &amp;(Fattr-&gt;attrmask), &amp;attrmasklen, attrmasklist ) ;
02281 
02282 
02283     <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen ; i++ )
02284       {
02285         <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
02286           {
02287              <span class="comment">/* Erroneous value... skip */</span>
02288              continue ;
02289           }
02290 
02291         <span class="keywordflow">if</span>( ( (int)fattr4tab[attrmasklist[i]].access &amp; access ) != access )
02292           <span class="keywordflow">return</span> 0 ;
02293       }   
02294    
02295     <span class="keywordflow">return</span> 1 ;
02296 } <span class="comment">/* nfs4_Fattr_Check_Access */</span>
02297 
<a name="l02311"></a><a class="code" href="nfs__proto__tools_8c.html#a21">02311</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a21">nfs4_Fattr_Check_Access_Bitmap</a>( bitmap4 * pbitmap,
02312                                     <span class="keywordtype">int</span>       access )
02313 {
02314    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
02315 
02316    uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02317    uint32_t attrmasklen = 0 ;
02318 
02319    <span class="comment">/* Parameter sanity check */</span>
02320    <span class="keywordflow">if</span>( pbitmap == NULL )
02321         <span class="keywordflow">return</span> 0 ;
02322 
02323    <span class="keywordflow">if</span>( access != FATTR4_ATTR_READ &amp;&amp;  access != FATTR4_ATTR_WRITE )
02324         <span class="keywordflow">return</span> 0 ;
02325 
02326     <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02327     <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( pbitmap, &amp;attrmasklen, attrmasklist ) ;
02328 
02329 
02330     <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen ; i++ )
02331       {
02332         <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
02333           {
02334              <span class="comment">/* Erroneous value... skip */</span>
02335              continue ;
02336           }
02337 
02338         <span class="keywordflow">if</span>( ( (int)fattr4tab[attrmasklist[i]].access &amp; access ) != access )
02339           <span class="keywordflow">return</span> 0 ;
02340       }
02341 
02342     <span class="keywordflow">return</span> 1 ;
02343 } <span class="comment">/* nfs4_Fattr_Check_Access */</span>
02344 
<a name="l02357"></a><a class="code" href="nfs__proto__tools_8c.html#a22">02357</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a22">nfs4_Fattr_Supported</a>( fattr4 * Fattr )
02358 {
02359    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
02360 
02361    uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02362    uint32_t attrmasklen = 0 ;
02363 
02364    <span class="comment">/* Parameter sanity check */</span>
02365    <span class="keywordflow">if</span>( Fattr == NULL )
02366         <span class="keywordflow">return</span> 0 ;
02367 
02368 
02369     <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02370     <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( &amp;(Fattr-&gt;attrmask), &amp;attrmasklen, attrmasklist ) ;
02371 
02372     <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen ; i++ )
02373       {
02374 
02375         <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
02376           {
02377              <span class="comment">/* Erroneous value... skip */</span>
02378              continue ;
02379           }
02380 
02381 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02382 <span class="preprocessor"></span>        printf( <span class="stringliteral">"nfs4_Fattr_Supported  ==============&gt; %s supported flag=%u\n"</span>, 
02383                 fattr4tab[ attrmasklist[i]  ].name, fattr4tab[attrmasklist[i]].supported  ) ;
02384 <span class="preprocessor">#endif</span>
02385 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( !fattr4tab[attrmasklist[i]].supported ) 
02386           <span class="keywordflow">return</span> 0 ;
02387       }
02388 
02389     <span class="keywordflow">return</span> 1 ;
02390 } <span class="comment">/* nfs4_Fattr_Supported */</span>
02391 
<a name="l02404"></a><a class="code" href="nfs__proto__tools_8c.html#a23">02404</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a23">nfs4_Fattr_Supported_Bitmap</a>( bitmap4 * pbitmap )
02405 {
02406    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ;
02407 
02408    uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02409    uint32_t attrmasklen = 0 ;
02410 
02411    <span class="comment">/* Parameter sanity check */</span>
02412    <span class="keywordflow">if</span>( pbitmap == NULL )
02413         <span class="keywordflow">return</span> 0 ;
02414 
02415 
02416     <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02417     <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( pbitmap, &amp;attrmasklen, attrmasklist ) ;
02418 
02419     <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen ; i++ )
02420       {
02421 
02422         <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
02423           {
02424              <span class="comment">/* Erroneous value... skip */</span>
02425              continue ;
02426           }
02427 
02428 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02429 <span class="preprocessor"></span>        printf( <span class="stringliteral">"nfs4_Fattr_Supported  ==============&gt; %s supported flag=%u\n"</span>,
02430                 fattr4tab[ attrmasklist[i]  ].name, fattr4tab[attrmasklist[i]].supported  ) ;
02431 <span class="preprocessor">#endif</span>
02432 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( !fattr4tab[attrmasklist[i]].supported )
02433           <span class="keywordflow">return</span> 0 ;
02434       }
02435 
02436     <span class="keywordflow">return</span> 1 ;
02437 } <span class="comment">/* nfs4_Fattr_Supported */</span>
02438 
<a name="l02451"></a><a class="code" href="nfs__proto__tools_8c.html#a24">02451</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a24">nfs4_Fattr_cmp</a>( fattr4 * Fattr1, fattr4 * Fattr2 ) 
02452 {
02453   uint32_t     attrmasklist1[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02454   uint32_t     attrmasklen1 = 0 ;
02455   u_int        LastOffset ;
02456   uint32_t     attrmasklist2[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02457   uint32_t     attrmasklen2 = 0 ;
02458   uint32_t     i ; 
02459   uint32_t     k ;
02460   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmp = 0 ;
02461   u_int        len = 0 ;
02462   uint32_t     attribute_to_set = 0 ; 
02463  
02464   <span class="keywordflow">if</span>( Fattr1 == NULL ) 
02465         <span class="keywordflow">return</span> FALSE ;
02466 
02467   <span class="keywordflow">if</span>( Fattr2 == NULL ) 
02468         <span class="keywordflow">return</span> FALSE ;
02469 
02470   <span class="keywordflow">if</span>( Fattr1-&gt;attrmask.bitmap4_len != Fattr2-&gt;attrmask.bitmap4_len ) <span class="comment">/* different mask */</span>
02471         <span class="keywordflow">return</span> FALSE ;
02472 
02473  <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02474   <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( &amp;(Fattr1-&gt;attrmask), &amp;attrmasklen1, attrmasklist1 ) ;
02475   <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( &amp;(Fattr2-&gt;attrmask), &amp;attrmasklen2, attrmasklist2 ) ;
02476 
02477  <span class="comment">/* Should not occur, bu this is a sanity check */</span>
02478  <span class="keywordflow">if</span>( attrmasklen1 != attrmasklen2 ) 
02479         <span class="keywordflow">return</span> FALSE ;
02480 
02481  <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen1 ; i++ )
02482    {
02483      <span class="keywordflow">if</span>(  attrmasklist1[i] !=  attrmasklist2[i] )
02484         <span class="keywordflow">return</span> 0 ;
02485 
02486      <span class="keywordflow">if</span>( attrmasklist1[i] == FATTR4_RDATTR_ERROR )
02487         <span class="keywordflow">return</span> -1 ;
02488 
02489 
02490      <span class="keywordflow">if</span>( attrmasklist2[i] == FATTR4_RDATTR_ERROR ) 
02491         <span class="keywordflow">return</span> -1 ;
02492    }
02493 
02494  cmp = 0 ; 
02495  LastOffset = 0 ;
02496  len = 0 ;
02497 
02498 
02499  <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen1 ; i ++ ) 
02500    {
02501      attribute_to_set = attrmasklist1[i] ;
02502 
02503 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02504 <span class="preprocessor"></span>     printf( <span class="stringliteral">"nfs4_Fattr_cmp ==============&gt; %s\n"</span>, fattr4tab[attribute_to_set].name  ) ;
02505 <span class="preprocessor">#endif</span>
02506 <span class="preprocessor"></span>
02507      <span class="keywordflow">switch</span>(  attribute_to_set )
02508        {
02509         <span class="keywordflow">case</span> FATTR4_SUPPORTED_ATTRS:
02510                 memcpy( &amp;len, (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset), <span class="keyword">sizeof</span>( u_int ) ) ;
02511                 cmp += memcmp( (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset),
02512                                (<span class="keywordtype">char</span> *)(Fattr2-&gt;attr_vals.attrlist4_val + LastOffset),
02513                                <span class="keyword">sizeof</span>( u_int ) )  ;
02514 
02515                 len = htonl( len ) ;
02516                 LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
02517 
02518                 <span class="keywordflow">for</span>( k = 0 ; k &lt; len ; k++ )
02519                    {
02520                         cmp += memcmp( (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset),
02521                                (<span class="keywordtype">char</span> *)(Fattr2-&gt;attr_vals.attrlist4_val + LastOffset),
02522                                <span class="keyword">sizeof</span>( uint32_t ) )  ;
02523                         LastOffset += <span class="keyword">sizeof</span>( uint32_t ) ;
02524                    }
02525                 
02526                 break ;
02527         
02528         <span class="keywordflow">case</span> FATTR4_FILEHANDLE:
02529         <span class="keywordflow">case</span> FATTR4_OWNER:
02530         <span class="keywordflow">case</span> FATTR4_OWNER_GROUP:
02531                  memcpy( &amp;len, (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset), <span class="keyword">sizeof</span>( u_int ) ) ;
02532                 len =  ntohl( len ) ; <span class="comment">/* xdr marshalling on fattr4 */</span>
02533                 cmp += memcmp( (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset),
02534                                (<span class="keywordtype">char</span> *)(Fattr2-&gt;attr_vals.attrlist4_val + LastOffset),
02535                                <span class="keyword">sizeof</span>( u_int ) )  ;
02536                 LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
02537                 cmp += memcmp( (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset),
02538                                (<span class="keywordtype">char</span> *)(Fattr2-&gt;attr_vals.attrlist4_val + LastOffset),
02539                                len ) ;
02540                 break ;
02541 
02542         <span class="keywordflow">case</span> FATTR4_TYPE:
02543         <span class="keywordflow">case</span> FATTR4_FH_EXPIRE_TYPE:
02544         <span class="keywordflow">case</span> FATTR4_CHANGE:
02545         <span class="keywordflow">case</span> FATTR4_SIZE:
02546         <span class="keywordflow">case</span> FATTR4_LINK_SUPPORT:
02547         <span class="keywordflow">case</span> FATTR4_SYMLINK_SUPPORT:
02548         <span class="keywordflow">case</span> FATTR4_NAMED_ATTR:
02549         <span class="keywordflow">case</span> FATTR4_FSID:
02550         <span class="keywordflow">case</span> FATTR4_UNIQUE_HANDLES:
02551         <span class="keywordflow">case</span> FATTR4_LEASE_TIME:
02552         <span class="keywordflow">case</span> FATTR4_RDATTR_ERROR:
02553         <span class="keywordflow">case</span> FATTR4_ACL:
02554         <span class="keywordflow">case</span> FATTR4_ACLSUPPORT:
02555         <span class="keywordflow">case</span> FATTR4_ARCHIVE:
02556         <span class="keywordflow">case</span> FATTR4_CANSETTIME:
02557         <span class="keywordflow">case</span> FATTR4_CASE_INSENSITIVE:
02558         <span class="keywordflow">case</span> FATTR4_CASE_PRESERVING:
02559         <span class="keywordflow">case</span> FATTR4_CHOWN_RESTRICTED:
02560         <span class="keywordflow">case</span> FATTR4_FILEID:
02561         <span class="keywordflow">case</span> FATTR4_FILES_AVAIL:
02562         <span class="keywordflow">case</span> FATTR4_FILES_FREE:
02563         <span class="keywordflow">case</span> FATTR4_FILES_TOTAL:
02564         <span class="keywordflow">case</span> FATTR4_FS_LOCATIONS:
02565         <span class="keywordflow">case</span> FATTR4_HIDDEN:
02566         <span class="keywordflow">case</span> FATTR4_HOMOGENEOUS:
02567         <span class="keywordflow">case</span> FATTR4_MAXFILESIZE:
02568         <span class="keywordflow">case</span> FATTR4_MAXLINK:
02569         <span class="keywordflow">case</span> FATTR4_MAXNAME:
02570         <span class="keywordflow">case</span> FATTR4_MAXREAD:
02571         <span class="keywordflow">case</span> FATTR4_MAXWRITE:
02572         <span class="keywordflow">case</span> FATTR4_MIMETYPE:
02573         <span class="keywordflow">case</span> FATTR4_MODE:
02574         <span class="keywordflow">case</span> FATTR4_NO_TRUNC:
02575         <span class="keywordflow">case</span> FATTR4_NUMLINKS:
02576         <span class="keywordflow">case</span> FATTR4_QUOTA_AVAIL_HARD:
02577         <span class="keywordflow">case</span> FATTR4_QUOTA_AVAIL_SOFT:
02578         <span class="keywordflow">case</span> FATTR4_QUOTA_USED:
02579         <span class="keywordflow">case</span> FATTR4_RAWDEV:
02580         <span class="keywordflow">case</span> FATTR4_SPACE_AVAIL:
02581         <span class="keywordflow">case</span> FATTR4_SPACE_FREE:
02582         <span class="keywordflow">case</span> FATTR4_SPACE_TOTAL:
02583         <span class="keywordflow">case</span> FATTR4_SPACE_USED:
02584         <span class="keywordflow">case</span> FATTR4_SYSTEM:
02585         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS:
02586         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS_SET:
02587         <span class="keywordflow">case</span> FATTR4_TIME_BACKUP:
02588         <span class="keywordflow">case</span> FATTR4_TIME_CREATE:
02589         <span class="keywordflow">case</span> FATTR4_TIME_DELTA:
02590         <span class="keywordflow">case</span> FATTR4_TIME_METADATA:
02591         <span class="keywordflow">case</span> FATTR4_TIME_MODIFY:
02592         <span class="keywordflow">case</span> FATTR4_TIME_MODIFY_SET:
02593         <span class="keywordflow">case</span> FATTR4_MOUNTED_ON_FILEID:
02594                  cmp += memcmp( (<span class="keywordtype">char</span> *)(Fattr1-&gt;attr_vals.attrlist4_val + LastOffset),
02595                                (<span class="keywordtype">char</span> *)(Fattr2-&gt;attr_vals.attrlist4_val + LastOffset),
02596                                fattr4tab[attribute_to_set].size_fattr4 ) ;
02597                 break ;
02598 
02599         <span class="keywordflow">default</span>:
02600                 <span class="keywordflow">return</span> 0 ; 
02601                 break ; 
02602        }
02603    }   
02604  <span class="keywordflow">if</span>( cmp == 0 )
02605         <span class="keywordflow">return</span> TRUE ;
02606  <span class="keywordflow">else</span>
02607         <span class="keywordflow">return</span> FALSE  ;
02608 }
<a name="l02621"></a><a class="code" href="nfs__proto__tools_8c.html#a25">02621</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a25">nfs4_Fattr_To_FSAL_attr</a>( fsal_attrib_list_t * pFSAL_attr,
02622                              fattr4             * Fattr )
02623 {
02624   u_int    LastOffset = 0  ;
02625   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i      = 0 ;
02626   <span class="keywordtype">char</span>     funcname[] = <span class="stringliteral">"nfs4_FattrToSattr"</span> ;
02627   uint32_t attrmasklist[FATTR4_MOUNTED_ON_FILEID] ; <span class="comment">/* List cannot be longer than FATTR4_MOUNTED_ON_FILEID */</span>
02628   uint32_t attrmasklen = 0 ;
02629   uint32_t attribute_to_set = 0 ; 
02630 
02631   <span class="keywordtype">int</span> len;
02632   <span class="keywordtype">char</span> buffer[MAXNAMLEN] ;
02633   utf8string utf8buffer ;
02634 
02635   fattr4_type            attr_type ;
02636   fattr4_fsid            attr_fsid ;
02637   fattr4_fileid          attr_fileid ;
02638   fattr4_time_modify_set attr_time_set ;
02639   fattr4_rdattr_error    rdattr_error ;
02640   nfstime4               attr_time ;
02641   fattr4_size            attr_size ;
02642   fattr4_change          attr_change ;
02643   fattr4_numlinks        attr_numlinks ;
02644   fattr4_rawdev          attr_rawdev ;
02645   fattr4_space_used      attr_space_used ;
02646   fattr4_time_access     attr_time_access ;
02647   fattr4_time_modify     attr_time_modify ;
02648   fattr4_time_metadata   attr_time_metadata ;
02649 
02650 
02651   
02652  
02653   <span class="keywordflow">if</span>( pFSAL_attr == NULL || Fattr == NULL ) 
02654     <span class="keywordflow">return</span> -1 ;
02655 
02656   <span class="comment">/* Check attributes data */</span>
02657   <span class="keywordflow">if</span>( Fattr-&gt;attr_vals.attrlist4_val == NULL )
02658     <span class="keywordflow">return</span> -1 ;
02659 
02660   <span class="comment">/* Convert the attribute bitmap to an attribute list */</span>
02661   <a class="code" href="nfs__proto__tools_8c.html#a16">nfs4_bitmap4_to_list</a>( &amp;(Fattr-&gt;attrmask), &amp;attrmasklen, attrmasklist ) ;
02662 
02663 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02664 <span class="preprocessor"></span>  printf( <span class="stringliteral">"   nfs4_bitmap4_to_list ====&gt; attrmasklen = %d\n"</span>, attrmasklen ) ;
02665 <span class="preprocessor">#endif  </span>
02666 <span class="preprocessor"></span>
02667   <span class="comment">/* Init */</span>
02668   pFSAL_attr-&gt;asked_attributes = 0 ;
02669   
02670   <span class="keywordflow">for</span>( i = 0 ; i &lt; attrmasklen; i++ )
02671     {
02672       attribute_to_set = attrmasklist[i] ;
02673 
02674       <span class="keywordflow">if</span>( attrmasklist[i] &gt; FATTR4_MOUNTED_ON_FILEID )
02675         {
02676           <span class="comment">/* Erroneous value... skip */</span>
02677           continue ;
02678         }
02679 
02680             
02681 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02682 <span class="preprocessor"></span>      printf( <span class="stringliteral">"=================&gt; nfs4_Fattr_To_FSAL_attr: i=%u attr=%u\n"</span>, i, attrmasklist[i] ) ;
02683       printf( <span class="stringliteral">"Flag for Operation = %d|%d is ON,  name  = %s  reply_size = %d\n"</span>, attrmasklist[i], 
02684               fattr4tab[attribute_to_set].val, fattr4tab[attribute_to_set].name, fattr4tab[attribute_to_set].size_fattr4 ) ;
02685 <span class="preprocessor">#endif</span>
02686 <span class="preprocessor"></span>       
02687       <span class="keywordflow">switch</span>( attribute_to_set )
02688         {
02689         <span class="keywordflow">case</span> FATTR4_TYPE: <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02690           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_type,
02691                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02692                   <span class="keyword">sizeof</span>( fattr4_type ) ) ;
02693 
02694  
02695           <span class="keywordflow">switch</span>( ntohl( attr_type ) )
02696            {
02697             <span class="keywordflow">case</span> NF4REG:
02698               pFSAL_attr-&gt;type = FSAL_TYPE_FILE ;
02699               break ;
02700 
02701             <span class="keywordflow">case</span> NF4DIR:
02702               pFSAL_attr-&gt;type = FSAL_TYPE_DIR ;
02703               break ;
02704 
02705             <span class="keywordflow">case</span> NF4BLK:
02706               pFSAL_attr-&gt;type = FSAL_TYPE_BLK ;
02707               break ;
02708 
02709             <span class="keywordflow">case</span> NF4CHR:
02710               pFSAL_attr-&gt;type = FSAL_TYPE_CHR ;
02711               break ;
02712 
02713             <span class="keywordflow">case</span> NF4LNK:
02714               pFSAL_attr-&gt;type = FSAL_TYPE_LNK ;
02715               break ;
02716 
02717             <span class="keywordflow">case</span> NF4SOCK:
02718               pFSAL_attr-&gt;type = FSAL_TYPE_SOCK ;
02719               break ;
02720 
02721             <span class="keywordflow">case</span> NF4FIFO:
02722               pFSAL_attr-&gt;type = FSAL_TYPE_FIFO ;
02723               break ;
02724 
02725             <span class="keywordflow">default</span>: <span class="comment">/* For wanting of a better solution */</span>
02726               pFSAL_attr-&gt;type  =  0 ;
02727               break ;
02728             } <span class="comment">/* switch( pattr-&gt;type ) */</span>
02729 
02730           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_TYPE ;
02731           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02732 <span class="preprocessor">#ifdef _DEBUG_NFS_V4</span>
02733 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: On voit le type %d\n"</span>, pFSAL_attr-&gt;filesize ) ;
02734 <span class="preprocessor">#endif</span>
02735 <span class="preprocessor"></span>          break ;
02736 
02737         <span class="keywordflow">case</span> FATTR4_FILEID:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02738           <span class="comment">/* The analog to the inode number. RFC3530 says "a number uniquely identifying the file within the filesystem"</span>
02739 <span class="comment">           * I use hpss_GetObjId to extract this information from the Name Server's handle */</span>
02740           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_fileid,
02741                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02742                   <span class="keyword">sizeof</span>( fattr4_fileid ) ) ;
02743           pFSAL_attr-&gt;fileid = nfs_ntohl64( attr_fileid ) ;
02744 
02745           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_FILEID ;
02746           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02747 
02748           break ;
02749 
02750         <span class="keywordflow">case</span> FATTR4_FSID:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02751           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_fsid,
02752                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02753                   <span class="keyword">sizeof</span>( fattr4_fsid ) ) ;
02754           pFSAL_attr-&gt;fsid.major = nfs_ntohl64( attr_fsid.major ) ;
02755           pFSAL_attr-&gt;fsid.minor = nfs_ntohl64( attr_fsid.minor ) ;
02756 
02757           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_FSID ;
02758           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02759 
02760           break ;
02761 
02762 
02763          <span class="keywordflow">case</span> FATTR4_NUMLINKS:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02764           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_numlinks,
02765                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02766                   <span class="keyword">sizeof</span>( fattr4_numlinks ) ) ;
02767           pFSAL_attr-&gt;numlinks = ntohl( attr_numlinks ) ;
02768 
02769           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_FILEID ;
02770           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02771 
02772           break ;
02773 
02774 
02775         <span class="keywordflow">case</span> FATTR4_SIZE:
02776           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_size, 
02777                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02778                   <span class="keyword">sizeof</span>( fattr4_size ) ) ;
02779 
02780           <span class="comment">/* Do not forget the XDR marshalling for the fattr4 stuff */</span>
02781           pFSAL_attr-&gt;filesize = nfs_ntohl64( attr_size ) ;
02782 
02783           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_SIZE ;
02784           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02785 <span class="preprocessor">#ifdef _DEBUG_NFS_V4          </span>
02786 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: On voit la taille %d\n"</span>, pFSAL_attr-&gt;filesize ) ;
02787 <span class="preprocessor">#endif</span>
02788 <span class="preprocessor"></span>          break ;
02789           
02790         <span class="keywordflow">case</span> FATTR4_MODE:
02791           memcpy( (<span class="keywordtype">char</span> *)&amp;(pFSAL_attr-&gt;mode),
02792                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02793                   <span class="keyword">sizeof</span>( fattr4_mode ) ) ;
02794 
02795           <span class="comment">/* Do not forget the XDR marshalling for the fattr4 stuff */</span>
02796           pFSAL_attr-&gt;mode = ntohl(pFSAL_attr-&gt;mode);
02797 
02798           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_MODE ;
02799           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02800 <span class="preprocessor">#ifdef _DEBUG_NFS_V4                </span>
02801 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: On voit le mode 0%o\n"</span>, pFSAL_attr-&gt;mode ) ;
02802 <span class="preprocessor">#endif</span>
02803 <span class="preprocessor"></span>          break ;
02804           
02805         <span class="keywordflow">case</span>  FATTR4_OWNER:
02806           memcpy( &amp;len, (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), <span class="keyword">sizeof</span>( u_int ) ) ;
02807           len = ntohl( len ) ; <span class="comment">/* xdr marshalling on fattr4 */</span>
02808           LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
02809 
02810           memcpy( buffer, (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), len ) ;
02811           buffer[len] = <span class="charliteral">'\0'</span> ;
02812 
02813           <span class="comment">/* Do not forget that xdr_opaque are aligned on 32bit long words */</span>
02814           <span class="keywordflow">while</span> ( ( len % 4 ) != 0 ) len += 1 ;
02815           
02816           LastOffset += len ;
02817 
02818           utf8buffer.utf8string_val = buffer ;
02819           utf8buffer.utf8string_len = strlen( buffer ) ;
02820 
02821           utf82uid( &amp;utf8buffer, &amp;(pFSAL_attr-&gt;owner) ) ;
02822           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_OWNER ;
02823 
02824 <span class="preprocessor">#ifdef _DEBUG_NFS_V4      </span>
02825 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: On voit le owner %s len = %d\n"</span>, buffer, len ) ;
02826           printf( <span class="stringliteral">"      SATTR: On voit le owner %d\n"</span>, pFSAL_attr-&gt;owner ) ;
02827 <span class="preprocessor">#endif</span>
02828 <span class="preprocessor"></span>          break ;
02829           
02830         <span class="keywordflow">case</span> FATTR4_OWNER_GROUP:
02831           memcpy( &amp;len, (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), <span class="keyword">sizeof</span>( u_int ) ) ;
02832           len = ntohl( len ) ;
02833           LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
02834 
02835           memcpy( buffer, (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), len ) ;
02836           buffer[len] = <span class="charliteral">'\0'</span> ;
02837 
02838            <span class="comment">/* Do not forget that xdr_opaque are aligned on 32bit long words */</span>
02839           <span class="keywordflow">while</span> ( ( len % 4 ) != 0 ) len += 1 ;
02840 
02841           LastOffset += len ;
02842 
02843           utf8buffer.utf8string_val = buffer ;
02844           utf8buffer.utf8string_len = strlen( buffer ) ;
02845 
02846           utf82gid( &amp;utf8buffer, &amp;(pFSAL_attr-&gt;group) ) ;
02847           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_GROUP ;
02848 
02849 <span class="preprocessor">#ifdef _DEBUG_NFS_V4   </span>
02850 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: On voit le owner_group %s len = %d\n"</span>, buffer, len ) ;          
02851           printf( <span class="stringliteral">"      SATTR: On voit le owner_group %d\n"</span>, pFSAL_attr-&gt;group ) ;
02852 <span class="preprocessor">#endif</span>
02853 <span class="preprocessor"></span>          break ;
02854 
02855         <span class="keywordflow">case</span> FATTR4_CHANGE:
02856           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_change,
02857                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02858                   <span class="keyword">sizeof</span>( fattr4_change ) ) ;
02859           pFSAL_attr-&gt;chgtime.seconds  = (uint32_t)nfs_ntohl64( attr_change ) ;
02860           pFSAL_attr-&gt;chgtime.nseconds = 0 ;
02861 
02862           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_CHGTIME ;
02863           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02864 
02865           break ;
02866 
02867         <span class="keywordflow">case</span> FATTR4_RAWDEV:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02868           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_rawdev,
02869                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02870                   <span class="keyword">sizeof</span>( fattr4_rawdev ) ) ;
02871           pFSAL_attr-&gt;rawdev.major  = (uint32_t)nfs_ntohl64( attr_rawdev.specdata1 ) ;
02872           pFSAL_attr-&gt;rawdev.minor  = (uint32_t)nfs_ntohl64( attr_rawdev.specdata2 ) ;
02873 
02874           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_RAWDEV ;
02875           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02876 
02877           break ;
02878 
02879         <span class="keywordflow">case</span> FATTR4_SPACE_USED:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02880           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_space_used,
02881                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02882                   <span class="keyword">sizeof</span>( fattr4_space_used ) ) ;
02883           pFSAL_attr-&gt;spaceused  = (uint32_t)nfs_ntohl64( attr_space_used ) ;
02884 
02885           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_SPACEUSED ;
02886           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02887 
02888           break ;
02889 
02890 
02891         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02892           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_time_access,
02893                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02894                   <span class="keyword">sizeof</span>( fattr4_time_access ) ) ;
02895           pFSAL_attr-&gt;atime.seconds   = (uint32_t)nfs_ntohl64( attr_time_access.seconds ) ;
02896           pFSAL_attr-&gt;atime.nseconds  = (uint32_t)ntohl( attr_time_access.nseconds ) ;
02897 
02898           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_ATIME ;
02899           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02900 
02901           break ;
02902 
02903         <span class="keywordflow">case</span> FATTR4_TIME_METADATA:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02904           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_time_metadata,
02905                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02906                   <span class="keyword">sizeof</span>( fattr4_time_metadata ) ) ;
02907           pFSAL_attr-&gt;ctime.seconds   = (uint32_t)nfs_ntohl64( attr_time_metadata.seconds ) ;
02908           pFSAL_attr-&gt;ctime.nseconds  = (uint32_t)ntohl( attr_time_metadata.nseconds ) ;
02909 
02910           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_CTIME ;
02911           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02912 
02913           break ;
02914 
02915         <span class="keywordflow">case</span> FATTR4_TIME_MODIFY:  <span class="comment">/* Used only by FSAL_PROXY to reverse convert */</span>
02916           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_time_modify,
02917                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02918                   <span class="keyword">sizeof</span>( fattr4_time_modify ) ) ;
02919           pFSAL_attr-&gt;mtime.seconds   = (uint32_t)nfs_ntohl64( attr_time_modify.seconds ) ;
02920           pFSAL_attr-&gt;mtime.nseconds  = (uint32_t)ntohl( attr_time_modify.nseconds ) ;
02921 
02922           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_MTIME ;
02923           LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02924 
02925           break ;
02926 
02927 
02928         <span class="keywordflow">case</span> FATTR4_TIME_ACCESS_SET:
02929           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_time_set,
02930                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02931                   <span class="keyword">sizeof</span>( fattr4_time_access_set ) ) ;
02932 
02933           <span class="keywordflow">if</span>( ntohl( attr_time_set.set_it ) == SET_TO_SERVER_TIME4 ) 
02934             {
02935                pFSAL_attr-&gt;atime.seconds  = time( NULL ) ; <span class="comment">/* Use current server's time */</span>
02936                pFSAL_attr-&gt;atime.nseconds = 0 ;
02937 
02938                LastOffset += 4 ; <span class="comment">/* Size is different (no data) */</span>
02939             }
02940           <span class="keywordflow">else</span>
02941             {
02942                <span class="comment">/* Take care of XDR when dealing with fattr4 */</span>
02943                attr_time = attr_time_set.settime4_u.time ;
02944                attr_time.seconds  = nfs_ntohl64( attr_time.seconds ) ;
02945                attr_time.nseconds = ntohl( attr_time.nseconds ) ;
02946 
02947                pFSAL_attr-&gt;atime.seconds  = attr_time.seconds ;
02948                pFSAL_attr-&gt;atime.nseconds = attr_time.nseconds ;
02949           
02950                LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02951             }
02952           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_ATIME ;
02953 
02954           break ;
02955           
02956         <span class="keywordflow">case</span>  FATTR4_TIME_MODIFY_SET:
02957           memcpy( (<span class="keywordtype">char</span> *)&amp;attr_time_set,
02958                   (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), 
02959                   <span class="keyword">sizeof</span>( fattr4_time_modify_set ) ) ;
02960 
02961           <span class="keywordflow">if</span>( ntohl( attr_time_set.set_it ) == SET_TO_SERVER_TIME4 )
02962             {
02963                pFSAL_attr-&gt;mtime.seconds  = time( NULL ) ; <span class="comment">/* Use current server's time */</span>
02964                pFSAL_attr-&gt;mtime.nseconds = 0 ;
02965  
02966                LastOffset += 4 ; <span class="comment">/* Size is different in this case (no data) */</span>
02967             }
02968           <span class="keywordflow">else</span>
02969             {
02970                <span class="comment">/* Take care of XDR when dealing with fattr4 */</span>
02971                attr_time = attr_time_set.settime4_u.time ;
02972                attr_time.seconds  = nfs_ntohl64( attr_time.seconds ) ;
02973                attr_time.nseconds = ntohl( attr_time.nseconds ) ;
02974 
02975                pFSAL_attr-&gt;mtime.seconds  = attr_time.seconds ;
02976                pFSAL_attr-&gt;mtime.nseconds = attr_time.nseconds ;
02977           
02978                LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
02979             }
02980 
02981           pFSAL_attr-&gt;asked_attributes |= FSAL_ATTR_MTIME ;
02982 
02983           break ;
02984           
02985         <span class="keywordflow">case</span> FATTR4_FILEHANDLE:
02986            memcpy( &amp;len, (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset), <span class="keyword">sizeof</span>( u_int ) ) ;
02987            len = ntohl( len ) ;
02988            LastOffset += <span class="keyword">sizeof</span>( u_int ) ;
02989            LastOffset += len ;
02990 <span class="preprocessor">#ifdef _DEBUG_NFS_V4   </span>
02991 <span class="preprocessor"></span>           printf( <span class="stringliteral">"     SATTR: On a demande le filehandle len =%u\n"</span>, len ) ;
02992 <span class="preprocessor">#endif</span>
02993 <span class="preprocessor"></span>           break ;
02994           
02995         <span class="keywordflow">case</span> FATTR4_RDATTR_ERROR: 
02996            memcpy( (<span class="keywordtype">char</span> *)&amp;rdattr_error,
02997                    (<span class="keywordtype">char</span> *)(Fattr-&gt;attr_vals.attrlist4_val + LastOffset),
02998                    <span class="keyword">sizeof</span>( fattr4_rdattr_error ) ) ;
02999            rdattr_error = ntohl( rdattr_error ) ;
03000            LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
03001 
03002            break ;
03003 
03004         <span class="keywordflow">default</span>:
03005 <span class="preprocessor">#ifdef _DEBUG_NFS_V4   </span>
03006 <span class="preprocessor"></span>          printf( <span class="stringliteral">"      SATTR: Attribut no supporte %d name=%s\n"</span>, attribute_to_set, fattr4tab[attribute_to_set].name ) ;
03007 <span class="preprocessor">#endif</span>
03008 <span class="preprocessor"></span>          LastOffset += fattr4tab[attribute_to_set].size_fattr4 ;
03009           <span class="comment">/* return 0 ; */</span> <span class="comment">/* Should not stop processing */</span>
03010           break ;
03011         } <span class="comment">/* switch */</span>
03012     } <span class="comment">/* for */</span>
03013 
03014   <span class="keywordflow">return</span> 1 ;
03015 } <span class="comment">/* nfs4_Fattr_To_FSAL_attr */</span>
03016 
03017 
03018 
03019 <span class="comment">/* Error conversion routines */</span>
<a name="l03031"></a><a class="code" href="nfs__proto__tools_8c.html#a26">03031</a> nfsstat4 <a class="code" href="nfs__proto__tools_8c.html#a26">nfs4_Errno</a>( cache_inode_status_t error ) 
03032 {
03033   nfsstat4 nfserror ;
03034   
03035  <span class="keywordflow">switch</span>( error )
03036     {
03037     <span class="keywordflow">case</span> CACHE_INODE_SUCCESS:
03038       nfserror = NFS4_OK ;
03039       break ;
03040       
03041     <span class="keywordflow">case</span> CACHE_INODE_MALLOC_ERROR:
03042     <span class="keywordflow">case</span> CACHE_INODE_POOL_MUTEX_INIT_ERROR:
03043     <span class="keywordflow">case</span> CACHE_INODE_GET_NEW_LRU_ENTRY:
03044     <span class="keywordflow">case</span> CACHE_INODE_INIT_ENTRY_FAILED:
03045     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EXISTS:
03046     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EMPTY:
03047       nfserror = NFS4ERR_SERVERFAULT ;
03048       break ;
03049 
03050     <span class="keywordflow">case</span> CACHE_INODE_UNAPPROPRIATED_KEY:
03051       nfserror = NFS4ERR_BADHANDLE ;
03052       break ;
03053       
03054     <span class="keywordflow">case</span> CACHE_INODE_BAD_TYPE:
03055       nfserror = NFS4ERR_INVAL ;
03056       break ;
03057 
03058     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERROR:
03059     <span class="keywordflow">case</span> CACHE_INODE_INVALID_ARGUMENT:
03060       nfserror = NFS4ERR_PERM ;
03061       break ;
03062       
03063     <span class="keywordflow">case</span>  CACHE_INODE_NOT_A_DIRECTORY:
03064       nfserror = NFS4ERR_NOTDIR  ;
03065       break ;
03066 
03067     <span class="keywordflow">case</span> CACHE_INODE_ENTRY_EXISTS:
03068       nfserror = NFS4ERR_EXIST ;
03069       break ;
03070       
03071       
03072     <span class="keywordflow">case</span> CACHE_INODE_DIR_NOT_EMPTY:
03073       nfserror = NFS4ERR_NOTEMPTY ;
03074       break ;
03075       
03076     <span class="keywordflow">case</span> CACHE_INODE_NOT_FOUND:
03077       nfserror = NFS4ERR_NOENT ;
03078       break ;
03079       
03080     <span class="keywordflow">case</span> CACHE_INODE_INSERT_ERROR:
03081     <span class="keywordflow">case</span>  CACHE_INODE_LRU_ERROR:
03082     <span class="keywordflow">case</span> CACHE_INODE_HASH_SET_ERROR :
03083       nfserror = NFS4ERR_IO ;
03084       break ;
03085       
03086     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EACCESS:
03087       nfserror = NFS4ERR_ACCESS ;
03088       break ;
03089 
03090     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EPERM:
03091       nfserror = NFS4ERR_PERM ;
03092       break ;
03093 
03094     <span class="keywordflow">case</span> CACHE_INODE_NO_SPACE_LEFT:
03095       nfserror = NFS4ERR_NOSPC ;
03096       break ;
03097       
03098     <span class="keywordflow">case</span> CACHE_INODE_IS_A_DIRECTORY:
03099       nfserror = NFS4ERR_ISDIR ;
03100       break ;
03101 
03102     <span class="keywordflow">case</span> CACHE_INODE_READ_ONLY_FS:
03103       nfserror = NFS4ERR_ROFS ;
03104       break ;
03105 
03106     <span class="keywordflow">case</span> CACHE_INODE_IO_ERROR:
03107       nfserror = NFS4ERR_IO ;
03108       break ;
03109 
03110     <span class="keywordflow">case</span> CACHE_INODE_DEAD_ENTRY:
03111     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ESTALE:
03112       nfserror = NFS4ERR_STALE ;
03113       break ;
03114 
03115     <span class="keywordflow">case</span> CACHE_INODE_LOCK_CONFLICT:
03116       nfserror = NFS4ERR_LOCK_RANGE ;
03117       break ;
03118 
03119     <span class="keywordflow">case</span> CACHE_INODE_QUOTA_EXCEEDED:
03120       nfserror = NFS4ERR_DQUOT ;
03121       break ;
03122       
03123     <span class="keywordflow">case</span> CACHE_INODE_NOT_SUPPORTED:
03124       nfserror = NFS4ERR_NOTSUPP ;
03125       break ;
03126 
03127     <span class="keywordflow">default</span>: <span class="comment">/* Should not occur */</span>
03128       nfserror = NFS4ERR_INVAL ;
03129       break ;
03130     }
03131 
03132   <span class="keywordflow">return</span> nfserror ;
03133 } <span class="comment">/* nfs4_Errno */</span>
03134 
03135 
<a name="l03147"></a><a class="code" href="nfs__proto__tools_8c.html#a27">03147</a> nfsstat3 <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_inode_status_t error ) 
03148 {
03149   nfsstat3 nfserror ;
03150   
03151   <span class="keywordflow">switch</span>( error )
03152     {
03153     <span class="keywordflow">case</span> CACHE_INODE_SUCCESS:
03154       nfserror = NFS3_OK ;
03155       break ;
03156       
03157     <span class="keywordflow">case</span> CACHE_INODE_MALLOC_ERROR:
03158     <span class="keywordflow">case</span> CACHE_INODE_POOL_MUTEX_INIT_ERROR:
03159     <span class="keywordflow">case</span> CACHE_INODE_GET_NEW_LRU_ENTRY:
03160     <span class="keywordflow">case</span> CACHE_INODE_UNAPPROPRIATED_KEY:
03161     <span class="keywordflow">case</span> CACHE_INODE_INIT_ENTRY_FAILED:
03162     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EXISTS:
03163     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EMPTY:
03164     <span class="keywordflow">case</span> CACHE_INODE_INSERT_ERROR:
03165     <span class="keywordflow">case</span> CACHE_INODE_LRU_ERROR:
03166     <span class="keywordflow">case</span> CACHE_INODE_HASH_SET_ERROR :
03167       DisplayLog( <span class="stringliteral">"Error %u converted to NFS3ERR_IO but was set non-retryable"</span>, error ) ;
03168       nfserror = NFS3ERR_IO ;
03169       break ;
03170 
03171     <span class="keywordflow">case</span> CACHE_INODE_INVALID_ARGUMENT:
03172       nfserror = NFS3ERR_INVAL ;
03173       break ;
03174 
03175     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERROR:
03176     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_ERROR: 
03177       DisplayLog( <span class="stringliteral">"Error CACHE_INODE_FSAL_ERROR converted to NFS3ERR_IO but was set non-retryable"</span> ) ;
03178       nfserror = NFS3ERR_IO ;
03179       break ;
03180       
03181     <span class="keywordflow">case</span>  CACHE_INODE_NOT_A_DIRECTORY:
03182       nfserror = NFS3ERR_NOTDIR  ;
03183       break ;
03184 
03185     <span class="keywordflow">case</span> CACHE_INODE_ENTRY_EXISTS:
03186       nfserror = NFS3ERR_EXIST ;
03187       break ;
03188       
03189       
03190     <span class="keywordflow">case</span> CACHE_INODE_DIR_NOT_EMPTY:
03191       nfserror = NFS3ERR_NOTEMPTY ;
03192       break ;
03193       
03194     <span class="keywordflow">case</span> CACHE_INODE_NOT_FOUND:
03195       nfserror = NFS3ERR_NOENT ;
03196       break ;
03197       
03198     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EACCESS:
03199       nfserror = NFS3ERR_ACCES ;
03200       break ;
03201 
03202     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EPERM:
03203     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERR_SEC:
03204       nfserror = NFS3ERR_PERM ;
03205       break ;
03206 
03207     <span class="keywordflow">case</span> CACHE_INODE_NO_SPACE_LEFT:
03208       nfserror = NFS3ERR_NOSPC ;
03209       break ;
03210       
03211     <span class="keywordflow">case</span> CACHE_INODE_IS_A_DIRECTORY:
03212       nfserror = NFS3ERR_ISDIR ;
03213       break ;
03214 
03215     <span class="keywordflow">case</span> CACHE_INODE_READ_ONLY_FS:
03216       nfserror = NFS3ERR_ROFS ;
03217       break ;
03218   
03219     <span class="keywordflow">case</span> CACHE_INODE_DEAD_ENTRY: 
03220     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ESTALE:
03221       nfserror = NFS3ERR_STALE ;
03222       break ;
03223 
03224     <span class="keywordflow">case</span> CACHE_INODE_QUOTA_EXCEEDED:
03225       nfserror = NFS3ERR_DQUOT ;
03226       break ;
03227       
03228     <span class="keywordflow">case</span> CACHE_INODE_BAD_TYPE:
03229       nfserror = NFS3ERR_BADTYPE ;
03230       break ;      
03231       
03232     <span class="keywordflow">case</span> CACHE_INODE_NOT_SUPPORTED:
03233       nfserror = NFS3ERR_NOTSUPP ;
03234       break ;
03235  
03236     <span class="keywordflow">case</span> CACHE_INODE_IO_ERROR:
03237       DisplayLog( <span class="stringliteral">"Error CACHE_INODE_IO_ERROR converted to NFS3ERR_IO but was set non-retryable"</span> ) ;
03238       nfserror = NFS3ERR_IO ;
03239       break ;      
03240       
03241     <span class="keywordflow">default</span>: <span class="comment">/* Should not occur */</span>
03242       DisplayLog( <span class="stringliteral">"Line %u should never be reached in nfs3_Errno for cache_status=%u"</span>, __LINE__ , error ) ;
03243       nfserror = NFS3ERR_INVAL ;
03244       break ;
03245     }
03246       
03247   <span class="keywordflow">return</span> nfserror ;
03248 } <span class="comment">/* nfs3_Errno */</span>
03249 
03250 
<a name="l03262"></a><a class="code" href="nfs__proto__tools_8c.html#a28">03262</a> nfsstat2 <a class="code" href="nfs__proto__tools_8c.html#a28">nfs2_Errno</a>( cache_inode_status_t error ) 
03263 {
03264    nfsstat2 nfserror ;
03265   
03266   <span class="keywordflow">switch</span>( error )
03267     {
03268     <span class="keywordflow">case</span> CACHE_INODE_SUCCESS:
03269       nfserror = NFS_OK ;
03270       break ;
03271       
03272     <span class="keywordflow">case</span> CACHE_INODE_MALLOC_ERROR:
03273     <span class="keywordflow">case</span> CACHE_INODE_POOL_MUTEX_INIT_ERROR:
03274     <span class="keywordflow">case</span> CACHE_INODE_GET_NEW_LRU_ENTRY:
03275     <span class="keywordflow">case</span> CACHE_INODE_UNAPPROPRIATED_KEY:
03276     <span class="keywordflow">case</span> CACHE_INODE_INIT_ENTRY_FAILED:
03277     <span class="keywordflow">case</span> CACHE_INODE_BAD_TYPE:
03278     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EXISTS:
03279     <span class="keywordflow">case</span> CACHE_INODE_CACHE_CONTENT_EMPTY:
03280     <span class="keywordflow">case</span> CACHE_INODE_INSERT_ERROR:
03281     <span class="keywordflow">case</span>  CACHE_INODE_LRU_ERROR:
03282     <span class="keywordflow">case</span> CACHE_INODE_HASH_SET_ERROR :
03283     <span class="keywordflow">case</span> CACHE_INODE_INVALID_ARGUMENT:
03284       DisplayLog( <span class="stringliteral">"Error %u converted to NFSERR_IO but was set non-retryable"</span>, error ) ;
03285       nfserror = NFSERR_IO ;
03286       break ;
03287 
03288       
03289     <span class="keywordflow">case</span>  CACHE_INODE_NOT_A_DIRECTORY:
03290       nfserror = NFSERR_NOTDIR  ;
03291       break ;
03292 
03293     <span class="keywordflow">case</span> CACHE_INODE_ENTRY_EXISTS:
03294       nfserror = NFSERR_EXIST ;
03295       break ;
03296       
03297       
03298     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ERROR:
03299       DisplayLog( <span class="stringliteral">"Error CACHE_INODE_FSAL_ERROR converted to NFSERR_IO but was set non-retryable"</span> ) ;
03300       nfserror = NFSERR_IO ;
03301       break ;
03302 
03303     <span class="keywordflow">case</span> CACHE_INODE_DIR_NOT_EMPTY:
03304       nfserror = NFSERR_NOTEMPTY ;
03305       break ;
03306       
03307     <span class="keywordflow">case</span> CACHE_INODE_NOT_FOUND:
03308       nfserror = NFSERR_NOENT ;
03309       break ;
03310       
03311     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EACCESS:
03312       nfserror = NFSERR_ACCES ;
03313       break ;
03314 
03315     <span class="keywordflow">case</span> CACHE_INODE_NO_SPACE_LEFT:
03316       nfserror = NFSERR_NOSPC ;
03317       break ;
03318       
03319     <span class="keywordflow">case</span> CACHE_INODE_FSAL_EPERM:
03320       nfserror = NFSERR_PERM ;
03321       break ;
03322 
03323     <span class="keywordflow">case</span> CACHE_INODE_IS_A_DIRECTORY:
03324       nfserror = NFSERR_ISDIR ;
03325       break ;
03326  
03327     <span class="keywordflow">case</span> CACHE_INODE_READ_ONLY_FS:
03328       nfserror = NFSERR_ROFS ;
03329       break ;
03330   
03331     <span class="keywordflow">case</span> CACHE_INODE_DEAD_ENTRY: 
03332     <span class="keywordflow">case</span> CACHE_INODE_FSAL_ESTALE:
03333       nfserror = NFSERR_STALE ;
03334       break ;
03335       
03336     <span class="keywordflow">case</span> CACHE_INODE_QUOTA_EXCEEDED:
03337       nfserror = NFSERR_DQUOT ;
03338       break ;
03339       
03340     <span class="keywordflow">case</span> CACHE_INODE_IO_ERROR:
03341       DisplayLog( <span class="stringliteral">"Error CACHE_INODE_IO_ERROR converted to NFSERR_IO but was set non-retryable"</span> ) ;
03342       nfserror = NFSERR_IO ;
03343       break ;
03344 
03345     <span class="keywordflow">default</span>: <span class="comment">/* Should not occur */</span>
03346       DisplayLog( <span class="stringliteral">"Line %u should never be reached in nfs2_Errno"</span>, __LINE__ ) ;
03347       nfserror = NFSERR_IO ;
03348       break ;
03349     }
03350   
03351   <span class="keywordflow">return</span> nfserror ;
03352 } <span class="comment">/* nfs2_Errno */</span>
03353 
<a name="l03365"></a><a class="code" href="nfs__proto__tools_8c.html#a29">03365</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a29">nfs4_AllocateFH</a>( nfs_fh4 * fh )
03366 {
03367   <span class="keywordtype">char</span> funcname[]= <span class="stringliteral">"AllocateFH4"</span> ;
03368 
03369   <span class="keywordflow">if</span>( fh == NULL )
03370     <span class="keywordflow">return</span> NFS4ERR_SERVERFAULT;
03371 
03372   fh-&gt;nfs_fh4_len = <span class="keyword">sizeof</span>( file_handle_v4_t ) ;  
03373   <span class="keywordflow">if</span>( ( fh-&gt;nfs_fh4_val = (<span class="keywordtype">char</span>*)Mem_Alloc( fh-&gt;nfs_fh4_len  )) == NULL )
03374     {
03375       DisplayErrorLog( ERR_SYS, ERR_MALLOC, errno ) ;
03376       <span class="keywordflow">return</span> NFS4ERR_RESOURCE ;
03377     }
03378   fh-&gt;nfs_fh4_len = <span class="keyword">sizeof</span>( file_handle_v4_t ) ;  
03379 
03380   <span class="comment">/* Allocating the filehandle in memory */</span>
03381   <span class="keywordflow">if</span>( ( fh-&gt;nfs_fh4_val = (<span class="keywordtype">char</span> *)Mem_Alloc( fh-&gt;nfs_fh4_len  )) == NULL )
03382     {
03383       DisplayErrorLog( ERR_SYS, ERR_MALLOC, errno ) ;
03384       <span class="keywordflow">return</span> NFS4ERR_STALE ;             
03385     }
03386   memset((<span class="keywordtype">char</span> *)fh-&gt;nfs_fh4_val, 0, fh-&gt;nfs_fh4_len ) ;
03387 
03388   <span class="keywordflow">return</span> NFS4_OK ;
03389 } <span class="comment">/* nfs4_AllocateFH */</span>
03390 
<a name="l03402"></a><a class="code" href="nfs__proto__tools_8c.html#a30">03402</a> <span class="keywordtype">int</span> <a class="code" href="nfs__proto__tools_8c.html#a30">nfs4_MakeCred</a>( compound_data_t * data )
03403 {
03404   exportlist_client_entry_t    related_client ;
03405   nfs_worker_data_t          * pworker = NULL ;
03406 
03407   pworker = (nfs_worker_data_t *)data-&gt;pclient-&gt;pworker ;
03408 
03409   <span class="keywordflow">if</span>( nfs_export_check_access( pworker-&gt;hostaddr,
03410                                data-&gt;reqp,
03411                                data-&gt;pexport,
03412                                <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.core_param.nfs_program,
03413                                <a class="code" href="nfs4__cb__getattr_8c.html#a0">nfs_param</a>.core_param.mnt_program,
03414                                pworker-&gt;ht_ip_stats,
03415                                pworker-&gt;ip_stats_pool,
03416                                &amp;related_client ) == FALSE )
03417         <span class="keywordflow">return</span> NFS4ERR_WRONGSEC ;
03418 
03419 
03420   <span class="keywordflow">if</span>( nfs_build_fsal_context( data-&gt;reqp, &amp;related_client,  data-&gt;pexport, data-&gt;pcontext ) == FALSE )
03421     <span class="keywordflow">return</span> NFS4ERR_WRONGSEC ;
03422 
03423   <span class="keywordflow">return</span> NFS4_OK ;
03424 } <span class="comment">/* nfs4_MakeCred */</span>
03425 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:29 2008 for NFS and Mount protocols layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
