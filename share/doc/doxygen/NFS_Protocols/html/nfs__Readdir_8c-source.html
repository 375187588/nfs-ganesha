<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NFS and Mount protocols layer: nfs_Readdir.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>nfs_Readdir.c</h1><a href="nfs__Readdir_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00086 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00091 <span class="preprocessor">#include &lt;string.h&gt;</span>
00092 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00093 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00094 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>  <span class="comment">/* for having FNDELAY */</span>
00095 <span class="preprocessor">#include "HashData.h"</span>
00096 <span class="preprocessor">#include "HashTable.h"</span>
00097 <span class="preprocessor">#ifdef _USE_GSSRPC</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gssrpc/types.h&gt;</span>
00099 <span class="preprocessor">#include &lt;gssrpc/rpc.h&gt;</span>
00100 <span class="preprocessor">#include &lt;gssrpc/auth.h&gt;</span>
00101 <span class="preprocessor">#include &lt;gssrpc/pmap_clnt.h&gt;</span>
00102 <span class="preprocessor">#else</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/types.h&gt;</span>
00104 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00105 <span class="preprocessor">#include &lt;rpc/auth.h&gt;</span>
00106 <span class="preprocessor">#include &lt;rpc/pmap_clnt.h&gt;</span>
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
00109 <span class="preprocessor">#include "log_functions.h"</span>
00110 <span class="preprocessor">#include "stuff_alloc.h"</span>
00111 <span class="preprocessor">#include "nfs23.h"</span>
00112 <span class="preprocessor">#include "nfs4.h"</span>
00113 <span class="preprocessor">#include "mount.h"</span>
00114 <span class="preprocessor">#include "nfs_core.h"</span>
00115 <span class="preprocessor">#include "cache_inode.h"</span>
00116 <span class="preprocessor">#include "cache_content.h"</span>
00117 <span class="preprocessor">#include "nfs_exports.h"</span>
00118 <span class="preprocessor">#include "nfs_creds.h"</span>
00119 <span class="preprocessor">#include "nfs_proto_functions.h"</span>
00120 <span class="preprocessor">#include "nfs_tools.h"</span>
00121 <span class="preprocessor">#include "nfs_proto_tools.h"</span>
00122 
00123 
<a name="l00144"></a><a class="code" href="nfs__Readdir_8c.html#a3">00144</a> <span class="keywordtype">int</span> <a class="code" href="nfs__Readdir_8c.html#a3">nfs_Readdir</a>( nfs_arg_t               * parg,    
00145                  exportlist_t            * pexport, 
00146                  fsal_op_context_t             * pcontext,   
00147                  cache_inode_client_t    * pclient,
00148                  hash_table_t            * ht,
00149                  <span class="keyword">struct</span> svc_req          * preq,    
00150                  nfs_res_t               * pres )
00151 {
00152         <span class="keyword">static</span> <span class="keywordtype">char</span>     funcName[] = <span class="stringliteral">"nfs_Readdir"</span>;
00153   
00154   cache_entry_t             * dir_pentry            ;
00155   cache_entry_t             * pentry_dot_dot = NULL ;
00156   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               count = 0             ;
00157   fsal_attrib_list_t          dir_attr              ;
00158   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                cookie                ;
00159   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                cache_inode_cookie    ;
00160   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                end_cookie            ;
00161   cache_inode_dir_entry_t   * dirent_array          ;
00162   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              * cookie_array          ;
00163   cookieverf3                 cookie_verifier       ;
00164   <span class="keywordtype">int</span>                         rc                    ;
00165   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                num_entries           ;
00166   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               space_used = 0        ;
00167   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               estimated_num_entries = 0 ;
00168   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>               asked_num_entries     ; 
00169   cache_inode_file_type_t     dir_filetype          ;
00170   cache_inode_endofdir_t      eod_met               ;
00171   cache_inode_status_t        cache_status          ;
00172   cache_inode_status_t        cache_status_gethandle;    
00173   fsal_handle_t             * pfsal_handle          ;
00174   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                delta = 0             ;
00175   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i = 0                 ;
00176   
00177         <span class="keywordflow">if</span>( preq-&gt;rq_vers == NFS_V3 )
00178     {
00179       <span class="comment">/* to avoid setting it on each error case */</span>
00180       pres-&gt;res_readdir3.READDIR3res_u.resfail.dir_attributes.attributes_follow = FALSE;
00181     }
00182 
00183   
00184         <span class="comment">/* Convert file handle into a vnode */</span>
00185   <span class="comment">/* BUGAZOMEU : rajouter acces direct au DIR_CONTINUE */</span>
00186   <span class="keywordflow">if</span>( ( dir_pentry = <a class="code" href="nfs__proto__tools_8c.html#a1">nfs_FhandleToCache</a>( preq-&gt;rq_vers, 
00187                                          &amp;(parg-&gt;arg_readdir2.dir),
00188                                          &amp;(parg-&gt;arg_readdir3.dir),
00189                                          NULL, 
00190                                          &amp;(pres-&gt;res_readdir2.status),
00191                                          &amp;(pres-&gt;res_readdir3.status),
00192                                          NULL, 
00193                                          &amp;dir_attr,
00194                                          pcontext, 
00195                                          pclient, 
00196                                          ht, 
00197                                          &amp;rc ) ) == NULL )
00198     {
00199       <span class="comment">/* Stale NFS FH ? */</span>
00200       <span class="keywordflow">return</span> rc ;
00201     }
00202 
00203         <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00204     {
00205     <span class="keywordflow">case</span> NFS_V2:
00206       count = parg-&gt;arg_readdir2.count;
00207       memcpy( (<span class="keywordtype">char</span> *)&amp;cookie, (<span class="keywordtype">char</span> *)parg-&gt;arg_readdir2.cookie, NFS2_COOKIESIZE ) ;
00208       space_used = <span class="keyword">sizeof</span>(READDIR2resok);
00209       estimated_num_entries = count / <span class="keyword">sizeof</span>(entry2);
00210 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00211 <span class="preprocessor"></span>      printf( <span class="stringliteral">"-- Readdir2 -&gt; count=%d  cookie = %d  estimated_num_entries=%d\n"</span>, count, cookie, estimated_num_entries ) ;
00212 <span class="preprocessor">#endif</span>
00213 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( estimated_num_entries == 0 )
00214         {
00215           pres-&gt;res_readdir2.status = NFSERR_IO ;
00216           <span class="keywordflow">return</span> NFS_REQ_OK ;
00217         }
00218       
00219       <span class="keywordflow">break</span>;
00220 
00221     <span class="keywordflow">case</span> NFS_V3:
00222                 {
00223                         count = parg-&gt;arg_readdir3.count;
00224                         cookie = parg-&gt;arg_readdir3.cookie;
00225                         space_used = <span class="keyword">sizeof</span>(READDIR3resok);
00226                         estimated_num_entries = count / <span class="keyword">sizeof</span>(entry3);
00227 
00228 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00229 <span class="preprocessor"></span>  printf( <span class="stringliteral">"---&gt; nfs3_Readdir: count=%d  cookie=%d  space_used=%d  estimated_num_entries=%d\n"</span>, 
00230           count, cookie, space_used, estimated_num_entries ) ;
00231 <span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>            
00233                   
00234       <span class="keywordflow">if</span>( estimated_num_entries == 0 )
00235         {
00236           pres-&gt;res_readdir3.status = NFS3ERR_TOOSMALL ;
00237           <span class="keywordflow">return</span> NFS_REQ_OK ;
00238         }
00239       
00240       <span class="comment">/* To make or check the cookie verifier */</span>
00241       memset(cookie_verifier, 0, <span class="keyword">sizeof</span>(cookieverf3));
00242       
00243       <span class="comment">/*</span>
00244 <span class="comment">       * If cookie verifier is used, then an</span>
00245 <span class="comment">       * non-trivial value is returned to the</span>
00246 <span class="comment">       * client         This value is the mtime of</span>
00247 <span class="comment">       * the directory. If verifier is unused (as</span>
00248 <span class="comment">       * in many NFS Servers) then only a set of</span>
00249 <span class="comment">       * zeros is returned (trivial value) </span>
00250 <span class="comment">       */</span>
00251       
00252       <span class="keywordflow">if</span>( pexport-&gt;UseCookieVerifier )
00253         memcpy(cookie_verifier, &amp;(dir_attr.mtime), <span class="keyword">sizeof</span>(dir_attr.mtime));
00254       <span class="comment">/*</span>
00255 <span class="comment">       * nothing to do if != 0 because the area is</span>
00256 <span class="comment">       * already full of zero </span>
00257 <span class="comment">       */</span>
00258 
00259       <span class="keywordflow">if</span> ( ( cookie != 0 ) &amp;&amp; ( pexport-&gt;UseCookieVerifier ) )
00260         {
00261           <span class="comment">/*</span>
00262 <span class="comment">           * Not the first call, so we have to</span>
00263 <span class="comment">           * check the cookie verifier </span>
00264 <span class="comment">           */</span>
00265           <span class="keywordflow">if</span> (memcmp(cookie_verifier, parg-&gt;arg_readdir3.cookieverf, NFS3_COOKIEVERFSIZE) != 0)
00266           {
00267                   pres-&gt;res_readdir3.status = NFS3ERR_BAD_COOKIE;
00268                   <span class="keywordflow">return</span> NFS_REQ_OK;
00269           }
00270         }
00271       <span class="keywordflow">else</span>
00272         {
00273           <span class="comment">/*</span>
00274 <span class="comment">           * This cookie verifier will always produce</span>
00275 <span class="comment">           * errors if it is used by the client </span>
00276 <span class="comment">           */</span>
00277           memset(cookie_verifier, 0xFF, <span class="keyword">sizeof</span>(cookieverf3));
00278         }
00279         <span class="comment">/*</span>
00280 <span class="comment">         * At thist point we ignore errors, the next vnode</span>
00281 <span class="comment">         * call will fail and we will return the error </span>
00282 <span class="comment">         */</span>
00283       }
00284 
00285       <span class="keywordflow">break</span>;
00286         }                       <span class="comment">/* switch(preq-&gt;pq_vers ) */</span>
00287 
00288   <span class="comment">/* Extract the filetype */</span>
00289   dir_filetype = cache_inode_fsal_type_convert( dir_attr.type ) ;
00290   
00291         <span class="comment">/* Sanity checks -- must be a directory */</span>
00292 
00293   <span class="keywordflow">if</span>( ( dir_filetype != DIR_BEGINNING ) &amp;&amp; ( dir_filetype != DIR_CONTINUE ) )
00294     {
00295       <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00296       {
00297       <span class="keywordflow">case</span> NFS_V2:
00298                                 <span class="comment">/*</span>
00299 <span class="comment">                                 * In the RFC tell it not good but it does</span>
00300 <span class="comment">                                 * not tell what to do ... </span>
00301 <span class="comment">                                 */</span>
00302                                 pres-&gt;res_readdir2.status = NFSERR_NOTDIR;
00303                                 <span class="keywordflow">break</span>;
00304         
00305       <span class="keywordflow">case</span> NFS_V3:
00306         pres-&gt;res_readdir3.status = NFS3ERR_NOTDIR;
00307         <span class="keywordflow">break</span>;
00308       } <span class="comment">/* switch */</span>
00309     
00310       <span class="keywordflow">return</span> NFS_REQ_OK;
00311     }
00312   
00313 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00314 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00315   BuddySetDebugLabel( <span class="stringliteral">"cache_inode_dir_entry_t in nfs_Readdir"</span> ) ;
00316 <span class="preprocessor">#endif      </span>
00317 <span class="preprocessor"></span>  
00318         dirent_array = (cache_inode_dir_entry_t *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>( cache_inode_dir_entry_t ) );
00319 
00320 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00321 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00322   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> );
00323 <span class="preprocessor">#endif   </span>
00324 <span class="preprocessor"></span>
00325         <span class="keywordflow">if</span> (dirent_array == NULL)
00326         {
00327     <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00328       {
00329       <span class="keywordflow">case</span> NFS_V2:
00330                                 <span class="comment">/*</span>
00331 <span class="comment">                                 * In the RFC tell it not good but it does</span>
00332 <span class="comment">                                 * not tell what to do ... </span>
00333 <span class="comment">                                 */</span>
00334                                 pres-&gt;res_readdir2.status = NFSERR_IO ;
00335                                 <span class="keywordflow">break</span>;
00336         
00337       <span class="keywordflow">case</span> NFS_V3:
00338         pres-&gt;res_readdir3.status = NFS3ERR_IO ;
00339         <span class="keywordflow">break</span>;
00340       } <span class="comment">/* switch */</span>
00341                 <span class="keywordflow">return</span> NFS_REQ_DROP;
00342         }
00343    
00344 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00345 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00346   BuddySetDebugLabel( <span class="stringliteral">"cookie array in nfs_Readdir"</span> ) ;
00347 <span class="preprocessor">#endif</span>
00348 <span class="preprocessor"></span>
00349   <span class="keywordflow">if</span>( ( cookie_array = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ) ) ) == NULL )
00350     {
00351       <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00352         {
00353         <span class="keywordflow">case</span> NFS_V2:
00354           <span class="comment">/*</span>
00355 <span class="comment">           * In the RFC tell it not good but it does</span>
00356 <span class="comment">           * not tell what to do ... </span>
00357 <span class="comment">           */</span>
00358           pres-&gt;res_readdir2.status = NFSERR_IO ;
00359           <span class="keywordflow">break</span>;
00360           
00361         <span class="keywordflow">case</span> NFS_V3:
00362           pres-&gt;res_readdir3.status = NFS3ERR_IO ;
00363           <span class="keywordflow">break</span>;
00364         } <span class="comment">/* switch */</span>    
00365       
00366       Mem_Free( dirent_array ) ;
00367       <span class="keywordflow">return</span> NFS_REQ_DROP ;
00368     }
00369   
00370 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00371 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00372   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00373 <span class="preprocessor">#endif</span>
00374 <span class="preprocessor"></span>    
00375   <span class="comment">/* How many entries will we retry from cache_inode ? */</span>
00376     
00377   <span class="keywordflow">if</span>( cookie &gt; 1 ) <span class="comment">/* it is not the cookie for "." nor ".." */</span>
00378     {
00379       asked_num_entries  = estimated_num_entries ;
00380       cache_inode_cookie = cookie - 2 ;
00381     }
00382   <span class="keywordflow">else</span>
00383     {
00384       
00385       <span class="comment">/* keep space for "." and ".." */</span>
00386         
00387       <span class="comment">/* cookie 0 must return "." as first entry (and keep 2 slots for . and ..)</span>
00388 <span class="comment">       * cookie 1 must return ".." as first entry (and keep 1 slot for ..)</span>
00389 <span class="comment">       */</span>
00390       
00391       asked_num_entries = ( estimated_num_entries &gt; 2 - cookie  ? estimated_num_entries + cookie - 2 : 0);      
00392       cache_inode_cookie = 0 ;
00393     }
00394     
00395 <span class="comment">/* Some definitions that will be very useful to avoid very long names for variables */</span>    
00396 <span class="preprocessor">#define RES_READDIR2_OK   pres-&gt;res_readdir2.READDIR2res_u.readdirok</span>
00397 <span class="preprocessor"></span><span class="preprocessor">#define RES_READDIR3_OK   pres-&gt;res_readdir3.READDIR3res_u.resok</span>
00398 <span class="preprocessor"></span><span class="preprocessor">#define RES_READDIR3_FAIL pres-&gt;res_readdir3.READDIR3res_u.resfail</span>
00399 <span class="preprocessor"></span>    
00400 
00401   <span class="comment">/* Call readdir */</span>
00402   <span class="keywordflow">if</span>( cache_inode_readdir( dir_pentry, 
00403                            cache_inode_cookie, 
00404                            asked_num_entries, 
00405                            &amp;num_entries, 
00406                            &amp;end_cookie,
00407                            &amp;eod_met, 
00408                            dirent_array, 
00409                            cookie_array,
00410                            ht, 
00411                            pclient, 
00412                            pcontext, 
00413                            &amp;cache_status ) == CACHE_INODE_SUCCESS )
00414     {
00415         
00416 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
00417 <span class="preprocessor"></span>      printf( <span class="stringliteral">"-- Readdir -&gt; Call to cache_inode_readdir( cookie=%d, asked=%d ) -&gt; num_entries = %d\n"</span>, 
00418          cache_inode_cookie, asked_num_entries, num_entries ) ; 
00419             
00420       <span class="keywordflow">if</span>( eod_met == END_OF_DIR )
00421         {
00422           printf( <span class="stringliteral">"+++++++++++++++++++++++++++++++++++++++++&gt; EOD MET \n"</span> ) ;
00423         }
00424 <span class="preprocessor">#endif</span>
00425 <span class="preprocessor"></span>        
00426         
00427       <span class="comment">/* If nothing was found, return nothing, but if cookie &lt;= 1, we should return . and .. */</span>
00428       <span class="keywordflow">if</span>( ( num_entries == 0 ) &amp;&amp; ( asked_num_entries != 0 ) &amp;&amp; ( cookie &gt; 1  ) )
00429         {
00430           <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00431             {
00432             <span class="keywordflow">case</span> NFS_V2:
00433               pres-&gt;res_readdir2.status    = NFS_OK;
00434               <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries      = NULL;
00435               <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.eof          = TRUE;
00436               break ;
00437               
00438             <span class="keywordflow">case</span> NFS_V3:
00439               pres-&gt;res_readdir3.status     = NFS3_OK;
00440               <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries = NULL;
00441               <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.eof     = TRUE;
00442               <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00443                                  dir_pentry, 
00444                                  &amp;dir_attr,
00445                                  &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.dir_attributes ) );
00446               memcpy( <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.cookieverf, cookie_verifier, <span class="keyword">sizeof</span>(cookieverf3));
00447                break ;
00448             }
00449         }
00450       <span class="keywordflow">else</span>
00451         {
00452           <span class="keyword">typedef</span> <span class="keywordtype">char</span>              entry_name_array_item_t[FSAL_MAX_NAME_LEN] ;
00453           entry_name_array_item_t * entry_name_array;
00454               
00455 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00456 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00457           BuddySetDebugLabel( <span class="stringliteral">"entry_name_array in nfs_Readdir"</span> );
00458 <span class="preprocessor">#endif   </span>
00459 <span class="preprocessor"></span>      
00460   
00461           entry_name_array = (entry_name_array_item_t *) Mem_Alloc( estimated_num_entries * ( FSAL_MAX_NAME_LEN + 1));
00462           
00463 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00464 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00465           BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> );
00466 <span class="preprocessor">#endif     </span>
00467 <span class="preprocessor"></span>            
00468           <span class="keywordflow">if</span>( entry_name_array == NULL )
00469           {
00470             Mem_Free( dirent_array );
00471             Mem_Free( cookie_array );            
00472             <span class="keywordflow">return</span> NFS_REQ_DROP;
00473           }   
00474               
00475           <span class="keywordflow">switch</span>( preq-&gt;rq_vers )
00476             {
00477             <span class="keywordflow">case</span> NFS_V2:
00478 
00479 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00480 <span class="preprocessor"></span>          <span class="comment">/* For debugging memory leaks */</span>
00481               BuddySetDebugLabel( <span class="stringliteral">"RES_READDIR2_OK.entries"</span> );
00482 <span class="preprocessor">#endif  </span>
00483 <span class="preprocessor"></span>              
00484               <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries = (entry2 *)Mem_Alloc( estimated_num_entries * <span class="keyword">sizeof</span>( entry2 ) ) ;
00485               
00486 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00487 <span class="preprocessor"></span>              <span class="comment">/* For debugging memory leaks */</span>
00488               BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> );
00489 <span class="preprocessor">#endif               </span>
00490 <span class="preprocessor"></span>              <span class="keywordflow">if</span> (<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries == NULL)
00491                 {
00492                   Mem_Free( dirent_array );
00493                   Mem_Free( cookie_array );
00494                   Mem_Free( entry_name_array );
00495                   <span class="keywordflow">return</span> NFS_REQ_DROP;
00496                 }
00497               
00498               delta = 0;
00499                 
00500               <span class="comment">/* fills "."  */</span>
00501               
00502               <span class="keywordflow">if</span>( cookie == 0 )
00503               {
00504                   <span class="keywordflow">if</span> ( estimated_num_entries &gt; 0 )
00505                   {
00506                       <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( dir_pentry, 
00507                                                                         &amp;cache_status_gethandle ) ) == NULL )
00508                         {
00509                           Mem_Free( dirent_array ) ;
00510                           Mem_Free( cookie_array ) ;
00511                           Mem_Free( entry_name_array ); 
00512 
00513                           pres-&gt;res_readdir2.status = <a class="code" href="nfs__proto__tools_8c.html#a28">nfs2_Errno</a>( cache_status_gethandle ) ;
00514                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00515                         }
00516 
00517                       FSAL_DigestHandle( pcontext-&gt;export_context,
00518                                          FSAL_DIGEST_FILEID2, 
00519                                          pfsal_handle,
00520                                          (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].fileid) ) ;
00521 
00522                       <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].name = entry_name_array[0] ;
00523                       strcpy( <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].name, <span class="stringliteral">"."</span> ) ;
00524 
00525                       *((<span class="keywordtype">int</span> *) <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].cookie ) = 1 ;
00526 
00527                       <span class="comment">/* pointer to next entry ( if any )*/</span>
00528                       
00529                       <span class="keywordflow">if</span> ( estimated_num_entries &gt; 1 )
00530                           <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[1]);
00531                       <span class="keywordflow">else</span>
00532                           <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[0].nextentry = NULL;
00533                       
00534                       delta ++;
00535                   }
00536 
00537               }
00538               
00539               <span class="comment">/* fills .. */</span>
00540               
00541               <span class="keywordflow">if</span>( cookie &lt;= 1 )
00542               {
00543                   <span class="comment">/* take care of the place taken by "." entry */</span>
00544                   <span class="keywordflow">if</span> ( estimated_num_entries &gt; delta )
00545                   {
00546                       <span class="comment">/* get parent pentry */</span>
00547                       
00548                       <span class="keywordflow">if</span>( ( pentry_dot_dot = cache_inode_lookupp( dir_pentry, 
00549                                                                   ht, 
00550                                                                   pclient, 
00551                                                                   pcontext, 
00552                                                                   &amp;cache_status_gethandle ) ) == NULL )
00553                         {
00554                           Mem_Free( dirent_array ) ;
00555                           Mem_Free( cookie_array ) ;
00556                           Mem_Free( entry_name_array ); 
00557 
00558                           pres-&gt;res_readdir2.status = <a class="code" href="nfs__proto__tools_8c.html#a28">nfs2_Errno</a>( cache_status_gethandle ) ;
00559                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00560                         }
00561                       
00562                       <span class="comment">/* get parent handle */</span>
00563                         
00564                       <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( pentry_dot_dot, 
00565                                                                         &amp;cache_status_gethandle ) ) == NULL )
00566                         {
00567                           Mem_Free( dirent_array ) ;
00568                           Mem_Free( cookie_array ) ;
00569                           Mem_Free( entry_name_array ); 
00570 
00571                           pres-&gt;res_readdir2.status = <a class="code" href="nfs__proto__tools_8c.html#a28">nfs2_Errno</a>( cache_status_gethandle ) ;
00572                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00573                         }
00574 
00575                       FSAL_DigestHandle( pcontext-&gt;export_context,
00576                                          FSAL_DIGEST_FILEID2, 
00577                                          pfsal_handle,
00578                                          (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].fileid) ) ;
00579 
00580                       <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].name = entry_name_array[delta] ;
00581                       strcpy( <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].name, <span class="stringliteral">".."</span> ) ;
00582 
00583                       *((<span class="keywordtype">int</span> *) <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].cookie ) = 2;
00584                       
00585                       <span class="comment">/* pointer to next entry ( if any )*/</span>
00586                       
00587                       <span class="keywordflow">if</span> (( num_entries &gt; 0 ) &amp;&amp; ( estimated_num_entries &gt; delta + 1 ))
00588                           <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta+1]);
00589                       <span class="keywordflow">else</span>
00590                           <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[delta].nextentry = NULL;
00591                       
00592                       delta ++;
00593                   }
00594               }
00595                             
00596                 
00597               <span class="comment">/* fill dir entries */</span>
00598                 
00599               <span class="keywordflow">for</span>( i = delta; i &lt; num_entries + delta; i++ )
00600                 {
00601                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   needed;
00602                   
00603                   needed = <span class="keyword">sizeof</span>(entry2) + ( ( strlen( dirent_array[i-delta].name.name ) + 3 ) &amp; ~3 );
00604                   
00605                   <span class="keywordflow">if</span> ((space_used += needed) &gt; count)
00606                     {
00607                       <span class="keywordflow">if</span>( i == delta )
00608                         {
00609                           <span class="comment">/*</span>
00610 <span class="comment">                           * Not enough room to make even 1 reply </span>
00611 <span class="comment">                           */</span>
00612                           pres-&gt;res_readdir2.status = NFSERR_IO;
00613                           Mem_Free( dirent_array ) ;
00614                           Mem_Free( cookie_array ) ;
00615                           Mem_Free( entry_name_array ); 
00616                           <span class="keywordflow">return</span> NFS_REQ_OK;
00617                         }
00618                       <span class="keywordflow">break</span>;
00619                     }
00620                   FSAL_DigestHandle( pcontext-&gt;export_context,
00621                                      FSAL_DIGEST_FILEID2, 
00622                                      cache_inode_get_fsal_handle( dirent_array[i-delta].pentry, &amp;cache_status_gethandle ),
00623                                      (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i].fileid) ) ;
00624                   
00625                   FSAL_name2str( &amp;dirent_array[i-delta].name, entry_name_array[i], FSAL_MAX_NAME_LEN ) ;
00626                   <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i].name = entry_name_array[i];
00627                   
00628                   <span class="comment">/* Set cookie :</span>
00629 <span class="comment">                   * If we are not at last returned dirent, the cookie is the index </span>
00630 <span class="comment">                   * of the next p_entry + 2.</span>
00631 <span class="comment">                   * Else, the cookie is the end_cookie + 2.</span>
00632 <span class="comment">                   */</span>
00633                   
00634                   <span class="keywordflow">if</span>( i != num_entries + delta - 1 )
00635                     *((<span class="keywordtype">int</span> *) <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i].cookie ) = cookie_array[i+1-delta] + 2;
00636                   <span class="keywordflow">else</span>
00637                     *((<span class="keywordtype">int</span> *) <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i].cookie ) = end_cookie + 2 ;
00638 
00639                   <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i].nextentry = NULL;
00640                   <span class="keywordflow">if</span> (i != 0)
00641                     <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i - 1].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.entries[i]);
00642                   
00643                 } <span class="comment">/* for */</span>
00644               
00645               <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.eof = FALSE; <span class="comment">/* the actual value will be set in post treatments */</span>
00646               pres-&gt;res_readdir2.status = NFS_OK;
00647               <span class="keywordflow">break</span>;
00648               
00649             <span class="keywordflow">case</span> NFS_V3:
00650            
00651 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00652 <span class="preprocessor"></span>              <span class="comment">/* For debugging memory leaks */</span>
00653               BuddySetDebugLabel( <span class="stringliteral">"RES_READDIR3_OK.reply.entries"</span> );
00654 <span class="preprocessor">#endif                    </span>
00655 <span class="preprocessor"></span>              
00656               <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries = (entry3 *)Mem_Alloc(estimated_num_entries * <span class="keyword">sizeof</span>( entry3 ) );
00657 
00658 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00659 <span class="preprocessor"></span>              <span class="comment">/* For debugging memory leaks */</span>
00660               BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> );
00661 <span class="preprocessor">#endif        </span>
00662 <span class="preprocessor"></span>              <span class="keywordflow">if</span> (<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries == NULL)
00663                 {
00664                   Mem_Free( dirent_array );
00665                   Mem_Free( cookie_array);
00666                   Mem_Free( entry_name_array );                   
00667                   <span class="keywordflow">return</span> NFS_REQ_DROP;
00668                 }
00669                 
00670                 
00671               delta = 0;
00672               
00673               <span class="comment">/* fill "." */</span>
00674               
00675               <span class="keywordflow">if</span>( cookie == 0 )
00676               {
00677                   <span class="keywordflow">if</span> ( estimated_num_entries &gt; 0 )
00678                   {
00679                       <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( dir_pentry, 
00680                                                                         &amp;cache_status_gethandle ) ) == NULL )
00681                         {
00682                           Mem_Free( dirent_array ) ;
00683                           Mem_Free( cookie_array ) ;
00684                           Mem_Free( entry_name_array ); 
00685 
00686                           pres-&gt;res_readdir3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00687                           
00688                           <span class="comment">/* could not retrieve dir pentry, so we cannot return its attributes */</span>
00689                           <a class="code" href="nfs__Readdir_8c.html#a2">RES_READDIR3_FAIL</a>.dir_attributes.attributes_follow = 0;
00690                           
00691                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00692                         }
00693 
00694                       FSAL_DigestHandle( pcontext-&gt;export_context,
00695                                          FSAL_DIGEST_FILEID3, 
00696                                          pfsal_handle,
00697                                          (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].fileid) ) ;
00698 
00699                       <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].name = entry_name_array[0] ;
00700                       strcpy( <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].name, <span class="stringliteral">"."</span> ) ;
00701 
00702                       <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].cookie = 1 ;
00703 
00704                       <span class="comment">/* pointer to next entry ( if any )*/</span>
00705                       
00706                       <span class="keywordflow">if</span> ( estimated_num_entries &gt; 1 )
00707                           <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[1]);
00708                       <span class="keywordflow">else</span>
00709                           <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[0].nextentry = NULL;
00710                       
00711                       delta ++;
00712                   }
00713 
00714               }
00715               
00716               
00717               <span class="comment">/* fills .. */</span>
00718               
00719               <span class="keywordflow">if</span>( cookie &lt;= 1 )
00720               {
00721                   <span class="comment">/* take care of the place taken by "." entry */</span>
00722                   <span class="keywordflow">if</span> ( estimated_num_entries &gt; delta )
00723                   {
00724                       <span class="comment">/* get parent pentry */</span>
00725                       
00726                       <span class="keywordflow">if</span>( ( pentry_dot_dot = cache_inode_lookupp( dir_pentry, 
00727                                                                   ht, 
00728                                                                   pclient, 
00729                                                                   pcontext, 
00730                                                                   &amp;cache_status_gethandle ) ) == NULL )
00731                         {
00732                           Mem_Free( dirent_array ) ;
00733                           Mem_Free( cookie_array ) ;
00734                           Mem_Free( entry_name_array ); 
00735                           
00736                           pres-&gt;res_readdir3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;                          
00737                           
00738                           <span class="comment">/* unexpected error, we don't return attributes */</span>
00739                           <a class="code" href="nfs__Readdir_8c.html#a2">RES_READDIR3_FAIL</a>.dir_attributes.attributes_follow = 0;                          
00740                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00741                         }
00742                       
00743                       <span class="comment">/* get parent handle */</span>
00744                         
00745                       <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( pentry_dot_dot, 
00746                                                                         &amp;cache_status_gethandle ) ) == NULL )
00747                         {
00748                           Mem_Free( dirent_array ) ;
00749                           Mem_Free( cookie_array ) ;
00750                           Mem_Free( entry_name_array ); 
00751 
00752                           pres-&gt;res_readdir3.status = <a class="code" href="nfs__proto__tools_8c.html#a27">nfs3_Errno</a>( cache_status_gethandle ) ;
00753                           
00754                           <span class="comment">/* unexpected error, we don't return attributes */</span>
00755                           <a class="code" href="nfs__Readdir_8c.html#a2">RES_READDIR3_FAIL</a>.dir_attributes.attributes_follow = 0;
00756                           <span class="keywordflow">return</span> NFS_REQ_OK ;
00757                         }
00758 
00759                       FSAL_DigestHandle( pcontext-&gt;export_context,
00760                                          FSAL_DIGEST_FILEID3, 
00761                                          pfsal_handle,
00762                                          (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].fileid) ) ;
00763 
00764                       <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].name = entry_name_array[delta] ;
00765                       strcpy( <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].name, <span class="stringliteral">".."</span> ) ;
00766                      
00767                       <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].cookie = 2 ;
00768                       
00769                       <span class="comment">/* pointer to next entry ( if any )*/</span>
00770                       
00771                       <span class="keywordflow">if</span> (( num_entries &gt; 0 ) &amp;&amp; ( estimated_num_entries &gt; delta + 1 ))
00772                           <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta+1]);
00773                       <span class="keywordflow">else</span>
00774                           <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[delta].nextentry = NULL;
00775                       
00776                       delta ++;
00777                   }
00778               }
00779               
00780               <span class="keywordflow">for</span>( i = delta; i &lt; num_entries + delta; i++ )
00781                 {
00782                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   needed;
00783                   
00784                   needed = <span class="keyword">sizeof</span>(entry3) + ( ( strlen( dirent_array[i-delta].name.name) + 3 ) &amp; ~3 );
00785                   <span class="keywordflow">if</span> ((space_used += needed) &gt; count)
00786                     {
00787                       <span class="keywordflow">if</span> (i == delta)
00788                         {
00789                           <span class="comment">/*</span>
00790 <span class="comment">                           * Not enough</span>
00791 <span class="comment">                           * room to</span>
00792 <span class="comment">                           * make even</span>
00793 <span class="comment">                           * 1 reply </span>
00794 <span class="comment">                           */</span>
00795                           pres-&gt;res_readdir3.status = NFS3ERR_TOOSMALL;
00796                           Mem_Free( dirent_array );
00797                           Mem_Free( cookie_array );
00798                           Mem_Free( entry_name_array ); 
00799                           <span class="keywordflow">return</span> NFS_REQ_OK;
00800                         }
00801                       <span class="keywordflow">break</span>;
00802                     }
00803                   FSAL_DigestHandle( pcontext-&gt;export_context,
00804                                      FSAL_DIGEST_FILEID3, 
00805                                      cache_inode_get_fsal_handle( dirent_array[i-delta].pentry, &amp;cache_status_gethandle ),
00806                                      (caddr_t)&amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i].fileid) );
00807 
00808                   FSAL_name2str(  &amp;dirent_array[i-delta].name, entry_name_array[i], FSAL_MAX_NAME_LEN ) ;
00809                   <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i].name = entry_name_array[i];
00810                   
00811                   <span class="comment">/* Set cookie :</span>
00812 <span class="comment">                   * If we are not at last returned dirent, the cookie is the index </span>
00813 <span class="comment">                   * of the next p_entry + 2.</span>
00814 <span class="comment">                   * Else, the cookie is the end_cookie + 2.</span>
00815 <span class="comment">                   */</span>
00816                   
00817                   <span class="keywordflow">if</span>( i != num_entries + delta - 1 )
00818                     <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i].cookie = cookie_array[i+1-delta] + 2;
00819                   <span class="keywordflow">else</span>
00820                     <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i].cookie = end_cookie + 2 ;
00821 
00822                   <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i].nextentry = NULL;
00823                   
00824                   <span class="keywordflow">if</span> (i != 0)
00825                     <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i - 1].nextentry = &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.entries[i]);
00826                   
00827                 }
00828               
00829               <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.eof = FALSE; <span class="comment">/* the actual value will be set in post treatments */</span>              
00830               
00831               <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00832                                  dir_pentry, 
00833                                  &amp;dir_attr,
00834                                  &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.dir_attributes ) ) ;
00835               
00836               memcpy( <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.cookieverf, cookie_verifier, <span class="keyword">sizeof</span>( cookieverf3 ) );
00837               pres-&gt;res_readdir3.status = NFS3_OK;
00838               <span class="keywordflow">break</span>;
00839               
00840             } <span class="comment">/* switch rq_vers */</span>
00841           
00842           
00843           Mem_Free( dirent_array );
00844           Mem_Free( cookie_array );
00845           
00846           <span class="keywordflow">if</span>( ( eod_met == END_OF_DIR ) &amp;&amp; ( i ==  num_entries + delta ) )
00847             {
00848               
00849               <span class="comment">/* End of directory */</span>
00850               <span class="keywordflow">switch</span> (preq-&gt;rq_vers)
00851                 {
00852                 <span class="keywordflow">case</span> NFS_V2:
00853                   pres-&gt;res_readdir2.status   = NFS_OK;
00854                   <a class="code" href="nfs__Readdir_8c.html#a0">RES_READDIR2_OK</a>.eof         = TRUE;
00855                   <span class="keywordflow">break</span>;
00856                   
00857                 <span class="keywordflow">case</span> NFS_V3:
00858                   pres-&gt;res_readdir3.status     = NFS3_OK;
00859                   <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.reply.eof     = TRUE;
00860                   <a class="code" href="nfs__proto__tools_8c.html#a2">nfs_SetPostOpAttr</a>( pcontext, pexport,
00861                                      dir_pentry, 
00862                                      &amp;dir_attr,
00863                                      &amp;(<a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.dir_attributes ) );
00864                   memcpy( <a class="code" href="nfs__Readdir_8c.html#a1">RES_READDIR3_OK</a>.cookieverf, cookie_verifier, <span class="keyword">sizeof</span>(cookieverf3));
00865                   <span class="keywordflow">break</span>;
00866                 }
00867               }
00868           <span class="keywordflow">return</span> NFS_REQ_OK;
00869           
00870         } <span class="comment">/* if num_entries &gt; 0 */</span>
00871         
00872     } <span class="comment">/* if cachine_inode_readdir */</span>
00873   
00874   Mem_Free( dirent_array );
00875   Mem_Free( cookie_array );
00876   
00877   <span class="comment">/* If we are here, there was an error */</span>
00878   <span class="keywordflow">if</span>( <a class="code" href="nfs__proto__tools_8c.html#a5">nfs_RetryableError</a>( cache_status ) )
00879     {
00880       <span class="keywordflow">return</span> NFS_REQ_DROP;
00881     }
00882   
00883     <a class="code" href="nfs__proto__tools_8c.html#a6">nfs_SetFailedStatus</a>( pcontext, pexport,
00884                          preq-&gt;rq_vers, 
00885                          cache_status,
00886                          &amp;pres-&gt;res_readdir2.status,
00887                          &amp;pres-&gt;res_readdir3.status,
00888                          dir_pentry,
00889                          &amp;(pres-&gt;res_readdir3.READDIR3res_u.resfail.dir_attributes),
00890                          NULL, NULL, NULL,
00891                          NULL, NULL, NULL);
00892   
00893         <span class="keywordflow">return</span> NFS_REQ_OK;
00894   
00895 } <span class="comment">/* nfs_Readdir */</span>
00896 
<a name="l00905"></a><a class="code" href="nfs__Readdir_8c.html#a4">00905</a> <span class="keywordtype">void</span> <a class="code" href="nfs__Readdir_8c.html#a4">nfs2_Readdir_Free</a>( nfs_res_t * resp )
00906 {
00907   <span class="keywordflow">if</span> ((resp-&gt;res_readdir2.status == NFS_OK) &amp;&amp;
00908       (resp-&gt;res_readdir2.READDIR2res_u.readdirok.entries != NULL))
00909     {
00910       Mem_Free(resp-&gt;res_readdir2.READDIR2res_u.readdirok.entries[0].name);
00911       Mem_Free(resp-&gt;res_readdir2.READDIR2res_u.readdirok.entries);
00912     }
00913 } <span class="comment">/* nfs2_Readdir_Free */</span>
00914 
<a name="l00923"></a><a class="code" href="nfs__Readdir_8c.html#a5">00923</a> <span class="keywordtype">void</span> <a class="code" href="nfs__Readdir_8c.html#a5">nfs3_Readdir_Free</a>( nfs_res_t * resp)
00924 {
00925   <span class="keywordflow">if</span> ((resp-&gt;res_readdir3.status == NFS3_OK) &amp;&amp;
00926       (resp-&gt;res_readdir3.READDIR3res_u.resok.reply.entries != NULL))
00927     {
00928       Mem_Free(resp-&gt;res_readdir3.READDIR3res_u.resok.reply.entries[0].name);
00929       Mem_Free(resp-&gt;res_readdir3.READDIR3res_u.resok.reply.entries);
00930     }
00931 } <span class="comment">/* nfs3_Readdir_Free */</span>
00932 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:29 2008 for NFS and Mount protocols layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
