.TH "fsal_internal.c" 3 "15 Sep 2010" "Version 0.1" "File System Abstraction Layer (POSIX) library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
fsal_internal.c \- 
.PP
Defines the datas that are to be accessed as extern by the fsal modules.  

.SH SYNOPSIS
.br
.PP
\fC#include 'fsal.h'\fP
.br
\fC#include 'fsal_internal.h'\fP
.br
\fC#include 'posixdb_consistency.h'\fP
.br
\fC#include 'stuff_alloc.h'\fP
.br
\fC#include 'SemN.h'\fP
.br
\fC#include 'fsal_convert.h'\fP
.br
\fC#include <libgen.h>\fP
.br
\fC#include <pthread.h>\fP
.br
\fC#include <string.h>\fP
.br
\fC#include <mntent.h>\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBFSAL_INTERNAL_C\fP"
.br
.ti -1c
.RI "#define \fBSET_INTEGER_PARAM\fP(cfg, p_init_info, _field)"
.br
.ti -1c
.RI "#define \fBSET_BITMAP_PARAM\fP(cfg, p_init_info, _field)"
.br
.ti -1c
.RI "#define \fBSET_BOOLEAN_PARAM\fP(cfg, p_init_info, _field)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBfsal_increment_nbcall\fP (int function_index, fsal_status_t status)"
.br
.ti -1c
.RI "void \fBfsal_internal_getstats\fP (fsal_statistics_t *output_stats)"
.br
.ti -1c
.RI "void \fBfsal_internal_SetCredentialLifetime\fP (fsal_uint_t lifetime_in)"
.br
.ti -1c
.RI "void \fBTakeTokenFSCall\fP ()"
.br
.ti -1c
.RI "void \fBReleaseTokenFSCall\fP ()"
.br
.ti -1c
.RI "fsal_status_t \fBfsal_internal_init_global\fP (fsal_init_info_t *fsal_info, fs_common_initinfo_t *fs_common_info, posixfs_specific_initinfo_t *fs_specific_info)"
.br
.ti -1c
.RI "fsal_status_t \fBfsal_internal_posix2posixdb_fileinfo\fP (struct stat *buffstat, fsal_posixdb_fileinfo_t *info)"
.br
.RI "\fIconvert 'struct stat' to 'fsal_posixdb_fileinfo_t' \fP"
.ti -1c
.RI "fsal_status_t \fBfsal_internal_posixdb_add_entry\fP (fsal_posixdb_conn *p_conn, fsal_name_t *p_filename, fsal_posixdb_fileinfo_t *p_info, posixfsal_handle_t *p_dir_handle, posixfsal_handle_t *p_new_handle)"
.br
.ti -1c
.RI "fsal_status_t \fBfsal_internal_appendFSALNameToFSALPath\fP (fsal_path_t *p_path, fsal_name_t *p_name)"
.br
.RI "\fIp_path <- p_path + '/' + p_name \fP"
.ti -1c
.RI "fsal_status_t \fBfsal_internal_getPathFromHandle\fP (posixfsal_op_context_t *p_context, posixfsal_handle_t *p_handle, int is_dir, fsal_path_t *p_fsalpath, struct stat *p_buffstat)"
.br
.ti -1c
.RI "fsal_status_t \fBfsal_internal_getInfoFromName\fP (posixfsal_op_context_t *p_context, posixfsal_handle_t *p_parent_dir_handle, fsal_name_t *p_fsalname, fsal_posixdb_fileinfo_t *p_infofs, posixfsal_handle_t *p_object_handle)"
.br
.RI "\fIGet the handle of a file, knowing its name and its parent dir. \fP"
.ti -1c
.RI "fsal_status_t \fBfsal_internal_getInfoFromChildrenList\fP (posixfsal_op_context_t *p_context, posixfsal_handle_t *p_parent_dir_handle, fsal_name_t *p_fsalname, fsal_posixdb_fileinfo_t *p_infofs, fsal_posixdb_child *p_children, unsigned int children_count, posixfsal_handle_t *p_object_handle)"
.br
.RI "\fIGet the handle of a file from a fsal_posixdb_child array, knowing its name. \fP"
.ti -1c
.RI "fsal_status_t \fBfsal_internal_testAccess\fP (posixfsal_op_context_t *p_context, fsal_accessflags_t access_type, struct stat *p_buffstat, fsal_attrib_list_t *p_object_attributes)"
.br
.ti -1c
.RI "int \fBfsal_internal_path2fsname\fP (char *rpath, char *fs_spec)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "fsal_uint_t \fBCredentialLifetime\fP = 3600"
.br
.ti -1c
.RI "fsal_staticfsinfo_t \fBglobal_fs_info\fP"
.br
.ti -1c
.RI "fsal_posixdb_conn_params_t \fBglobal_posixdb_params\fP"
.br
.ti -1c
.RI "semaphore_t \fBsem_fs_calls\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Defines the datas that are to be accessed as extern by the fsal modules. 

\fBAuthor:\fP
.RS 4
.RE
.PP
\fBAuthor\fP.RS 4
leibovic 
.RE
.PP
\fBDate:\fP
.RS 4
.RE
.PP
\fBDate\fP.RS 4
2006/01/17 14:20:07 
.RE
.PP
\fBVersion:\fP
.RS 4
.RE
.PP
\fBRevision\fP.RS 4
1.24 
.RE
.PP

.PP
Definition in file \fBfsal_internal.c\fP.
.SH "Define Documentation"
.PP 
.SS "#define SET_BITMAP_PARAM(cfg, p_init_info, _field)"\fBValue:\fP
.PP
.nf
switch( (p_init_info)->behaviors._field ){                    \
    case FSAL_INIT_FORCE_VALUE :                                  \
        /* force the value in any case */                         \
        cfg._field = (p_init_info)->values._field;                \
        break;                                                    \
    case FSAL_INIT_MAX_LIMIT :                                    \
      /* proceed a bit AND */                                     \
      cfg._field &= (p_init_info)->values._field ;                \
      break;                                                      \
    case FSAL_INIT_MIN_LIMIT :                                    \
      /* proceed a bit OR */                                      \
      cfg._field |= (p_init_info)->values._field ;                \
      break;                                                      \
    /* In the other cases, we keep the default value. */          \
    }
.fi
.PP
Definition at line 283 of file fsal_internal.c.
.SS "#define SET_BOOLEAN_PARAM(cfg, p_init_info, _field)"\fBValue:\fP
.PP
.nf
switch( (p_init_info)->behaviors._field ){                    \
    case FSAL_INIT_FORCE_VALUE :                                  \
        /* force the value in any case */                         \
        cfg._field = (p_init_info)->values._field;                \
        break;                                                    \
    case FSAL_INIT_MAX_LIMIT :                                    \
      /* proceed a boolean AND */                                 \
      cfg._field = cfg._field && (p_init_info)->values._field ;   \
      break;                                                      \
    case FSAL_INIT_MIN_LIMIT :                                    \
      /* proceed a boolean OR */                                  \
      cfg._field = cfg._field && (p_init_info)->values._field ;   \
      break;                                                      \
    /* In the other cases, we keep the default value. */          \
    }
.fi
.PP
Definition at line 300 of file fsal_internal.c.
.SS "#define SET_INTEGER_PARAM(cfg, p_init_info, _field)"\fBValue:\fP
.PP
.nf
switch( (p_init_info)->behaviors._field ){                    \
    case FSAL_INIT_FORCE_VALUE :                                  \
      /* force the value in any case */                           \
      cfg._field = (p_init_info)->values._field;                  \
      break;                                                      \
    case FSAL_INIT_MAX_LIMIT :                                    \
      /* check the higher limit */                                \
      if ( cfg._field > (p_init_info)->values._field )            \
        cfg._field = (p_init_info)->values._field ;               \
      break;                                                      \
    case FSAL_INIT_MIN_LIMIT :                                    \
      /* check the lower limit */                                 \
      if ( cfg._field < (p_init_info)->values._field )            \
        cfg._field = (p_init_info)->values._field ;               \
      break;                                                      \
    /* In the other cases, we keep the default value. */          \
    }
.fi
.PP
Definition at line 264 of file fsal_internal.c.
.SH "Function Documentation"
.PP 
.SS "void fsal_increment_nbcall (int function_index, fsal_status_t status)"fsal_increment_nbcall: Updates fonction call statistics.
.PP
\fBParameters:\fP
.RS 4
\fIfunction_index\fP (input): Index of the function whom number of call is to be incremented. 
.br
\fIstatus\fP (input): Status the function returned.
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP

.PP
Definition at line 98 of file fsal_internal.c.
.PP
References fsal_is_retryable().
.SS "fsal_status_t fsal_internal_appendFSALNameToFSALPath (fsal_path_t * p_path, fsal_name_t * p_name)"
.PP
p_path <- p_path + '/' + p_name \fBParameters:\fP
.RS 4
\fIp_path\fP 
.br
\fIp_name\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 555 of file fsal_internal.c.
.PP
Referenced by POSIXFSAL_create(), POSIXFSAL_link(), POSIXFSAL_lookup(), POSIXFSAL_mkdir(), POSIXFSAL_mknode(), POSIXFSAL_readdir(), POSIXFSAL_rename(), POSIXFSAL_symlink(), and POSIXFSAL_unlink().
.SS "fsal_status_t fsal_internal_getInfoFromChildrenList (posixfsal_op_context_t * p_context, posixfsal_handle_t * p_parent_dir_handle, fsal_name_t * p_fsalname, fsal_posixdb_fileinfo_t * p_infofs, fsal_posixdb_child * p_children, unsigned int children_count, posixfsal_handle_t * p_object_handle)"
.PP
Get the handle of a file from a fsal_posixdb_child array, knowing its name. \fBParameters:\fP
.RS 4
\fIp_context\fP 
.br
\fIp_parent_dir_handle\fP Handle of the parent directory 
.br
\fIp_fsalname\fP Name of the object 
.br
\fIp_infofs\fP Information about the file (taken from the filesystem) to be compared to information stored in database 
.br
\fIp_children\fP fsal_posixdb_child array (that contains the entries of the directory stored in the db) 
.br
\fIp_object_handle\fP Handle of the file.
.RE
.PP
\fBReturns:\fP
.RS 4
ERR_FSAL_NOERR, if no error Anothere error code else. 
.RE
.PP

.PP
Definition at line 776 of file fsal_internal.c.
.PP
References posixdb2fsal_error().
.PP
Referenced by POSIXFSAL_readdir().
.SS "fsal_status_t fsal_internal_getInfoFromName (posixfsal_op_context_t * p_context, posixfsal_handle_t * p_parent_dir_handle, fsal_name_t * p_fsalname, fsal_posixdb_fileinfo_t * p_infofs, posixfsal_handle_t * p_object_handle)"
.PP
Get the handle of a file, knowing its name and its parent dir. \fBParameters:\fP
.RS 4
\fIp_context\fP 
.br
\fIp_parent_dir_handle\fP Handle of the parent directory 
.br
\fIp_fsalname\fP Name of the object 
.br
\fIp_infofs\fP Information about the file (taken from the filesystem) to be compared to information stored in database 
.br
\fIp_object_handle\fP Handle of the file.
.RE
.PP
\fBReturns:\fP
.RS 4
ERR_FSAL_NOERR, if no error Anothere error code else. 
.RE
.PP

.PP
Definition at line 709 of file fsal_internal.c.
.PP
References posixdb2fsal_error().
.PP
Referenced by POSIXFSAL_lookup(), and POSIXFSAL_readdir().
.SS "fsal_status_t fsal_internal_getPathFromHandle (posixfsal_op_context_t * p_context, posixfsal_handle_t * p_handle, int is_dir, fsal_path_t * p_fsalpath, struct stat * p_buffstat)"Get a valid path associated to an handle. The function selects many paths from the DB and return the first valid one. If is_dir is set, then only 1 path will be constructed from the database. 
.PP
Definition at line 589 of file fsal_internal.c.
.PP
References fsal_internal_posix2posixdb_fileinfo(), posixdb2fsal_error(), POSIXFSAL_lookupPath(), and TakeTokenFSCall().
.PP
Referenced by POSIXFSAL_create(), POSIXFSAL_dynamic_fsinfo(), POSIXFSAL_getattrs(), POSIXFSAL_link(), POSIXFSAL_lookup(), POSIXFSAL_mkdir(), POSIXFSAL_mknode(), POSIXFSAL_open(), POSIXFSAL_opendir(), POSIXFSAL_readlink(), POSIXFSAL_rename(), POSIXFSAL_setattrs(), POSIXFSAL_symlink(), POSIXFSAL_truncate(), and POSIXFSAL_unlink().
.SS "void fsal_internal_getstats (fsal_statistics_t * output_stats)"fsal_internal_getstats: (For internal use in the FSAL). Retrieve call statistics for current thread.
.PP
\fBParameters:\fP
.RS 4
\fIoutput_stats\fP (output): Pointer to the call statistics structure.
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP

.PP
Definition at line 176 of file fsal_internal.c.
.PP
Referenced by POSIXFSAL_get_stats().
.SS "fsal_status_t fsal_internal_posix2posixdb_fileinfo (struct stat * buffstat, fsal_posixdb_fileinfo_t * info)"
.PP
convert 'struct stat' to 'fsal_posixdb_fileinfo_t' \fBParameters:\fP
.RS 4
\fIbuffstat\fP 
.br
\fIinfo\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 499 of file fsal_internal.c.
.PP
Referenced by fsal_internal_getPathFromHandle(), POSIXFSAL_create(), POSIXFSAL_link(), POSIXFSAL_lookup(), POSIXFSAL_mkdir(), POSIXFSAL_mknode(), POSIXFSAL_readdir(), POSIXFSAL_rename(), POSIXFSAL_symlink(), and POSIXFSAL_unlink().
.SS "void fsal_internal_SetCredentialLifetime (fsal_uint_t lifetime_in)"Set credential lifetime. (For internal use in the FSAL). Set the period for thread's credential renewal.
.PP
\fBParameters:\fP
.RS 4
\fIlifetime_in\fP (input): The period for thread's credential renewal.
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP

.PP
Definition at line 234 of file fsal_internal.c.
.SS "void TakeTokenFSCall ()"Used to limit the number of simultaneous calls to Filesystem. 
.PP
Definition at line 242 of file fsal_internal.c.
.PP
Referenced by fsal_internal_getPathFromHandle(), POSIXFSAL_close(), POSIXFSAL_create(), POSIXFSAL_dynamic_fsinfo(), POSIXFSAL_link(), POSIXFSAL_lookup(), POSIXFSAL_mkdir(), POSIXFSAL_mknode(), POSIXFSAL_open(), POSIXFSAL_opendir(), POSIXFSAL_read(), POSIXFSAL_readdir(), POSIXFSAL_readlink(), POSIXFSAL_rename(), POSIXFSAL_setattrs(), POSIXFSAL_symlink(), POSIXFSAL_truncate(), POSIXFSAL_unlink(), and POSIXFSAL_write().
.SH "Author"
.PP 
Generated automatically by Doxygen for File System Abstraction Layer (POSIX) library from the source code.
