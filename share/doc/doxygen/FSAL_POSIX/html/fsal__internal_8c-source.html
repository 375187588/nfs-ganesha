<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>File System Abstraction Layer (POSIX) library: fsal_internal.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>fsal_internal.c</h1><a href="fsal__internal_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> */</span>
00004 
00015 <span class="preprocessor">#define FSAL_INTERNAL_C</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#include  "fsal.h"</span>
00021 <span class="preprocessor">#include "fsal_internal.h"</span>
00022 <span class="preprocessor">#include "posixdb_consistency.h"</span>
00023 <span class="preprocessor">#include "stuff_alloc.h"</span>
00024 <span class="preprocessor">#include "SemN.h"</span>
00025 <span class="preprocessor">#include "fsal_convert.h"</span>
00026 <span class="preprocessor">#include &lt;libgen.h&gt;</span> <span class="comment">/* used for 'dirname' */</span>
00027  
00028 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00029 <span class="preprocessor">#include &lt;string.h&gt;</span>
00030 
00031 <span class="comment">/* credential lifetime (1h) */</span>
00032 fsal_uint_t  CredentialLifetime = 3600 ;
00033 
00034 <span class="comment">/* static filesystem info.</span>
00035 <span class="comment"> * The access is thread-safe because</span>
00036 <span class="comment"> * it is read-only, except during initialization.</span>
00037 <span class="comment"> */</span>
00038 fsal_staticfsinfo_t           global_fs_info;
00039 fsal_posixdb_conn_params_t    global_posixdb_params;
00040 
00041 <span class="comment">/* filesystem info for HPSS */</span>
00042 <span class="keyword">static</span> fsal_staticfsinfo_t default_posix_info =
00043   {
00044     0xFFFFFFFFFFFFFFFFLL, <span class="comment">/* max file size (64bits) */</span>
00045     _POSIX_LINK_MAX, <span class="comment">/* max links */</span>
00046     FSAL_MAX_NAME_LEN, <span class="comment">/* max filename */</span>
00047     FSAL_MAX_PATH_LEN, <span class="comment">/* min filename */</span>
00048     TRUE,  <span class="comment">/* no_trunc */</span>
00049     TRUE,  <span class="comment">/* chown restricted */</span>
00050     FALSE, <span class="comment">/* case insensitivity */</span>
00051     TRUE,  <span class="comment">/* case preserving */</span>
00052     FSAL_EXPTYPE_PERSISTENT, <span class="comment">/* FH expire type */</span>
00053     TRUE, <span class="comment">/* hard link support */</span>
00054     TRUE, <span class="comment">/* sym link support */</span>
00055     FALSE, <span class="comment">/* lock management */</span>    
00056     FALSE, <span class="comment">/* cannot set named attributes */</span>
00057     TRUE,  <span class="comment">/* handles are unique and persistent */</span>
00058     {10,0}, <span class="comment">/* Duration of lease at FS in seconds */</span>
00059     FSAL_ACLSUPPORT_ALLOW,     <span class="comment">/* ACL support */</span>
00060     TRUE,  <span class="comment">/* can change times */</span>
00061     TRUE,  <span class="comment">/* homogenous */</span>
00062     POSIX_SUPPORTED_ATTRIBUTES, <span class="comment">/* supported attributes */</span>
00063     0,     <span class="comment">/* maxread size */</span>
00064     0,     <span class="comment">/* maxwrite size */</span>
00065     0,      <span class="comment">/* default umask */</span>
00066     0      <span class="comment">/* cross junctions */</span>
00067   };
00068 
00069 
00070 <span class="comment">/*</span>
00071 <span class="comment"> *  Log Descriptor</span>
00072 <span class="comment"> */</span>
00073 log_t   fsal_log;
00074 
00075 
00076 <span class="comment">/* variables for limiting the calls to the filesystem */</span>
00077 <span class="keyword">static</span> <span class="keywordtype">int</span> limit_calls = FALSE;
00078 semaphore_t sem_fs_calls;
00079 
00080 
00081 <span class="comment">/* threads keys for stats */</span>
00082 <span class="keyword">static</span> pthread_key_t key_stats ;
00083 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00084 
00085 <span class="comment">/* init keys */</span>
00086 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00087 {
00088   <span class="keywordflow">if</span>( pthread_key_create( &amp;key_stats, NULL ) == -1 )
00089       DisplayErrorJd( fsal_log, ERR_SYS , ERR_PTHREAD_KEY_CREATE, errno );
00090   
00091   return ;
00092 } <span class="comment">/* init_keys */</span>
00093 
00094 
<a name="l00106"></a><a class="code" href="fsal__internal_8c.html#a14">00106</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a14">fsal_increment_nbcall</a>( <span class="keywordtype">int</span> function_index , fsal_status_t  status )
00107 {
00108   
00109   fsal_statistics_t * bythread_stat = NULL ;
00110 
00111   <span class="comment">/* verify index */</span>
00112   
00113   <span class="keywordflow">if</span> (function_index &gt;= FSAL_NB_FUNC) <span class="keywordflow">return</span>;
00114   
00115   <span class="comment">/* first, we init the keys if this is the first time */</span>
00116   
00117   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 )
00118   {
00119     DisplayErrorJd( fsal_log, ERR_SYS, ERR_PTHREAD_ONCE, errno );
00120     <span class="keywordflow">return</span>;
00121   }
00122   
00123   <span class="comment">/* we get the specific value */</span>
00124   
00125   bythread_stat = (fsal_statistics_t *) pthread_getspecific( key_stats ) ;
00126   
00127   <span class="comment">/* we allocate stats if this is the first time */</span>
00128   
00129   <span class="keywordflow">if</span>( bythread_stat == NULL )
00130   {
00131       <span class="keywordtype">int</span> i;
00132       
00133       bythread_stat =
00134             (fsal_statistics_t *)Mem_Alloc( <span class="keyword">sizeof</span>(fsal_statistics_t )) ;
00135       
00136       <span class="keywordflow">if</span>( bythread_stat == NULL )
00137       {
00138         DisplayErrorJd( fsal_log, ERR_SYS, ERR_MALLOC, Mem_Errno );
00139       }
00140       
00141       <span class="comment">/* inits the struct */</span>
00142       
00143       <span class="keywordflow">for</span> (i=0;i&lt;FSAL_NB_FUNC;i++)
00144       {
00145          bythread_stat-&gt;func_stats.nb_call[i]=0;
00146          bythread_stat-&gt;func_stats.nb_success[i]=0;
00147          bythread_stat-&gt;func_stats.nb_err_retryable[i]=0;
00148          bythread_stat-&gt;func_stats.nb_err_unrecover[i]=0;
00149       }
00150       
00151       <span class="comment">/* set the specific value */</span>
00152       pthread_setspecific( key_stats , (<span class="keywordtype">void</span> *)bythread_stat ) ;
00153 
00154   }
00155     
00156   <span class="comment">/* we increment the values */</span>
00157   
00158   <span class="keywordflow">if</span> ( bythread_stat )
00159   {
00160     bythread_stat-&gt;func_stats.nb_call[function_index]++;
00161     
00162     <span class="keywordflow">if</span> (  ! FSAL_IS_ERROR(status) )
00163       bythread_stat-&gt;func_stats.nb_success[function_index]++;
00164     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="fsal__errors_8c.html#a0">fsal_is_retryable</a>(status) )
00165       bythread_stat-&gt;func_stats.nb_err_retryable[function_index]++;
00166     <span class="keywordflow">else</span> 
00167       bythread_stat-&gt;func_stats.nb_err_unrecover[function_index]++;    
00168   }
00169   
00170   <span class="keywordflow">return</span>;
00171 }
00172 
00173 
00174 
<a name="l00185"></a><a class="code" href="fsal__internal_8c.html#a15">00185</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a15">fsal_internal_getstats</a>(fsal_statistics_t * output_stats)
00186 {
00187 
00188   fsal_statistics_t * bythread_stat = NULL ;
00189     
00190   <span class="comment">/* first, we init the keys if this is the first time */</span>
00191   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00192     DisplayErrorJd(fsal_log, ERR_SYS, ERR_PTHREAD_ONCE, errno );
00193     <span class="keywordflow">return</span>;
00194   }
00195   
00196   <span class="comment">/* we get the specific value */</span>
00197   bythread_stat = (fsal_statistics_t *) pthread_getspecific( key_stats ) ;
00198   
00199   <span class="comment">/* we allocate stats if this is the first time */</span>
00200   <span class="keywordflow">if</span>( bythread_stat == NULL ){
00201       <span class="keywordtype">int</span> i;
00202            
00203       <span class="keywordflow">if</span>( (
00204             bythread_stat =
00205             (fsal_statistics_t *)Mem_Alloc( <span class="keyword">sizeof</span>(fsal_statistics_t ))
00206            ) == NULL )
00207         DisplayErrorJd(fsal_log, ERR_SYS, ERR_MALLOC, Mem_Errno );
00208       
00209       <span class="comment">/* inits the struct */</span>
00210       <span class="keywordflow">for</span> (i=0;i&lt;FSAL_NB_FUNC;i++){
00211          bythread_stat-&gt;func_stats.nb_call[i]=0;
00212          bythread_stat-&gt;func_stats.nb_success[i]=0;
00213          bythread_stat-&gt;func_stats.nb_err_retryable[i]=0;
00214          bythread_stat-&gt;func_stats.nb_err_unrecover[i]=0;
00215       }
00216       
00217       <span class="comment">/* set the specific value */</span>
00218       pthread_setspecific( key_stats , (<span class="keywordtype">void</span> *)bythread_stat ) ;
00219 
00220   }
00221   
00222   <span class="keywordflow">if</span> (output_stats)
00223     (*output_stats)=(*bythread_stat);
00224   
00225   <span class="keywordflow">return</span>;
00226   
00227 }
00228 
00229 
<a name="l00240"></a><a class="code" href="fsal__internal_8c.html#a16">00240</a> <span class="keywordtype">void</span> <a class="code" href="fsal__internal_8c.html#a16">fsal_internal_SetCredentialLifetime</a>(fsal_uint_t lifetime_in)
00241 {
00242   CredentialLifetime = lifetime_in;
00243 }
00244 
00245 
<a name="l00249"></a><a class="code" href="fsal__internal_8c.html#a17">00249</a> <span class="keywordtype">void</span>  <a class="code" href="fsal__internal_8c.html#a17">TakeTokenFSCall</a>()
00250 {
00251   <span class="comment">/* no limits */</span>
00252   <span class="keywordflow">if</span> ( limit_calls == FALSE ) <span class="keywordflow">return</span>;
00253   
00254   <span class="comment">/* there is a limit */</span>  
00255   semaphore_P( &amp;sem_fs_calls );
00256   
00257 }
00258 
00259 <span class="keywordtype">void</span>  ReleaseTokenFSCall()
00260 {
00261   <span class="comment">/* no limits */</span>
00262   <span class="keywordflow">if</span> ( limit_calls == FALSE ) <span class="keywordflow">return</span>;
00263   
00264   <span class="comment">/* there is a limit */</span>  
00265   semaphore_V( &amp;sem_fs_calls );
00266   
00267 }
00268 
00269 
00270 
00271 
00272 <span class="preprocessor">#define SET_INTEGER_PARAM( cfg, p_init_info, _field )             \</span>
00273 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00274 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00275 <span class="preprocessor">      </span><span class="comment">/* force the value in any case */</span>                           \
00276       cfg._field = (p_init_info)-&gt;values._field;                  \
00277       break;                                                      \
00278     case FSAL_INIT_MAX_LIMIT :                                    \
00279       <span class="comment">/* check the higher limit */</span>                                \
00280       if ( cfg._field &gt; (p_init_info)-&gt;values._field )            \
00281         cfg._field = (p_init_info)-&gt;values._field ;               \
00282       break;                                                      \
00283     case FSAL_INIT_MIN_LIMIT :                                    \
00284       <span class="comment">/* check the lower limit */</span>                                 \
00285       if ( cfg._field &lt; (p_init_info)-&gt;values._field )            \
00286         cfg._field = (p_init_info)-&gt;values._field ;               \
00287       break;                                                      \
00288     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00289     }
00290     
00291 
00292 <span class="preprocessor">#define SET_BITMAP_PARAM( cfg, p_init_info, _field )              \</span>
00293 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00294 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00295 <span class="preprocessor">        </span><span class="comment">/* force the value in any case */</span>                         \
00296         cfg._field = (p_init_info)-&gt;values._field;                \
00297         break;                                                    \
00298     case FSAL_INIT_MAX_LIMIT :                                    \
00299       <span class="comment">/* proceed a bit AND */</span>                                     \
00300       cfg._field &amp;= (p_init_info)-&gt;values._field ;                \
00301       break;                                                      \
00302     case FSAL_INIT_MIN_LIMIT :                                    \
00303       <span class="comment">/* proceed a bit OR */</span>                                      \
00304       cfg._field |= (p_init_info)-&gt;values._field ;                \
00305       break;                                                      \
00306     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00307     }
00308 
00309 
00310 <span class="preprocessor">#define SET_BOOLEAN_PARAM( cfg, p_init_info, _field )             \</span>
00311 <span class="preprocessor">    switch( (p_init_info)-&gt;behaviors._field ){                    \</span>
00312 <span class="preprocessor">    case FSAL_INIT_FORCE_VALUE :                                  \</span>
00313 <span class="preprocessor">        </span><span class="comment">/* force the value in any case */</span>                         \
00314         cfg._field = (p_init_info)-&gt;values._field;                \
00315         break;                                                    \
00316     case FSAL_INIT_MAX_LIMIT :                                    \
00317       <span class="comment">/* proceed a boolean AND */</span>                                 \
00318       cfg._field = cfg._field &amp;&amp; (p_init_info)-&gt;values._field ;   \
00319       break;                                                      \
00320     case FSAL_INIT_MIN_LIMIT :                                    \
00321       <span class="comment">/* proceed a boolean OR */</span>                                  \
00322       cfg._field = cfg._field &amp;&amp; (p_init_info)-&gt;values._field ;   \
00323       break;                                                      \
00324     <span class="comment">/* In the other cases, we keep the default value. */</span>          \
00325     }
00326 
00327             
00328 <span class="comment">/*</span>
00329 <span class="comment"> *  This function initializes shared variables of the fsal.</span>
00330 <span class="comment"> */</span>
00331 fsal_status_t fsal_internal_init_global( fsal_init_info_t       * fsal_info ,
00332                                          fs_common_initinfo_t   * fs_common_info,
00333                                          fs_specific_initinfo_t * fs_specific_info)
00334 {
00335   
00336   
00337   <span class="comment">/* sanity check */</span>
00338   <span class="keywordflow">if</span> (!fsal_info || !fs_common_info || !fs_specific_info) ReturnCode(ERR_FSAL_FAULT,0);
00339   
00340   <span class="comment">/* Setting log info */</span>
00341   fsal_log = fsal_info-&gt;log_outputs;
00342   
00343   
00344   <span class="comment">/* inits FS call semaphore */</span>
00345   <span class="keywordflow">if</span> ( fsal_info-&gt;max_fs_calls &gt; 0 )
00346   {
00347     <span class="keywordtype">int</span> rc;
00348     
00349     limit_calls = TRUE;
00350     
00351     rc=semaphore_init(&amp;sem_fs_calls, fsal_info-&gt;max_fs_calls);
00352     
00353     <span class="keywordflow">if</span> (rc != 0) ReturnCode(ERR_FSAL_SERVERFAULT,rc);
00354     
00355     DisplayLogJdLevel( fsal_log, NIV_DEBUG,
00356         <span class="stringliteral">"FSAL INIT: Max simultaneous calls to filesystem is limited to %u."</span>, 
00357         fsal_info-&gt;max_fs_calls );
00358     
00359   }
00360   <span class="keywordflow">else</span>
00361   {
00362     DisplayLogJdLevel( fsal_log, NIV_DEBUG,
00363         <span class="stringliteral">"FSAL INIT: Max simultaneous calls to filesystem is unlimited."</span> );
00364   }
00365   
00366   
00367   <span class="comment">/* setting default values. */</span>
00368   global_fs_info = default_posix_info;
00369 
00370 <span class="preprocessor">#ifdef _DEBUG_FSAL</span>
00371 <span class="preprocessor"></span>  
00372 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"{"</span>);
00373 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxfilesize  = %llX    "</span>,default_posix_info.maxfilesize);
00374 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxlink  = %lu   "</span>,default_posix_info.maxlink);
00375 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxnamelen  = %lu  "</span>,default_posix_info.maxnamelen);
00376 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxpathlen  = %lu  "</span>,default_posix_info.maxpathlen);
00377 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  no_trunc  = %d "</span>,default_posix_info.no_trunc);
00378 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  chown_restricted  = %d "</span>,default_posix_info.chown_restricted);
00379 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  case_insensitive  = %d "</span>,default_posix_info.case_insensitive);
00380 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  case_preserving  = %d "</span>,default_posix_info.case_preserving);
00381 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  fh_expire_type  = %hu "</span>,default_posix_info.fh_expire_type);
00382 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  link_support  = %d  "</span>,default_posix_info.link_support);
00383 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  symlink_support  = %d  "</span>,default_posix_info.symlink_support);
00384 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  lock_support  = %d  "</span>,default_posix_info.lock_support);
00385 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  named_attr  = %d  "</span>,default_posix_info.named_attr);
00386 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  unique_handles  = %d  "</span>,default_posix_info.unique_handles);
00387 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  acl_support  = %hu  "</span>,default_posix_info.acl_support);
00388 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  cansettime  = %d  "</span>,default_posix_info.cansettime);
00389 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  homogenous  = %d  "</span>,default_posix_info.homogenous);
00390 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  supported_attrs  = %llX  "</span>,default_posix_info.supported_attrs);
00391 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxread  = %llX     "</span>,default_posix_info.maxread);
00392 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  maxwrite  = %llX     "</span>,default_posix_info.maxwrite);
00393 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"  umask  = %X "</span>,default_posix_info.umask);
00394 DisplayLogJdLevel( fsal_log, NIV_DEBUG,<span class="stringliteral">"}"</span>);
00395   
00396 <span class="preprocessor">#endif</span>
00397 <span class="preprocessor"></span>  
00398   
00399   <span class="comment">/* Analyzing fs_common_info struct */</span>  
00400   
00401   <span class="keywordflow">if</span> (
00402       (fs_common_info-&gt;behaviors.maxfilesize != FSAL_INIT_FS_DEFAULT ) ||
00403       (fs_common_info-&gt;behaviors.maxlink  != FSAL_INIT_FS_DEFAULT ) ||
00404       (fs_common_info-&gt;behaviors.maxnamelen != FSAL_INIT_FS_DEFAULT ) ||
00405       (fs_common_info-&gt;behaviors.maxpathlen != FSAL_INIT_FS_DEFAULT ) ||
00406       (fs_common_info-&gt;behaviors.no_trunc != FSAL_INIT_FS_DEFAULT ) ||
00407       (fs_common_info-&gt;behaviors.case_insensitive != FSAL_INIT_FS_DEFAULT ) ||
00408       (fs_common_info-&gt;behaviors.case_preserving != FSAL_INIT_FS_DEFAULT ) ||
00409       (fs_common_info-&gt;behaviors.named_attr != FSAL_INIT_FS_DEFAULT ) ||
00410       (fs_common_info-&gt;behaviors.lease_time != FSAL_INIT_FS_DEFAULT ) ||
00411       (fs_common_info-&gt;behaviors.supported_attrs != FSAL_INIT_FS_DEFAULT ) ||
00412       (fs_common_info-&gt;behaviors.homogenous != FSAL_INIT_FS_DEFAULT ) )
00413       ReturnCode(ERR_FSAL_NOTSUPP,0);
00414 
00415   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, symlink_support );
00416   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, link_support );
00417   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, lock_support );
00418   SET_BOOLEAN_PARAM( global_fs_info, fs_common_info, cansettime );
00419   
00420   SET_INTEGER_PARAM( global_fs_info, fs_common_info, maxread );
00421   SET_INTEGER_PARAM( global_fs_info, fs_common_info, maxwrite );
00422   
00423   SET_BITMAP_PARAM( global_fs_info, fs_common_info, umask );
00424 
00425   <span class="comment">/* setting global database parameters */</span>
00426   global_posixdb_params = fs_specific_info-&gt;dbparams;
00427   
00428 <span class="preprocessor">#ifdef _DEBUG_FSAL</span>
00429 <span class="preprocessor"></span>  DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG,
00430         <span class="stringliteral">"Supported attributes constant = 0x%llX."</span>, 
00431         POSIX_SUPPORTED_ATTRIBUTES );  
00432   
00433   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG,
00434         <span class="stringliteral">"Supported attributes default = 0x%llX."</span>,
00435         default_posix_info.supported_attrs );  
00436 <span class="preprocessor">#endif</span>
00437 <span class="preprocessor"></span>    
00438   DisplayLogJdLevel( fsal_log, NIV_DEBUG,
00439         <span class="stringliteral">"FSAL INIT: Supported attributes mask = 0x%llX."</span>, 
00440         global_fs_info.supported_attrs );  
00441 
00442   ReturnCode(ERR_FSAL_NO_ERROR,0);
00443 }
00444 
<a name="l00453"></a><a class="code" href="fsal__internal_8c.html#a20">00453</a> fsal_status_t <a class="code" href="fsal__internal_8c.html#a20">fsal_internal_posix2posixdb_fileinfo</a>(<span class="keyword">struct</span> stat *buffstat, fsal_posixdb_fileinfo_t *info)
00454 {
00455   <span class="comment">/* sanity check */</span>
00456   <span class="keywordflow">if</span> (!info || !buffstat) ReturnCode(ERR_FSAL_FAULT,0);
00457   
00458   memset(info, 0, <span class="keyword">sizeof</span>(fsal_posixdb_fileinfo_t));
00459   info-&gt;devid = buffstat-&gt;st_dev;
00460   info-&gt;inode = buffstat-&gt;st_ino;
00461   info-&gt;nlink = (int) buffstat-&gt;st_nlink;
00462   info-&gt;ctime = buffstat-&gt;st_ctime;
00463   info-&gt;ftype = <a class="code" href="fsal__convert_8c.html#a7">posix2fsal_type</a>(buffstat-&gt;st_mode);
00464   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00465 }
00466 
00467 <span class="comment">/*</span>
00468 <span class="comment"> *  This function adds an entry in the database</span>
00469 <span class="comment"> */</span>
00470 fsal_status_t fsal_internal_posixdb_add_entry( fsal_posixdb_conn *p_conn, 
00471                                  fsal_name_t *p_filename, 
00472                                  fsal_posixdb_fileinfo_t *p_info, 
00473                                  fsal_handle_t *p_dir_handle, 
00474                                  fsal_handle_t *p_new_handle)
00475 {
00476   fsal_posixdb_status_t stdb;
00477    
00478   <span class="keywordflow">if</span> (!p_info || !p_conn || !p_new_handle) <span class="comment">/* p_filename &amp; p_dir_handle can be NULL for the root */</span> 
00479     ReturnCode(ERR_FSAL_FAULT,0);
00480 
00481 add:  
00482   stdb = fsal_posixdb_add( p_conn, p_info, p_dir_handle, p_filename, p_new_handle );
00483   
00484   <span class="keywordflow">if</span> (stdb.major == ERR_FSAL_POSIXDB_CONSISTENCY) { <span class="comment">/* there is already an entry with this path, but it's an inconsistent one */</span>
00485     stdb = fsal_posixdb_deleteHandle(p_conn, p_new_handle);
00486     <span class="keywordflow">if</span> ( FSAL_POSIXDB_IS_ERROR(stdb) )
00487       <span class="keywordflow">return</span> <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(stdb);
00488     <span class="keywordflow">goto</span> add;
00489   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( FSAL_POSIXDB_IS_ERROR(stdb) ) {
00490     <span class="keywordflow">return</span> <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(stdb);
00491   }
00492   
00493   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00494 }
00495 
<a name="l00504"></a><a class="code" href="fsal__internal_8c.html#a22">00504</a> fsal_status_t <a class="code" href="fsal__internal_8c.html#a22">fsal_internal_appendFSALNameToFSALPath</a>(fsal_path_t *p_path, fsal_name_t * p_name)
00505 {
00506   <span class="keywordtype">char</span> *end;
00507   <span class="keywordflow">if</span> (!p_path || !p_name)
00508     ReturnCode(ERR_FSAL_FAULT,0);
00509 
00510   end = p_path-&gt;path + p_path-&gt;len - 1;
00511   <span class="keywordflow">if</span> (*end != <span class="charliteral">'/'</span>) {
00512     <span class="keywordflow">if</span> (p_path-&gt;len + 1 + p_name-&gt;len &gt; FSAL_MAX_PATH_LEN)
00513       ReturnCode(ERR_FSAL_NAMETOOLONG, 0);
00514     p_path-&gt;len += p_name-&gt;len + 1;
00515     end++;
00516     *end = <span class="charliteral">'/'</span>;
00517     end++;
00518     strcpy(end, p_name-&gt;name);
00519   } <span class="keywordflow">else</span> {
00520     <span class="keywordflow">if</span> (p_path-&gt;len + p_name-&gt;len &gt; FSAL_MAX_PATH_LEN)
00521       ReturnCode(ERR_FSAL_NAMETOOLONG, 0);
00522     p_path-&gt;len += p_name-&gt;len;
00523     end++;
00524     strcpy(end, p_name-&gt;name);
00525   }
00526   
00527   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00528 }
00529 
<a name="l00534"></a><a class="code" href="fsal__internal_8c.html#a23">00534</a> fsal_status_t <a class="code" href="fsal__internal_8c.html#a23">fsal_internal_getPathFromHandle</a>( fsal_op_context_t      * p_context,  <span class="comment">/* IN */</span>
00535                                               fsal_handle_t           * p_handle,   <span class="comment">/* IN */</span>
00536                                               <span class="keywordtype">int</span>                       is_dir,     <span class="comment">/* IN */</span>
00537                                               fsal_path_t             * p_fsalpath, <span class="comment">/* OUT */</span>
00538                                               <span class="keyword">struct</span> stat             * p_buffstat <span class="comment">/* OUT */</span>)
00539 {
00540   fsal_status_t         status;
00541   fsal_posixdb_status_t statusdb;
00542   <span class="keywordtype">int</span> rc, errsv, count, i;
00543   fsal_posixdb_fileinfo_t infofs;
00544   fsal_path_t paths[global_fs_info.maxlink];
00545 
00546   <span class="keywordflow">if</span> ( !p_context || !p_handle || !p_fsalpath )
00547     ReturnCode(ERR_FSAL_FAULT, 0);
00548   
00549   <span class="comment">/* if there is a path in the fsal_handle_t variable, then try to use it instead of querying the database for it */</span> 
00550   <span class="comment">/* Read the path from the Handle. If it's valid &amp; coherent, then no need to query the database ! */</span>
00551   <span class="comment">/* if !p_buffstat, we don't need to check the path*/</span>
00552   statusdb = fsal_posixdb_getInfoFromHandle( p_context-&gt;p_conn,
00553                                              p_handle,
00554                                              paths,
00555                                              (is_dir ? 1 : global_fs_info.maxlink),
00556                                              &amp;count);
00557   <span class="keywordflow">if</span> (FSAL_POSIXDB_IS_ERROR(statusdb) &amp;&amp; FSAL_IS_ERROR(status = <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(statusdb))) <span class="keywordflow">return</span> status;
00558 
00559   <span class="comment">/* if !p_buffstat, then we do not stat the path to test if file is valid */</span>
00560   <span class="keywordflow">if</span> (p_buffstat) {
00561     <span class="keywordflow">for</span> (i=0; i&lt;count; i++) {
00562       <a class="code" href="fsal__internal_8c.html#a17">TakeTokenFSCall</a>();
00563       rc = lstat( paths[i].path, p_buffstat );
00564       errsv = errno;
00565       ReleaseTokenFSCall();
00566 
00567       <span class="keywordflow">if</span> ( rc ) {
00568       <span class="comment">/* error : delete the bad path from the database */</span>
00569         <span class="keywordtype">char</span> dirc[FSAL_MAX_PATH_LEN];
00570         <span class="keywordtype">char</span> basec[FSAL_MAX_PATH_LEN];
00571         fsal_path_t parentdir;
00572         fsal_name_t filename;
00573         fsal_handle_t parenthdl;
00574         <span class="keywordtype">char</span> *dname, *bname;
00575         
00576         <span class="comment">/* split /path/to/filename in /path/to &amp; filename */</span>
00577         strncpy(dirc, paths[i].path, FSAL_MAX_PATH_LEN);
00578         strncpy(basec, paths[i].path, FSAL_MAX_PATH_LEN);
00579         dname = dirname(dirc);
00580         bname = basename(basec);
00581 
00582         status = <a class="code" href="group__FSALNameFunctions.html#ga1">FSAL_str2path</a>( dname, FSAL_MAX_PATH_LEN, &amp;parentdir);
00583         status = <a class="code" href="group__FSALNameFunctions.html#ga0">FSAL_str2name</a>( bname, FSAL_MAX_NAME_LEN, &amp;filename);
00584 
00585         <span class="comment">/* get the handle of /path/to */</span>
00586         status = <a class="code" href="fsal__lookup_8c.html#a1">FSAL_lookupPath</a>( &amp;parentdir, p_context, &amp;parenthdl, NULL);
00587 
00588         <span class="keywordflow">if</span> (!FSAL_IS_ERROR(status)) {
00589           statusdb = fsal_posixdb_delete(p_context-&gt;p_conn, &amp;parenthdl, &amp;filename, NULL);
00590           <span class="comment">/* no need to check if there was an error, because it doesn't change the behavior of the function */</span>
00591         }
00592 
00593       } <span class="keywordflow">else</span> { <span class="comment">/* no error */</span>
00594         <a class="code" href="group__FSALNameFunctions.html#ga7">FSAL_pathcpy</a>( p_fsalpath, &amp;(paths[0]) );
00595         <span class="keywordflow">break</span>; 
00596       }
00597     }
00598     <span class="keywordflow">if</span> (i==count) ReturnCode( ERR_FSAL_STALE, 0);
00599     
00600     <span class="comment">/* check consistency */</span>
00601     status = <a class="code" href="fsal__internal_8c.html#a20">fsal_internal_posix2posixdb_fileinfo</a>( p_buffstat, &amp;infofs ); 
00602     <span class="keywordflow">if</span> (FSAL_IS_ERROR(status)) <span class="keywordflow">return</span> status;
00603     
00604     <span class="keywordflow">if</span> ( fsal_posixdb_consistency_check(&amp;(p_handle-&gt;info), &amp;infofs) ) {
00605       <span class="comment">/* not consistent !! */</span>
00606       <span class="comment">/* delete the stale handle */</span>
00607       statusdb = fsal_posixdb_deleteHandle( p_context-&gt;p_conn, p_handle );
00608       <span class="keywordflow">if</span> (FSAL_POSIXDB_IS_ERROR(statusdb) &amp;&amp; FSAL_IS_ERROR( status = <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(statusdb) )) <span class="keywordflow">return</span> status;
00609       
00610       ReturnCode(ERR_FSAL_STALE, 0);
00611     }
00612     
00613   } <span class="keywordflow">else</span> {
00614       <span class="comment">/* @TODO : check that there si at liste 1 path */</span>
00615       <a class="code" href="group__FSALNameFunctions.html#ga7">FSAL_pathcpy</a>( p_fsalpath, &amp;(paths[0]) );
00616   }
00617   
00618   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00619 }
00620 
<a name="l00638"></a><a class="code" href="fsal__internal_8c.html#a24">00638</a> fsal_status_t <a class="code" href="fsal__internal_8c.html#a24">fsal_internal_getInfoFromName</a>( fsal_op_context_t       * p_context,  <span class="comment">/* IN */</span>
00639                                              fsal_handle_t           * p_parent_dir_handle,   <span class="comment">/* IN */</span>
00640                                              fsal_name_t             * p_fsalname, <span class="comment">/* IN */</span>
00641                                              fsal_posixdb_fileinfo_t * p_infofs, <span class="comment">/* IN */</span>
00642                                              fsal_handle_t           * p_object_handle)   <span class="comment">/* OUT */</span>
00643 {
00644   fsal_posixdb_status_t   stdb;
00645   fsal_status_t           st;
00646 
00647   stdb = fsal_posixdb_getInfoFromName( p_context-&gt;p_conn, 
00648                                        p_parent_dir_handle, 
00649                                        p_fsalname, 
00650                                        NULL, 
00651                                        p_object_handle);
00652   <span class="keywordflow">switch</span> (stdb.major) {
00653     <span class="keywordflow">case</span> ERR_FSAL_POSIXDB_NOERR:
00654       <span class="comment">/* No error, the object is in the database */</span>
00655       <span class="comment">/* check consistency */</span>
00656       <span class="keywordflow">if</span> ( fsal_posixdb_consistency_check(&amp;(p_object_handle-&gt;info), p_infofs) ) {
00657         <span class="comment">/* Entry not consistent */</span>
00658         <span class="comment">/* Delete the Handle entry, then add a new one (with a Parent entry) */</span>
00659         stdb = fsal_posixdb_deleteHandle( p_context-&gt;p_conn, p_object_handle );
00660         <span class="keywordflow">if</span> (FSAL_POSIXDB_IS_ERROR(stdb) &amp;&amp; FSAL_IS_ERROR( st = <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(stdb) )) <span class="keywordflow">return</span> st;
00661         <span class="comment">/* don't break, add a new entry */</span>
00662       } <span class="keywordflow">else</span> {
00663         <span class="keywordflow">break</span>;
00664       }
00665     <span class="keywordflow">case</span> ERR_FSAL_POSIXDB_NOENT:
00666       <span class="comment">/* object not in the database, add a new entry */</span>
00667       st = fsal_internal_posixdb_add_entry( p_context-&gt;p_conn,
00668                                             p_fsalname,
00669                                             p_infofs,
00670                                             p_parent_dir_handle,
00671                                             p_object_handle);
00672       <span class="keywordflow">if</span> (FSAL_IS_ERROR(st)) <span class="keywordflow">return</span> st;
00673       <span class="keywordflow">break</span>;
00674     <span class="keywordflow">default</span>:
00675       <span class="comment">/* error */</span>
00676       <span class="keywordflow">if</span> (FSAL_IS_ERROR(st = <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(stdb))) <span class="keywordflow">return</span> st;
00677   }
00678   
00679   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00680 }
00681 
00682 
00683 
<a name="l00703"></a><a class="code" href="fsal__internal_8c.html#a25">00703</a> fsal_status_t <a class="code" href="fsal__internal_8c.html#a25">fsal_internal_getInfoFromChildrenList</a>( fsal_op_context_t       * p_context,  <span class="comment">/* IN */</span>
00704                                                      fsal_handle_t           * p_parent_dir_handle,   <span class="comment">/* IN */</span>
00705                                                      fsal_name_t             * p_fsalname, <span class="comment">/* IN */</span>
00706                                                      fsal_posixdb_fileinfo_t * p_infofs, <span class="comment">/* IN */</span>
00707                                                      fsal_posixdb_child      * p_children, <span class="comment">/* IN */</span>
00708                                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              children_count, <span class="comment">/* IN */</span>
00709                                                      fsal_handle_t           * p_object_handle)   <span class="comment">/* OUT */</span>
00710 {
00711   fsal_posixdb_status_t   stdb;
00712   fsal_status_t           st;
00713   <span class="keywordtype">int</span>                     cmp = -1; <span class="comment">/* when no children is available */</span>
00714   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            count;
00715 
00716   <span class="comment">/* sanity check */</span>
00717   <span class="keywordflow">if</span> ( !p_context || !p_parent_dir_handle || !p_fsalname || ( !p_children &amp;&amp; children_count ) || !p_object_handle )
00718     ReturnCode(ERR_FSAL_FAULT, 0);
00719 
00720   <span class="comment">/* check if the filename is in the list */</span>
00721   <span class="keywordflow">for</span> (count = 0; count &lt; children_count; count++)
00722   {
00723     cmp = <a class="code" href="group__FSALNameFunctions.html#ga4">FSAL_namecmp</a>( p_fsalname, &amp;(p_children[count].name) );
00724     <span class="keywordflow">if</span> (!cmp) <span class="keywordflow">break</span>;
00725     <span class="comment">/* maybe a sorted list could give better result */</span>
00726   }
00727 
00728   <span class="keywordflow">switch</span> (cmp) {
00729     <span class="keywordflow">case</span> 0:
00730       <span class="comment">/* Entry found : check consistency */</span>
00731         
00732       <span class="keywordflow">if</span> ( fsal_posixdb_consistency_check(&amp;(p_children[count].handle.info), p_infofs) )
00733       {
00734         <span class="comment">/* Entry not consistent */</span>
00735         <span class="comment">/* Delete the Handle entry, then add a new one (with a Parent entry) */</span>
00736         stdb = fsal_posixdb_deleteHandle( p_context-&gt;p_conn, &amp;(p_children[count].handle) );
00737         
00738         <span class="keywordflow">if</span> (FSAL_POSIXDB_IS_ERROR(stdb) &amp;&amp; FSAL_IS_ERROR( st = <a class="code" href="fsal__convert_8c.html#a12">posixdb2fsal_error</a>(stdb) )) <span class="keywordflow">return</span> st;
00739         
00740         <span class="comment">/* don't break, add a new entry */</span>
00741         
00742       }
00743       <span class="keywordflow">else</span>
00744       {
00745         memcpy(p_object_handle, &amp;(p_children[count].handle), <span class="keyword">sizeof</span>(fsal_handle_t));
00746         <span class="keywordflow">break</span>;
00747       }
00748       
00749     <span class="keywordflow">default</span>:
00750       <span class="comment">/* not found ! Add it */</span>
00751       st = fsal_internal_posixdb_add_entry( p_context-&gt;p_conn,
00752                                             p_fsalname,
00753                                             p_infofs,
00754                                             p_parent_dir_handle,
00755                                             p_object_handle);
00756       <span class="keywordflow">if</span> (FSAL_IS_ERROR(st)) <span class="keywordflow">return</span> st;
00757   }
00758 
00759   ReturnCode(ERR_FSAL_NO_ERROR, 0);
00760 }
00761 
00762 
00763 <span class="comment">/*</span>
00764 <span class="comment">   Check the access from an existing fsal_attrib_list_t or struct stat</span>
00765 <span class="comment">*/</span>
00766 <span class="comment">/* XXX : ACL */</span>
00767 fsal_status_t fsal_internal_testAccess( fsal_op_context_t   * p_context,          <span class="comment">/* IN */</span>
00768                                         fsal_accessflags_t  access_type,          <span class="comment">/* IN */</span>
00769                                         <span class="keyword">struct</span> stat         * p_buffstat,          <span class="comment">/* IN */</span>
00770                                         fsal_attrib_list_t  * p_object_attributes   <span class="comment">/* IN */</span>)
00771 {
00772   fsal_accessflags_t missing_access;
00773   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_grp, i;
00774   fsal_uid_t uid;
00775   fsal_gid_t gid;
00776   fsal_accessmode_t mode;
00777   
00778   <span class="comment">/* sanity checks. */</span>
00779   
00780   <span class="keywordflow">if</span> ( (!p_object_attributes &amp;&amp; !p_buffstat) || !p_context)
00781     ReturnCode(ERR_FSAL_FAULT, 0);
00782   
00783   <span class="comment">/* If the FSAL_F_OK flag is set, returns ERR INVAL*/</span>  
00784   
00785   <span class="keywordflow">if</span> ( access_type &amp; FSAL_F_OK )
00786     ReturnCode(ERR_FSAL_INVAL, 0);
00787   
00788   
00789   <span class="comment">/* test root access */</span>
00790   
00791   <span class="keywordflow">if</span> ( p_context-&gt;credential.user == 0 )
00792     ReturnCode(ERR_FSAL_NO_ERROR, 0 );
00793     
00794   <span class="comment">/* unsatisfied flags */</span>  
00795   
00796   missing_access = access_type;
00797 
00798   
00799   <span class="keywordflow">if</span> (p_object_attributes) {
00800     uid = p_object_attributes-&gt;owner;
00801     gid = p_object_attributes-&gt;group;
00802     mode = p_object_attributes-&gt;mode;
00803   } <span class="keywordflow">else</span> {
00804     uid = p_buffstat-&gt;st_uid;
00805     gid = p_buffstat-&gt;st_gid;
00806     mode = <a class="code" href="fsal__convert_8c.html#a6">unix2fsal_mode</a>( p_buffstat-&gt;st_mode );
00807   }
00808     
00809   <span class="comment">/* Test if file belongs to user. */</span>
00810  
00811   <span class="keywordflow">if</span> ( p_context-&gt;credential.user == uid )
00812   {
00813     
00814 <span class="preprocessor">#if defined( _DEBUG_FSAL )</span>
00815 <span class="preprocessor"></span>   DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, <span class="stringliteral">"File belongs to user %d"</span>,
00816        uid );
00817 <span class="preprocessor">#endif</span>
00818 <span class="preprocessor"></span>    
00819     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_RUSR )
00820       missing_access &amp;= ~FSAL_R_OK ;
00821 
00822     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_WUSR )
00823       missing_access &amp;= ~FSAL_W_OK ;
00824     
00825     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_XUSR )
00826       missing_access &amp;= ~FSAL_X_OK ;
00827     
00828     
00829     <span class="keywordflow">if</span> ( missing_access == 0 )
00830       ReturnCode(ERR_FSAL_NO_ERROR, 0);
00831     <span class="keywordflow">else</span>
00832       ReturnCode(ERR_FSAL_ACCESS, 0 );
00833     
00834      
00835   }
00836   
00837   <span class="comment">/* Test if the file belongs to user's group. */</span>
00838 
00839   is_grp = ( p_context-&gt;credential.group == gid );
00840   
00841 <span class="preprocessor"># ifdef _DEBUG_FSAL</span>
00842 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (is_grp)
00843     DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, <span class="stringliteral">"File belongs to user's group %d"</span>,
00844        p_context-&gt;credential.group );
00845 <span class="preprocessor"># endif</span>
00846 <span class="preprocessor"></span>  
00847   <span class="comment">/* Test if file belongs to alt user's groups */</span> 
00848  
00849   <span class="keywordflow">if</span> ( !is_grp )
00850   {
00851     <span class="keywordflow">for</span> ( i = 0; i &lt; p_context-&gt;credential.nbgroups; i++ )
00852     {
00853       is_grp = ( p_context-&gt;credential.alt_groups[i] == gid );
00854 
00855 <span class="preprocessor">      #ifdef _DEBUG_FSAL</span>
00856 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (is_grp)
00857           DisplayLogJdLevel( fsal_log, NIV_FULL_DEBUG, <span class="stringliteral">"File belongs to user's alt group %d"</span>,
00858              p_context-&gt;credential.alt_groups[i]  );
00859 <span class="preprocessor">      #endif</span>
00860 <span class="preprocessor"></span>            
00861       <span class="comment">// exits loop if found</span>
00862       <span class="keywordflow">if</span> ( is_grp ) <span class="keywordflow">break</span>;
00863     }
00864   }
00865     
00866   <span class="comment">/* finally apply group rights */</span>
00867   
00868   <span class="keywordflow">if</span> ( is_grp )
00869   {
00870     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_RGRP )
00871       missing_access &amp;= ~FSAL_R_OK ;
00872 
00873     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_WGRP )
00874       missing_access &amp;= ~FSAL_W_OK ;
00875 
00876     <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_XGRP )
00877       missing_access &amp;= ~FSAL_X_OK ;
00878     
00879     <span class="keywordflow">if</span> ( missing_access == 0 )
00880       ReturnCode(ERR_FSAL_NO_ERROR , 0 );
00881     <span class="keywordflow">else</span>
00882       ReturnCode(ERR_FSAL_ACCESS , 0 );
00883     
00884   }
00885   
00886       
00887   <span class="comment">/* test other perms */</span>  
00888       
00889   <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_ROTH )
00890     missing_access &amp;= ~FSAL_R_OK ;
00891 
00892   <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_WOTH )
00893     missing_access &amp;= ~FSAL_W_OK ;
00894 
00895   <span class="keywordflow">if</span> ( mode &amp; FSAL_MODE_XOTH )
00896     missing_access &amp;= ~FSAL_X_OK ;
00897      
00898     
00899   <span class="comment">/* XXX ACLs. */</span>
00900   
00901   <span class="keywordflow">if</span> ( missing_access == 0 )
00902     ReturnCode(ERR_FSAL_NO_ERROR ,0 );
00903   <span class="keywordflow">else</span>
00904     ReturnCode(ERR_FSAL_ACCESS , 0 );
00905   
00906   
00907 }
00908 
00909 
00910 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:45 2008 for File System Abstraction Layer (POSIX) library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
