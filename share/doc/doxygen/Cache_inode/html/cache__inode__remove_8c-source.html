<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Cache inode layer: cache_inode_remove.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cache_inode_remove.c</h1><a href="cache__inode__remove_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00010 <span class="comment">/*</span>
00011 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00012 <span class="comment"> */</span>
00013 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00015 <span class="preprocessor">#endif</span>
00016 <span class="preprocessor"></span>
00017 
00018 <span class="preprocessor">#include "LRU_List.h"</span>
00019 <span class="preprocessor">#include "log_functions.h"</span>
00020 <span class="preprocessor">#include "HashData.h"</span>
00021 <span class="preprocessor">#include "HashTable.h"</span>
00022 <span class="preprocessor">#include "fsal.h"</span>
00023 <span class="preprocessor">#include "cache_inode.h"</span>
00024 <span class="preprocessor">#include "cache_content.h"</span>
00025 <span class="preprocessor">#include "stuff_alloc.h"</span>
00026 
00027 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00028 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00029 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00030 <span class="preprocessor">#include &lt;time.h&gt;</span>
00031 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00032 
<a name="l00046"></a><a class="code" href="cache__inode__remove_8c.html#a0">00046</a> cache_inode_status_t <a class="code" href="cache__inode__remove_8c.html#a0">cache_inode_is_dir_empty</a>( cache_entry_t * pentry )
00047 {
00048   cache_inode_status_t   status ;
00049   cache_entry_t        * pentry_iter ;
00050 
00051   <span class="comment">/* Sanity check */</span>
00052   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type != DIR_BEGINNING )
00053     <span class="keywordflow">return</span> CACHE_INODE_BAD_TYPE ;
00054 
00055   <span class="comment">/* Initialisation */</span>
00056   status = CACHE_INODE_SUCCESS ;
00057   pentry_iter = pentry ;
00058    
00059   <span class="keywordflow">do</span>
00060     {
00061       <span class="keywordflow">if</span>( pentry_iter-&gt;internal_md.type == DIR_BEGINNING )
00062         {
00063           <span class="keywordflow">if</span>( pentry_iter-&gt;object.dir_begin.nbactive != 0 )
00064             {
00065               status = CACHE_INODE_DIR_NOT_EMPTY ;
00066               break ;
00067             }
00068           
00069           <span class="keywordflow">if</span>( pentry_iter-&gt;object.dir_begin.end_of_dir == END_OF_DIR )
00070             break ;
00071           
00072           pentry_iter = pentry_iter-&gt;object.dir_begin.pdir_cont ;
00073         }
00074       <span class="keywordflow">else</span>
00075         {
00076           <span class="keywordflow">if</span>( pentry_iter-&gt;object.dir_cont.nbactive != 0 )
00077             {
00078               status = CACHE_INODE_DIR_NOT_EMPTY ;
00079               break ;
00080             }
00081           
00082           <span class="keywordflow">if</span>( pentry_iter-&gt;object.dir_cont.end_of_dir == END_OF_DIR )
00083             break ;
00084           
00085           pentry_iter = pentry_iter-&gt;object.dir_cont.pdir_cont ;
00086         }
00087     } <span class="keywordflow">while</span>( pentry_iter != NULL ) ;
00088   
00089   <span class="keywordflow">return</span> status ;
00090 } <span class="comment">/* cache_inode_is_dir_empty */</span>
00091 
00092 
<a name="l00106"></a><a class="code" href="cache__inode__remove_8c.html#a1">00106</a> cache_inode_status_t <a class="code" href="cache__inode__remove_8c.html#a1">cache_inode_is_dir_empty_WithLock</a>( cache_entry_t * pentry )
00107 {
00108    cache_inode_status_t status ;
00109 
00110    P( pentry-&gt;lock ) ;
00111    status = <a class="code" href="cache__inode__remove_8c.html#a0">cache_inode_is_dir_empty</a>( pentry ) ;
00112    V( pentry-&gt;lock ) ;
00113 
00114    <span class="keywordflow">return</span> status ;
00115 } <span class="comment">/* cache_inode_is_dir_empty_WithLock */</span>
00116 
00117 
<a name="l00136"></a><a class="code" href="cache__inode__remove_8c.html#a2">00136</a> cache_inode_status_t <a class="code" href="cache__inode__remove_8c.html#a2">cache_inode_remove_sw</a>( cache_entry_t        * pentry,     
00137                                             fsal_name_t          * pnode_name,
00138                                             fsal_attrib_list_t   * pattr,
00139                                             hash_table_t         * ht,  
00140                                             cache_inode_client_t * pclient, 
00141                                             fsal_op_context_t          * pcontext, 
00142                                             cache_inode_status_t * pstatus,
00143                                             <span class="keywordtype">int</span>                    use_mutex )
00144 {
00145   fsal_status_t             fsal_status ;
00146   cache_entry_t           * parent_entry ;
00147   cache_entry_t           * pentry_iter ;
00148   cache_entry_t           * to_remove_entry ;
00149   fsal_handle_t             fsal_handle_parent ;
00150   fsal_handle_t           * pfsal_handle_remove ;
00151   cache_inode_fsal_data_t   fsaldata ;
00152   hash_buffer_t             key, old_key, old_value ;
00153   <span class="keywordtype">int</span>                       rc ;
00154   fsal_attrib_list_t        remove_attr ;
00155   fsal_attrib_list_t        after_attr ;
00156   cache_inode_status_t      status ;
00157   cache_content_status_t    cache_content_status ;
00158   <span class="keywordtype">int</span>                       dir_is_empty ;
00159   <span class="keywordtype">int</span>                       to_remove_numlinks = 0 ;
00160   
00161   <span class="comment">/* stats */</span>
00162   pclient-&gt;stat.nb_call_total += 1 ;
00163   pclient-&gt;stat.func_stats.nb_call[CACHE_INODE_REMOVE] += 1 ;
00164 
00165   <span class="comment">/* Looks up for the entry to remove */</span>
00166   <span class="keywordflow">if</span>( ( to_remove_entry = <a class="code" href="cache__inode__lookup_8c.html#a0">cache_inode_lookup_sw</a>( pentry, 
00167                                                  pnode_name, 
00168                                                  &amp;remove_attr, 
00169                                                  ht, 
00170                                                  pclient, 
00171                                                  pcontext, 
00172                                                  &amp;status, 
00173                                                  use_mutex ) ) == NULL )
00174     {
00175       *pstatus = status ;
00176       <span class="keywordflow">return</span> *pstatus ; 
00177     }
00178 
00179   <span class="comment">/* pentry is a directory */</span>
00180   <span class="keywordflow">if</span>( use_mutex )
00181     P( pentry-&gt;lock ) ;
00182   
00183   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type != DIR_BEGINNING &amp;&amp; pentry-&gt;internal_md.type != DIR_CONTINUE )
00184     {
00185       <span class="keywordflow">if</span>( use_mutex )
00186         V( pentry-&gt;lock ) ;
00187       
00188       *pstatus = CACHE_INODE_BAD_TYPE   ;
00189       <span class="keywordflow">return</span> *pstatus;
00190     } 
00191 
00192   <span class="comment">/* Non-empty directories should not be removed. If entry is of type DIR_CONTINUE, then the directory is not empty */</span>
00193   <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type == DIR_CONTINUE )
00194     {
00195       <span class="keywordflow">if</span>( use_mutex )
00196         V( pentry-&gt;lock ) ;
00197       
00198       *pstatus = CACHE_INODE_DIR_NOT_EMPTY ;
00199       <span class="keywordflow">return</span> *pstatus;
00200     }
00201   
00202   <span class="comment">/* A directory is empty if none of its pdir_chain itemps contains something */</span>
00203   <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type == DIR_BEGINNING &amp;&amp;
00204       to_remove_entry-&gt;object.dir_begin.has_been_readdir == CACHE_INODE_YES )
00205     {
00206       <span class="keywordflow">if</span>( <a class="code" href="cache__inode__remove_8c.html#a0">cache_inode_is_dir_empty</a>( to_remove_entry ) != CACHE_INODE_SUCCESS )
00207         { 
00208           <span class="keywordflow">if</span>( use_mutex )
00209              V( pentry-&gt;lock ) ;
00210 
00211           *pstatus = CACHE_INODE_DIR_NOT_EMPTY ;
00212           <span class="keywordflow">return</span> *pstatus ;
00213         }
00214     }
00215   
00216    <span class="comment">/* We have to get parent's fsal handle */</span>
00217   parent_entry = pentry ;
00218 
00219   <span class="comment">/* /!\ Possible deadlocks in this area: make sure to P(DIR_BEGIN)/P(DIR_CONT)/V(DIR_CONT)/V(DIR_BEGIN) */</span>
00220 
00221   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_BEGINNING )
00222     {
00223       fsal_handle_parent = pentry-&gt;object.dir_begin.handle ;
00224     }
00225   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_CONTINUE )
00226     {
00227       <span class="keywordflow">if</span>( use_mutex )
00228         P( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00229        
00230       fsal_handle_parent = pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.handle ;
00231 
00232       <span class="keywordflow">if</span>( use_mutex )
00233         V( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00234     }
00235 
00236 
00237 
00238   <span class="keywordflow">if</span>( status == CACHE_INODE_SUCCESS )
00239     {
00240       <span class="comment">/* Remove the file from FSAL */</span>
00241       after_attr.asked_attributes = pclient-&gt;attrmask ;
00242       fsal_status =  FSAL_unlink( &amp;fsal_handle_parent, pnode_name, pcontext, &amp;after_attr ) ;
00243      
00244       <span class="comment">/* Set the 'after' attr */</span>
00245       <span class="keywordflow">if</span>( pattr != NULL ) 
00246         *pattr = after_attr ; 
00247  
00248       <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00249         {
00250           <span class="keywordflow">if</span>( fsal_status.major == ERR_FSAL_STALE )
00251             {
00252                 cache_inode_status_t kill_status ;
00253 
00254                 DisplayLog( <span class="stringliteral">"cache_inode_remove: Stale FSAL FH detected for pentry %p"</span>, pentry ) ;
00255 
00256                 <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS ) 
00257                   DisplayLog( <span class="stringliteral">"cache_inode_remove: Could not kill entry %p, status = %u"</span>, pentry, kill_status ) ;
00258 
00259                 *pstatus = CACHE_INODE_FSAL_ESTALE ;
00260             }
00261 
00262           *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00263           <span class="keywordflow">if</span>( use_mutex )
00264             V( pentry-&gt;lock ) ;
00265           <span class="keywordflow">return</span> *pstatus ;
00266         }
00267     }
00268   <span class="keywordflow">else</span>
00269     {
00270       <span class="keywordflow">if</span>( use_mutex )
00271         V( pentry-&gt;lock ) ;
00272       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_REMOVE] += 1 ;
00273       <span class="keywordflow">return</span> status ;
00274     }
00275 
00276   <span class="comment">/* Remove the entry from parent dir_entries array */</span>
00277   <a class="code" href="cache__inode__readdir_8c.html#a3">cache_inode_remove_cached_dirent</a>( pentry, 
00278                                     pnode_name, 
00279                                     ht, 
00280                                     pclient, 
00281                                     &amp;status )  ;
00282   
00283   DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, 
00284                      <span class="stringliteral">"cache_inode_remove_cached_dirent: status=%d"</span>, status ) ;
00285 
00286   <span class="comment">/* Update the cached attributes */</span>
00287   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_BEGINNING )
00288     {
00289       pentry-&gt;object.dir_begin.attributes = after_attr ;
00290     }
00291   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_CONTINUE )
00292     {
00293       <span class="keywordflow">if</span>( use_mutex )
00294         P( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00295 
00296       pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.attributes = after_attr ;
00297 
00298       <span class="keywordflow">if</span>( use_mutex )
00299         V( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00300     }
00301   
00302 
00303   <span class="comment">/* Update the attributes for the removed entry */</span>
00304   <span class="keywordflow">if</span>( use_mutex )
00305     P( to_remove_entry-&gt;lock ) ;
00306   <span class="keywordflow">if</span>( remove_attr.type != FSAL_TYPE_DIR )
00307     {
00308       <span class="keywordflow">if</span>( remove_attr.numlinks &gt; 1 )
00309         {
00310           <span class="keywordflow">switch</span>( to_remove_entry-&gt;internal_md.type )
00311             {
00312             <span class="keywordflow">case</span> SYMBOLIC_LINK:
00313               to_remove_entry-&gt;object.symlink.attributes.numlinks -= 1 ;
00314               to_remove_entry-&gt;object.symlink.attributes.ctime.seconds = time( NULL ) ;
00315               to_remove_entry-&gt;object.symlink.attributes.ctime.nseconds = 0 ;
00316               to_remove_numlinks = to_remove_entry-&gt;object.symlink.attributes.numlinks ;
00317               break ;
00318 
00319             <span class="keywordflow">case</span> REGULAR_FILE:
00320               to_remove_entry-&gt;object.file.attributes.numlinks -= 1 ;
00321               to_remove_entry-&gt;object.file.attributes.ctime.seconds = time( NULL ) ;
00322               to_remove_entry-&gt;object.file.attributes.ctime.nseconds = 0 ;
00323               to_remove_numlinks = to_remove_entry-&gt;object.file.attributes.numlinks ;
00324               break ;
00325               
00326             <span class="keywordflow">case</span> CHARACTER_FILE:
00327             <span class="keywordflow">case</span> BLOCK_FILE:
00328             <span class="keywordflow">case</span> SOCKET_FILE:
00329             <span class="keywordflow">case</span> FIFO_FILE:
00330               to_remove_entry-&gt;object.special_obj.attributes.numlinks -= 1 ;
00331               to_remove_entry-&gt;object.special_obj.attributes.ctime.seconds = time( NULL ) ;
00332               to_remove_entry-&gt;object.special_obj.attributes.ctime.nseconds = 0 ;
00333               to_remove_numlinks = to_remove_entry-&gt;object.special_obj.attributes.numlinks ;
00334               break ;
00335               
00336             <span class="keywordflow">default</span>:
00337               <span class="comment">/* Other objects should not be hard linked */</span>
00338               <span class="keywordflow">if</span>( use_mutex )
00339                 V( to_remove_entry-&gt;lock ) ;
00340               *pstatus = CACHE_INODE_BAD_TYPE ;
00341               <span class="keywordflow">return</span> *pstatus ;
00342               break ;
00343             }
00344         }
00345     }
00346   <span class="keywordflow">else</span>
00347     {
00348       <span class="comment">/* No hardlink counter to be decremented for a directory: hardlink are not allowed for them */</span>
00349     }
00350   
00351   <span class="comment">/* Now, delete "to_remove_entry" from the cache inode and free its associated resources, but only if numlinks == 0 */</span>
00352   <span class="keywordflow">if</span>( to_remove_numlinks == 0 )
00353     {
00354 
00355      <span class="comment">/* If pentry is a regular file, data cached, the related data cache entry should be removed as well */</span>
00356      <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type == REGULAR_FILE )
00357       {
00358         <span class="keywordflow">if</span>( to_remove_entry-&gt;object.file.pentry_content != NULL )
00359          {
00360             <span class="comment">/* Something is to be deleted, release the cache data entry */</span>
00361             <span class="keywordflow">if</span>( cache_content_release_entry( (cache_content_entry_t  *)to_remove_entry-&gt;object.file.pentry_content ,
00362                                              (cache_content_client_t *)pclient-&gt;pcontent_client,
00363                                              &amp;cache_content_status )  != CACHE_CONTENT_SUCCESS )
00364               {
00365                 DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_EVENT, 
00366                                    <span class="stringliteral">"pentry %p, named %s could not be released from data cache, status=%d"</span>,
00367                                     to_remove_entry, pnode_name-&gt;name, cache_content_status ) ;  
00368               }
00369          }
00370       }
00371 
00372       <span class="keywordflow">if</span>( ( pfsal_handle_remove =  <a class="code" href="cache__inode__misc_8c.html#a10">cache_inode_get_fsal_handle</a>( to_remove_entry, pstatus ) ) == NULL )
00373         {
00374           <span class="keywordflow">if</span>( use_mutex )
00375             V( to_remove_entry-&gt;lock ) ;
00376           
00377           <span class="keywordflow">return</span> *pstatus ;
00378         }
00379       
00380       <span class="comment">/* Invalidate the related LRU gc entry (no more required) */</span>
00381       <span class="keywordflow">if</span>( to_remove_entry-&gt;gc_lru_entry != NULL )
00382         {
00383           <span class="keywordflow">if</span>( LRU_invalidate( to_remove_entry-&gt;gc_lru, to_remove_entry-&gt;gc_lru_entry ) != LRU_LIST_SUCCESS )
00384             {
00385               *pstatus = CACHE_INODE_LRU_ERROR ;
00386               
00387               <span class="keywordflow">return</span> *pstatus ;
00388             }
00389         }
00390       
00391       <span class="comment">/* delete the entry from the cache */</span>
00392       fsaldata.handle = *pfsal_handle_remove ;
00393       <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type !=  DIR_CONTINUE )
00394         fsaldata.cookie = DIR_START ;
00395       <span class="keywordflow">else</span>
00396         fsaldata.cookie = to_remove_entry-&gt;object.dir_cont.dir_cont_pos ;
00397       
00398       <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a1">cache_inode_fsaldata_2_key</a>( &amp;key, &amp;fsaldata, pclient ) )
00399         {
00400           <span class="keywordflow">if</span>( use_mutex )
00401             {
00402               V( to_remove_entry-&gt;lock ) ;
00403               V( pentry-&gt;lock ) ;
00404             }
00405           
00406           *pstatus =  CACHE_INODE_INCONSISTENT_ENTRY ;
00407           
00408           <span class="keywordflow">return</span> *pstatus ;
00409         }
00410       
00411       <span class="comment">/* use the key to delete the entry */</span>
00412       <span class="keywordflow">if</span>( ( rc = HashTable_Del( ht, &amp;key, &amp;old_key, &amp;old_value ) ) != HASHTABLE_SUCCESS )
00413         {
00414           <span class="keywordflow">if</span>( use_mutex )
00415             {
00416               V( to_remove_entry-&gt;lock ) ;
00417               V( pentry-&gt;lock ) ;
00418             }
00419           <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient ) ;
00420           
00421           *pstatus =  CACHE_INODE_INCONSISTENT_ENTRY ;
00422           
00423           <span class="keywordflow">return</span> *pstatus ;
00424         }
00425       
00426       <span class="comment">/* release the key that was stored in hash table */</span>
00427       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;old_key, pclient ) ;
00428       
00429       <span class="comment">/* Sanity check: old_value.pdata is expected to be equal to pentry,</span>
00430 <span class="comment">       * and is released later in this function */</span>
00431       <span class="keywordflow">if</span> ( (cache_entry_t*)old_value.pdata != to_remove_entry )
00432       {
00433            DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
00434                              <span class="stringliteral">"cache_inode_remove: unexpected pdata %p from hash table (pentry=%p)"</span>,
00435                               old_value.pdata, to_remove_entry ) ;
00436       }      
00437       
00438       <span class="comment">/* release the key used for hash query */</span>
00439       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient ) ;
00440 
00441       <span class="comment">/* If entry is a DIR_CONTINUE or a DIR_BEGINNING, release pdir_data */</span>
00442       <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type == DIR_BEGINNING )
00443         {
00444           <span class="comment">/* Put the pentry back to the pool */</span>
00445           RELEASE_PREALLOC( to_remove_entry-&gt;object.dir_begin.pdir_data, pclient-&gt;pool_dir_data, next_alloc ) ;
00446         }
00447       
00448       <span class="keywordflow">if</span>( to_remove_entry-&gt;internal_md.type == DIR_CONTINUE )
00449         {
00450           <span class="comment">/* Put the pentry back to the pool */</span>
00451           RELEASE_PREALLOC( to_remove_entry-&gt;object.dir_cont.pdir_data, pclient-&gt;pool_dir_data, next_alloc ) ;
00452         }
00453       
00454       <span class="comment">/* Put the pentry back to pool */</span>
00455       <span class="keywordflow">if</span>( use_mutex )
00456         V( to_remove_entry-&gt;lock );
00457       
00458       <span class="comment">/* Destroy the mutex associated with the pentry */</span>
00459       <a class="code" href="cache__inode__misc_8c.html#a12">cache_inode_mutex_destroy</a>( to_remove_entry ) ;
00460       
00461       RELEASE_PREALLOC( to_remove_entry, pclient-&gt;pool_entry, next_alloc ) ;
00462     }
00463   
00464   <span class="comment">/* Validate the entries */</span>
00465   *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry, CACHE_INODE_OP_SET, pclient ) ;  
00466 
00467   <span class="comment">/* Regular exit */</span>
00468   <span class="keywordflow">if</span>( use_mutex )
00469     {
00470       <span class="keywordflow">if</span>( to_remove_numlinks != 0 )
00471         V( to_remove_entry-&gt;lock ) ; <span class="comment">/* This was not release yet, it should be done here */</span>
00472 
00473       V( pentry-&gt;lock ) ;
00474     }  
00475   
00476   <span class="keywordflow">if</span>( status == CACHE_INODE_SUCCESS )
00477     pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_REMOVE] += 1 ;
00478   <span class="keywordflow">else</span>
00479     pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_REMOVE] += 1 ;
00480   
00481   <span class="keywordflow">return</span> status ;
00482 } <span class="comment">/* cache_inode_remove */</span>
00483 
<a name="l00502"></a><a class="code" href="cache__inode__remove_8c.html#a3">00502</a> cache_inode_status_t <a class="code" href="cache__inode__remove_8c.html#a3">cache_inode_remove_no_mutex</a>( cache_entry_t        * pentry,     
00503                                                   fsal_name_t          * pnode_name,
00504                                                   fsal_attrib_list_t   * pattr,
00505                                                   hash_table_t         * ht,  
00506                                                   cache_inode_client_t * pclient, 
00507                                                   fsal_op_context_t          * pcontext, 
00508                                                   cache_inode_status_t * pstatus )
00509 {
00510   <span class="keywordflow">return</span> <a class="code" href="cache__inode__remove_8c.html#a2">cache_inode_remove_sw</a>( pentry,
00511                                 pnode_name,
00512                                 pattr,
00513                                 ht,
00514                                 pclient,
00515                                 pcontext,
00516                                 pstatus, 
00517                                 FALSE ) ;
00518 } <span class="comment">/* cache_inode_remove_no_mutex */</span>
00519 
00520 
<a name="l00539"></a><a class="code" href="cache__inode__remove_8c.html#a4">00539</a> cache_inode_status_t <a class="code" href="cache__inode__remove_8c.html#a4">cache_inode_remove</a>( cache_entry_t        * pentry,     
00540                                          fsal_name_t          * pnode_name,
00541                                          fsal_attrib_list_t   * pattr,
00542                                          hash_table_t         * ht,  
00543                                          cache_inode_client_t * pclient, 
00544                                          fsal_op_context_t          * pcontext, 
00545                                          cache_inode_status_t * pstatus )
00546 {
00547   <span class="keywordflow">return</span> <a class="code" href="cache__inode__remove_8c.html#a2">cache_inode_remove_sw</a>( pentry,
00548                                 pnode_name,
00549                                 pattr,
00550                                 ht,
00551                                 pclient,
00552                                 pcontext,
00553                                 pstatus, 
00554                                 TRUE ) ;
00555 } <span class="comment">/* cache_inode_remove_no_mutex */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:52 2008 for Cache inode layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
