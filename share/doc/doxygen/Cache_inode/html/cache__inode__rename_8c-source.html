<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Cache inode layer: cache_inode_rename.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cache_inode_rename.c</h1><a href="cache__inode__rename_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00086 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 
00091 <span class="preprocessor">#include "LRU_List.h"</span>
00092 <span class="preprocessor">#include "log_functions.h"</span>
00093 <span class="preprocessor">#include "HashData.h"</span>
00094 <span class="preprocessor">#include "HashTable.h"</span>
00095 <span class="preprocessor">#include "fsal.h"</span>
00096 <span class="preprocessor">#include "cache_inode.h"</span>
00097 
00098 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00099 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00100 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00101 <span class="preprocessor">#include &lt;time.h&gt;</span>
00102 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00103 
00104 
<a name="l00122"></a><a class="code" href="cache__inode__rename_8c.html#a0">00122</a> cache_inode_status_t <a class="code" href="cache__inode__rename_8c.html#a0">cache_inode_rename_cached_dirent</a>( cache_entry_t        * pentry_parent,
00123                                                        fsal_name_t          * oldname,
00124                                                        fsal_name_t          * newname,
00125                                                        hash_table_t         * ht,
00126                                                        cache_inode_client_t * pclient,
00127                                                        cache_inode_status_t * pstatus )
00128 {
00129   cache_entry_t              * removed_pentry = NULL ;
00130   cache_inode_parent_entry_t * parent_iter    = NULL ;
00131   cache_inode_parent_entry_t * previous_iter  = NULL ;
00132   <span class="keywordtype">int</span>                          found          = 0 ;
00133 
00134   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00135   *pstatus = CACHE_INODE_SUCCESS ;
00136 
00137   <span class="comment">/* Sanity check */</span>
00138   <span class="keywordflow">if</span>( pentry_parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00139       pentry_parent-&gt;internal_md.type != DIR_CONTINUE )
00140     {
00141       *pstatus = CACHE_INODE_BAD_TYPE ;
00142       <span class="keywordflow">return</span> *pstatus ;
00143     }
00144 
00145   <span class="comment">/* BUGAZOMEU: Ne pas oublier de jarter un dir_cont dont toutes les entrees sont inactives */</span>
00146   <span class="keywordflow">if</span>( ( removed_pentry = <a class="code" href="cache__inode__readdir_8c.html#a0">cache_inode_operate_cached_dirent</a>( pentry_parent,
00147                                                             oldname,
00148                                                             newname,
00149                                                             CACHE_INODE_DIRENT_OP_RENAME,
00150                                                             pstatus ) ) == NULL )
00151     <span class="keywordflow">return</span> *pstatus ;
00152 
00153 
00154   <span class="keywordflow">return</span> *pstatus ;
00155 } <span class="comment">/* cache_inode_rename_cached_dirent */</span>
00156  
<a name="l00179"></a><a class="code" href="cache__inode__rename_8c.html#a1">00179</a> cache_inode_status_t <a class="code" href="cache__inode__rename_8c.html#a1">cache_inode_rename</a>( cache_entry_t           * pentry_dirsrc,
00180                                          fsal_name_t             * poldname,
00181                                          cache_entry_t           * pentry_dirdest, 
00182                                          fsal_name_t             * pnewname, 
00183                                          fsal_attrib_list_t      * pattr_src, 
00184                                          fsal_attrib_list_t      * pattr_dst, 
00185                                          hash_table_t            * ht,
00186                                          cache_inode_client_t    * pclient,
00187                                          fsal_op_context_t       * pcontext, 
00188                                          cache_inode_status_t    * pstatus)
00189 {
00190   cache_inode_status_t    status ;
00191   fsal_status_t           fsal_status ;
00192   cache_entry_t         * pentry_lookup_src  = NULL ;
00193   cache_entry_t         * pentry_lookup_dest = NULL ;
00194   fsal_attrib_list_t      attrlookup ;
00195   fsal_attrib_list_t    * pattrsrc ;
00196   fsal_attrib_list_t    * pattrdest ;
00197   fsal_handle_t         * phandle_dirsrc ;
00198   fsal_handle_t         * phandle_dirdest ;
00199   
00200   <span class="keywordtype">int</span> do_remove = FALSE;
00201 
00202   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00203   *pstatus = CACHE_INODE_SUCCESS ;
00204   
00205    <span class="comment">/* stats */</span>
00206   pclient-&gt;stat.nb_call_total += 1 ;
00207   pclient-&gt;stat.func_stats.nb_call[CACHE_INODE_RENAME] += 1 ;
00208   
00209   <span class="comment">/* Are we working on directories ? */</span>
00210   <span class="keywordflow">if</span>( ( pentry_dirsrc-&gt;internal_md.type != DIR_BEGINNING &amp;&amp; pentry_dirsrc-&gt;internal_md.type != DIR_CONTINUE ) ||
00211       ( pentry_dirdest-&gt;internal_md.type != DIR_BEGINNING &amp;&amp; pentry_dirdest-&gt;internal_md.type != DIR_CONTINUE ) )
00212     {
00213       <span class="comment">/* Bad type .... */</span>
00214       *pstatus = CACHE_INODE_BAD_TYPE ;
00215       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00216 
00217       <span class="keywordflow">return</span> *pstatus ;
00218     }
00219     
00220     
00221   <span class="comment">/* Must take locks on directories now,</span>
00222 <span class="comment">   * because if another thread checks source and destination existence</span>
00223 <span class="comment">   * in the same time, it will try to do the same checks...</span>
00224 <span class="comment">   * and it will have the same conclusion !!!</span>
00225 <span class="comment">   */</span>
00226     
00227   <span class="comment">/* Get the locks on bot pentry. If the same if used twice (as src and dest), take only one lock.</span>
00228 <span class="comment">   * Lock are acquired has their related pentry are allocated (to avoid deadlocks) */</span>
00229   <span class="keywordflow">if</span>( pentry_dirsrc == pentry_dirdest )
00230     P( pentry_dirsrc-&gt;lock ) ;
00231   <span class="keywordflow">else</span>
00232     {
00233       <span class="keywordflow">if</span>( pentry_dirsrc &lt; pentry_dirdest )
00234         {
00235            P( pentry_dirsrc-&gt;lock ) ;
00236            P( pentry_dirdest-&gt;lock ) ;
00237         }
00238       <span class="keywordflow">else</span>
00239         {
00240           P( pentry_dirdest-&gt;lock ) ;
00241           P( pentry_dirsrc-&gt;lock ) ;
00242         }
00243     }
00244 
00245             
00246     
00247   <span class="comment">/* Check for object existence in source directory */</span>
00248   <span class="keywordflow">if</span>( ( pentry_lookup_src = <a class="code" href="cache__inode__lookup_8c.html#a1">cache_inode_lookup_no_mutex</a>( pentry_dirsrc, 
00249                                                          poldname, 
00250                                                          &amp;attrlookup, 
00251                                                          ht,
00252                                                          pclient,
00253                                                          pcontext,
00254                                                          pstatus ) ) == NULL )
00255     {
00256       <span class="comment">/* Source object does not exist */</span>
00257       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00258     
00259       <span class="comment">/* If FSAL FH is staled, then this was managed in cache_inode_lookup */</span> 
00260       <span class="keywordflow">if</span>( *pstatus != CACHE_INODE_FSAL_ESTALE )  
00261         *pstatus = CACHE_INODE_NOT_FOUND ;
00262       
00263       V( pentry_dirsrc-&gt;lock ) ;          
00264       <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00265         {
00266           V( pentry_dirdest-&gt;lock ) ;
00267         }
00268 
00269       <span class="keywordflow">if</span>( *pstatus != CACHE_INODE_FSAL_ESTALE ) 
00270         DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : source doesn't exist"</span>,
00271                           pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00272       <span class="keywordflow">else</span>
00273         DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename : stale source"</span> ) ;
00274 
00275       
00276       <span class="keywordflow">return</span> *pstatus ;
00277     }
00278       
00279   <span class="comment">/* Check if an object with the new name exists in the destination directory */</span>
00280   <span class="keywordflow">if</span>( ( pentry_lookup_dest = <a class="code" href="cache__inode__lookup_8c.html#a1">cache_inode_lookup_no_mutex</a>( pentry_dirdest, 
00281                                                           pnewname, 
00282                                                           &amp;attrlookup,
00283                                                           ht,
00284                                                           pclient,
00285                                                           pcontext,
00286                                                           pstatus ) ) != NULL )
00287     {
00288       
00289       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : destination already exists"</span>,
00290                          pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00291             
00292       <span class="comment">/* If the already existing object is a directory, source object should ne a directory */</span>
00293       <span class="keywordflow">if</span>( pentry_lookup_dest-&gt;internal_md.type == DIR_BEGINNING &amp;&amp;
00294           pentry_lookup_src-&gt;internal_md.type != DIR_BEGINNING )
00295         {
00296           V( pentry_dirsrc-&gt;lock ) ;          
00297           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00298             {
00299               V( pentry_dirdest-&gt;lock ) ;
00300             }
00301           
00302           <span class="comment">/* Return EISDIR */</span>
00303           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00304           *pstatus = CACHE_INODE_IS_A_DIRECTORY ;
00305           
00306           <span class="keywordflow">return</span> *pstatus ;
00307         }
00308       
00309       <span class="keywordflow">if</span>( pentry_lookup_dest-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00310           pentry_lookup_src-&gt;internal_md.type == DIR_BEGINNING )
00311         {
00312           <span class="comment">/* Return ENOTDIR */</span>
00313           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00314           *pstatus = CACHE_INODE_NOT_A_DIRECTORY ;
00315 
00316           V( pentry_dirsrc-&gt;lock ) ;          
00317           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00318             {
00319               V( pentry_dirdest-&gt;lock ) ;
00320             }
00321 
00322           <span class="keywordflow">return</span> *pstatus ;
00323         }
00324 
00325       <span class="comment">/* If caller wants to rename a file on himself, let it do it: return CACHE_INODE_SUCCESS but do nothing */</span>
00326       <span class="keywordflow">if</span>( pentry_lookup_dest == pentry_lookup_src )
00327         {
00328           <span class="comment">/* There is in fact only one file (may be one of the arguments is a hard link to the other) */</span>
00329           
00330           <span class="comment">/* Return SUCCESS */</span>
00331           pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_RENAME] += 1 ;          
00332           *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry_dirdest, CACHE_INODE_OP_SET, pclient ) ;  
00333           
00334           V( pentry_dirsrc-&gt;lock ) ;          
00335           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00336             {
00337               V( pentry_dirdest-&gt;lock ) ;
00338             }
00339                     
00340           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : rename the object on itself"</span>,
00341                              pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00342 
00343           <span class="keywordflow">return</span> *pstatus ;
00344         }
00345 
00346       <span class="comment">/* Entry with the newname exists, if it is a non-empty directory, operation cannot be performed */</span>
00347       <span class="keywordflow">if</span>( ( pentry_lookup_dest-&gt;internal_md.type == DIR_BEGINNING ) &amp;&amp;
00348           ( <a class="code" href="cache__inode__remove_8c.html#a0">cache_inode_is_dir_empty</a>( pentry_lookup_dest ) != CACHE_INODE_SUCCESS ) )
00349         {
00350           <span class="comment">/* The entry is a non-empty directory */</span>
00351           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00352           *pstatus = CACHE_INODE_DIR_NOT_EMPTY  ;
00353          
00354           V( pentry_dirsrc-&gt;lock ) ;          
00355           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00356             {
00357               V( pentry_dirdest-&gt;lock ) ;
00358             }
00359           
00360           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : destination is a non-empty directory"</span>,
00361                              pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00362           <span class="keywordflow">return</span> *pstatus ;
00363         }
00364         
00365     
00366       <span class="comment">/* get ride of this entry by trying removing it */</span>
00367 
00368       status = <a class="code" href="cache__inode__remove_8c.html#a3">cache_inode_remove_no_mutex</a>(  pentry_dirdest, 
00369                                              pnewname, 
00370                                              &amp;attrlookup, 
00371                                              ht, 
00372                                              pclient, 
00373                                              pcontext, 
00374                                              pstatus ) ;
00375       <span class="keywordflow">if</span>( status != CACHE_INODE_SUCCESS )
00376         {
00377           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00378           *pstatus = status ;
00379 
00380           V( pentry_dirsrc-&gt;lock ) ;          
00381           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00382             {
00383               V( pentry_dirdest-&gt;lock ) ;
00384             }
00385 
00386           <span class="keywordflow">return</span> *pstatus ;
00387         }
00388            
00389     } <span class="comment">/* if( pentry_lookup_dest != NULL ) */</span>
00390   <span class="keywordflow">else</span>
00391    {
00392      <span class="keywordflow">if</span>( *pstatus == CACHE_INODE_FSAL_ESTALE )
00393       {
00394         DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename : stale destnation"</span> ) ;
00395 
00396         
00397         V( pentry_dirsrc-&gt;lock ) ;
00398         <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00399           {
00400              V( pentry_dirdest-&gt;lock ) ;
00401           }
00402 
00403         <span class="keywordflow">return</span> *pstatus ;
00404       }
00405    }
00406  
00407     
00408   <span class="comment">/* Get the handle for the dirsrc pentry */</span>
00409     
00410   <span class="keywordflow">if</span>( pentry_dirsrc-&gt;internal_md.type == DIR_BEGINNING )
00411     {
00412       phandle_dirsrc = &amp;pentry_dirsrc-&gt;object.dir_begin.handle ;
00413       pattrsrc = &amp;pentry_dirsrc-&gt;object.dir_begin.attributes ;
00414     }
00415   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pentry_dirsrc-&gt;internal_md.type == DIR_CONTINUE )
00416     {
00417       P( pentry_dirsrc-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00418 
00419       phandle_dirsrc = &amp;pentry_dirsrc-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.handle ;
00420       pattrsrc = &amp;pentry_dirsrc-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.attributes ;
00421 
00422       V( pentry_dirsrc-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00423     }
00424   <span class="keywordflow">else</span>
00425     {
00426       *pstatus = CACHE_INODE_BAD_TYPE ;
00427       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00428 
00429       V( pentry_dirsrc-&gt;lock ) ;          
00430       <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00431         {
00432           V( pentry_dirdest-&gt;lock ) ;
00433         }
00434 
00435       <span class="keywordflow">return</span> *pstatus ;
00436     }
00437 
00438     
00439   <span class="comment">/* Get the handle for the dirdest pentry */</span>
00440     
00441   <span class="keywordflow">if</span>( pentry_dirdest-&gt;internal_md.type == DIR_BEGINNING )
00442     {
00443       phandle_dirdest = &amp;pentry_dirdest-&gt;object.dir_begin.handle ;
00444       pattrdest = &amp;pentry_dirdest-&gt;object.dir_begin.attributes ;
00445     }
00446   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( pentry_dirdest-&gt;internal_md.type == DIR_CONTINUE )
00447     {
00448       P( pentry_dirdest-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00449 
00450       phandle_dirdest = &amp;pentry_dirdest-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.handle ;
00451       pattrdest = &amp;pentry_dirdest-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.attributes ;
00452       
00453       V( pentry_dirdest-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00454     }
00455   <span class="keywordflow">else</span>
00456     {
00457       V( pentry_dirsrc-&gt;lock ) ;          
00458       <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00459         {
00460           V( pentry_dirdest-&gt;lock ) ;
00461         }
00462 
00463       *pstatus = CACHE_INODE_BAD_TYPE ;
00464       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00465 
00466       V( pentry_dirsrc-&gt;lock ) ;
00467       <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00468         V( pentry_dirdest-&gt;lock ) ;
00469               
00470       <span class="keywordflow">return</span> *pstatus ;
00471     }
00472     
00473     
00474         
00475     <span class="comment">/* Perform the rename operation in FSAL,</span>
00476 <span class="comment">     * before doing anything in the cache.</span>
00477 <span class="comment">     * Indeed, if the FSAL_rename fails unexpectly,</span>
00478 <span class="comment">     * the cache would be inconsistent !</span>
00479 <span class="comment">     */</span>
00480     fsal_status = FSAL_rename( phandle_dirsrc, 
00481                                poldname, 
00482                                phandle_dirdest, 
00483                                pnewname, 
00484                                pcontext, 
00485                                pattrsrc, 
00486                                pattrdest ) ;
00487     <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00488       {
00489         *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00490         pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00491 
00492         V( pentry_dirsrc-&gt;lock ) ;          
00493         <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00494           {
00495             V( pentry_dirdest-&gt;lock ) ;
00496           }
00497 
00498         <span class="keywordflow">if</span>( fsal_status.major == ERR_FSAL_STALE )
00499           {
00500              cache_inode_status_t kill_status ;
00501              fsal_status_t        getattr_status ;
00502 
00503              DisplayLog( <span class="stringliteral">"cache_inode_rename: Stale FSAL File Handle detected for at least one in  pentry = %p and pentry = %p"</span>, 
00504                         pentry_dirsrc, pentry_dirdest ) ;
00505 
00506            <span class="comment">/* Use FSAL_getattrs to find which entry is staled */</span>
00507            getattr_status = FSAL_getattrs(  phandle_dirsrc, pcontext, &amp;attrlookup ) ;
00508            <span class="keywordflow">if</span>( getattr_status.major == ERR_FSAL_ACCESS )
00509             {
00510                DisplayLog( <span class="stringliteral">"cache_inode_rename: Stale FSAL File Handle detected for pentry = %p"</span>, pentry_dirsrc ) ;
00511 
00512                 <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry_dirsrc, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
00513                     DisplayLog( <span class="stringliteral">"cache_inode_rename: Could not kill entry %p, status = %u"</span>, pentry_dirsrc, kill_status ) ;
00514             }           
00515 
00516            getattr_status = FSAL_getattrs(  phandle_dirdest, pcontext, &amp;attrlookup ) ;
00517            <span class="keywordflow">if</span>( getattr_status.major == ERR_FSAL_ACCESS )
00518             {
00519                DisplayLog( <span class="stringliteral">"cache_inode_rename: Stale FSAL File Handle detected for pentry = %p"</span>, pentry_dirdest ) ;
00520 
00521                 <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry_dirdest, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
00522                     DisplayLog( <span class="stringliteral">"cache_inode_rename: Could not kill entry %p, status = %u"</span>, pentry_dirdest, kill_status ) ;
00523             }           
00524        
00525            *pstatus = CACHE_INODE_FSAL_ESTALE ;
00526         
00527           }
00528 
00529         <span class="keywordflow">return</span> *pstatus ;
00530       }
00531 
00532     <span class="comment">/* Manage the returned attributes */</span>
00533     <span class="keywordflow">if</span>( pattr_src != NULL )
00534       *pattr_src = *pattrsrc ;
00535 
00536     <span class="keywordflow">if</span>( pattr_dst != NULL )
00537       *pattr_dst = *pattrdest ;
00538 
00539     
00540     
00541   <span class="comment">/* At this point, we know that:</span>
00542 <span class="comment">   *  - both pentry_dir_src and pentry_dir_dest are directories </span>
00543 <span class="comment">   *  - pentry_dir_src/oldname exists</span>
00544 <span class="comment">   *  - pentry_dir_dest/newname does not exists or has just been removed */</span>
00545  
00546  <span class="keywordflow">if</span>( pentry_dirsrc == pentry_dirdest )
00547     { 
00548        <span class="comment">/* if the rename operation is made within the same dir, then we use an optimization:</span>
00549 <span class="comment">        * cache_inode_rename_dirent is used instead of adding/removing dirent. This limits</span>
00550 <span class="comment">        * the use of resource in this case */</span>
00551 
00552       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : source and target directory are the same"</span>,
00553                          pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00554 
00555       status = <a class="code" href="cache__inode__rename_8c.html#a0">cache_inode_rename_cached_dirent</a>( pentry_dirdest, 
00556                                                  poldname,
00557                                                  pnewname,
00558                                                  ht,
00559                                                  pclient,
00560                                                  pstatus ) ;
00561 
00562       <span class="keywordflow">if</span>( status != CACHE_INODE_SUCCESS )
00563        {
00564           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00565           *pstatus = status ;
00566         
00567           <span class="comment">/* Unlock the pentry and exists */</span> 
00568           V( pentry_dirsrc-&gt;lock ) ;          
00569       
00570           <span class="keywordflow">return</span> *pstatus ;
00571         }
00572     }
00573   <span class="keywordflow">else</span>
00574     { 
00575       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"Rename (%p,%s)-&gt;(%p,%s) : moving entry"</span>,
00576                          pentry_dirsrc, poldname-&gt;name, pentry_dirdest, pnewname-&gt;name );
00577 
00578       
00579       <span class="comment">/* Add the new entry */</span>
00580       status = <a class="code" href="cache__inode__readdir_8c.html#a1">cache_inode_add_cached_dirent</a>( pentry_dirdest, 
00581                                               pnewname, 
00582                                               pentry_lookup_src, 
00583                                               NULL, 
00584                                               ht, 
00585                                               pclient, 
00586                                               pcontext, 
00587                                               pstatus ) ;
00588       <span class="keywordflow">if</span>( status != CACHE_INODE_SUCCESS )
00589         {
00590           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00591           *pstatus = status ;
00592       
00593       
00594           V( pentry_dirsrc-&gt;lock ) ;          
00595           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00596             {
00597               V( pentry_dirdest-&gt;lock ) ;
00598             }
00599       
00600           <span class="keywordflow">return</span> *pstatus ;
00601         }
00602 
00603       <span class="comment">/* Remove the old entry */</span>
00604       <span class="keywordflow">if</span>( <a class="code" href="cache__inode__readdir_8c.html#a3">cache_inode_remove_cached_dirent</a>( pentry_dirsrc, 
00605                                             poldname, 
00606                                             ht, 
00607                                             pclient, 
00608                                             &amp;status ) != CACHE_INODE_SUCCESS )
00609         {
00610           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_RENAME] += 1 ;
00611           *pstatus = status ;
00612       
00613           V( pentry_dirsrc-&gt;lock ) ;          
00614           <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00615             {
00616               V( pentry_dirdest-&gt;lock ) ;
00617             }
00618       
00619           <span class="keywordflow">return</span> *pstatus ;
00620         }
00621      }
00622        
00623     
00624   <span class="comment">/* Validate the entries */</span>
00625   *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry_dirsrc, CACHE_INODE_OP_SET, pclient ) ;  
00626 
00627   <span class="comment">/* stat */</span>
00628   <span class="keywordflow">if</span>( *pstatus != CACHE_INODE_SUCCESS )
00629     pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_RENAME] += 1 ;
00630   <span class="keywordflow">else</span>
00631     {
00632       *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry_dirdest, CACHE_INODE_OP_SET, pclient ) ;  
00633       
00634       <span class="keywordflow">if</span>( *pstatus != CACHE_INODE_SUCCESS )
00635         pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_RENAME] += 1 ;
00636       <span class="keywordflow">else</span>
00637         pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_RENAME] += 1 ;
00638     }
00639   
00640   <span class="comment">/* unlock entries */</span>
00641     
00642   V( pentry_dirsrc-&gt;lock ) ;          
00643   <span class="keywordflow">if</span>(  pentry_dirsrc !=  pentry_dirdest )
00644     {
00645       V( pentry_dirdest-&gt;lock ) ;
00646     }
00647 
00648   <span class="keywordflow">return</span> *pstatus ;
00649 } <span class="comment">/* cache_inode_rename */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:52 2008 for Cache inode layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
