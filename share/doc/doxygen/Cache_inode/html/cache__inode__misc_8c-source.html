<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Cache inode layer: cache_inode_misc.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cache_inode_misc.c</h1><a href="cache__inode__misc_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> * \File    cache_inode_misc.c</span>
00076 <span class="comment"> * \author  $Author: deniel $</span>
00077 <span class="comment"> * \date    $Date: 2006/01/05 15:14:51 $</span>
00078 <span class="comment"> * \version $Revision: 1.63 $</span>
00079 <span class="comment"> * \brief   Some routines for management of the cache_inode layer, shared by other calls. </span>
00080 <span class="comment"> *</span>
00081 <span class="comment"> * HashTable.c : Some routines for management of the cache_inode layer, shared by other calls. </span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> *</span>
00084 <span class="comment"> */</span>
00085 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00087 <span class="preprocessor">#endif</span>
00088 <span class="preprocessor"></span>
00089 <span class="preprocessor">#include "LRU_List.h"</span>
00090 <span class="preprocessor">#include "log_functions.h"</span>
00091 <span class="preprocessor">#include "HashData.h"</span>
00092 <span class="preprocessor">#include "HashTable.h"</span>
00093 <span class="preprocessor">#include "fsal.h"</span>
00094 <span class="preprocessor">#include "cache_inode.h"</span>
00095 <span class="preprocessor">#include "cache_content.h"</span>
00096 <span class="preprocessor">#include "stuff_alloc.h"</span>
00097 
00098 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00099 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00100 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00101 <span class="preprocessor">#include &lt;time.h&gt;</span>
00102 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00103 <span class="preprocessor">#include &lt;string.h&gt;</span>
00104 
00105 <span class="preprocessor">#ifdef _USE_PROXY</span>
00106 <span class="preprocessor"></span><span class="keywordtype">void</span> cache_inode_print_srvhandle( <span class="keywordtype">char</span> * comment, cache_entry_t * pentry ) ;
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
<a name="l00123"></a><a class="code" href="cache__inode__misc_8c.html#a0">00123</a> <span class="keywordtype">int</span> <a class="code" href="cache__inode__misc_8c.html#a0">cache_inode_compare_key_fsal</a>(  hash_buffer_t * buff1, hash_buffer_t * buff2 ) 
00124 {
00125   fsal_status_t             status;
00126   cache_inode_fsal_data_t * pfsdata1 = NULL ;
00127   cache_inode_fsal_data_t * pfsdata2 = NULL ;
00128   <span class="keywordtype">int</span>                       rc = 0 ;
00129   
00130   <span class="comment">/* Test if one of teh entries are NULL */</span>
00131   <span class="keywordflow">if</span>( buff1-&gt;pdata == NULL )
00132     <span class="keywordflow">return</span> ( buff2-&gt;pdata == NULL ) ? 0 : 1 ;
00133   <span class="keywordflow">else</span>
00134     {
00135       <span class="keywordflow">if</span>( buff2-&gt;pdata== NULL )
00136         <span class="keywordflow">return</span> -1 ; <span class="comment">/* left member is the greater one */</span>
00137       <span class="keywordflow">else</span>
00138         {
00139           <span class="keywordtype">int</span> rc ;
00140           pfsdata1 = (cache_inode_fsal_data_t *)(buff1-&gt;pdata) ;
00141           pfsdata2 = (cache_inode_fsal_data_t *)(buff2-&gt;pdata) ;
00142       
00143           rc = ( !FSAL_handlecmp( &amp;pfsdata1-&gt;handle, &amp;pfsdata2-&gt;handle, &amp;status)   
00144                  &amp;&amp;  ( pfsdata1-&gt;cookie == pfsdata2-&gt;cookie ) ) ? 0 : 1 ; 
00145 
00146           <span class="keywordflow">return</span> rc ;
00147         }
00148       
00149     }
00150   <span class="comment">/* This line should never be reached */</span>
00151 } <span class="comment">/* cache_inode_compare_key_fsal */</span>
00152 
<a name="l00168"></a><a class="code" href="cache__inode__misc_8c.html#a1">00168</a> <span class="keywordtype">int</span> <a class="code" href="cache__inode__misc_8c.html#a1">cache_inode_fsaldata_2_key</a>( hash_buffer_t * pkey, cache_inode_fsal_data_t * pfsdata, cache_inode_client_t  * pclient )
00169 {
00170   cache_inode_fsal_data_t * ppoolfsdata = NULL ;
00171   
00172   <span class="comment">/* Allocate a new key for storing data, if this a set, not a get</span>
00173 <span class="comment">   * in the case of a 'get' key, pclient == NULL and * pfsdata is used */</span>
00174 
00175 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00176 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00177   BuddySetDebugLabel( <span class="stringliteral">"cache_inode_fsal_data_t:conversion"</span> ) ;
00178 <span class="preprocessor">#endif</span>
00179 <span class="preprocessor"></span>
00180   <span class="keywordflow">if</span>( pclient != NULL )
00181     {
00182       GET_PREALLOC( ppoolfsdata, 
00183                     pclient-&gt;pool_key, 
00184                     pclient-&gt;nb_prealloc,  
00185                     cache_inode_fsal_data_t , 
00186                     next_alloc ) ;
00187       <span class="keywordflow">if</span>( ppoolfsdata == NULL )
00188         {
00189           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"Can't allocate a new key from cache pool"</span> ) ;
00190           <span class="keywordflow">return</span> 1 ;
00191         }
00192       
00193       *ppoolfsdata = *pfsdata ;
00194       
00195       pkey-&gt;pdata = (caddr_t)ppoolfsdata ;
00196     }
00197   <span class="keywordflow">else</span>
00198     pkey-&gt;pdata = (caddr_t)pfsdata ;
00199 
00200 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00201 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00202   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>  
00205   pkey-&gt;len = <span class="keyword">sizeof</span>( cache_inode_fsal_data_t ) ;
00206 
00207   <span class="keywordflow">return</span> 0 ;
00208 } <span class="comment">/* cache_inode_fsaldata_2_key */</span>
00209 
<a name="l00222"></a><a class="code" href="cache__inode__misc_8c.html#a2">00222</a> <span class="keywordtype">void</span> <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>(  hash_buffer_t * pkey, cache_inode_client_t  * pclient )
00223 {
00224   cache_inode_fsal_data_t * ppoolfsdata = NULL ;
00225 
00226   ppoolfsdata = (cache_inode_fsal_data_t *)pkey-&gt;pdata ;
00227 
00228   RELEASE_PREALLOC( ppoolfsdata, pclient-&gt;pool_key, next_alloc ) ; 
00229 } <span class="comment">/* cache_inode_release_fsaldata_key */</span>
00230 
<a name="l00252"></a><a class="code" href="cache__inode__misc_8c.html#a3">00252</a> cache_entry_t * <a class="code" href="cache__inode__misc_8c.html#a3">cache_inode_new_entry</a>( cache_inode_fsal_data_t  * pfsdata, 
00253                                        fsal_attrib_list_t       * pfsal_attr,
00254                                        cache_inode_file_type_t    type,
00255                                        cache_inode_create_arg_t * pcreate_arg, 
00256                                        cache_entry_t            * pentry_dir_prev,
00257                                        hash_table_t             * ht,
00258                                        cache_inode_client_t     * pclient,
00259                                        fsal_op_context_t        * pcontext, 
00260                                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               create_flag,
00261                                        cache_inode_status_t     * pstatus)
00262 { 
00263   pthread_mutexattr_t          mutexattr ;
00264   cache_entry_t              * pentry = NULL ;
00265   cache_inode_dir_data_t     * pdir_data = NULL ;
00266   hash_buffer_t                key, value ;
00267   fsal_attrib_list_t           fsal_attributes;
00268   cache_inode_parent_entry_t * pparent ;
00269   fsal_status_t                fsal_status ;
00270   LRU_status_t                 lru_status ;
00271   cache_content_status_t       cache_content_status ;
00272   <span class="keywordtype">int</span>                          i = 0 ;
00273   <span class="keywordtype">int</span>                          rc = 0 ;
00274   cache_inode_fsal_data_t    * ppoolfsdata = NULL ;
00275   off_t                        size_in_cache ; 
00276   <span class="keywordtype">char</span>                         cache_path_index[MAXPATHLEN] ;
00277 
00278   
00279 
00280  
00281   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00282   *pstatus = CACHE_INODE_SUCCESS ;
00283 
00284   <span class="comment">/* stat */</span>
00285   pclient-&gt;stat.nb_call_total += 1 ;
00286   pclient-&gt;stat.func_stats.nb_call[CACHE_INODE_NEW_ENTRY] += 1 ;
00287   
00288   <span class="comment">/* Turn the input to a hash key */</span>
00289   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a1">cache_inode_fsaldata_2_key</a>( &amp;key, pfsdata, NULL ) )
00290     {
00291       *pstatus = CACHE_INODE_UNAPPROPRIATED_KEY ;
00292 
00293       <span class="comment">/* stat */</span>
00294       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;     
00295       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient ) ;
00296 
00297       <span class="keywordflow">return</span> NULL ;
00298     }
00299 
00300   <span class="comment">/* Check if the entry doesn't already exists */</span>
00301   <span class="keywordflow">if</span>( HashTable_Get( ht, &amp;key, &amp;value ) == HASHTABLE_SUCCESS   )
00302     {
00303       <span class="comment">/* Entry is already in the cache, do not add it */</span>
00304       pentry = (cache_entry_t *)value.pdata ;
00305       *pstatus = CACHE_INODE_ENTRY_EXISTS ;
00306 
00307       <span class="comment">/* stat */</span>
00308       pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_NEW_ENTRY] += 1 ;
00309 
00310       <span class="keywordflow">return</span> pentry ;
00311     }
00312   
00313 
00314   <span class="comment">/* Init the lock attr */</span>
00315   <span class="keywordflow">if</span>( pthread_mutexattr_init( &amp;mutexattr ) != 0 )
00316     { 
00317       *pstatus = CACHE_INODE_INIT_ENTRY_FAILED ;
00318 
00319       <span class="comment">/* stat */</span>
00320       pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_NEW_ENTRY] += 1 ;
00321       <span class="keywordflow">return</span> NULL ;
00322     }
00323 
00324 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00325 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00326   BuddySetDebugLabel( <span class="stringliteral">"cache_entry_t"</span> ) ;
00327 <span class="preprocessor">#endif</span>
00328 <span class="preprocessor"></span>
00329   GET_PREALLOC( pentry, 
00330                 pclient-&gt;pool_entry, 
00331                 pclient-&gt;nb_prealloc, 
00332                 cache_entry_t, 
00333                 next_alloc ) ;
00334   <span class="keywordflow">if</span>( pentry == NULL )
00335     {
00336       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"Can't allocate a new entry from cache pool"</span> ) ;
00337       *pstatus = CACHE_INODE_MALLOC_ERROR ;
00338 
00339        <span class="comment">/* stat */</span>
00340       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00341 
00342       <span class="keywordflow">return</span> NULL ;
00343     }
00344 
00345 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00346 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00347   BuddySetDebugLabel( <span class="stringliteral">"cache_inode_parent_entry_t"</span> ) ;
00348 <span class="preprocessor">#endif</span>
00349 <span class="preprocessor"></span>
00350   <span class="comment">/* Allocate a client entry parent. Ath the pentry creation, there is only one parent. List is </span>
00351 <span class="comment">   * extended if hard links are made  */</span>
00352   GET_PREALLOC( pparent,  pclient-&gt;pool_parent, 
00353                 pclient-&gt;nb_pre_parent, 
00354                 cache_inode_parent_entry_t, next_alloc  )  ;
00355   <span class="keywordflow">if</span>( pparent == NULL )
00356     {
00357       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"cache_inode_new_entry: client parent allocation failed"</span> ) ;
00358       
00359       RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry, next_alloc ) ;
00360           
00361        <span class="comment">/* stat */</span>
00362       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00363       
00364       <span class="keywordflow">return</span> NULL ;
00365     }
00366  
00367   pentry-&gt;parent_list = pparent ;
00368   pentry-&gt;parent_list-&gt;next_parent = NULL ;
00369   pentry-&gt;parent_list-&gt;next_alloc  = NULL ;
00370 
00371 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00372 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00373   BuddySetDebugLabel( <span class="stringliteral">"cache_inode_dir_data_t"</span> ) ;
00374 <span class="preprocessor">#endif</span>
00375 <span class="preprocessor"></span>
00376   <span class="comment">/* if entry is of tyep DIR_CONTINUE or DIR_BEGINNING, it should have a pdir_data */</span>
00377   <span class="keywordflow">if</span>( type == DIR_BEGINNING || type == DIR_CONTINUE )
00378     {
00379       GET_PREALLOC( pdir_data,
00380                     pclient-&gt;pool_dir_data, 
00381                     pclient-&gt;nb_pre_dir_data,
00382                     cache_inode_dir_data_t,
00383                     next_alloc );
00384       <span class="keywordflow">if</span>( pdir_data == NULL )
00385         {
00386           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"Can't allocate a new dir_data from cache pool"</span> ) ;
00387           *pstatus = CACHE_INODE_MALLOC_ERROR ;
00388           
00389           <span class="comment">/* stat */</span>
00390       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00391       
00392       <span class="keywordflow">return</span> NULL ;
00393         }
00394 
00395       <span class="keywordflow">if</span>( type == DIR_BEGINNING )
00396         pentry-&gt;object.dir_begin.pdir_data = pdir_data ;
00397       <span class="keywordflow">else</span>
00398         pentry-&gt;object.dir_cont.pdir_data = pdir_data ;
00399     } <span class="comment">/*  if( type == DIR_BEGINNING || type == DIR_CONTINUE ) */</span>
00400    
00401 
00402 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00403 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00404   BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00405 <span class="preprocessor">#endif</span>
00406 <span class="preprocessor"></span>
00407   <span class="keywordflow">if</span>( pthread_mutex_init( &amp;(pentry-&gt;lock), &amp;mutexattr ) !=0 ) 
00408     {
00409       RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry, next_alloc ) ;
00410       DisplayErrorJd( pclient-&gt;log_outputs, ERR_SYS, ERR_PTHREAD_MUTEX_INIT, errno ) ;
00411       *pstatus = CACHE_INODE_INIT_ENTRY_FAILED ;
00412 
00413       <span class="comment">/* stat */</span>
00414       pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_NEW_ENTRY] += 1 ;
00415       
00416       <span class="keywordflow">return</span> NULL ;
00417     }
00418     
00419   <span class="comment">/* Call FSAL to get information about the object if not provided, except for DIR_CONTINUE </span>
00420 <span class="comment">   * that points to their DIR_BEGINNING .</span>
00421 <span class="comment">   * If attributes are provided as pfsal_attr parameter, use them. Call FSAL_getattrs otherwise. */</span>
00422   <span class="keywordflow">if</span>( pfsal_attr == NULL )
00423     {
00424       <span class="comment">/* No attributes are provided, use FSAL_getattrs to query them. */</span>
00425       <span class="keywordflow">if</span>( type != DIR_CONTINUE )
00426         {
00427           fsal_attributes.asked_attributes= pclient-&gt;attrmask  ; 
00428           fsal_status =  FSAL_getattrs( &amp;pfsdata-&gt;handle, pcontext, &amp;fsal_attributes ) ;
00429 
00430           <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00431             {
00432               <span class="comment">/* Put the entry back in its pool */</span>
00433               DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"cache_inode_new_entry: FSAL_getattrs failed"</span> ) ;
00434               RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00435               *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00436              
00437               <span class="keywordflow">if</span>( fsal_status.major == ERR_FSAL_STALE )
00438                 {
00439                   cache_inode_status_t kill_status ;
00440 
00441                   DisplayLog( <span class="stringliteral">"cache_inode_new_entry: Stale FSAL File Handle detected for pentry = %p"</span>, pentry ) ;
00442 
00443                   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
00444                     DisplayLog( <span class="stringliteral">"cache_inode_new_entry: Could not kill entry %p, status = %u"</span>, pentry, kill_status ) ;
00445 
00446                 } 
00447               <span class="comment">/* stat */</span>
00448               pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00449               
00450               <span class="keywordflow">return</span> NULL ;
00451             }
00452         }
00453     }
00454   <span class="keywordflow">else</span>
00455     {
00456       <span class="comment">/* Use the provided attributes */</span>
00457       fsal_attributes = *pfsal_attr ;
00458     }
00459   
00460   <span class="comment">/* Init the internal metadata */</span>
00461   pentry-&gt;internal_md.type          = type ;
00462   pentry-&gt;internal_md.valid_state   = VALID ;
00463   pentry-&gt;internal_md.read_time     = 0 ;
00464   pentry-&gt;internal_md.mod_time      = pentry-&gt;internal_md.alloc_time = time( NULL ) ;
00465   pentry-&gt;internal_md.refresh_time  = pentry-&gt;internal_md.alloc_time ;
00466 
00467   
00468   pentry-&gt;gc_lru_entry        = NULL ;
00469   pentry-&gt;gc_lru              = NULL ;
00470   pentry-&gt;parent_list-&gt;parent = NULL ;
00471   
00472   <span class="keywordflow">switch</span>( type )
00473     {
00474     <span class="keywordflow">case</span> REGULAR_FILE: 
00475       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a REGULAR_FILE"</span> ) ;
00476 
00477       pentry-&gt;object.file.handle         = pfsdata-&gt;handle ;
00478       pentry-&gt;object.file.attributes     = fsal_attributes ;
00479       pentry-&gt;object.file.pentry_content = NULL ; <span class="comment">/* Not yet a File Content entry associated with this entry */</span>
00480       pentry-&gt;object.file.state_v4       = NULL ; <span class="comment">/* No associated client yet                                */</span>
00481       pentry-&gt;object.file.pshare         = NULL ; <span class="comment">/* No associated client yet                                */</span>
00482       pentry-&gt;object.file.open_fd.fileno    = -1 ;
00483       pentry-&gt;object.file.open_fd.last_op   = 0 ;
00484       pentry-&gt;object.file.open_fd.openflags = 0 ;
00485 <span class="preprocessor">#ifdef _USE_PROXY</span>
00486 <span class="preprocessor"></span>      pentry-&gt;object.file.pname = NULL ;
00487       pentry-&gt;object.file.pentry_parent_open = NULL ;
00488 <span class="preprocessor">#endif</span>
00489 <span class="preprocessor"></span>
00490       break ;
00491         
00492     <span class="keywordflow">case</span> DIR_BEGINNING:
00493       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a DIR_BEGINNING"</span> ) ;
00494 
00495       pentry-&gt;object.dir_begin.handle = pfsdata-&gt;handle ;
00496       pentry-&gt;object.dir_begin.attributes = fsal_attributes ; 
00497 
00498       pentry-&gt;object.dir_begin.has_been_readdir = CACHE_INODE_NO ;
00499       pentry-&gt;object.dir_begin.end_of_dir = END_OF_DIR ;
00500       pentry-&gt;object.dir_begin.pdir_cont = NULL ;
00501       pentry-&gt;object.dir_begin.pdir_last = pentry ;
00502       pentry-&gt;object.dir_begin.nbactive = 0 ;
00503       pentry-&gt;object.dir_begin.nbdircont = 0 ;
00504       
00505       <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00506         {
00507           pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active = INVALID ;
00508           pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry = NULL ;
00509           FSAL_str2name( <span class="stringliteral">""</span>, 1, &amp;pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].name ) ;
00510         }
00511       
00512       <span class="keywordflow">break</span>;
00513 
00514     <span class="keywordflow">case</span> DIR_CONTINUE:
00515       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a DIR_CONTINUE"</span> ) ;
00516 
00517       pentry-&gt;object.dir_cont.end_of_dir = END_OF_DIR ;
00518       pentry-&gt;object.dir_cont.pdir_cont = NULL ; <span class="comment">/* The last entry has no next entry */</span>
00519       pentry-&gt;object.dir_cont.pdir_prev = pentry_dir_prev ; 
00520 
00521       <span class="keywordflow">switch</span>( pentry_dir_prev-&gt;internal_md.type )
00522         {
00523         <span class="keywordflow">case</span> DIR_BEGINNING:
00524           pentry-&gt;object.dir_cont.pdir_begin = pentry_dir_prev ;
00525           pentry-&gt;object.dir_cont.dir_cont_pos = 1 ; <span class="comment">/* The first after the DIR_BEGINNIG */</span>
00526           break ;
00527           
00528         <span class="keywordflow">case</span> DIR_CONTINUE:
00529           pentry-&gt;object.dir_cont.pdir_begin = pentry_dir_prev-&gt;object.dir_cont.pdir_begin ;
00530           pentry-&gt;object.dir_cont.dir_cont_pos = pentry_dir_prev-&gt;object.dir_cont.dir_cont_pos + 1 ;
00531           break ;
00532           
00533         <span class="keywordflow">default</span>:
00534           *pstatus = CACHE_INODE_NOT_A_DIRECTORY ;
00535           RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00536 
00537           <span class="comment">/* stat */</span>
00538           pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00539 
00540           <span class="keywordflow">return</span> NULL ;
00541           break ;
00542         }
00543 
00544       pentry-&gt;object.dir_cont.nbactive = 0 ;
00545       <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00546         { 
00547           pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active = INVALID ;
00548           pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry = NULL ;
00549           FSAL_str2name( <span class="stringliteral">""</span>, 1, &amp;pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].name ) ; 
00550         }
00551       break ;
00552       
00553     <span class="keywordflow">case</span> SYMBOLIC_LINK:
00554       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a SYMBOLIC_LINK"</span> ) ;
00555       
00556       pentry-&gt;object.symlink.handle = pfsdata-&gt;handle ;
00557       pentry-&gt;object.symlink.attributes = fsal_attributes ;
00558       fsal_status = FSAL_pathcpy( &amp;pentry-&gt;object.symlink.content, &amp;pcreate_arg-&gt;link_content ) ;
00559       <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00560         {
00561           *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00562           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"cache_inode_new_entry: FSAL_pathcpy failed"</span> ) ;
00563           RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00564         }
00565       
00566       break ;
00567 
00568     <span class="keywordflow">case</span> SOCKET_FILE: 
00569       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a SOCKET_FILE"</span> ) ;
00570 
00571       pentry-&gt;object.special_obj.handle         = pfsdata-&gt;handle ;
00572       pentry-&gt;object.special_obj.attributes     = fsal_attributes ;
00573       break ;
00574 
00575     <span class="keywordflow">case</span> FIFO_FILE: 
00576       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a FIFO_FILE"</span> ) ;
00577 
00578       pentry-&gt;object.special_obj.handle         = pfsdata-&gt;handle ;
00579       pentry-&gt;object.special_obj.attributes     = fsal_attributes ;
00580       break ;
00581       
00582     <span class="keywordflow">case</span> BLOCK_FILE:
00583       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a BLOCK_FILE"</span> ) ;
00584 
00585       pentry-&gt;object.special_obj.handle         = pfsdata-&gt;handle ;
00586       pentry-&gt;object.special_obj.attributes     = fsal_attributes ;
00587       break ;
00588       
00589     <span class="keywordflow">case</span> CHARACTER_FILE: 
00590       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Adding a CHARACTER_FILE"</span> ) ;
00591 
00592       pentry-&gt;object.special_obj.handle          = pfsdata-&gt;handle ;
00593       pentry-&gt;object.special_obj.attributes      = fsal_attributes ;
00594       break ;
00595              
00596     <span class="keywordflow">default</span>:
00597       <span class="comment">/* Should never happen */</span>
00598       *pstatus = CACHE_INODE_INCONSISTENT_ENTRY ;
00599       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_MAJOR, <span class="stringliteral">"/!\\ | cache_inode_new_entry: unknown type provided"</span> ) ;
00600       RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00601 
00602       <span class="comment">/* stat */</span>
00603       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00604       
00605       <span class="keywordflow">return</span> NULL ;
00606     }
00607 
00608    <span class="comment">/* Turn the input to a hash key */</span>
00609   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a1">cache_inode_fsaldata_2_key</a>( &amp;key, pfsdata, pclient ) )
00610     {
00611       *pstatus = CACHE_INODE_UNAPPROPRIATED_KEY ;
00612 
00613       <span class="comment">/* stat */</span>
00614       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;      
00615       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient ) ;      
00616 
00617       <span class="keywordflow">return</span> NULL ;
00618     }
00619 
00620   <span class="comment">/* Adding the entry in the cache */</span>
00621   value.pdata = (caddr_t)pentry ;
00622   value.len = <span class="keyword">sizeof</span>( cache_entry_t ) ;
00623 
00624   <span class="keywordflow">if</span>( ( rc = HashTable_Test_And_Set( ht, &amp;key, &amp;value, HASHTABLE_SET_HOW_SET_NO_OVERWRITE ) ) != HASHTABLE_SUCCESS )
00625     {
00626       <span class="comment">/* Put the entry back in its pool */</span>
00627       RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00628       DisplayLogJdLevel( pclient-&gt;log_outputs, 
00629                          NIV_EVENT, 
00630                          <span class="stringliteral">"cache_inode_new_entry: entry could not be added to hash, rc=%d"</span>, 
00631                          rc ) ;
00632       
00633       *pstatus = CACHE_INODE_HASH_SET_ERROR ;
00634 
00635       <span class="comment">/* stat */</span>
00636       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_NEW_ENTRY] += 1 ;
00637       
00638       <span class="keywordflow">return</span> NULL ;
00639     }
00640 
00641   <span class="comment">/* if entry is a REGULAR_FILE and has a related data cache entry from a previous server instance that crashed, recover it */</span>  
00642   <span class="comment">/* This is done only when this is not a creation (when creating a new file, it is impossible to have it cached)           */</span>
00643   <span class="keywordflow">if</span>( type == REGULAR_FILE &amp;&amp; create_flag == FALSE )
00644    {
00645       cache_content_test_cached( pentry, 
00646                                  (cache_content_client_t *)pclient-&gt;pcontent_client, 
00647                                  pcontext, 
00648                                  &amp;cache_content_status ) ;
00649 
00650       <span class="keywordflow">if</span>( cache_content_status == CACHE_CONTENT_SUCCESS ) 
00651         {
00652            DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"cache_inode_new_entry: Entry %p is already datacached, recovering..."</span>, pentry ) ;
00653 
00654            <span class="comment">/* Adding the cached entry to the data cache */</span>
00655            <span class="keywordflow">if</span>( (  pentry-&gt;object.file.pentry_content= cache_content_new_entry( pentry,
00656                                                                                NULL,
00657                                                                                (cache_content_client_t *)pclient-&gt;pcontent_client,
00658                                                                                RECOVER_ENTRY,
00659                                                                                pcontext,
00660                                                                                &amp;cache_content_status ) ) == NULL )
00661              {
00662               DisplayLogJd(  pclient-&gt;log_outputs, <span class="stringliteral">"Error recovering cached data for pentry %p"</span>, pentry ) ;
00663              }
00664             <span class="keywordflow">else</span>
00665               DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, <span class="stringliteral">"Cached data added successfully for pentry %p"</span>, pentry ) ;
00666             
00667            <span class="comment">/* Recover the size from the data cache too... */</span> 
00668            <span class="keywordflow">if</span>(  ( size_in_cache = cache_content_get_cached_size( (cache_content_entry_t *)pentry-&gt;object.file.pentry_content ) ) == -1 )
00669              {
00670                 DisplayLogJd(  pclient-&gt;log_outputs, <span class="stringliteral">"Error when recovering size in cache for pentry %p"</span>, pentry ) ;
00671              }
00672            <span class="keywordflow">else</span>
00673              pentry-&gt;object.file.attributes.filesize = (fsal_size_t)size_in_cache ;
00674 
00675         }
00676    } 
00677 
00678 
00679   <span class="comment">/* Final step */</span>
00680   P( pentry-&gt;lock ) ;
00681   *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry, CACHE_INODE_OP_GET, pclient ) ;
00682   V( pentry-&gt;lock ) ;
00683   
00684   DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_FULL_DEBUG, <span class="stringliteral">"cache_inode_new_entry: New entry %p added"</span>, pentry ) ;
00685   *pstatus = CACHE_INODE_SUCCESS  ;
00686   
00687   <span class="comment">/* stat */</span>
00688   pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_NEW_ENTRY] += 1 ;
00689 
00690   <span class="keywordflow">return</span> pentry ;
00691 } <span class="comment">/* cache_inode_new_entry */</span>
00692 
<a name="l00704"></a><a class="code" href="cache__inode__misc_8c.html#a4">00704</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a4">cache_inode_clean_entry</a>( cache_entry_t * pentry )
00705 {
00706   pentry-&gt;internal_md.type         = RECYCLED ;
00707   pentry-&gt;internal_md.valid_state  = INVALID ;
00708   pentry-&gt;internal_md.read_time    = 0 ;
00709   pentry-&gt;internal_md.mod_time     = 0 ;
00710   pentry-&gt;internal_md.refresh_time = 0 ;
00711   pentry-&gt;internal_md.alloc_time   = 0 ;
00712   <span class="keywordflow">return</span> CACHE_INODE_SUCCESS ;
00713 }
00714 
<a name="l00726"></a><a class="code" href="cache__inode__misc_8c.html#a5">00726</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status_t fsal_status )
00727 {
00728   <span class="keywordflow">switch</span>( fsal_status.major )
00729     {
00730     <span class="keywordflow">case</span> ERR_FSAL_NO_ERROR:
00731       <span class="keywordflow">return</span> CACHE_INODE_SUCCESS ;
00732       break ;
00733       
00734     <span class="keywordflow">case</span> ERR_FSAL_NOENT:
00735       <span class="keywordflow">return</span>  CACHE_INODE_NOT_FOUND ;
00736       break ;
00737       
00738     <span class="keywordflow">case</span> ERR_FSAL_EXIST:
00739       <span class="keywordflow">return</span> CACHE_INODE_ENTRY_EXISTS ;
00740       break ;
00741       
00742     <span class="keywordflow">case</span> ERR_FSAL_ACCESS:
00743       <span class="keywordflow">return</span> CACHE_INODE_FSAL_EACCESS ;
00744       break ;
00745 
00746     <span class="keywordflow">case</span> ERR_FSAL_PERM:
00747       <span class="keywordflow">return</span> CACHE_INODE_FSAL_EPERM ;
00748       break ;
00749 
00750     <span class="keywordflow">case</span> ERR_FSAL_NOSPC:
00751       <span class="keywordflow">return</span> CACHE_INODE_NO_SPACE_LEFT ;
00752       break ;
00753       
00754     <span class="keywordflow">case</span> ERR_FSAL_NOTEMPTY:
00755       <span class="keywordflow">return</span>  CACHE_INODE_DIR_NOT_EMPTY ;
00756       break ;
00757 
00758     <span class="keywordflow">case</span> ERR_FSAL_ROFS:
00759       <span class="keywordflow">return</span> CACHE_INODE_READ_ONLY_FS  ;
00760       break ;
00761 
00762     <span class="keywordflow">case</span> ERR_FSAL_NOTDIR:
00763       <span class="keywordflow">return</span> CACHE_INODE_NOT_A_DIRECTORY ;
00764       break ;
00765 
00766     <span class="keywordflow">case</span> ERR_FSAL_IO:
00767       <span class="keywordflow">return</span> CACHE_INODE_IO_ERROR ;
00768       break ;
00769 
00770     <span class="keywordflow">case</span> ERR_FSAL_STALE:
00771       <span class="keywordflow">return</span> CACHE_INODE_FSAL_ESTALE ;
00772       break ;
00773   
00774     <span class="keywordflow">case</span> ERR_FSAL_INVAL:
00775       <span class="keywordflow">return</span> CACHE_INODE_INVALID_ARGUMENT ;
00776       break ;
00777 
00778     <span class="keywordflow">case</span> ERR_FSAL_DQUOT:
00779       <span class="keywordflow">return</span> CACHE_INODE_QUOTA_EXCEEDED ;
00780       break ;
00781   
00782     <span class="keywordflow">case</span> ERR_FSAL_SEC:
00783       <span class="keywordflow">return</span> CACHE_INODE_FSAL_ERR_SEC ;
00784       break ;
00785 
00786     <span class="keywordflow">case</span> ERR_FSAL_NOTSUPP:
00787       <span class="keywordflow">return</span> CACHE_INODE_NOT_SUPPORTED ;
00788       break ;
00789 
00790     <span class="keywordflow">default</span>:
00791       <span class="comment">/* generic FSAL error */</span>
00792       DisplayLog(<span class="stringliteral">"cache_inode_error_convert: default conversion to CACHE_INODE_FSAL_ERROR for error %d,%d"</span>, fsal_status.major, fsal_status.minor ) ;
00793       <span class="keywordflow">return</span>  CACHE_INODE_FSAL_ERROR   ;
00794       break ;
00795     }
00796 
00797   <span class="comment">/* We should never reach this line, this may produce a warning with certain compiler */</span>
00798   DisplayLog(<span class="stringliteral">"cache_inode_error_convert: default conversion to CACHE_INODE_FSAL_ERROR for error %d, this line should never be reached"</span>, 
00799             fsal_status.major, __LINE__ ) ;
00800   <span class="keywordflow">return</span>  CACHE_INODE_FSAL_ERROR   ;
00801 } <span class="comment">/* cache_inode_error_convert */</span>
00802 
<a name="l00818"></a><a class="code" href="cache__inode__misc_8c.html#a6">00818</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( cache_entry_t * pentry, 
00819                                         cache_inode_op_t op,
00820                                         cache_inode_client_t * pclient )
00821 {
00822   <span class="comment">/* /!\ NOTE THIS CAREFULLY: entry is supposed to be locked when this function is called !! */</span>
00823 
00824   cache_inode_status_t     cache_status ; 
00825   cache_content_status_t   cache_content_status ;
00826   LRU_status_t             lru_status ;
00827   LRU_entry_t            * plru_entry = NULL ;
00828   cache_content_client_t * pclient_content = NULL ;
00829   cache_content_entry_t  * pentry_content = NULL ;
00830 <span class="preprocessor">#ifndef _NO_BUDDY_SYSTEM</span>
00831 <span class="preprocessor"></span>  buddy_stats_t        bstats;
00832 <span class="preprocessor">#endif</span>
00833 <span class="preprocessor"></span>  
00834   <span class="keywordflow">if</span>( pentry == NULL )
00835     <span class="keywordflow">return</span> CACHE_INODE_INVALID_ARGUMENT ;
00836 
00837   <span class="comment">/* Invalidate former entry if needed */</span>
00838   <span class="keywordflow">if</span>( pentry-&gt;gc_lru != NULL &amp;&amp; pentry-&gt;gc_lru_entry )
00839     {
00840       <span class="keywordflow">if</span>( LRU_invalidate( pentry-&gt;gc_lru, pentry-&gt;gc_lru_entry ) != LRU_LIST_SUCCESS )
00841         {
00842           RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00843           <span class="keywordflow">return</span>  CACHE_INODE_LRU_ERROR ;
00844         }
00845     }
00846   
00847   <span class="keywordflow">if</span>( ( plru_entry = LRU_new_entry( pclient-&gt;lru_gc, &amp;lru_status ) ) == NULL )
00848     {
00849       RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00850       <span class="keywordflow">return</span> CACHE_INODE_LRU_ERROR ;
00851     }
00852   plru_entry-&gt;buffdata.pdata = (caddr_t)pentry ;
00853   plru_entry-&gt;buffdata.len = <span class="keyword">sizeof</span>( cache_entry_t ) ;
00854 
00855   <span class="comment">/* Setting the anchors */</span>
00856   pentry-&gt;gc_lru = pclient-&gt;lru_gc ;
00857   pentry-&gt;gc_lru_entry = plru_entry ;
00858   
00859   <span class="comment">/* Update internal md */</span>
00860   pentry-&gt;internal_md.valid_state = VALID ;
00861 
00862   <span class="keywordflow">if</span>( op == CACHE_INODE_OP_GET )
00863     pentry-&gt;internal_md.read_time = time( NULL ) ;
00864   
00865   <span class="keywordflow">if</span>( op == CACHE_INODE_OP_SET )
00866     {
00867       pentry-&gt;internal_md.mod_time = time( NULL ) ;
00868       pentry-&gt;internal_md.refresh_time = pentry-&gt;internal_md.mod_time ;
00869     }
00870   
00871   <span class="comment">/* Add a call to the GC counter */</span>
00872   pclient-&gt;call_since_last_gc += 1 ;
00873  
00874   <span class="comment">/* If open/close fd cache is used for FSAL, manage it here */</span> 
00875 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
00876 <span class="preprocessor"></span>  printf( <span class="stringliteral">"--------&gt; use_cache=%u fileno=%d last_op=%u time(NULL)=%u delta=%d retention=%u\n"</span>,
00877         pclient-&gt;use_cache, pentry-&gt;object.file.open_fd.fileno ,  pentry-&gt;object.file.open_fd.last_op, time(NULL),
00878         time( NULL ) - pentry-&gt;object.file.open_fd.last_op, pclient-&gt;retention ) ;
00879 <span class="preprocessor">#endif</span>
00880 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == REGULAR_FILE ) 
00881    {
00882      <span class="keywordflow">if</span>( pclient-&gt;use_cache == 1) 
00883        {
00884         <span class="keywordflow">if</span>( pentry-&gt;object.file.open_fd.fileno &gt;= 0 )
00885           {
00886              <span class="keywordflow">if</span>( time( NULL ) - pentry-&gt;object.file.open_fd.last_op &gt; pclient-&gt;retention ) 
00887                {
00888                    <span class="keywordflow">if</span>( <a class="code" href="cache__inode__open__close_8c.html#a2">cache_inode_close</a>( pentry, pclient, &amp;cache_status ) != CACHE_INODE_SUCCESS )
00889                      {
00890                        <span class="comment">/* Bad close */</span>
00891                        <span class="keywordflow">return</span> cache_status ;
00892                      }
00893                }        
00894           }
00895        }
00896 
00897       <span class="comment">/* Same of local fd cache */</span>
00898       pclient_content = (cache_content_client_t *)pclient-&gt;pcontent_client ;
00899       pentry_content = (cache_content_entry_t *)pentry-&gt;object.file.pentry_content ;
00900 
00901       <span class="keywordflow">if</span>( pentry_content != NULL ) 
00902         <span class="keywordflow">if</span>( pclient_content-&gt;use_cache == 1 ) 
00903               <span class="keywordflow">if</span>( pentry_content-&gt;local_fs_entry.opened_file.local_fd &gt; 0 )
00904                 <span class="keywordflow">if</span>( time( NULL ) - pentry_content-&gt;local_fs_entry.opened_file.last_op  &gt; pclient_content-&gt;retention )
00905                       <span class="keywordflow">if</span>( cache_content_close( pentry_content, pclient_content, &amp;cache_content_status ) != CACHE_CONTENT_SUCCESS )
00906                         <span class="keywordflow">return</span> CACHE_INODE_CACHE_CONTENT_ERROR ;
00907     }
00908  
00909 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
00910 <span class="preprocessor"></span>  <span class="comment">/* Log */</span>
00911 
00912 <span class="preprocessor">#ifndef _NO_BUDDY_SYSTEM </span>
00913 <span class="preprocessor"></span>  BuddyGetStats( &amp;bstats ) ;
00914   printf( <span class="stringliteral">"(pthread_self=%u) NbStandard=%lu  NbStandardUsed=%lu  InsideStandard(nb=%lu, size=%lu)\n"</span>, 
00915           pthread_self(),
00916           bstats.NbStdPages, 
00917           bstats.NbStdUsed, 
00918           bstats.StdUsedSpace, 
00919           bstats.NbStdUsed) ;
00920 <span class="preprocessor">#endif</span>
00921 <span class="preprocessor"></span>  printf( <span class="stringliteral">"(pthread_self=%u) LRU GC state: nb_entries=%d nb_invalid=%d nb_call_gc=%d param.nb_call_gc_invalid=%d\n"</span>, 
00922           pthread_self(), pclient-&gt;lru_gc-&gt;nb_entry, pclient-&gt;lru_gc-&gt;nb_invalid, 
00923           pclient-&gt;lru_gc-&gt;nb_call_gc, pclient-&gt;lru_gc-&gt;parameter.nb_call_gc_invalid ) ;
00924   
00925   printf( <span class="stringliteral">"LRU GC state: nb_entries=%d nb_invalid=%d nb_call_gc=%d param.nb_call_gc_invalid=%d\n"</span>, 
00926                      pclient-&gt;lru_gc-&gt;nb_entry, pclient-&gt;lru_gc-&gt;nb_invalid, 
00927                      pclient-&gt;lru_gc-&gt;nb_call_gc, pclient-&gt;lru_gc-&gt;parameter.nb_call_gc_invalid ) ;
00928 
00929   DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, 
00930                      <span class="stringliteral">"LRU GC state: nb_entries=%d nb_invalid=%d nb_call_gc=%d param.nb_call_gc_invalid=%d"</span>, 
00931                      pclient-&gt;lru_gc-&gt;nb_entry, pclient-&gt;lru_gc-&gt;nb_invalid, 
00932                      pclient-&gt;lru_gc-&gt;nb_call_gc, pclient-&gt;lru_gc-&gt;parameter.nb_call_gc_invalid ) ;
00933 <span class="preprocessor">#endif</span>
00934 <span class="preprocessor"></span>
00935   <span class="comment">/* Call LRU_gc_invalid to get ride of the unused invalid lru entries */</span>
00936   <span class="keywordflow">if</span>( LRU_gc_invalid( pclient-&gt;lru_gc, NULL ) != LRU_LIST_SUCCESS )
00937     <span class="keywordflow">return</span> CACHE_INODE_LRU_ERROR ;
00938 
00939   <span class="keywordflow">return</span>  CACHE_INODE_SUCCESS ;
00940 } <span class="comment">/* cache_inode_valid */</span>
00941 
00942 
<a name="l00955"></a><a class="code" href="cache__inode__misc_8c.html#a7">00955</a> <span class="keywordtype">void</span> <a class="code" href="cache__inode__misc_8c.html#a7">cache_inode_get_attributes</a>( cache_entry_t * pentry, fsal_attrib_list_t * pattr )
00956 {
00957   <span class="comment">/* The pentry is supposed to be locked */</span>
00958   <span class="keywordflow">switch</span>( pentry-&gt;internal_md.type )
00959     {
00960     <span class="keywordflow">case</span> REGULAR_FILE:
00961       *pattr = pentry-&gt;object.file.attributes ;
00962       break ;
00963       
00964     <span class="keywordflow">case</span> SYMBOLIC_LINK:
00965       *pattr = pentry-&gt;object.symlink.attributes ;
00966       break ;
00967       
00968     <span class="keywordflow">case</span> DIR_BEGINNING:
00969       *pattr = pentry-&gt;object.dir_begin.attributes ;
00970       break ;
00971       
00972     <span class="keywordflow">case</span> DIR_CONTINUE:
00973       <span class="comment">/* lock the related dir_begin (dir begin are garbagge collected AFTER their related dir_cont)</span>
00974 <span class="comment">       * this means that if a DIR_CONTINUE exists, its pdir pointer is not endless */</span>
00975       P( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00976       *pattr =  pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.attributes ;
00977       V( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
00978       break ;
00979       
00980     <span class="keywordflow">case</span> SOCKET_FILE:
00981     <span class="keywordflow">case</span> FIFO_FILE:
00982     <span class="keywordflow">case</span> BLOCK_FILE:
00983     <span class="keywordflow">case</span> CHARACTER_FILE:
00984       *pattr = pentry-&gt;object.special_obj.attributes ;
00985       break ;
00986       
00987     }
00988 } <span class="comment">/* cache_inode_get_attributes */</span>
00989 
00990 
<a name="l01003"></a><a class="code" href="cache__inode__misc_8c.html#a8">01003</a> <span class="keywordtype">void</span> <a class="code" href="cache__inode__misc_8c.html#a8">cache_inode_set_attributes</a>( cache_entry_t * pentry, fsal_attrib_list_t * pattr )
01004 {
01005     <span class="keywordflow">switch</span>( pentry-&gt;internal_md.type )
01006     {
01007     <span class="keywordflow">case</span> REGULAR_FILE:
01008        pentry-&gt;object.file.attributes =  *pattr;
01009       break ;
01010       
01011     <span class="keywordflow">case</span> SYMBOLIC_LINK:
01012       pentry-&gt;object.symlink.attributes = *pattr ;
01013       break ;
01014       
01015     <span class="keywordflow">case</span> DIR_BEGINNING:
01016        pentry-&gt;object.dir_begin.attributes  = *pattr ;
01017       break ;
01018       
01019     <span class="keywordflow">case</span> DIR_CONTINUE:
01020       <span class="comment">/* lock the related dir_begin (dir begin are garbagge collected AFTER their related dir_cont)</span>
01021 <span class="comment">       * this means that if a DIR_CONTINUE exists, its pdir pointer is not endless */</span>
01022       P( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
01023       pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.attributes = *pattr ;
01024       V( pentry-&gt;object.dir_cont.pdir_begin-&gt;lock ) ;
01025       break ;
01026     
01027     <span class="keywordflow">case</span> SOCKET_FILE:
01028     <span class="keywordflow">case</span> FIFO_FILE:
01029     <span class="keywordflow">case</span> BLOCK_FILE:
01030     <span class="keywordflow">case</span> CHARACTER_FILE:
01031       pentry-&gt;object.special_obj.attributes = *pattr ;
01032       break ;      
01033     }
01034 } <span class="comment">/* cache_inode_set_attributes */</span>
01035 
01036 
<a name="l01048"></a><a class="code" href="cache__inode__misc_8c.html#a9">01048</a> cache_inode_file_type_t <a class="code" href="cache__inode__misc_8c.html#a9">cache_inode_fsal_type_convert</a>(  fsal_nodetype_t type ) 
01049 {
01050   cache_inode_file_type_t rctype ;
01051   
01052   <span class="keywordflow">switch</span>( type )
01053     {
01054     <span class="keywordflow">case</span> FSAL_TYPE_DIR:
01055       rctype = DIR_BEGINNING ;
01056       break ;
01057       
01058     <span class="keywordflow">case</span> FSAL_TYPE_FILE:
01059       rctype = REGULAR_FILE ;
01060       break ;
01061       
01062     <span class="keywordflow">case</span> FSAL_TYPE_LNK:
01063       rctype = SYMBOLIC_LINK ;
01064       break ;
01065       
01066     <span class="keywordflow">case</span> FSAL_TYPE_BLK :
01067       rctype = BLOCK_FILE ;
01068       break ;
01069       
01070     <span class="keywordflow">case</span> FSAL_TYPE_FIFO:
01071       rctype = FIFO_FILE ;
01072       break ;
01073         
01074     <span class="keywordflow">case</span> FSAL_TYPE_CHR:
01075       rctype = CHARACTER_FILE ;
01076       break ;
01077 
01078     <span class="keywordflow">case</span> FSAL_TYPE_SOCK:
01079       rctype = SOCKET_FILE; 
01080       <span class="keywordflow">break</span>;
01081 
01082     <span class="keywordflow">default</span>:
01083       rctype = UNASSIGNED ;
01084       break ;
01085     }
01086 
01087   <span class="keywordflow">return</span> rctype ;
01088 } <span class="comment">/* cache_inode_fsal_type_convert */</span>
01089 
<a name="l01103"></a><a class="code" href="cache__inode__misc_8c.html#a10">01103</a> fsal_handle_t *  <a class="code" href="cache__inode__misc_8c.html#a10">cache_inode_get_fsal_handle</a>( cache_entry_t * pentry, cache_inode_status_t * pstatus ) 
01104 {
01105   fsal_handle_t * preturned_handle = NULL ;
01106   
01107   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
01108   *pstatus = CACHE_INODE_SUCCESS ;
01109 
01110   <span class="keywordflow">if</span>( pentry == NULL )
01111     {
01112       preturned_handle = NULL ;
01113       *pstatus = CACHE_INODE_INVALID_ARGUMENT ;
01114     }
01115   <span class="keywordflow">else</span>
01116     {
01117       <span class="keywordflow">switch</span>( pentry-&gt;internal_md.type )
01118         {
01119         <span class="keywordflow">case</span> REGULAR_FILE:
01120           preturned_handle = &amp;pentry-&gt;object.file.handle ;
01121           *pstatus = CACHE_INODE_SUCCESS ;
01122           break ;
01123           
01124         <span class="keywordflow">case</span> SYMBOLIC_LINK:
01125           preturned_handle = &amp;pentry-&gt;object.symlink.handle ;
01126           *pstatus = CACHE_INODE_SUCCESS ;
01127           break ;
01128           
01129         <span class="keywordflow">case</span> DIR_BEGINNING:
01130           preturned_handle = &amp;pentry-&gt;object.dir_begin.handle ;
01131           *pstatus = CACHE_INODE_SUCCESS ;
01132           break ;
01133           
01134         <span class="keywordflow">case</span> DIR_CONTINUE:
01135           preturned_handle = &amp;pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.handle ;
01136           *pstatus = CACHE_INODE_SUCCESS ;
01137           break ;
01138           
01139         <span class="keywordflow">case</span> SOCKET_FILE:
01140         <span class="keywordflow">case</span> FIFO_FILE:
01141         <span class="keywordflow">case</span> BLOCK_FILE:
01142         <span class="keywordflow">case</span> CHARACTER_FILE:
01143           preturned_handle = &amp;pentry-&gt;object.special_obj.handle ;
01144           break ;      
01145           
01146         <span class="keywordflow">default</span>:
01147           preturned_handle = NULL ;
01148           *pstatus =  CACHE_INODE_BAD_TYPE ;
01149           break ;
01150         } <span class="comment">/* switch( pentry-&gt;internal_md.type ) */</span>
01151     }
01152   
01153   <span class="keywordflow">return</span> preturned_handle ;
01154 } <span class="comment">/* cache_inode_get_fsal_handle */</span>
01155 
01156 
<a name="l01169"></a><a class="code" href="cache__inode__misc_8c.html#a11">01169</a> <span class="keywordtype">int</span> <a class="code" href="cache__inode__misc_8c.html#a11">cache_inode_type_are_rename_compatible</a>( cache_entry_t * pentry_src, cache_entry_t * pentry_dest )
01170 {
01171   <span class="comment">/* Manage the case where pentry is DIR_CONTINUE */</span>
01172   <span class="keywordflow">if</span>( pentry_src-&gt;internal_md.type == DIR_CONTINUE )
01173     <span class="keywordflow">return</span>  <a class="code" href="cache__inode__misc_8c.html#a11">cache_inode_type_are_rename_compatible</a>( pentry_src-&gt;object.dir_cont.pdir_begin, pentry_dest ) ;
01174   
01175   <span class="keywordflow">if</span>( pentry_dest-&gt;internal_md.type == DIR_CONTINUE )
01176     <span class="keywordflow">return</span>  <a class="code" href="cache__inode__misc_8c.html#a11">cache_inode_type_are_rename_compatible</a>( pentry_src, pentry_dest-&gt;object.dir_cont.pdir_begin ) ;
01177   
01178   <span class="comment">/* TRUE is both entries are non directories or to directories and the second is empty */</span>
01179   <span class="keywordflow">if</span>( pentry_src-&gt;internal_md.type == DIR_BEGINNING )
01180     {
01181       <span class="keywordflow">if</span>( pentry_dest-&gt;internal_md.type == DIR_BEGINNING )
01182         {
01183           <span class="keywordflow">if</span>( <a class="code" href="cache__inode__remove_8c.html#a0">cache_inode_is_dir_empty</a>( pentry_dest ) == CACHE_INODE_SUCCESS )
01184             <span class="keywordflow">return</span> TRUE ;
01185           <span class="keywordflow">else</span>
01186             <span class="keywordflow">return</span> FALSE ;
01187         }
01188       <span class="keywordflow">else</span>
01189         <span class="keywordflow">return</span> FALSE  ;
01190     }
01191   <span class="keywordflow">else</span>
01192     {
01193       <span class="comment">/* pentry_src is not a directory */</span>
01194       <span class="keywordflow">if</span>( pentry_dest-&gt;internal_md.type == DIR_BEGINNING )
01195         <span class="keywordflow">return</span> FALSE ;
01196       <span class="keywordflow">else</span>
01197         <span class="keywordflow">return</span> TRUE ;
01198     }
01199 } <span class="comment">/* cache_inode_type_are_rename_compatible */</span>
01200 
<a name="l01212"></a><a class="code" href="cache__inode__misc_8c.html#a12">01212</a> <span class="keywordtype">void</span> <a class="code" href="cache__inode__misc_8c.html#a12">cache_inode_mutex_destroy</a>( cache_entry_t * pentry )
01213 {
01214   pthread_mutex_destroy( &amp;pentry-&gt;lock ) ;
01215 } <span class="comment">/* cache_inode_mutex_destroy */</span>
01216 
<a name="l01228"></a><a class="code" href="cache__inode__misc_8c.html#a13">01228</a> u_int32_t <a class="code" href="cache__inode__misc_8c.html#a13">cache_inode_increment_seqid</a> ( cache_entry_t * pentry )
01229 {
01230   <span class="comment">/* Argument should be a valid pentry */</span>
01231   <span class="keywordflow">if</span>( pentry == NULL ) 
01232         <span class="keywordflow">return</span> 0 ;
01233 
01234   <span class="comment">/* Should operate only on a file */</span>
01235   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type != REGULAR_FILE )
01236         <span class="keywordflow">return</span> 0 ;
01237 
01238   <span class="comment">/* file should have an asssociated state */</span>
01239   <span class="keywordflow">if</span>( pentry-&gt;object.file.pshare == NULL )
01240         <span class="keywordflow">return</span> 0 ;
01241 
01242   P( pentry-&gt;lock ) ;
01243   pentry-&gt;object.file.pshare-&gt;seqid += 1 ; 
01244   V( pentry-&gt;lock ) ;
01245 
01246   <span class="keywordflow">return</span> pentry-&gt;object.file.pshare-&gt;seqid ;
01247 } <span class="comment">/* cache_inode_increment_seqid */</span>
01248 
<a name="l01260"></a><a class="code" href="cache__inode__misc_8c.html#a14">01260</a> u_int32_t <a class="code" href="cache__inode__misc_8c.html#a14">cache_inode_get_seqid</a> ( cache_entry_t * pentry )
01261 {
01262   u_int32_t seqid = 0 ;
01263 
01264   <span class="comment">/* Argument should be a valid pentry */</span>
01265   <span class="keywordflow">if</span>( pentry == NULL )
01266         <span class="keywordflow">return</span> 0 ;
01267 
01268   <span class="comment">/* Should operate only on a file */</span>
01269   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type != REGULAR_FILE )
01270         <span class="keywordflow">return</span> 0 ;
01271  
01272   <span class="keywordflow">if</span>( pentry-&gt;object.file.pshare == NULL )
01273         <span class="keywordflow">return</span> 0 ;
01274 
01275   P( pentry-&gt;lock ) ;
01276   seqid = pentry-&gt;object.file.pshare-&gt;seqid ;
01277   V( pentry-&gt;lock ) ;
01278 
01279   <span class="keywordflow">return</span> seqid ;
01280 } <span class="comment">/* cache_inode_get_seqid */</span>
01281 
01282 
<a name="l01295"></a><a class="code" href="cache__inode__misc_8c.html#a15">01295</a> <span class="keywordtype">void</span> <a class="code" href="cache__inode__misc_8c.html#a15">cache_inode_print_dir</a>( cache_entry_t * cache_entry_root  )
01296 {
01297    cache_entry_t * cache_entry_iter = NULL ;
01298    <span class="keywordtype">int</span> i = 0 ;
01299    
01300    <span class="keywordflow">if</span>( cache_entry_root-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
01301        cache_entry_root-&gt;internal_md.type != DIR_CONTINUE )
01302      {
01303        printf( <span class="stringliteral">"This entry is not a directory segment\n"</span> ) ;
01304        return ;
01305      }
01306 
01307    cache_entry_iter = cache_entry_root ;
01308    
01309    <span class="keywordflow">while</span>( cache_entry_iter != NULL ) 
01310      { 
01311        <span class="keywordflow">if</span>(  cache_entry_iter-&gt;internal_md.type == DIR_BEGINNING )
01312          {
01313            <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
01314              printf( <span class="stringliteral">"Name = %s, DIR_BEGINNING entry = %p, active=%d, i=%d\n"</span>, 
01315                      cache_entry_iter-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].name.name,
01316                      cache_entry_iter-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry, 
01317                      cache_entry_iter-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active,
01318                      i ) ;
01319 
01320            cache_entry_iter = cache_entry_iter-&gt;object.dir_begin.pdir_cont ;
01321          }
01322        <span class="keywordflow">else</span>
01323          {
01324            <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
01325              printf( <span class="stringliteral">"Name = %s, DIR_CONTINUE entry = %p, active=%d, i=%d\n"</span>,
01326                      cache_entry_iter-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].name.name, 
01327                      cache_entry_iter-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry,
01328                      cache_entry_iter-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active,
01329                      i ) ;
01330 
01331            cache_entry_iter = cache_entry_iter-&gt;object.dir_cont.pdir_cont ;
01332          }
01333      }
01334    printf( <span class="stringliteral">"------------------\n"</span> ) ;
01335 } <span class="comment">/* cache_inode_print_dir */</span>
01336 
<a name="l01351"></a><a class="code" href="cache__inode__misc_8c.html#a16">01351</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a16">cache_inode_dump_content</a>( <span class="keywordtype">char</span> * path, cache_entry_t * pentry )
01352 {
01353   FILE * stream = NULL ;
01354   
01355   <span class="keywordtype">char</span>   buff[CACHE_INODE_DUMP_LEN] ;
01356   
01357   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type != REGULAR_FILE )
01358     <span class="keywordflow">return</span> CACHE_INODE_BAD_TYPE ;
01359 
01360   <span class="comment">/* Open the index file */</span>
01361   <span class="keywordflow">if</span>( ( stream = fopen( path, <span class="stringliteral">"w"</span> ) ) == NULL )
01362     <span class="keywordflow">return</span> CACHE_INODE_INVALID_ARGUMENT ;
01363 
01364   <span class="comment">/* Dump the information */</span>
01365   fprintf( stream, <span class="stringliteral">"internal:read_time=%d\n"</span>, (<span class="keywordtype">int</span>)pentry-&gt;internal_md.read_time ) ;
01366   fprintf( stream, <span class="stringliteral">"internal:mod_time=%d\n"</span>,  (<span class="keywordtype">int</span>)pentry-&gt;internal_md.mod_time ) ;
01367   fprintf( stream, <span class="stringliteral">"internal:export_id=%d\n"</span>, 0 ) ;
01368   
01369   snprintHandle( buff, CACHE_INODE_DUMP_LEN, &amp;(pentry-&gt;object.file.handle) ) ;
01370   fprintf( stream, <span class="stringliteral">"file: FSAL handle=%s"</span>, buff ) ;
01371   
01372   <span class="comment">/* Close the handle */</span>
01373   fclose( stream ) ;
01374 
01375   <span class="keywordflow">return</span> CACHE_INODE_SUCCESS   ;
01376 } <span class="comment">/* cache_inode_dump_content */</span>
01377 
01378 
<a name="l01392"></a><a class="code" href="cache__inode__misc_8c.html#a17">01392</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a17">cache_inode_reload_content</a>( <span class="keywordtype">char</span> * path, cache_entry_t * pentry )
01393 {
01394    FILE * stream = NULL ;
01395 
01396    <span class="keywordtype">char</span>   buff[CACHE_INODE_DUMP_LEN] ;
01397 
01398    <span class="comment">/* Open the index file */</span>
01399   <span class="keywordflow">if</span>( ( stream = fopen( path, <span class="stringliteral">"r"</span> ) ) == NULL )
01400     <span class="keywordflow">return</span> CACHE_INODE_INVALID_ARGUMENT ;
01401 
01402   <span class="comment">/* The entry is a file (only file inode are dumped), in state VALID for the gc (not garbageable) */</span>
01403   pentry-&gt;internal_md.type = REGULAR_FILE ;
01404   pentry-&gt;internal_md.valid_state = VALID ;
01405   
01406   <span class="comment">/* Read the information */</span>
01407   fscanf( stream, <span class="stringliteral">"internal:read_time=%s\n"</span>, buff) ;
01408   pentry-&gt;internal_md.read_time = atoi( buff ) ;
01409   
01410   fscanf( stream, <span class="stringliteral">"internal:mod_time=%s\n"</span>, buff ) ;
01411   pentry-&gt;internal_md.mod_time = atoi( buff ) ;
01412   
01413   fscanf( stream, <span class="stringliteral">"internal:export_id=%s\n"</span>, buff ) ;
01414     
01415   fscanf( stream, <span class="stringliteral">"file: FSAL handle=%s"</span>, buff ) ;
01416   sscanHandle( &amp;(pentry-&gt;object.file.handle), buff ) ;
01417   
01418   <span class="comment">/* Close the handle */</span>
01419   fclose( stream ) ;
01420 
01421   <span class="keywordflow">return</span> CACHE_INODE_SUCCESS   ;
01422 } <span class="comment">/* cache_inode_reload_content */</span>
01423 
01436 <span class="keyword">static</span> <span class="keywordtype">void</span> cache_inode_invalidate_related_dirent(  cache_entry_t            * pentry, 
01437                                                     cache_inode_client_t     * pclient )
01438 
01439 {
01440   cache_inode_parent_entry_t * parent_iter    = NULL ;
01441   
01442 
01443   <span class="comment">/* Set the cache status as INVALID in the directory entries */</span>
01444   <span class="keywordflow">for</span>( parent_iter = pentry-&gt;parent_list ; parent_iter != NULL ; parent_iter = parent_iter-&gt;next_parent )
01445     {
01446       <span class="keywordflow">if</span>( parent_iter-&gt;parent == NULL )
01447         {
01448            DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG,
01449                               <span class="stringliteral">"cache_inode_gc_invalidate_related_dirent: pentry %p has no parent, no dirent to be removed..."</span>, pentry ) ;
01450             continue ;
01451         } 
01452       
01453       <span class="comment">/* If I reached this point, then parent_iter-&gt;parent is not null and is a valid cache_inode pentry */</span>
01454       P( parent_iter-&gt;parent-&gt;lock ) ;
01455       
01456       <span class="comment">/* Check for type of the parent */</span>
01457       <span class="keywordflow">if</span>( parent_iter-&gt;parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp; 
01458           parent_iter-&gt;parent-&gt;internal_md.type != DIR_CONTINUE )
01459         {
01460           V( parent_iter-&gt;parent-&gt;lock ) ;
01461           <span class="comment">/* Major parent incoherency: parent is no directory */</span>
01462           DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_DEBUG, 
01463                              <span class="stringliteral">"cache_inode_gc_invalidate_related_dirent: major incoherency. Found an entry whose parent is no directory"</span> ) ;
01464           return ;
01465         }
01466       
01467       <span class="comment">/* Set the entry as invalid in the dirent array */</span>
01468       <span class="keywordflow">if</span>( parent_iter-&gt;parent-&gt;internal_md.type == DIR_BEGINNING )
01469         {
01470           <span class="keywordflow">if</span>( parent_iter-&gt;subdirpos &gt; CHILDREN_ARRAY_SIZE )
01471             {
01472                 V( parent_iter-&gt;parent-&gt;lock ) ;
01473                 DisplayLog( <span class="stringliteral">"A known bug occured line %d file %s: pentry=%p type=%u parent_iter-&gt;subdirpos=%d, should never exceed, entry not removed %d"</span>, 
01474                             __LINE__, __FILE__, pentry, pentry-&gt;internal_md.type, parent_iter-&gt;subdirpos, CHILDREN_ARRAY_SIZE ) ;
01475                 return ;
01476             }
01477           <span class="keywordflow">else</span>
01478            {
01479               parent_iter-&gt;parent-&gt;object.dir_begin.pdir_data-&gt;dir_entries[parent_iter-&gt;subdirpos].active = INVALID ;
01480               <span class="comment">/* Garbagge invalidates the effet of the readdir previously made */</span>
01481               parent_iter-&gt;parent-&gt;object.dir_begin.has_been_readdir = CACHE_INODE_NO ;
01482               parent_iter-&gt;parent-&gt;object.dir_begin.nbactive -= 1 ;
01483            }
01484         }
01485       <span class="keywordflow">else</span>
01486         {
01487           <span class="keywordflow">if</span>( parent_iter-&gt;subdirpos &gt; CHILDREN_ARRAY_SIZE )
01488             {
01489                 V( parent_iter-&gt;parent-&gt;lock ) ;
01490                 DisplayLog( <span class="stringliteral">"A known bug occured line %d file %s: pentry=%p type=%u parent_iter-&gt;subdirpos=%d, should never exceed %d, entry not removed"</span>,
01491                             __LINE__, __FILE__, pentry, pentry-&gt;internal_md.type, parent_iter-&gt;subdirpos, CHILDREN_ARRAY_SIZE ) ;
01492                 return ;
01493             }
01494           <span class="keywordflow">else</span>
01495             {
01496                parent_iter-&gt;parent-&gt;object.dir_cont.pdir_data-&gt;dir_entries[parent_iter-&gt;subdirpos].active = INVALID ;
01497                parent_iter-&gt;parent-&gt;object.dir_cont.nbactive -= 1 ;
01498             }
01499         }
01500       
01501 
01502       V( parent_iter-&gt;parent-&gt;lock ) ;
01503     }
01504 } <span class="comment">/* cache_inode_invalidate_related_dirent */</span>
01505 
<a name="l01521"></a><a class="code" href="cache__inode__misc_8c.html#a19">01521</a> cache_inode_status_t <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( cache_entry_t            * pentry, 
01522                                              hash_table_t             * ht,
01523                                              cache_inode_client_t     * pclient,
01524                                              cache_inode_status_t     * pstatus)
01525 {
01526    fsal_handle_t              * pfsal_handle     = NULL ;
01527    cache_inode_fsal_data_t      fsaldata ;
01528    cache_inode_parent_entry_t * parent_iter      = NULL ;
01529    cache_inode_parent_entry_t * parent_iter_next = NULL ;
01530    hash_buffer_t                key , old_key;
01531    hash_buffer_t                old_value ;
01532    <span class="keywordtype">int</span>                          rc ;
01533    <span class="keywordtype">int</span>                          i ;
01534    fsal_status_t                fsal_status ;
01535    hash_data_t                * pdata = NULL ;
01536    cache_inode_fsal_data_t    * ppoolfsdata = NULL ;
01537    cache_entry_t              * pentry_iter = NULL ;
01538    cache_entry_t              * pentry_iter_save = NULL ;
01539    cache_inode_status_t         kill_status ;
01540 
01541    DisplayLog( <span class="stringliteral">"Using cache_inode_kill_entry for entry %p"</span>, pentry ) ;
01542 
01543    <span class="keywordflow">if</span>( pstatus == NULL )
01544         <span class="keywordflow">return</span> CACHE_INODE_INVALID_ARGUMENT ;
01545 
01546    <span class="keywordflow">if</span>( pentry == NULL || pclient == NULL || ht == NULL ) 
01547      {
01548         *pstatus = CACHE_INODE_INVALID_ARGUMENT ;
01549         <span class="keywordflow">return</span> *pstatus ;
01550      }
01551 
01552    <span class="comment">/* Get the FSAL handle */</span>
01553    <span class="keywordflow">if</span>( ( pfsal_handle = <a class="code" href="cache__inode__misc_8c.html#a10">cache_inode_get_fsal_handle</a>( pentry, pstatus ) ) == NULL )
01554     {
01555       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
01556                          <span class="stringliteral">"cache_inode_kill_entry: unable to retrieve pentry's specific filesystem info"</span> ) ;
01557       <span class="keywordflow">return</span> *pstatus ;
01558     }
01559 
01560    fsaldata.handle = *pfsal_handle ;
01561 
01562    <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_CONTINUE ) 
01563      fsaldata.cookie = pentry-&gt;object.dir_cont.dir_cont_pos ;
01564    <span class="keywordflow">else</span>
01565      fsaldata.cookie = DIR_START ;
01566 
01567   <span class="comment">/* Use the handle to build the key */</span>
01568   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a1">cache_inode_fsaldata_2_key</a>( &amp;key, &amp;fsaldata, pclient ) )
01569     {
01570       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
01571                          <span class="stringliteral">"cache_inode_kill_entry: could not build hashtable key"</span> ) ;
01572 
01573       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient );
01574       *pstatus = CACHE_INODE_NOT_FOUND ; 
01575       <span class="keywordflow">return</span> *pstatus ;
01576     }
01577 
01578    
01579   <span class="comment">/* Remove the whole dir_chain from the cache */</span>
01580   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_BEGINNING )
01581    {
01582      pentry_iter = pentry-&gt;object.dir_begin.pdir_cont ;
01583      <span class="keywordflow">while</span>( pentry_iter != NULL ) 
01584       {
01585         pentry_iter_save = pentry_iter-&gt;object.dir_cont.pdir_cont ;
01586 
01587         <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry_iter, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
01588                 DisplayLog( <span class="stringliteral">"cache_inode_kill_entry: could not kill pentry %p of type %u"</span>, pentry_iter, pentry_iter-&gt;internal_md.type ) ;
01589         
01590         pentry_iter = pentry_iter_save ;
01591        }
01592     }
01593 
01594   <span class="comment">/* Clean parent entries */</span>
01595   cache_inode_invalidate_related_dirent( pentry, pclient ) ;
01596   
01597   <span class="comment">/* use the key to delete the entry */</span>
01598   <span class="keywordflow">if</span>( ( rc = HashTable_Del( ht, &amp;key, &amp;old_key, &amp;old_value ) ) != HASHTABLE_SUCCESS )
01599     {
01600       DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
01601                          <span class="stringliteral">"cache_inode_kill_entry: entry could not be deleted, status = %d"</span>, rc ) ;
01602 
01603       <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient );
01604             
01605       *pstatus = CACHE_INODE_NOT_FOUND ; 
01606       <span class="keywordflow">return</span> *pstatus ;
01607     }
01608 
01609   
01610   <span class="comment">/* Clean up the associated ressources in the FSAL */</span>
01611   <span class="keywordflow">if</span>( FSAL_IS_ERROR(  fsal_status = FSAL_CleanObjectResources( pfsal_handle ) ) )
01612     {
01613        DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
01614                          <span class="stringliteral">"cache_inode_kill_entry: Could'nt free FSAL ressources fsal_status.major=%u"</span>, fsal_status.major ) ;
01615     }
01616 
01617   <span class="comment">/* Release the hash key data */</span> 
01618   <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;old_key, pclient );
01619 
01620   <span class="comment">/* Sanity check: old_value.pdata is expected to be equal to pentry,</span>
01621 <span class="comment">   * and is released later in this function */</span>
01622   <span class="keywordflow">if</span> ( (cache_entry_t*)old_value.pdata != pentry )
01623   {
01624        DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT,
01625                          <span class="stringliteral">"cache_inode_kill_entry: unexpected pdata %p from hash table (pentry=%p)"</span>,
01626                           old_value.pdata, pentry ) ;
01627   }
01628   
01629   <span class="comment">/* Release the current key */</span>
01630   <a class="code" href="cache__inode__misc_8c.html#a2">cache_inode_release_fsaldata_key</a>( &amp;key, pclient );
01631 
01632    <span class="comment">/* Recover the parent list entries */</span>
01633   parent_iter = pentry-&gt;parent_list  ;
01634   <span class="keywordflow">while</span>( parent_iter != NULL ) 
01635     {
01636       parent_iter_next = parent_iter-&gt;next_parent ;
01637 
01638       RELEASE_PREALLOC( parent_iter, pclient-&gt;pool_parent, next_alloc ) ;
01639    
01640       parent_iter = parent_iter_next ;
01641     }
01642  
01643   <span class="comment">/* If entry is datacached, remove it from the cache */</span>
01644   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == REGULAR_FILE )
01645    {
01646      cache_content_status_t cache_content_status ;
01647 
01648      <span class="keywordflow">if</span>( pentry-&gt;object.file.pentry_content != NULL )
01649         <span class="keywordflow">if</span>( cache_content_release_entry( (cache_content_entry_t  *)pentry-&gt;object.file.pentry_content,
01650                                          (cache_content_client_t *)pclient-&gt;pcontent_client,
01651                                          &amp;cache_content_status )  != CACHE_CONTENT_SUCCESS )
01652                 DisplayLogJdLevel( pclient-&gt;log_outputs, NIV_CRIT, <span class="stringliteral">"Could not removed datacached entry for pentry %p"</span>, pentry ) ;
01653    }
01654  
01655   <span class="comment">/* If entry is a DIR_CONTINUE or a DIR_BEGINNING, release pdir_data */</span>
01656   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_BEGINNING )
01657     {
01658       <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
01659         {
01660            pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active = INVALID ;
01661            pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry = NULL ;
01662         }
01663       <span class="comment">/* Put the pentry back to the pool */</span>
01664       RELEASE_PREALLOC( pentry-&gt;object.dir_begin.pdir_data, pclient-&gt;pool_dir_data, next_alloc ) ;
01665     }
01666 
01667   <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_CONTINUE )
01668     {
01669       <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
01670         {
01671            pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active = INVALID ;
01672            pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry = NULL ;
01673         }
01674       <span class="comment">/* Put the pentry back to the pool */</span>
01675       RELEASE_PREALLOC( pentry-&gt;object.dir_cont.pdir_data, pclient-&gt;pool_dir_data, next_alloc ) ;
01676     }
01677  
01678   
01679   <span class="comment">/* Put the pentry back to the pool */</span>
01680   RELEASE_PREALLOC( pentry, pclient-&gt;pool_entry, next_alloc ) ;
01681 
01682   <span class="comment">/* Destroy the mutex associated with the pentry */</span>
01683   <a class="code" href="cache__inode__misc_8c.html#a12">cache_inode_mutex_destroy</a>( pentry ) ;
01684 
01685   *pstatus = CACHE_INODE_SUCCESS ;
01686   <span class="keywordflow">return</span> *pstatus ; 
01687 } <span class="comment">/* cache_inode_kill_entry */</span>
01688 
01689 <span class="preprocessor">#ifdef _USE_PROXY</span>
01690 <span class="preprocessor"></span><span class="keywordtype">void</span> nfs4_sprint_fhandle( nfs_fh4 * fh4p, <span class="keywordtype">char</span> * outstr ) ;
01691 
01692 <span class="keywordtype">void</span> cache_inode_print_srvhandle( <span class="keywordtype">char</span> * comment, cache_entry_t * pentry )
01693 {
01694    fsal_handle_t * pfsal_handle ;
01695    nfs_fh4         nfsfh ;
01696    <span class="keywordtype">char</span>            tag[30] ;
01697    <span class="keywordtype">char</span>            outstr[1024] ;
01698 
01699    <span class="keywordflow">if</span>( pentry == NULL ) 
01700         return ;
01701 
01702    <span class="keywordflow">switch</span>( pentry-&gt;internal_md.type ) 
01703     {
01704         <span class="keywordflow">case</span> REGULAR_FILE:
01705             strcpy( tag, <span class="stringliteral">"file"</span> );
01706             pfsal_handle = &amp;(pentry-&gt;object.file.handle) ;
01707             break ;
01708 
01709         <span class="keywordflow">case</span> SYMBOLIC_LINK:
01710             strcpy( tag, <span class="stringliteral">"link"</span> );
01711             pfsal_handle = &amp;(pentry-&gt;object.symlink.handle ) ;
01712             break ;
01713 
01714         <span class="keywordflow">case</span> DIR_BEGINNING:
01715             strcpy( tag, <span class="stringliteral">"dir "</span> );
01716             pfsal_handle = &amp;(pentry-&gt;object.dir_begin.handle ) ;
01717             break ;
01718 
01719         <span class="keywordflow">default</span>:
01720             return ;
01721             break ;
01722     }
01723 
01724    nfsfh.nfs_fh4_len = pfsal_handle-&gt;srv_handle_len ;
01725    nfsfh.nfs_fh4_val = pfsal_handle-&gt;srv_handle_val ;
01726   
01727    nfs4_sprint_fhandle( &amp;nfsfh, outstr ) ;
01728 
01729    DisplayLog( <span class="stringliteral">"--&gt;--&gt;--&gt;--&gt;--&gt; External FH (%s) comment=%s = %s"</span>, tag, comment, outstr ) ;
01730 } <span class="comment">/* cache_inode_print_srvhandle */</span>
01731 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:52 2008 for Cache inode layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
