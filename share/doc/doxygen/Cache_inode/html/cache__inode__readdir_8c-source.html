<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Cache inode layer: cache_inode_readdir.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cache_inode_readdir.c</h1><a href="cache__inode__readdir_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00087 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 
00092 <span class="preprocessor">#include "LRU_List.h"</span>
00093 <span class="preprocessor">#include "log_functions.h"</span>
00094 <span class="preprocessor">#include "HashData.h"</span>
00095 <span class="preprocessor">#include "HashTable.h"</span>
00096 <span class="preprocessor">#include "stuff_alloc.h"</span>
00097 <span class="preprocessor">#include "fsal.h"</span>
00098 <span class="preprocessor">#include "cache_inode.h"</span>
00099 
00100 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00101 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00102 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00103 <span class="preprocessor">#include &lt;time.h&gt;</span>
00104 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00105 
<a name="l00123"></a><a class="code" href="cache__inode__readdir_8c.html#a0">00123</a> cache_entry_t * <a class="code" href="cache__inode__readdir_8c.html#a0">cache_inode_operate_cached_dirent</a>( cache_entry_t           * pentry_parent, 
00124                                                    fsal_name_t             * pname,
00125                                                    fsal_name_t             * newname,
00126                                                    cache_inode_dirent_op_t   dirent_op,
00127                                                    cache_inode_status_t    * pstatus )
00128 {
00129   cache_entry_t * pdir_chain = NULL ;
00130   cache_entry_t * pentry     = NULL ;
00131   fsal_status_t   fsal_status ; 
00132   <span class="keywordtype">int</span> i = 0 ;
00133   
00134   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00135   *pstatus = CACHE_INODE_SUCCESS ;
00136 
00137   <span class="comment">/* Sanity check */</span>
00138   <span class="keywordflow">if</span>( pentry_parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00139       pentry_parent-&gt;internal_md.type != DIR_CONTINUE )
00140     {
00141       *pstatus = CACHE_INODE_BAD_TYPE ;
00142       
00143       <span class="keywordflow">return</span> NULL ;
00144     }
00145 
00146   <span class="comment">/* Try to look into the dir and its dir_cont. At this point, it must be said than lock on dir_cont are</span>
00147 <span class="comment">   *  taken when a lock is previously acquired on the related dir_begin */</span>
00148   pdir_chain = pentry_parent ;
00149   
00150   <span class="keywordflow">do</span>
00151     {
00152       <span class="comment">/* Is this entry known ? */</span>
00153       <span class="keywordflow">if</span>( pdir_chain-&gt;internal_md.type == DIR_BEGINNING )
00154         {
00155           <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00156             {
00157 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
00158 <span class="preprocessor"></span>                    printf( <span class="stringliteral">"DIR_BEGINNING %d | %d | %s | %s\n"</span>, 
00159                       pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active, 
00160                       pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry-&gt;internal_md.valid_state, 
00161                       pname-&gt;name,  pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].name.name ) ; 
00162 <span class="preprocessor">#endif</span>
00163 <span class="preprocessor"></span>              <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active == VALID &amp;&amp;
00164                   pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry-&gt;internal_md.valid_state == VALID &amp;&amp;
00165                   !FSAL_namecmp( pname,  &amp;(pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].name) ) )
00166                 {
00167                   <span class="comment">/* Entry was found */</span>
00168                   pentry = pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry ;
00169                   *pstatus = CACHE_INODE_SUCCESS ;
00170                   break ;
00171                 }    
00172             }
00173           
00174           <span class="keywordflow">if</span>( pentry != NULL )
00175             break ; <span class="comment">/* Exit the do...while loop */</span>
00176           
00177           <span class="comment">/* Do we have to go on browsing the cache_inode ? */</span>
00178           <span class="comment">/* We have to check if eod is reached and no pentry found */</span>
00179           <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_begin.end_of_dir == END_OF_DIR )
00180             {
00181               pentry = NULL ;
00182               *pstatus = CACHE_INODE_NOT_FOUND ;
00183               break ;
00184             }
00185           
00186           <span class="comment">/* Next step, release the lock and acquire a new one */</span>
00187           pdir_chain = pdir_chain-&gt;object.dir_begin.pdir_cont ;
00188         }
00189       <span class="keywordflow">else</span>
00190         {
00191           <span class="comment">/* Entry is no DIR_BEGINNING, it is of type DIR_CONTINUE */</span>
00192           <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00193             {
00194               <span class="comment">/*</span>
00195 <span class="comment">               printf( "DIR_CONTINUE %d | %d | %s | %s\n", </span>
00196 <span class="comment">                       pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active, </span>
00197 <span class="comment">                       pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry-&gt;internal_md.valid_state, </span>
00198 <span class="comment">                       name.name, </span>
00199 <span class="comment">                       pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].name.name ) ; */</span>
00200                
00201               <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active == VALID &amp;&amp;
00202                   pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry-&gt;internal_md.valid_state == VALID &amp;&amp;
00203                   !FSAL_namecmp( pname,  &amp;(pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].name) ) )
00204                 {
00205                   <span class="comment">/* Entry was found */</span>
00206                   pentry = pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry ;
00207                   *pstatus = CACHE_INODE_SUCCESS ;
00208                   break ;
00209                 }    
00210             }
00211           
00212            <span class="keywordflow">if</span>( pentry != NULL )
00213              break ; <span class="comment">/* Exit the do...while loop */</span>
00214 
00215           <span class="comment">/* Do we have to go on browsing the cache_inode ? */</span>
00216           <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_cont.end_of_dir == END_OF_DIR ) 
00217             {
00218               pentry = NULL ;
00219               *pstatus = CACHE_INODE_NOT_FOUND ;
00220               break ;
00221             }
00222           <span class="comment">/* Next step */</span>
00223           pdir_chain = pdir_chain-&gt;object.dir_cont.pdir_cont ;
00224         }
00225       
00226     } <span class="keywordflow">while</span>( pentry == NULL ) ;
00227 
00228   <span class="comment">/* Did we find something */</span>
00229   <span class="keywordflow">if</span>( pentry != NULL )
00230     {
00231       <span class="comment">/* Yes, we did ! */</span>
00232       <span class="keywordflow">switch</span>( dirent_op )
00233         {
00234         <span class="keywordflow">case</span> CACHE_INODE_DIRENT_OP_REMOVE:
00235           <span class="comment">/* Related DIR_BEGINNING or DIR_CONTINUE is pointed by pdir_chain, entry is the i-th is dir_entries </span>
00236 <span class="comment">           * The dirent entry is removed by being set invalid */</span>
00237           <span class="keywordflow">if</span>( pdir_chain-&gt;internal_md.type == DIR_BEGINNING )
00238             {
00239               pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active =INVALID ;
00240               pdir_chain-&gt;object.dir_begin.nbactive -= 1 ;
00241               *pstatus = CACHE_INODE_SUCCESS ;
00242             }
00243           <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pdir_chain-&gt;internal_md.type == DIR_CONTINUE )
00244             {
00245               pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active =INVALID ;
00246               pdir_chain-&gt;object.dir_cont.nbactive -= 1 ;
00247               *pstatus = CACHE_INODE_SUCCESS ;
00248             }
00249           <span class="keywordflow">else</span>
00250             *pstatus = CACHE_INODE_INVALID_ARGUMENT ;
00251           break ;
00252          
00253         <span class="keywordflow">case</span> CACHE_INODE_DIRENT_OP_RENAME:
00254           <span class="comment">/* Entry to rename is the i-th in pdir_chain */</span>
00255           <span class="keywordflow">if</span>(  pdir_chain-&gt;internal_md.type == DIR_BEGINNING )
00256             {
00257                 fsal_status = FSAL_namecpy(  &amp;(pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].name), newname ) ;
00258             }
00259           <span class="keywordflow">else</span>
00260             {   
00261                 fsal_status = FSAL_namecpy(  &amp;(pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].name), newname ) ;
00262             }
00263 
00264           <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00265             {
00266                 *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00267             } 
00268           <span class="keywordflow">else</span>
00269             {
00270                 *pstatus = CACHE_INODE_SUCCESS ;
00271             }
00272           break ; 
00273 
00274         <span class="keywordflow">default</span>:
00275           <span class="comment">/* Should never occurs, in any case, it cost nothing to handle this situation */</span>
00276           *pstatus = CACHE_INODE_INVALID_ARGUMENT ;
00277           break ;
00278           
00279         } <span class="comment">/* switch */</span>      
00280     }
00281 
00282   <span class="comment">/* Last lock released */</span>
00283 
00284   <span class="keywordflow">return</span> pentry ;
00285 } <span class="comment">/* cache_inode_operate_cached_dirent */</span>
00286 
00287 <span class="preprocessor">#ifdef _TOTO</span>
00288 <span class="preprocessor"></span>
00303 cache_entry_t * cache_inode_lookup_cached_dirent( cache_entry_t        * pentry_parent, 
00304                                                   fsal_name_t          * pname,
00305                                                   cache_inode_status_t * pstatus )
00306 {
00307   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00308   *pstatus = CACHE_INODE_SUCCESS ;
00309 
00310    <span class="comment">/* Sanity check */</span>
00311   <span class="keywordflow">if</span>( pentry_parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00312       pentry_parent-&gt;internal_md.type != DIR_CONTINUE )
00313     {
00314       *pstatus = CACHE_INODE_BAD_TYPE ;
00315       <span class="keywordflow">return</span> NULL ;
00316     }
00317   <span class="keywordflow">return</span> <a class="code" href="cache__inode__readdir_8c.html#a0">cache_inode_operate_cached_dirent</a>( pentry_parent, *pname, NULL, CACHE_INODE_DIRENT_OP_LOOKUP, pstatus ) ;
00318 } <span class="comment">/* cache_inode_lookup_cached_dirent */</span>
00319 <span class="preprocessor">#endif</span>
00320 <span class="preprocessor"></span>
<a name="l00343"></a><a class="code" href="cache__inode__readdir_8c.html#a1">00343</a> cache_inode_status_t <a class="code" href="cache__inode__readdir_8c.html#a1">cache_inode_add_cached_dirent</a>( cache_entry_t        *  pentry_parent,
00344                                                     fsal_name_t          *  pname, 
00345                                                     cache_entry_t        *  pentry_added,
00346                                                     cache_entry_t        ** ppentry_next,
00347                                                     hash_table_t         *  ht,
00348                                                     cache_inode_client_t *  pclient,
00349                                                     fsal_op_context_t          *  pcontext, 
00350                                                     cache_inode_status_t *  pstatus )
00351 {  
00352    cache_entry_t              * pdir_chain = NULL ;
00353    cache_entry_t              * pentry = NULL ;
00354    fsal_status_t                fsal_status ;
00355    cache_inode_fsal_data_t      fsdata ;
00356    cache_inode_parent_entry_t * next_parent_entry = NULL ;
00357 
00358    <span class="keywordtype">int</span> i          = 0 ;
00359    <span class="keywordtype">int</span> slot_index = 0 ;
00360    
00361    <span class="comment">/* For the moment, we add no error...</span>
00362 <span class="comment">    * Get ride of former *pstatus value */</span>
00363    *pstatus = CACHE_INODE_SUCCESS ;
00364    
00365    <span class="comment">/* Sanity check */</span>
00366    <span class="keywordflow">if</span>( pentry_parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00367        pentry_parent-&gt;internal_md.type != DIR_CONTINUE )
00368      {
00369        *pstatus = CACHE_INODE_BAD_TYPE ;
00370        <span class="keywordflow">return</span> *pstatus ;
00371      }
00372    
00373    <span class="comment">/* We don't known where to write, we have to seek for an empty place */</span>
00374    <span class="comment">/* Search loop. We look for an empty slot in a dirent array */</span>
00375    pdir_chain = pentry_parent ;
00376    <span class="keywordflow">do</span>
00377      {
00378        
00379        <span class="keywordflow">if</span>( pdir_chain-&gt;internal_md.type == DIR_BEGINNING )
00380          {
00381            <span class="comment">/* DIR_BEGINNING management */</span>
00382            
00383            <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_begin.nbactive  != CHILDREN_ARRAY_SIZE )
00384              {
00385                <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00386                  {
00387                    <span class="keywordflow">if</span>(  pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active == INVALID ||
00388                         pdir_chain-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].pentry == NULL )
00389                      {
00390                        <span class="comment">/* slot found */</span>
00391                        pentry = pdir_chain ;
00392                        slot_index = i ; 
00393                        break ;
00394                      }
00395                  }
00396              }
00397            
00398            <span class="comment">/* Next step */</span>
00399            <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_begin.end_of_dir == END_OF_DIR )
00400              {
00401                <span class="comment">/* Entry was not found, break the main loop */</span>
00402                break ;
00403              }
00404            <span class="keywordflow">else</span>
00405              {
00406                pdir_chain = pdir_chain-&gt;object.dir_begin.pdir_cont ;
00407              }
00408            
00409          }
00410        <span class="keywordflow">else</span>
00411          {
00412            <span class="comment">/* DIR_CONTINUE management */</span>
00413            
00414            <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_cont.nbactive  != CHILDREN_ARRAY_SIZE )
00415              {
00416                <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00417                  {
00418                    <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active == INVALID ||
00419                        pdir_chain-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].pentry == NULL )
00420                      {
00421                        pentry = pdir_chain ;
00422                        slot_index = i ;
00423                        break ;
00424                      }
00425                  }
00426              }
00427            
00428            
00429            <span class="comment">/* Next step */</span>
00430            <span class="keywordflow">if</span>( pdir_chain-&gt;object.dir_cont.end_of_dir == END_OF_DIR )
00431              {
00432                <span class="comment">/* Entry was not found, break the main loop */</span>
00433                break ;
00434              }
00435            <span class="keywordflow">else</span>
00436              {
00437                pdir_chain = pdir_chain-&gt;object.dir_cont.pdir_cont ;
00438              }
00439          }
00440        
00441      } <span class="keywordflow">while</span>( pentry == NULL ) ;
00442    
00443    
00444    <span class="comment">/* If pentry is NULL, all the dirent are full and a new entry is needed */</span>
00445    <span class="keywordflow">if</span>( pentry == NULL )
00446      {
00447        <span class="comment">/* Pointer pentry is NULL, a new entry DIR_CONTINUE is required */</span>
00448        
00449        <span class="comment">/* There may be previously invalidated dirents, in this case pdir_cont already exists</span>
00450 <span class="comment">        * we won't allocate new things in this case and reuse the old ones </span>
00451 <span class="comment">        * This case is identified by pdir_chain-&gt;object.*.pdir_cont != NULL </span>
00452 <span class="comment">        */</span>
00453        <span class="keywordflow">switch</span>( pdir_chain-&gt;internal_md.type )
00454          {
00455          <span class="keywordflow">case</span> DIR_BEGINNING:
00456            fsdata.handle = pdir_chain-&gt;object.dir_begin.handle ;
00457            fsdata.cookie = CHILDREN_ARRAY_SIZE ;
00458            pentry = pdir_chain-&gt;object.dir_begin.pdir_cont ;
00459            break ;
00460            
00461          <span class="keywordflow">case</span> DIR_CONTINUE:
00462            fsdata.handle = pdir_chain-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.handle ;
00463            fsdata.cookie = ( pdir_chain-&gt;object.dir_cont.dir_cont_pos + 1 )*CHILDREN_ARRAY_SIZE ;
00464            pentry = pdir_chain-&gt;object.dir_cont.pdir_cont ;
00465            break ;
00466          }
00467        
00468        <span class="comment">/* Allocate a new DIR_CONTINUE to the dir chain if needed */</span>
00469        <span class="keywordflow">if</span>( pentry == NULL )
00470          <span class="keywordflow">if</span>( ( pentry = <a class="code" href="cache__inode__misc_8c.html#a3">cache_inode_new_entry</a>( &amp;fsdata, 
00471                                                NULL, 
00472                                                DIR_CONTINUE, 
00473                                                NULL,
00474                                                pdir_chain, 
00475                                                ht,
00476                                                pclient, 
00477                                                pcontext, 
00478                                                FALSE, <span class="comment">/* this is population, no creation */</span>
00479                                                pstatus ) ) == NULL )
00480            {
00481              <span class="keywordflow">return</span> *pstatus ;
00482            }
00483        
00484        <span class="comment">/* Chain the new entry with the pdir_chain */</span>
00485        <span class="keywordflow">switch</span>( pdir_chain-&gt;internal_md.type )
00486          {
00487          <span class="keywordflow">case</span> DIR_BEGINNING:
00488            pdir_chain-&gt;object.dir_begin.pdir_cont = pentry ;
00489            pdir_chain-&gt;object.dir_begin.pdir_last = pentry ;
00490            pdir_chain-&gt;object.dir_begin.end_of_dir = TO_BE_CONTINUED ;
00491            pdir_chain-&gt;object.dir_begin.nbdircont += 1 ;
00492            break ;
00493            
00494          <span class="keywordflow">case</span> DIR_CONTINUE:
00495            pdir_chain-&gt;object.dir_cont.pdir_cont = pentry ;
00496            
00497            pdir_chain-&gt;object.dir_cont.end_of_dir = TO_BE_CONTINUED ;
00498            
00499            pdir_chain-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.pdir_last = pentry ;
00500            pdir_chain-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.nbdircont += 1 ;
00501            break ;
00502          }
00503        
00504        
00505        <span class="comment">/* slot to be used in the dirent array will be the first */</span>
00506        slot_index = 0 ;
00507      }
00508    
00509    <span class="comment">/* pentry is not NULL, if it was NULL a new DIR_CONTINUE has just been allocated */</span>
00510 
00511 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00512 <span class="preprocessor"></span>  <span class="comment">/* For debugging memory leaks */</span>
00513    BuddySetDebugLabel( <span class="stringliteral">"cache_inode_parent_entry_t"</span> ) ;
00514 <span class="preprocessor">#endif</span>
00515 <span class="preprocessor"></span>
00516    GET_PREALLOC( next_parent_entry, 
00517                  pclient-&gt;pool_parent,
00518                  pclient-&gt;nb_pre_parent,
00519                  cache_inode_parent_entry_t,      
00520                  next_alloc ) ;
00521 
00522 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
00523 <span class="preprocessor"></span>   <span class="comment">/* For debugging memory leaks */</span>
00524    BuddySetDebugLabel( <span class="stringliteral">"N/A"</span> ) ;
00525 <span class="preprocessor">#endif</span>
00526 <span class="preprocessor"></span>
00527    <span class="keywordflow">if</span>( next_parent_entry == NULL )
00528      {
00529        *pstatus = CACHE_INODE_MALLOC_ERROR ;
00530        pentry = NULL ;
00531        <span class="keywordflow">return</span> *pstatus ;
00532      }
00533 
00534    <span class="comment">/* Init the next_parent_entry variable */</span>
00535    next_parent_entry-&gt;subdirpos   = 0 ;
00536    next_parent_entry-&gt;parent      = NULL ;
00537    next_parent_entry-&gt;next_parent = NULL ;
00538 
00539    
00540    <span class="keywordflow">if</span>( pentry-&gt;internal_md.type == DIR_BEGINNING )
00541      {
00542        pentry-&gt;object.dir_begin.nbactive += 1 ;
00543        
00544        pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[slot_index].active = VALID ;
00545        pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[slot_index].pentry = pentry_added ;
00546        
00547        fsal_status = FSAL_namecpy( &amp;pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[slot_index].name, pname ) ;
00548        <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00549          {
00550            *pstatus = CACHE_INODE_FSAL_ERROR ;
00551            pentry-&gt;object.dir_begin.nbactive -= 1 ;
00552            pentry = NULL ;
00553            <span class="keywordflow">return</span> *pstatus ;
00554          }
00555      }
00556    <span class="keywordflow">else</span>
00557      {
00558        <span class="comment">/* DIR_CONTINUE */</span>
00559        pentry-&gt;object.dir_cont.nbactive += 1 ;
00560        
00561        pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[slot_index].active = VALID ;
00562        pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[slot_index].pentry = pentry_added ;
00563        
00564        fsal_status = FSAL_namecpy( &amp;pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[slot_index].name, pname ) ;
00565        <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00566          {
00567            *pstatus = CACHE_INODE_FSAL_ERROR ;
00568            pentry-&gt;object.dir_cont.nbactive -= 1 ;
00569            pentry = NULL ;
00570            <span class="keywordflow">return</span> *pstatus ;
00571          }
00572        
00573        
00574      }
00575 
00576    <span class="comment">/* link with the parent entry */</span> 
00577    next_parent_entry-&gt;subdirpos   = slot_index ;
00578    next_parent_entry-&gt;parent      = pentry ;
00579    next_parent_entry-&gt;next_parent = NULL ;
00580    
00581    <span class="keywordflow">if</span>( pentry_added-&gt;parent_list         == NULL ||
00582        pentry_added-&gt;parent_list-&gt;parent == NULL ) 
00583      pentry_added-&gt;parent_list = next_parent_entry ;
00584    <span class="keywordflow">else</span>
00585      pentry_added-&gt;parent_list-&gt;next_parent = next_parent_entry ;
00586    
00587    <span class="keywordflow">if</span>( ppentry_next != NULL )
00588      {
00589        *ppentry_next = pentry ;
00590      }
00591    
00592    <span class="keywordflow">return</span> *pstatus ;
00593 } <span class="comment">/* cache_inode_add_cached_dirent */</span>
00594 
00595 <span class="comment">/*</span>
00596 <span class="comment"> * cache_inode_invalidate_all_cached_dirent: Invalidates all the entries for a cached directory and its DIR_CONTINUE.</span>
00597 <span class="comment"> *</span>
00598 <span class="comment"> * Invalidates all the entries for a cached directory and its DIR_CONTINUE. No MT Safety managed here !!</span>
00599 <span class="comment"> *</span>
00600 <span class="comment"> * @param pentry_parent [INOUT] cache entry representing the directory to be managed.</span>
00601 <span class="comment"> * @param ht [IN] hash table used for the cache, unused in this call.</span>
00602 <span class="comment"> * @param pclient [INOUT] ressource allocated by the client for the nfs management.</span>
00603 <span class="comment"> * @param pstatus [OUT] returned status.</span>
00604 <span class="comment"> *</span>
00605 <span class="comment"> * @return the same as *pstatus</span>
00606 <span class="comment"> *</span>
00607 <span class="comment"> */</span>
<a name="l00608"></a><a class="code" href="cache__inode__readdir_8c.html#a2">00608</a> cache_inode_status_t <a class="code" href="cache__inode__readdir_8c.html#a2">cache_inode_invalidate_all_cached_dirent</a>(  cache_entry_t * pentry_dir,
00609                                                                 hash_table_t * ht,
00610                                                                 cache_inode_client_t * pclient,
00611                                                                 cache_inode_status_t *pstatus )
00612 {
00613   <span class="keywordtype">int</span> i ;
00614   cache_entry_t * pentry = NULL ;
00615   
00616   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00617   *pstatus = CACHE_INODE_SUCCESS ;
00618 
00619   <span class="comment">/* Only DIR_BEGINNING entries are concerned */</span>
00620   <span class="keywordflow">if</span>( pentry_dir-&gt;internal_md.type != DIR_BEGINNING )
00621     {
00622       *pstatus = CACHE_INODE_BAD_TYPE ;
00623       <span class="keywordflow">return</span> *pstatus ;
00624     }
00625   
00626   <span class="comment">/* Get ride of entries cached in the DIR_BEGINNING */</span>
00627   pentry = pentry_dir ;
00628 
00629   <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00630     pentry-&gt;object.dir_begin.pdir_data-&gt;dir_entries[i].active = INVALID ;
00631   pentry-&gt;object.dir_begin.nbactive = 0 ;
00632 
00633 
00634   <span class="comment">/* Loop on the next DIR_CONTINUE */</span>
00635   pentry = pentry-&gt;object.dir_begin.pdir_cont ;
00636   
00637   <span class="keywordflow">while</span>( pentry != NULL )
00638     {
00639       <span class="keywordflow">for</span>( i = 0 ; i &lt; CHILDREN_ARRAY_SIZE ; i++ )
00640         pentry-&gt;object.dir_cont.pdir_data-&gt;dir_entries[i].active = INVALID ;
00641       pentry-&gt;object.dir_cont.nbactive = 0 ;
00642       
00643       pentry =  pentry-&gt;object.dir_cont.pdir_cont ;
00644     }
00645   
00646   <span class="comment">/* Reinit the fields */</span>
00647   pentry_dir-&gt;object.dir_begin.has_been_readdir = CACHE_INODE_NO ;
00648   pentry_dir-&gt;object.dir_begin.end_of_dir = END_OF_DIR ;
00649   *pstatus = CACHE_INODE_SUCCESS ;
00650   
00651   <span class="keywordflow">return</span> *pstatus ;
00652 } <span class="comment">/* cache_inode_invalidate_all_cached_dirent */</span>
00653 
<a name="l00669"></a><a class="code" href="cache__inode__readdir_8c.html#a3">00669</a> cache_inode_status_t <a class="code" href="cache__inode__readdir_8c.html#a3">cache_inode_remove_cached_dirent</a>( cache_entry_t        * pentry_parent, 
00670                                                        fsal_name_t          * pname, 
00671                                                        hash_table_t         * ht,
00672                                                        cache_inode_client_t * pclient,
00673                                                        cache_inode_status_t * pstatus )
00674 {
00675   cache_entry_t              * removed_pentry = NULL ;
00676   cache_inode_parent_entry_t * parent_iter    = NULL ;
00677   cache_inode_parent_entry_t * previous_iter  = NULL ;
00678   <span class="keywordtype">int</span>                          found          = 0 ;
00679   
00680   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00681   *pstatus = CACHE_INODE_SUCCESS ;
00682 
00683   <span class="comment">/* Sanity check */</span>
00684   <span class="keywordflow">if</span>( pentry_parent-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
00685       pentry_parent-&gt;internal_md.type != DIR_CONTINUE )
00686     {
00687       *pstatus = CACHE_INODE_BAD_TYPE ;
00688       <span class="keywordflow">return</span> *pstatus ;
00689     }
00690 
00691   <span class="comment">/* BUGAZOMEU: Ne pas oublier de jarter un dir_cont dont toutes les entrees sont inactives */</span>
00692   <span class="keywordflow">if</span>( ( removed_pentry = <a class="code" href="cache__inode__readdir_8c.html#a0">cache_inode_operate_cached_dirent</a>( pentry_parent, 
00693                                                             pname, 
00694                                                             NULL,
00695                                                             CACHE_INODE_DIRENT_OP_REMOVE, 
00696                                                             pstatus ) ) == NULL )
00697     <span class="keywordflow">return</span> *pstatus ;
00698 
00699   <span class="comment">/* Remove the parent entry from the entry whose dirent is removed */</span>
00700   <span class="keywordflow">for</span>( previous_iter = NULL, parent_iter = removed_pentry-&gt;parent_list ; 
00701        parent_iter != NULL ;
00702        previous_iter = parent_iter, parent_iter = parent_iter-&gt;next_parent )
00703     {
00704       <span class="keywordflow">if</span>( parent_iter-&gt;parent == pentry_parent || 
00705           ( parent_iter-&gt;parent-&gt;internal_md.type           == DIR_CONTINUE &amp;&amp;
00706             parent_iter-&gt;parent-&gt;object.dir_cont.pdir_begin == pentry_parent ) )
00707         {
00708           found = 1 ;
00709           break ;
00710         }
00711     }
00712   
00713   <span class="comment">/* Check for pentry cache inconsistency */</span>
00714   <span class="keywordflow">if</span>( !found )
00715     {
00716       *pstatus = CACHE_INODE_INCONSISTENT_ENTRY ;
00717     }
00718   <span class="keywordflow">else</span>
00719     {
00720       <span class="keywordflow">if</span>(  previous_iter == NULL )
00721         {
00722           <span class="comment">/* this is the first parent */</span>
00723           removed_pentry-&gt;parent_list = parent_iter-&gt;next_parent ;
00724         }
00725       <span class="keywordflow">else</span>
00726         {
00727           <span class="comment">/* This is not the first parent */</span>
00728           previous_iter-&gt;next_parent = parent_iter-&gt;next_parent ;
00729         }
00730       
00731       <span class="comment">/* It is now time to put parent_iter back to its pool */</span>
00732       RELEASE_PREALLOC( parent_iter,  pclient-&gt;pool_parent, next_alloc ) ;
00733       
00734     }
00735   <span class="keywordflow">return</span> CACHE_INODE_SUCCESS ;
00736 } <span class="comment">/* cache_inode_remove_cached_dirent */</span>
00737 
00738 
<a name="l00752"></a><a class="code" href="cache__inode__readdir_8c.html#a4">00752</a> cache_inode_status_t <a class="code" href="cache__inode__readdir_8c.html#a4">cache_inode_readdir_populate</a>(  cache_entry_t           * pentry_dir, 
00753                                                     hash_table_t            * ht,
00754                                                     cache_inode_client_t    * pclient,
00755                                                     fsal_op_context_t       * pcontext, 
00756                                                     cache_inode_status_t    * pstatus) 
00757 {
00758   fsal_dir_t         fsal_dirhandle ;
00759   fsal_status_t      fsal_status ;
00760   fsal_attrib_list_t dir_attributes ;
00761   
00762   fsal_cookie_t   begin_cookie ;
00763   fsal_cookie_t   end_cookie ;
00764   fsal_count_t    nbfound ;
00765   fsal_count_t    iter ;
00766   fsal_boolean_t  fsal_eod ;
00767 
00768   cache_entry_t *           pentry             = NULL ;
00769   cache_entry_t *           next_pentry_parent = NULL ;
00770   cache_entry_t *           pentry_parent      = pentry_dir ;
00771   fsal_attrib_list_t        object_attributes ;
00772   
00773   cache_inode_create_arg_t  create_arg;
00774   cache_inode_file_type_t   type ;
00775   cache_inode_status_t      cache_status ;
00776   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              dirent_array_pos = 0 ;
00777   fsal_dirent_t             array_fsal_dirent[FSAL_READDIR_SIZE+20] ;
00778   cache_inode_fsal_data_t   new_entry_fsdata ;
00779 
00780   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00781   *pstatus = CACHE_INODE_SUCCESS ;
00782   
00783   <span class="comment">/* Only DIR_BEGINNING entries are concerned */</span>
00784   <span class="keywordflow">if</span>( pentry_dir-&gt;internal_md.type != DIR_BEGINNING )
00785     {
00786       *pstatus = CACHE_INODE_BAD_TYPE ;
00787       <span class="keywordflow">return</span> *pstatus ;
00788     }
00789   
00790   <span class="comment">/* If directory is already populated , there is no job to do */</span>
00791   <span class="keywordflow">if</span>( pentry_dir-&gt;object.dir_begin.has_been_readdir == CACHE_INODE_YES )
00792     {
00793       *pstatus = CACHE_INODE_SUCCESS ;
00794       <span class="keywordflow">return</span> *pstatus ;
00795      }
00796 
00797   <span class="comment">/* Invalidate all the dirents */</span>
00798   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__readdir_8c.html#a2">cache_inode_invalidate_all_cached_dirent</a>( pentry_dir,
00799                                                 ht, 
00800                                                 pclient,
00801                                                 pstatus ) != CACHE_INODE_SUCCESS )
00802     <span class="keywordflow">return</span> *pstatus ;
00803   
00804   <span class="comment">/* Open the directory */</span>
00805   dir_attributes.asked_attributes = pclient-&gt;attrmask  ;
00806   fsal_status = FSAL_opendir( &amp;pentry_dir-&gt;object.dir_begin.handle, 
00807                               pcontext, 
00808                               &amp;fsal_dirhandle, 
00809                               &amp;dir_attributes ) ;
00810   <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00811     {
00812       *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00813 
00814       <span class="keywordflow">if</span>( fsal_status.major == ERR_FSAL_STALE ) 
00815         {
00816            cache_inode_status_t kill_status ;
00817 
00818            DisplayLog( <span class="stringliteral">"cache_inode_readdir: Stale FSAL File Handle detected for pentry = %p"</span>, pentry_dir ) ;
00819 
00820            <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry_dir, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
00821                DisplayLog( <span class="stringliteral">"cache_inode_readdir: Could not kill entry %p, status = %u"</span>, pentry_dir, kill_status ) ;
00822 
00823            *pstatus = CACHE_INODE_FSAL_ESTALE ;
00824         }
00825       <span class="keywordflow">return</span> *pstatus ;
00826     }
00827   
00828   <span class="comment">/* Loop for readding the directory */</span>
00829   begin_cookie = FSAL_READDIR_FROM_BEGINNING ;
00830   end_cookie   = FSAL_READDIR_FROM_BEGINNING ;
00831   fsal_eod     = FALSE ;
00832  
00833  
00834   <span class="keywordflow">do</span>
00835     {
00836        fsal_status = FSAL_readdir( &amp;fsal_dirhandle, 
00837                                      begin_cookie, 
00838                                      pclient-&gt;attrmask, 
00839                                      FSAL_READDIR_SIZE * <span class="keyword">sizeof</span>( fsal_dirent_t ),
00840                                      array_fsal_dirent,
00841                                      &amp;end_cookie, 
00842                                      &amp;nbfound, 
00843                                      &amp;fsal_eod ) ;
00844       
00845        <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00846          {
00847            *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00848            <span class="keywordflow">return</span> *pstatus ;
00849          }
00850       
00851         <span class="keywordflow">for</span>( iter = 0 ; iter &lt; nbfound ; iter++ )
00852         {
00853           DisplayLogJdLevel( pclient-&gt;log_outputs, 
00854                              NIV_FULL_DEBUG, 
00855                              <span class="stringliteral">"cache readdir populate found entry %s"</span>, array_fsal_dirent[iter].name.name ) ;
00856           
00857           <span class="comment">/* It is not needed to cache '.' and '..' */</span>
00858           <span class="keywordflow">if</span>( !FSAL_namecmp( &amp;(array_fsal_dirent[iter].name), &amp;FSAL_DOT ) ||
00859               !FSAL_namecmp( &amp;(array_fsal_dirent[iter].name), &amp;FSAL_DOT_DOT ) )
00860             {
00861               DisplayLogJdLevel( pclient-&gt;log_outputs,
00862                                  NIV_FULL_DEBUG,
00863                                  <span class="stringliteral">"cache readdir populate : do not cache . and .."</span> ) ;
00864               continue ;
00865             }
00866           
00867           <span class="comment">/* If dir entry is a symbolic link, its content has to be read */</span>
00868           <span class="keywordflow">if</span>( ( type = <a class="code" href="cache__inode__misc_8c.html#a9">cache_inode_fsal_type_convert</a>( array_fsal_dirent[iter].attributes.type ) ) == SYMBOLIC_LINK )
00869             {
00870               <span class="comment">/* Let's read the link for caching its value */</span>
00871               object_attributes.asked_attributes = pclient-&gt;attrmask ;
00872               fsal_status = FSAL_readlink( &amp;array_fsal_dirent[iter].handle,
00873                                            pcontext, 
00874                                            &amp;create_arg.link_content, 
00875                                            &amp;object_attributes  ) ;
00876               <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00877                 {
00878                   *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00879 
00880                    <span class="keywordflow">if</span>( fsal_status.major == ERR_FSAL_STALE )
00881                      {
00882                        cache_inode_status_t kill_status ;
00883 
00884                        DisplayLog( <span class="stringliteral">"cache_inode_readdir: Stale FSAL File Handle detected for pentry = %p"</span>, pentry_dir ) ;
00885 
00886                        <span class="keywordflow">if</span>( <a class="code" href="cache__inode__misc_8c.html#a19">cache_inode_kill_entry</a>( pentry_dir, ht, pclient, &amp;kill_status ) != CACHE_INODE_SUCCESS )
00887                                 DisplayLog( <span class="stringliteral">"cache_inode_readdir: Could not kill entry %p, status = %u"</span>, pentry_dir, kill_status ) ;
00888 
00889                        *pstatus = CACHE_INODE_FSAL_ESTALE ;
00890                       }
00891 
00892                   <span class="keywordflow">return</span> *pstatus ;
00893                 }
00894             }
00895          
00896           <span class="comment">/* Try adding the entry, if it exists then this existing entry is returned */</span>
00897           new_entry_fsdata.handle = array_fsal_dirent[iter].handle ;
00898           new_entry_fsdata.cookie = 0 ;
00899           
00900           <span class="keywordflow">if</span>( ( pentry = <a class="code" href="cache__inode__misc_8c.html#a3">cache_inode_new_entry</a>( &amp;new_entry_fsdata, 
00901                                                 &amp;array_fsal_dirent[iter].attributes,
00902                                                 type, 
00903                                                 &amp;create_arg,
00904                                                 NULL, 
00905                                                 ht, 
00906                                                 pclient, 
00907                                                 pcontext,
00908                                                 FALSE, <span class="comment">/* This is population and no creation */</span>
00909                                                 pstatus ) ) == NULL )
00910             <span class="keywordflow">return</span> *pstatus ;
00911           
00912           <span class="comment">/* Prepare to link the new entry to its parent directory */</span>
00913           <span class="comment">/* This is a newly created entry: the list of parent is limited to one element */</span>
00914           pentry-&gt;parent_list-&gt;parent      = NULL ;
00915           pentry-&gt;parent_list-&gt;next_parent = NULL ;
00916 
00917           cache_status = <a class="code" href="cache__inode__readdir_8c.html#a1">cache_inode_add_cached_dirent</a>( pentry_parent,
00918                                                         &amp;(array_fsal_dirent[iter].name), 
00919                                                         pentry,
00920                                                         &amp;next_pentry_parent,
00921                                                         ht, 
00922                                                         pclient, 
00923                                                         pcontext,
00924                                                         pstatus) ;
00925       
00926         <span class="keywordflow">if</span>( cache_status != CACHE_INODE_SUCCESS &amp;&amp; cache_status != CACHE_INODE_ENTRY_EXISTS )
00927           <span class="keywordflow">return</span> *pstatus ;
00928         
00929         }
00930 
00931       <span class="comment">/* Step to next item in dir_chain */</span>
00932       pentry_parent = next_pentry_parent ;  
00933      
00934       
00935       <span class="comment">/* Get prepared for next step */</span>
00936       begin_cookie = end_cookie ;
00937     } <span class="keywordflow">while</span>( fsal_eod != TRUE ) ;
00938   
00939   <span class="comment">/* Close the directory */</span>
00940   fsal_status = FSAL_closedir( &amp;fsal_dirhandle ) ;
00941   <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00942     {
00943       *pstatus = <a class="code" href="cache__inode__misc_8c.html#a5">cache_inode_error_convert</a>( fsal_status ) ;
00944       <span class="keywordflow">return</span> *pstatus ;
00945     }
00946   
00947   <span class="comment">/* End of work */</span> 
00948   pentry_dir-&gt;object.dir_begin.has_been_readdir = CACHE_INODE_YES ;
00949   *pstatus = CACHE_INODE_SUCCESS ;
00950   <span class="keywordflow">return</span> *pstatus ;
00951 } <span class="comment">/* cache_inode_readdir_populate */</span>
00952 
00953 
<a name="l00976"></a><a class="code" href="cache__inode__readdir_8c.html#a5">00976</a> cache_inode_status_t <a class="code" href="cache__inode__readdir_8c.html#a5">cache_inode_readdir</a>( cache_entry_t           * dir_pentry, 
00977                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              cookie,
00978                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              nbwanted, 
00979                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            * pnbfound,
00980                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            * pend_cookie,
00981                                           cache_inode_endofdir_t  * peod_met,
00982                                           cache_inode_dir_entry_t * dirent_array, 
00983                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            * cookie_array,
00984                                           hash_table_t            * ht,
00985                                           cache_inode_client_t    * pclient,
00986                                           fsal_op_context_t             * pcontext, 
00987                                           cache_inode_status_t    * pstatus) 
00988 {
00989   cache_inode_flag_t    tstflag ;
00990   cache_entry_t       * pentry_iter ;
00991   cache_entry_t       * pentry_to_read ;
00992   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          first_pentry_cookie = 0 ;
00993   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          i = 0 ;
00994   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          cookie_iter = 0 ;
00995   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          nbdirchain = 0 ;
00996   
00997   <span class="comment">/* Set the return default to CACHE_INODE_SUCCESS */</span>
00998   *pstatus = CACHE_INODE_SUCCESS ;
00999 
01000   <span class="comment">/* end cookie initial value is the begin cookie */</span>
01001   *pend_cookie = cookie ;
01002 
01003   <span class="comment">/* stats */</span>
01004   pclient-&gt;stat.nb_call_total += 1 ;
01005   pclient-&gt;stat.func_stats.nb_call[CACHE_INODE_READDIR] += 1 ;
01006 
01007 <span class="preprocessor">#ifdef _DEBUG_NFSPROTO</span>
01008 <span class="preprocessor"></span>  printf( <span class="stringliteral">"--&gt; Cache_inode_readdir: parameters are cookie=%u nbwanted=%u\n"</span>,  cookie, nbwanted ) ;
01009 <span class="preprocessor">#endif</span>
01010 <span class="preprocessor"></span>
01011   <span class="comment">/* Sanity check */</span>
01012   <span class="keywordflow">if</span>( nbwanted == 0 )
01013     {
01014       <span class="comment">/* Asking for nothing is not a crime !!!!! </span>
01015 <span class="comment">       * build a 'dummy' return in this case */</span>
01016       *pstatus = CACHE_INODE_SUCCESS ;
01017       *pnbfound = 0 ;
01018       *peod_met = TO_BE_CONTINUED ;
01019       
01020       <span class="comment">/* stats */</span>
01021       pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_READDIR] += 1 ;
01022 
01023       <span class="keywordflow">return</span> *pstatus ;
01024     }
01025   
01026   P( dir_pentry-&gt;lock ) ;          
01027 
01028     <span class="comment">/* Renew the entry (to avoid having it being garbagged */</span>
01029   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__renew__entry_8c.html#a0">cache_inode_renew_entry</a>( dir_pentry, NULL, ht, pclient, pcontext, pstatus ) != CACHE_INODE_SUCCESS )
01030     {
01031       pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_GETATTR] += 1 ;
01032       V( dir_pentry-&gt;lock ) ;          
01033       <span class="keywordflow">return</span> *pstatus ;
01034     }
01035 
01036   <span class="comment">/* readdir can be done only with a directory */</span>
01037   <span class="keywordflow">if</span>( dir_pentry-&gt;internal_md.type != DIR_BEGINNING &amp;&amp;
01038       dir_pentry-&gt;internal_md.type != DIR_CONTINUE )
01039     {
01040       V( dir_pentry-&gt;lock ) ;
01041       *pstatus = CACHE_INODE_BAD_TYPE ;
01042 
01043       <span class="comment">/* stats */</span>
01044       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_READDIR] += 1 ;
01045   
01046       <span class="keywordflow">return</span> *pstatus ;
01047     }
01048   
01049   <span class="comment">/* Check is user (as specified by the credentials) is authorized to read the directory or not */</span>
01050   <span class="keywordflow">if</span>( <a class="code" href="cache__inode__access_8c.html#a1">cache_inode_access_no_mutex</a>( dir_pentry, 
01051                                    FSAL_R_OK,
01052                                    ht,
01053                                    pclient, 
01054                                    pcontext,
01055                                    pstatus ) != CACHE_INODE_SUCCESS )
01056      {
01057        V( dir_pentry-&gt;lock ) ;
01058        
01059        pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_GETATTR] += 1 ;
01060        <span class="keywordflow">return</span> *pstatus ;
01061      }
01062 
01063   <span class="comment">/* Is the directory fully cached (this is done if a readdir call if done on the directory) */</span>
01064   <span class="keywordflow">if</span>( dir_pentry-&gt;internal_md.type == DIR_BEGINNING )
01065     { 
01066       <span class="keywordflow">if</span>(  dir_pentry-&gt;object.dir_begin.has_been_readdir != CACHE_INODE_YES )
01067         {
01068 
01069            <span class="comment">/* populate the cache*/</span>
01070            <span class="keywordflow">if</span>( <a class="code" href="cache__inode__readdir_8c.html#a4">cache_inode_readdir_populate</a>( dir_pentry, 
01071                                              ht, 
01072                                              pclient, 
01073                                              pcontext, 
01074                                              pstatus ) != CACHE_INODE_SUCCESS )
01075              {
01076                <span class="comment">/* stats */</span>
01077                pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_READDIR] += 1 ;
01078          
01079                V( dir_pentry-&gt;lock ) ;
01080                <span class="keywordflow">return</span> *pstatus ;
01081              }
01082            
01083         }
01084 
01085        <span class="comment">/* Compute fist cookie in readdir */</span>
01086       first_pentry_cookie = 0 ;
01087     }
01088   <span class="keywordflow">else</span>
01089     {
01090       <span class="comment">/* DIR_CONTINUE */</span>
01091       tstflag = dir_pentry-&gt;object.dir_cont.pdir_begin-&gt;object.dir_begin.has_been_readdir ;
01092 
01093       <span class="comment">/* This test should see that "tstflag" is not CACHE_INODE_YES for a DIR_CONTINUE (if a DIR_CONTINUE exists, then </span>
01094 <span class="comment">       * it means that dir_chain was populated and this means a former call to cache_inode_readdir_populate. Later evolution</span>
01095 <span class="comment">       * of the code could make 'has_been_readdir' returned from CACHE_INODE_YES to CACHE_INODE_NO during garbagge collection.</span>
01096 <span class="comment">       * In this case, the following lines wil become necessary, but for now they are just here as 'defensive coding' */</span>
01097       <span class="keywordflow">if</span>( tstflag != CACHE_INODE_YES )
01098         {
01099 
01100           <span class="comment">/* populate the cache*/</span>
01101            <span class="keywordflow">if</span>( <a class="code" href="cache__inode__readdir_8c.html#a4">cache_inode_readdir_populate</a>(  dir_pentry-&gt;object.dir_cont.pdir_begin, 
01102                                               ht, 
01103                                               pclient, 
01104                                               pcontext, 
01105                                               pstatus ) != CACHE_INODE_SUCCESS )
01106              {
01107                <span class="comment">/* stats */</span>
01108                pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_READDIR] += 1 ;
01109          
01110                V( dir_pentry-&gt;lock ) ;
01111                <span class="keywordflow">return</span> *pstatus ;
01112              }
01113            
01114         }
01115       
01116       <span class="comment">/* Compute fist cookie in readdir */</span>
01117       first_pentry_cookie = dir_pentry-&gt;object.dir_cont.dir_cont_pos * CHILDREN_ARRAY_SIZE ;
01118     }
01119   
01120   <span class="comment">/* Now go through the pdir_chain for filling in dirent_array </span>
01121 <span class="comment">   * the first cookie is parameter 'cookie'</span>
01122 <span class="comment">   * number of entries queried is set by parameter 'nbwanted'</span>
01123 <span class="comment">   * number of found entries before eod is return is '*pnbfound' </span>
01124 <span class="comment">   * '*peod_met' is set if end of directory is encountered */</span>
01125 
01126   <span class="comment">/* Now, we can fill in the dirent array */</span>
01127   *pnbfound = 0 ;
01128   *peod_met = TO_BE_CONTINUED ;
01129 
01130   <span class="comment">/* Do we start to read the directory from the beginning ? */</span>
01131   <span class="keywordflow">if</span>( cookie == 0 )
01132     {
01133       <span class="comment">/* First call: the two first entries should be '.' and '..' */</span>
01134     }
01135   
01136 
01137   <span class="comment">/* loop into the dirent array to locate the pdir_chain item related to the input cookie */</span>
01138   nbdirchain = 0 ;
01139   pentry_to_read = dir_pentry ;
01140   
01141   <span class="keywordflow">while</span>( cookie - first_pentry_cookie &gt;= CHILDREN_ARRAY_SIZE ) <span class="comment">/* ????? */</span>
01142     {
01143       nbdirchain += 1 ;
01144 
01145       <span class="keywordflow">if</span>( pentry_to_read-&gt;internal_md.type == DIR_BEGINNING )
01146         {
01147           <span class="comment">/* if cookie - first_pentry_cookie is bigger than  CHILDREN_ARRAY_SIZE</span>
01148 <span class="comment">           * then the provided cookie was far too big for this pdir_chain. The </span>
01149 <span class="comment">           * client to cache_inode tried to read beyond the end of directory.</span>
01150 <span class="comment">           * In this case, return that EOD was met, but no entries found. */</span>
01151           
01152           <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_begin.end_of_dir == END_OF_DIR )
01153             { 
01154               V( dir_pentry-&gt;lock ) ;
01155 
01156                <span class="comment">/* stats */</span>
01157               pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_READDIR] += 1 ;
01158 
01159                <span class="keywordflow">if</span>( pentry_to_read-&gt;internal_md.type == DIR_BEGINNING )
01160                  *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry_to_read, CACHE_INODE_OP_GET, pclient ) ;
01161                <span class="keywordflow">else</span>
01162                  *pstatus = CACHE_INODE_SUCCESS ;
01163 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
01164 <span class="preprocessor"></span>               printf( <span class="stringliteral">"Big input cookie found in cache_inode_readdir (DIR_BEGIN) : pentry=%p cookie=%d first_pentry_cookie=%d nbdirchain=%d\n"</span>, 
01165                        pentry_to_read, cookie, first_pentry_cookie, nbdirchain ) ;
01166 <span class="preprocessor">#endif</span>
01167 <span class="preprocessor"></span>
01168                <span class="comment">/* Set the returned values */</span>
01169                *pnbfound    = 0 ;
01170                *pend_cookie = cookie ;
01171                *peod_met    = END_OF_DIR ;
01172 
01173               <span class="keywordflow">return</span> *pstatus ;
01174             }
01175           pentry_iter = pentry_to_read-&gt;object.dir_begin.pdir_cont ;
01176         }
01177       <span class="keywordflow">else</span>
01178         {
01179           <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_cont.end_of_dir == END_OF_DIR )
01180             {
01181               V( dir_pentry-&gt;lock ) ;
01182               
01183                <span class="comment">/* stats */</span>
01184                pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_READDIR] += 1 ;
01185                
01186                <span class="comment">/* OPeration is a success */</span>
01187                *pstatus = CACHE_INODE_SUCCESS ;
01188 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR</span>
01189 <span class="preprocessor"></span>               printf( <span class="stringliteral">"Trouble found in cache_inode_readdir (DIR_CONTINUE) : pentry=%p cookie=%d first_pentry_cookie=%d nbdirchain=%d\n"</span>, 
01190                        pentry_to_read, cookie, first_pentry_cookie, nbdirchain ) ;
01191 <span class="preprocessor">#endif</span>
01192 <span class="preprocessor"></span>               <span class="comment">/* Set the returned values */</span>
01193                *pnbfound    = 0 ;
01194                *pend_cookie = cookie ;
01195                *peod_met    = END_OF_DIR ;
01196                
01197                <span class="keywordflow">return</span> *pstatus ;
01198             }
01199           pentry_iter = pentry_to_read-&gt;object.dir_cont.pdir_cont ;
01200         }
01201 
01202       pentry_to_read = pentry_iter ;
01203       
01204       <span class="comment">/* At this step, pentry can't be something different of a DIR_CONTINUE,</span>
01205 <span class="comment">       * becase  cookie - first_pentry_cookie &gt;= CHILDREN_ARRAY_SIZE */</span>
01206       first_pentry_cookie = pentry_to_read-&gt;object.dir_cont.dir_cont_pos * CHILDREN_ARRAY_SIZE ;
01207       
01208     } <span class="comment">/* while */</span>
01209 <span class="preprocessor">#ifdef _DEBUG_NFS_READDIR  </span>
01210 <span class="preprocessor"></span>  printf( <span class="stringliteral">"About to readdir in  cache_inode_readdir: pentry=%p cookie=%d first_pentry_cookie=%d nbdirchain=%d\n"</span>, 
01211           pentry_to_read, cookie, first_pentry_cookie, nbdirchain ) ;
01212 <span class="preprocessor">#endif</span>
01213 <span class="preprocessor"></span>  <span class="comment">/* Get prepaired for readdir */</span>
01214 
01215   cookie_iter = cookie ;
01216   
01217   <span class="keywordflow">for</span>( i = 0 ; i &lt; nbwanted ; ) <span class="comment">/* i is incremented when something is found */</span>
01218     {
01219       <span class="keywordflow">if</span>( pentry_to_read-&gt;internal_md.type == DIR_BEGINNING )
01220         {
01221           <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_begin.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE].active == VALID )
01222             {
01223               <span class="comment">/* another entry was add to the result array */</span>
01224               dirent_array[i] = pentry_to_read-&gt;object.dir_begin.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE] ;
01225               cookie_array[i] = cookie_iter ;
01226 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
01227 <span class="preprocessor"></span>              printf( <span class="stringliteral">"--&gt; Cache_inode_readdir: Found slot with file named %s\n"</span>, 
01228                       pentry_to_read-&gt;object.dir_begin.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE].name.name ) ;
01229 <span class="preprocessor">#endif</span>
01230 <span class="preprocessor"></span>              <span class="comment">/* Step to next iter */</span>
01231               *pnbfound += 1 ;
01232               i += 1 ;
01233               
01234             }
01235         }
01236       <span class="keywordflow">else</span>
01237         {
01238           <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_cont.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE].active == VALID ) 
01239             {
01240               <span class="comment">/* another entry was add to the result array */</span>
01241               dirent_array[i] = pentry_to_read-&gt;object.dir_cont.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE] ;
01242               cookie_array[i] = cookie_iter ;
01243 <span class="preprocessor">#ifdef _DEBUG_CACHE_INODE</span>
01244 <span class="preprocessor"></span>              printf( <span class="stringliteral">"--&gt; Cache_inode_readdir: Found slot with file named %s\n"</span>, 
01245                       pentry_to_read-&gt;object.dir_cont.pdir_data-&gt;dir_entries[cookie_iter % CHILDREN_ARRAY_SIZE].name.name ) ;
01246 <span class="preprocessor">#endif</span>
01247 <span class="preprocessor"></span>              <span class="comment">/* Step to next iter */</span>
01248               *pnbfound += 1 ;
01249               i +=1 ;
01250               
01251             }
01252         }
01253 
01254       <span class="comment">/* Loop at next entry in dirent array */</span>
01255       cookie_iter += 1 ;
01256       *pend_cookie = cookie_iter ;
01257 
01258       <span class="keywordflow">if</span>( ( cookie_iter % CHILDREN_ARRAY_SIZE ) == 0 )
01259         {
01260           <span class="comment">/* It's time to step to the next dir_cont */</span>
01261           <span class="keywordflow">if</span>( pentry_to_read-&gt;internal_md.type == DIR_BEGINNING )
01262             {
01263               <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_begin.end_of_dir == END_OF_DIR )
01264                 {
01265                   <span class="comment">/* End of dir is reached */</span>
01266                   *peod_met = END_OF_DIR ;
01267                   *pstatus  = CACHE_INODE_SUCCESS ;
01268                   V( dir_pentry-&gt;lock ) ;
01269 
01270                   <span class="comment">/* stats */</span>
01271                   pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_READDIR] += 1 ;
01272 
01273                   <span class="keywordflow">return</span> *pstatus ;
01274                 }
01275               pentry_iter =  pentry_to_read-&gt;object.dir_begin.pdir_cont ;
01276               pentry_to_read = pentry_iter ;
01277               <span class="comment">/* cookie_iter = 0 ; */</span>
01278             } 
01279           <span class="keywordflow">else</span>
01280             {
01281               <span class="keywordflow">if</span>( pentry_to_read-&gt;object.dir_cont.end_of_dir == END_OF_DIR )
01282                 {
01283                   <span class="comment">/* End of dir is reached */</span>
01284                   *peod_met = END_OF_DIR ;
01285                   *pstatus  = CACHE_INODE_SUCCESS ;
01286                   V( dir_pentry-&gt;lock ) ;
01287 
01288                   <span class="comment">/* stats */</span>
01289                   pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_INODE_READDIR] += 1 ;
01290                
01291                   <span class="keywordflow">return</span> *pstatus ;
01292                 }
01293               pentry_iter =  pentry_to_read-&gt;object.dir_cont.pdir_cont ;
01294               pentry_to_read = pentry_iter ;
01295               <span class="comment">/* cookie_iter = 0 ; */</span>
01296             }
01297         } <span class="comment">/* if( cookie_iter == CHILDREN_ARRAY_SIZE ) */</span>
01298       
01299     } <span class="comment">/* for( i = 0 ; i &lt; nbwanted ; i ++ ) */</span>
01300 
01301   
01302   <span class="keywordflow">if</span>( pentry_to_read-&gt;internal_md.type == DIR_BEGINNING )
01303     *pstatus = <a class="code" href="cache__inode__misc_8c.html#a6">cache_inode_valid</a>( pentry_to_read, CACHE_INODE_OP_GET, pclient ) ;
01304   <span class="keywordflow">else</span>
01305     *pstatus = CACHE_INODE_SUCCESS ;
01306   
01307   V( dir_pentry-&gt;lock ) ;
01308 
01309   <span class="comment">/* stat */</span>
01310    <span class="keywordflow">if</span>( *pstatus != CACHE_INODE_SUCCESS )
01311      pclient-&gt;stat.func_stats.nb_err_retryable[CACHE_INODE_READDIR] += 1 ;
01312    <span class="keywordflow">else</span>
01313      pclient-&gt;stat.func_stats.nb_success[CACHE_INODE_READDIR] += 1 ;
01314   
01315   <span class="keywordflow">return</span> *pstatus ;
01316 } <span class="comment">/* cache_inode_readdir */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:52 2008 for Cache inode layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
