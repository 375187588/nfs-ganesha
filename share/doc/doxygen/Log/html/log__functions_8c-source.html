<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Log Library: log_functions.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>log_functions.c</h1><a href="log__functions_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> * ensemble des fonctions d'affichage et de gestion des erreurs</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> */</span>
00078 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00080 <span class="preprocessor">#endif</span>
00081 <span class="preprocessor"></span>
00082 
00083 <span class="preprocessor">#include &lt;stdlib.h&gt;</span> <span class="comment">/* for malloc */</span>
00084 <span class="preprocessor">#include &lt;ctype.h&gt;</span>  <span class="comment">/* for isdigit */</span>
00085 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00086 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00087 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00088 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00089 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00090 <span class="preprocessor">#include &lt;time.h&gt;</span>
00091 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00092 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00093 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00094 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00095 <span class="preprocessor">#include &lt;string.h&gt;</span>
00096 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00097 
00098 <span class="preprocessor">#include "log_functions.h"</span>
00099 
00100 <span class="comment">/* La longueur d'une chaine */</span>
<a name="l00101"></a><a class="code" href="log__functions_8c.html#a0">00101</a> <span class="preprocessor">#define STR_LEN_TXT      2048</span>
<a name="l00102"></a><a class="code" href="log__functions_8c.html#a1">00102</a> <span class="preprocessor"></span><span class="preprocessor">#define PATH_LEN         1024</span>
<a name="l00103"></a><a class="code" href="log__functions_8c.html#a2">00103</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_STR_LEN      1024</span>
<a name="l00104"></a><a class="code" href="log__functions_8c.html#a3">00104</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_NUM_FAMILY  50 </span>
<a name="l00105"></a><a class="code" href="log__functions_8c.html#a4">00105</a> <span class="preprocessor"></span><span class="preprocessor">#define UNUSED_SLOT -1 </span>
00106 <span class="preprocessor"></span>
00107 <span class="comment">/* P et V pour etre Djikstra-compliant */</span>
<a name="l00108"></a><a class="code" href="log__functions_8c.html#a5">00108</a> <span class="preprocessor">#define P( _mutex_ ) pthread_mutex_lock( &amp;_mutex_)</span>
<a name="l00109"></a><a class="code" href="log__functions_8c.html#a6">00109</a> <span class="preprocessor"></span><span class="preprocessor">#define V( _mutex_ ) pthread_mutex_unlock( &amp;_mutex_ )</span>
00110 <span class="preprocessor"></span>
00111 
00112 <span class="comment">/* constants */</span>
00113 <span class="keyword">static</span> <span class="keywordtype">int</span> masque_log = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ;
00114 
00115 
00116 <span class="comment">/* Array of error families */</span>
00117 
00118 <span class="keyword">static</span> family_t tab_family[MAX_NUM_FAMILY] ;
00119 
00120 
00121 <span class="comment">/* Global variables */</span>
00122 
00123 <span class="keyword">static</span> <span class="keywordtype">char</span> nom_programme[1024];
00124 <span class="keyword">static</span> <span class="keywordtype">char</span> nom_host[256] ;
00125 <span class="keyword">static</span> <span class="keywordtype">char</span> nom_fichier_log[PATH_LEN] = <span class="stringliteral">"/tmp/logfile"</span> ;
00126 <span class="keyword">static</span> <span class="keywordtype">int</span> niveau_debug = 2 ;
00127 
00128 <span class="comment">/*</span>
00129 <span class="comment"> * Variables specifiques aux threads.</span>
00130 <span class="comment"> */</span>
00131 
<a name="l00132"></a><a class="code" href="structThreadLogContext__t.html">00132</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> {
00133   
<a name="l00134"></a><a class="code" href="structThreadLogContext__t.html#o0">00134</a>   <span class="keywordtype">char</span> nom_fonction[STR_LEN] ;  
00135   
00136 } <a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a>;
00137 
00138 <span class="comment">/* threads keys */</span>
00139 <span class="keyword">static</span> pthread_key_t thread_key ;
00140 <span class="keyword">static</span> pthread_once_t once_key = PTHREAD_ONCE_INIT ;
00141 
00142 
00143 <span class="preprocessor">#ifdef _DONT_HAVE_LOCALTIME_R</span>
00144 <span class="preprocessor"></span>
00145 <span class="comment">/* Localtime is not reentrant...</span>
00146 <span class="comment"> * So we are obliged to have a mutex for calling it.</span>
00147 <span class="comment"> * pffff....</span>
00148 <span class="comment"> */</span>
00149 <span class="keyword">static</span> pthread_mutex_t mutex_localtime = PTHREAD_MUTEX_INITIALIZER;
00150 
00151 
00152 <span class="comment">/* thread-safe and PORTABLE version of localtime */</span>
00153 
00154 <span class="keyword">static</span> <span class="keyword">struct </span>tm * <a class="code" href="log__functions_8c.html#a7">Localtime_r</a>( <span class="keyword">const</span> time_t * p_time, <span class="keyword">struct</span> tm * p_tm )
00155 {
00156   <span class="keyword">struct </span>tm * p_tmp_tm;
00157   
00158   <span class="keywordflow">if</span> ( !p_tm )
00159   {
00160     errno = EFAULT;
00161     <span class="keywordflow">return</span> NULL;
00162   }
00163   
00164   pthread_mutex_lock( &amp;mutex_localtime );
00165   
00166   p_tmp_tm = localtime( p_time );
00167   
00168   <span class="comment">/* copy the result */</span>
00169    (*p_tm) = (*p_tmp_tm);
00170     
00171   pthread_mutex_unlock( &amp;mutex_localtime );
00172   
00173   <span class="keywordflow">return</span> p_tm;
00174 }
00175 <span class="preprocessor">#else</span>
<a name="l00176"></a><a class="code" href="log__functions_8c.html#a7">00176</a> <span class="preprocessor"></span><span class="preprocessor"># define Localtime_r localtime_r</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00178 <span class="preprocessor"></span>
00179 
00180 <span class="comment">/* forward declaration for diplaying errors. */</span>
00181 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayError( <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status );
00182 
00183 
00184 <span class="comment">/* Init of pthread_keys */</span>
00185 <span class="keyword">static</span> <span class="keywordtype">void</span> init_keys( <span class="keywordtype">void</span> )
00186 {
00187   <span class="keywordflow">if</span>( pthread_key_create( &amp;thread_key, NULL ) == -1 )
00188       DisplayError( ERR_PTHREAD_KEY_CREATE, errno ) ;
00189   
00190   return ;
00191 } <span class="comment">/* init_keys */</span>
00192 
00193 
00194 
00199 <span class="keyword">static</span> <a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a>  * Log_GetThreadContext(){
00200   
00201   <a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> * p_current_thread_vars ;
00202   
00203   
00204   <span class="comment">/* first, we init the keys if this is the first time */</span>
00205   <span class="keywordflow">if</span>( pthread_once( &amp;once_key, init_keys ) != 0 ){
00206     DisplayError( ERR_PTHREAD_ONCE,errno);
00207     <span class="keywordflow">return</span> NULL;
00208   }
00209   
00210   p_current_thread_vars = (<a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> *)pthread_getspecific( thread_key );
00211   
00212   <span class="comment">/* we allocate the thread key if this is the first time */</span>
00213   <span class="keywordflow">if</span> (p_current_thread_vars==NULL){
00214       
00215     <span class="comment">/* allocates thread structure */</span>
00216     p_current_thread_vars = (<a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a>));
00217     
00218 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
00219 <span class="preprocessor"></span>    printf(<span class="stringliteral">"malloc =&gt; %p\n"</span>,p_current_thread_vars);
00220 <span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span>    
00222     <span class="keywordflow">if</span> (p_current_thread_vars == NULL) {      
00223       DisplayError( ERR_MALLOC, errno ) ;
00224       <span class="keywordflow">return</span> NULL;
00225     }
00226     
00227     <span class="comment">/* inits thread structures */</span>
00228     p_current_thread_vars-&gt;<a class="code" href="structThreadLogContext__t.html#o0">nom_fonction</a>[0] = <span class="charliteral">'\0'</span>;
00229     
00230     <span class="comment">/* set the specific value */</span>
00231     pthread_setspecific( thread_key , (<span class="keywordtype">void</span> *)p_current_thread_vars ) ;
00232     
00233   } 
00234  
00235   <span class="keywordflow">return</span> p_current_thread_vars ;
00236   
00237 }<span class="comment">/* GetThreadContext */</span>
00238 
00239 
00240 
00241 
00242 <span class="comment">/* Affichage d'erreurs */</span>
00243 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayError( <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status )
00244 {
00245   
00246   <span class="keywordflow">return</span> fprintf( stderr, <span class="stringliteral">"Error %s status %d ==&gt; %s\n"</span>, tab_systeme_err[num_error].label,
00247                   status, strerror( status ) ) ;
00248   
00249 } <span class="comment">/* DisplayError */</span>
00250 
00251 
00252 <span class="comment">/*</span>
00253 <span class="comment"> * Fait la conversion nom du niveau de log</span>
00254 <span class="comment"> * en ascii vers valeur numerique du niveau</span>
00255 <span class="comment"> *</span>
00256 <span class="comment"> */</span>
00257 
<a name="l00258"></a><a class="code" href="log__functions_8c.html#a48">00258</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a48">ReturnLevelAscii</a>( <span class="keywordtype">char</span> * LevelEnAscii )
00259 {
00260   <span class="keywordtype">int</span> i=0 ;
00261   
00262   <span class="keywordflow">for</span>( i = 0 ; i &lt; NB_LOG_LEVEL ; i++ )
00263     <span class="keywordflow">if</span>( !strcmp( tabLogLevel[i].str, LevelEnAscii ) )
00264       <span class="keywordflow">return</span> tabLogLevel[i].value ;
00265   
00266   <span class="comment">/* Si rien n'est trouve on retourne -1 */</span>
00267   <span class="keywordflow">return</span> -1 ; 
00268 } <span class="comment">/* ReturnLevelAscii */</span>
00269 
<a name="l00270"></a><a class="code" href="log__functions_8c.html#a49">00270</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a49">ReturnLevelInt</a>( <span class="keywordtype">int</span> level )
00271 {
00272   <span class="keywordtype">int</span> i=0 ;
00273   
00274   <span class="keywordflow">for</span>( i = 0 ; i &lt; NB_LOG_LEVEL ; i++ )
00275     <span class="keywordflow">if</span>(  tabLogLevel[i].value == level ) 
00276       <span class="keywordflow">return</span> tabLogLevel[i].str ;
00277   
00278   <span class="comment">/* Si on n'a rien trouve on retourne NULL */</span>
00279   <span class="keywordflow">return</span> NULL ;  
00280 } <span class="comment">/* ReturnLevelInt */</span>
00281 
00282 
00283 <span class="comment">/*</span>
00284 <span class="comment"> * Set le nom du programme en cours.</span>
00285 <span class="comment"> */</span>
<a name="l00286"></a><a class="code" href="log__functions_8c.html#a50">00286</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a50">SetNamePgm</a>( <span class="keywordtype">char</span> * nom )
00287 {
00288 
00289   <span class="comment">/* Cette fonction n'est pas thread-safe car le nom du programme</span>
00290 <span class="comment">   * est commun a tous les threads */</span>
00291   strcpy( nom_programme, nom ) ;
00292 
00293   <span class="keywordflow">return</span> 1 ;
00294 } <span class="comment">/* SetNamePgm */</span>
00295 
00296 
00297 <span class="comment">/*</span>
00298 <span class="comment"> * Set le nom d'host en cours </span>
00299 <span class="comment"> */</span>
<a name="l00300"></a><a class="code" href="log__functions_8c.html#a51">00300</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a51">SetNameHost</a>( <span class="keywordtype">char</span> * nom )
00301 {
00302   strcpy( nom_host, nom ) ;
00303   <span class="keywordflow">return</span> 1 ;
00304 } <span class="comment">/* SetNameHost */</span>
00305 
00306 <span class="comment">/*</span>
00307 <span class="comment"> *</span>
00308 <span class="comment"> * Set le nom de la fonction en cours</span>
00309 <span class="comment"> *</span>
00310 <span class="comment"> */</span>
<a name="l00311"></a><a class="code" href="log__functions_8c.html#a52">00311</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a52">SetNameFunction</a>( <span class="keywordtype">char</span> * nom )
00312 {
00313 
00314   <a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> * context = Log_GetThreadContext();
00315   
00316   strcpy( context-&gt;<a class="code" href="structThreadLogContext__t.html#o0">nom_fonction</a>, nom ) ;
00317 
00318   <span class="keywordflow">return</span> 1;
00319 } <span class="comment">/* SetNameFunction */</span>
00320 
00321 
00322 <span class="comment">/* </span>
00323 <span class="comment"> * Set le fichier dans lequel vont etre loggues les messages</span>
00324 <span class="comment"> */</span>
<a name="l00325"></a><a class="code" href="log__functions_8c.html#a53">00325</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a53">SetNameFileLog</a>( <span class="keywordtype">char</span> * nom )
00326 { 
00327   <span class="comment">/* Cette fonction n'est pas thread-safe car le fichier de log</span>
00328 <span class="comment">   * est commun a tous les threads du programme */</span>
00329   strcpy( nom_fichier_log, nom ) ;
00330   
00331   <span class="keywordflow">return</span> 1;
00332 } <span class="comment">/* SetNameFileLog */</span>
00333 
00334 
00335 <span class="comment">/*</span>
00336 <span class="comment"> * Return le nom du programme en cours </span>
00337 <span class="comment"> */</span> 
<a name="l00338"></a><a class="code" href="log__functions_8c.html#a54">00338</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a54">ReturnNamePgm</a>()
00339 {
00340   <span class="keywordflow">return</span> nom_programme ;
00341 } <span class="comment">/* ReturnNamePgm */</span>
00342 
00343 
00344 <span class="comment">/*</span>
00345 <span class="comment"> * Return le nom du host en cours </span>
00346 <span class="comment"> */</span> 
<a name="l00347"></a><a class="code" href="log__functions_8c.html#a55">00347</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a55">ReturnNameHost</a>()
00348 {  
00349   <span class="keywordflow">return</span> nom_host ;
00350 } <span class="comment">/* ReturnNameHost */</span>
00351 
00352 
00353 <span class="comment">/*</span>
00354 <span class="comment"> * Return le nom de la fonction en cours </span>
00355 <span class="comment"> */</span>
00356 
<a name="l00357"></a><a class="code" href="log__functions_8c.html#a56">00357</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a56">ReturnNameFunction</a>()
00358 {
00359   <a class="code" href="structThreadLogContext__t.html">ThreadLogContext_t</a> * context = Log_GetThreadContext();
00360   
00361   <span class="keywordflow">return</span> context-&gt;<a class="code" href="structThreadLogContext__t.html#o0">nom_fonction</a> ;
00362 } <span class="comment">/* ReturnNameFunction */</span>
00363 
00364 
00365 <span class="comment">/*</span>
00366 <span class="comment"> * Return le chemin du fichier de log</span>
00367 <span class="comment"> */</span>
<a name="l00368"></a><a class="code" href="log__functions_8c.html#a57">00368</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a57">ReturnNameFileLog</a>()  <span class="comment">/* Cette fonction n'est PAS MT-Safe */</span>
00369 {
00370   <span class="keywordflow">return</span> nom_fichier_log ;
00371 } <span class="comment">/* ReturnNameFileLog */</span>
00372 
00373  
00374 <span class="comment">/*</span>
00375 <span class="comment"> * Cette fonction permet d'installer un handler de signal </span>
00376 <span class="comment"> */</span>
00377 
00378 <span class="keyword">static</span> <span class="keywordtype">void</span> ArmeSignal( <span class="keywordtype">int</span> signal, <span class="keywordtype">void</span> (*action)() )
00379 {
00380   <span class="keyword">struct </span>sigaction act ; <span class="comment">/* Soyons POSIX et puis signal() c'est pas joli */</span>
00381   <span class="keywordtype">char</span> buffer[1024] ;
00382   
00383   <span class="comment">/* Mise en place des champs du struct sigaction */</span>
00384   act.sa_flags = 0 ;
00385   act.sa_handler = action ;
00386   sigemptyset( &amp;act.sa_mask ) ;
00387   
00388   <span class="keywordflow">if</span>( sigaction( signal, &amp;act, NULL ) == -1 )
00389     {
00390       DisplayError( ERR_SIGACTION, errno ) ;
00391       snprintf( buffer, 1024, <span class="stringliteral">"Impossible de controler %d"</span>, signal ) ;
00392       <a class="code" href="log__functions_8c.html#a70">DisplayLogFlux</a>( stdout, <span class="stringliteral">"%s"</span>, buffer ) ;
00393     }
00394 } <span class="comment">/* ArmeSignal */</span>
00395 
00396   
00397 <span class="comment">/*</span>
00398 <span class="comment"> *</span>
00399 <span class="comment"> * Cinq fonctions pour gerer le niveau de debug et le controler</span>
00400 <span class="comment"> * a distance au travers de handlers de signaux</span>
00401 <span class="comment"> *</span>
00402 <span class="comment"> * InitDebug</span>
00403 <span class="comment"> * IncrementeLevelDebug</span>
00404 <span class="comment"> * DecrementeLevelDebug</span>
00405 <span class="comment"> * SetLevelDebug</span>
00406 <span class="comment"> * ReturnLevelDebug</span>
00407 <span class="comment"> * </span>
00408 <span class="comment"> */</span>
00409 
<a name="l00410"></a><a class="code" href="log__functions_8c.html#a59">00410</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a59">ReturnLevelDebug</a>()
00411 {
00412   <span class="keywordflow">return</span> niveau_debug ;
00413 } <span class="comment">/* ReturnLevelDebug */</span>
00414 
<a name="l00415"></a><a class="code" href="log__functions_8c.html#a60">00415</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a60">SetLevelDebug</a>( <span class="keywordtype">int</span> level_to_set )
00416 {
00417   <span class="keywordflow">if</span>( level_to_set &lt; 0 )
00418     level_to_set = 0 ;
00419   
00420   niveau_debug = level_to_set ;
00421   
00422   <span class="keywordflow">return</span> niveau_debug ;
00423 } <span class="comment">/* SetLevelDebug */</span>
00424 
00425 
00426 
00427 <span class="keyword">static</span> <span class="keywordtype">void</span> IncrementeLevelDebug()
00428 {
00429   <span class="keywordtype">char</span> buffer[1024] ;
00430   
00431   niveau_debug += 1 ;
00432   <span class="keywordflow">if</span>( niveau_debug &gt;= NB_LOG_LEVEL )
00433     niveau_debug = NB_LOG_LEVEL-1 ;
00434   
00435   snprintf( buffer, 1024, <span class="stringliteral">"SIGUSR1 recu -&gt; Level de debug: %s = %d "</span>, 
00436            <a class="code" href="log__functions_8c.html#a49">ReturnLevelInt</a>( niveau_debug ), niveau_debug ) ;
00437 
00438   <a class="code" href="log__functions_8c.html#a70">DisplayLogFlux</a>( stdout, <span class="stringliteral">"%s"</span>, buffer ) ;
00439 } <span class="comment">/* IncrementeLevelDebug */</span>
00440 
00441 <span class="keyword">static</span> <span class="keywordtype">void</span> DecrementeLevelDebug()
00442 {
00443   <span class="keywordtype">char</span> buffer[1024] ;
00444   
00445   niveau_debug -= 1 ;
00446   <span class="keywordflow">if</span>( niveau_debug &lt; 0 ) 
00447     niveau_debug = 0 ;
00448 
00449   snprintf( buffer, 1024, <span class="stringliteral">"SIGUSR2 recu -&gt; Level de debug: %s = %d "</span>, 
00450            <a class="code" href="log__functions_8c.html#a49">ReturnLevelInt</a>( niveau_debug ), niveau_debug ) ;
00451 
00452   <a class="code" href="log__functions_8c.html#a70">DisplayLogFlux</a>( stdout, <span class="stringliteral">"%s"</span>, buffer ) ;
00453 } <span class="comment">/* DecrementeLevelDebug */</span>
00454 
00455 
<a name="l00456"></a><a class="code" href="log__functions_8c.html#a63">00456</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a63">InitDebug</a>( <span class="keywordtype">int</span> level_to_set )
00457 {
00458   <span class="keywordtype">int</span> i = 0 ;
00459   
00460   <span class="comment">/* Initialisation du tableau des familys */</span>
00461   tab_family[0].num_family = 0 ;
00462   tab_family[0].tab_err     = (family_error_t *)tab_systeme_err ;
00463   strcpy( tab_family[0].name_family, <span class="stringliteral">"Errors Systeme UNIX"</span> ) ;
00464   
00465   <span class="keywordflow">for</span>( i = 1 ; i &lt; MAX_NUM_FAMILY ; i++ )
00466     tab_family[i].num_family = UNUSED_SLOT ;
00467   
00468   <span class="comment">/* On impose le niveau de debug */</span>
00469   <a class="code" href="log__functions_8c.html#a60">SetLevelDebug</a>( level_to_set ) ;
00470   
00471   ArmeSignal( SIGUSR1, IncrementeLevelDebug ) ;
00472   ArmeSignal( SIGUSR2, DecrementeLevelDebug ) ;
00473 
00474   <span class="keywordflow">return</span> 0 ;
00475 } <span class="comment">/* InitLevelDebug */</span>
00476 
00477 <span class="comment">/* </span>
00478 <span class="comment"> *</span>
00479 <span class="comment"> * La fonction qui fait l'entete pour tout le monde</span>
00480 <span class="comment"> *</span>
00481 <span class="comment"> */</span>
00482 
00483 <span class="keyword">static</span> <span class="keywordtype">int</span> FaireEntete( <span class="keywordtype">char</span> * output )
00484 {
00485   <span class="keyword">struct </span>tm the_date ;
00486   time_t heure ; 
00487       
00488   heure = time( NULL );
00489   <a class="code" href="log__functions_8c.html#a7">Localtime_r</a>( &amp;heure, &amp;the_date );  
00490   
00491   <span class="keywordflow">return</span> snprintf( output,STR_LEN,<span class="stringliteral">"%.2d/%.2d/%.4d %.2d:%.2d:%.2d epoch=%ld : %s : %s-%d[%s] :"</span>,
00492                    the_date.tm_mday, the_date.tm_mon+1, 1900 + the_date.tm_year,
00493                   the_date.tm_hour, the_date.tm_min, the_date.tm_sec, heure,  nom_host, 
00494                   nom_programme,getpid(),<a class="code" href="log__functions_8c.html#a56">ReturnNameFunction</a>() ) ;
00495   
00496 } <span class="comment">/* Faire_entete */</span>
00497 
00498 
00499 <span class="comment">/*</span>
00500 <span class="comment"> * Une fonction d'affichage tout a fait generique </span>
00501 <span class="comment"> */</span>
00502 
00503 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayLogString_valist( <span class="keywordtype">char</span> * buff_dest, <span class="keywordtype">char</span> * format, va_list arguments )
00504 { 
00505   <span class="keywordtype">char</span> entete[STR_LEN] ;
00506   <span class="keywordtype">char</span> texte[STR_LEN_TXT] ;
00507   
00508   <span class="comment">/* Je mets en place l'entete */</span>
00509   FaireEntete( entete ) ;
00510   
00511   <span class="comment">/* Ecriture sur le fichier choisi */</span>
00512   <a class="code" href="log__functions_8c.html#a94">log_vsnprintf</a>( texte, STR_LEN_TXT, format, arguments ) ;
00513   <span class="keywordflow">return</span> snprintf( buff_dest, STR_LEN_TXT, <span class="stringliteral">"%s%s\n"</span>, entete, texte )  ;
00514 } <span class="comment">/* DisplayLogString_valist */</span>
00515 
00516 
00517 <span class="comment">/* </span>
00518 <span class="comment"> *</span>
00519 <span class="comment"> * Display un message avec entete et avec le format (printf-like) indique </span>
00520 <span class="comment"> *</span>
00521 <span class="comment"> */</span>
00522 
<a name="l00523"></a><a class="code" href="log__functions_8c.html#a66">00523</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a66">DisplayLogString</a>( <span class="keywordtype">char</span> * chaine, <span class="keywordtype">char</span> * format, ... )
00524 {
00525   <span class="keywordtype">int</span> rc;
00526   va_list arguments ;  
00527   
00528   va_start( arguments, format ) ;  
00529   rc = DisplayLogString_valist( chaine, format, arguments ) ;  
00530   va_end( arguments );
00531   
00532   <span class="keywordflow">return</span> rc;
00533   
00534 } <span class="comment">/* DisplayLogString */</span>
00535 
00536 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayLogFd_valist( <span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> * format, va_list arguments )
00537 {
00538   <span class="keywordtype">char</span> tampon[STR_LEN_TXT]  ;
00539 
00540   DisplayLogString_valist( tampon, format, arguments ) ;
00541   <span class="keywordflow">return</span> write( fd, tampon, strlen( tampon ) ) ;
00542 } <span class="comment">/* DisplayLogFd_valist */</span>
00543 
00544 
<a name="l00545"></a><a class="code" href="log__functions_8c.html#a68">00545</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a68">DisplayLogFd</a>( <span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> * format, ... )
00546 {
00547   va_list arguments ;
00548   <span class="keywordtype">int</span> rc;
00549   
00550   va_start( arguments, format ) ;
00551   rc = DisplayLogFd_valist( fd, format, arguments ) ;
00552   va_end( arguments) ;
00553   
00554   <span class="keywordflow">return</span> rc;
00555   
00556 } <span class="comment">/* DisplayLogFd */</span>
00557 
00558 
00559 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayLogFlux_valist( FILE * flux, <span class="keywordtype">char</span> * format, va_list arguments ) 
00560 {
00561   <span class="keywordtype">char</span> tampon[STR_LEN_TXT] ;
00562 
00563   DisplayLogString_valist( tampon, format, arguments ) ;
00564   
00565   fprintf( flux, <span class="stringliteral">"%s"</span>, tampon ) ;
00566   <span class="keywordflow">return</span> fflush( flux ) ;
00567 } <span class="comment">/* DisplayLogFlux_valist */</span>
00568 
<a name="l00569"></a><a class="code" href="log__functions_8c.html#a70">00569</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a70">DisplayLogFlux</a>( FILE * flux, <span class="keywordtype">char</span> * format, ... )
00570 {
00571   va_list arguments ;
00572   <span class="keywordtype">int</span> rc;
00573 
00574   va_start( arguments, format ) ;
00575   rc = DisplayLogFlux_valist( flux, format, arguments ) ;
00576   va_end( arguments );
00577   
00578   <span class="keywordflow">return</span> rc;
00579   
00580 } <span class="comment">/* DisplayLogFlux */</span>
00581 
00582 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayLogPath_valist( <span class="keywordtype">char</span> * path, <span class="keywordtype">char</span> * format, va_list arguments ) 
00583 {
00584   <span class="keywordtype">char</span> tampon[STR_LEN_TXT] ;
00585   <span class="keywordtype">int</span> fd , my_status ;
00586 
00587   DisplayLogString_valist( tampon, format, arguments ) ;
00588  
00589   <span class="keywordflow">if</span>( path[0] != <span class="charliteral">'\0'</span> )
00590     {
00591 <span class="preprocessor">#ifdef _LOCK_LOG</span>
00592 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (( fd = open( path, O_WRONLY | O_SYNC | O_APPEND | O_CREAT,
00593                        masque_log ) ) != -1 )
00594 <span class="preprocessor">#else</span>
00595 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (( fd = open( path, O_WRONLY | O_NONBLOCK | O_APPEND | O_CREAT,
00596                        masque_log ) ) != -1 )
00597 <span class="preprocessor">#endif</span>
00598 <span class="preprocessor"></span>        {
00599           <span class="comment">/* Si la creation ou l'ouverture du fichier est OK */</span>
00600          
00601           <span class="comment">/* un verrou sur fichier */</span>
00602           <span class="keyword">struct </span>flock lock_file ;
00603         
00604           <span class="comment">/* mise en place de la structure de verrou sur fichier */</span>
00605           lock_file.l_type = F_WRLCK ;
00606           lock_file.l_whence = SEEK_SET ;
00607           lock_file.l_start = 0 ;
00608           lock_file.l_len = 0 ;
00609           
00610 <span class="preprocessor">#ifdef _LOCK_LOG</span>
00611 <span class="preprocessor"></span>          <span class="keywordflow">if</span>( fcntl( fd, F_SETLKW, (<span class="keywordtype">char</span> *)&amp;lock_file ) != -1 )
00612             {
00613 <span class="preprocessor">#endif</span>
00614 <span class="preprocessor"></span>              <span class="comment">/* Si la prise du verrou est OK */</span>
00615               write( fd, tampon, strlen( tampon ) ) ;
00616               
00617 <span class="preprocessor">#ifdef _LOCK_LOG</span>
00618 <span class="preprocessor"></span>              <span class="comment">/* Relache du verrou sur fichier */</span>
00619               lock_file.l_type = F_UNLCK ;
00620               fcntl( fd, F_SETLKW, (<span class="keywordtype">char</span> *)&amp;lock_file ) ;
00621 <span class="preprocessor">#endif</span>
00622 <span class="preprocessor"></span>             
00623               <span class="comment">/* fermeture du fichier */</span>
00624               close( fd ) ;
00625               
00626               <span class="keywordflow">return</span> SUCCES ;
00627 <span class="preprocessor">#ifdef _LOCK_LOG</span>
00628 <span class="preprocessor"></span>            } <span class="comment">/* if fcntl */</span>
00629           <span class="keywordflow">else</span>
00630             {
00631               <span class="comment">/* Si la prise du verrou a fait un probleme */</span>
00632               my_status = errno ;
00633               close( fd ) ;
00634             }
00635 <span class="preprocessor">#endif</span>
00636 <span class="preprocessor"></span>          close( fd ) ; 
00637         } <span class="comment">/* if open */</span>
00638       <span class="keywordflow">else</span>
00639         {
00640           <span class="comment">/* Si l'ouverture du fichier s'est mal passee */</span>
00641           my_status = errno ;
00642         } 
00643       fprintf( stderr, <span class="stringliteral">"Error %s : %s : status %d\n"</span>, 
00644                tab_systeme_err[ERR_FICHIER_LOG].label,
00645                tab_systeme_err[ERR_FICHIER_LOG].msg, 
00646                my_status ) ;
00647       
00648       <span class="keywordflow">return</span> ERR_FICHIER_LOG ;
00649     } <span class="comment">/* if path */</span>
00650  
00651   <span class="keywordflow">return</span> SUCCES ;
00652 } <span class="comment">/* DisplayLogPath_valist */</span>
00653 
<a name="l00654"></a><a class="code" href="log__functions_8c.html#a72">00654</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a72">DisplayLogPath</a>( <span class="keywordtype">char</span> * path, <span class="keywordtype">char</span> * format, ... )
00655 {
00656   <span class="keywordtype">int</span> rc;
00657   va_list arguments ;
00658   
00659   va_start( arguments, format ) ;
00660   rc = DisplayLogPath_valist( path, format, arguments ) ;
00661   va_end( arguments );
00662   
00663   <span class="keywordflow">return</span> rc;
00664   
00665 } <span class="comment">/* DisplayLogPath */</span>
00666 
00667 <span class="keyword">static</span> <span class="keywordtype">int</span> DisplayLog_valist( <span class="keywordtype">char</span> * format, va_list arguments ) 
00668 {
00669   <span class="keywordflow">return</span> DisplayLogPath_valist( nom_fichier_log, format, arguments ) ;
00670 } <span class="comment">/* DisplayLog_valist */</span>
00671 
<a name="l00672"></a><a class="code" href="log__functions_8c.html#a74">00672</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a74">DisplayLog</a>( <span class="keywordtype">char</span> * format, ... )
00673 {
00674   va_list arguments ;
00675   <span class="keywordtype">int</span> rc;
00676   
00677   va_start( arguments, format ) ;
00678   rc = DisplayLog_valist( format, arguments ) ;
00679   va_end( arguments );
00680   
00681   <span class="keywordflow">return</span> rc;
00682   
00683 } <span class="comment">/* DisplayLog */</span>
00684 
00685 
00686 
00687 <span class="comment">/*</span>
00688 <span class="comment"> *</span>
00689 <span class="comment"> * Les memes fonctions mais avec des considerations de niveau</span>
00690 <span class="comment"> *</span>
00691 <span class="comment"> */</span>
00692 
<a name="l00693"></a><a class="code" href="log__functions_8c.html#a75">00693</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a75">DisplayLogStringLevel</a>( <span class="keywordtype">char</span> * tampon, <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... )
00694 {
00695   va_list arguments ;
00696   <span class="keywordtype">int</span> rc;
00697   
00698   va_start( arguments, format ) ;
00699   
00700   <span class="keywordflow">if</span>( level &lt;= niveau_debug )
00701   {
00702     rc = DisplayLogString_valist( tampon, format, arguments ) ;    
00703   }
00704   <span class="keywordflow">else</span> 
00705     rc = SUCCES ;
00706   
00707   va_end( arguments ) ;
00708   
00709   <span class="keywordflow">return</span> rc;
00710   
00711 } <span class="comment">/* DisplayLogStringLevel */</span>
00712 
00713 
<a name="l00714"></a><a class="code" href="log__functions_8c.html#a76">00714</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a76">DisplayLogFluxLevel</a>( FILE * flux, <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... ) 
00715 {
00716   va_list arguments ;
00717   <span class="keywordtype">int</span> rc;
00718   
00719   va_start( arguments, format ) ;
00720   
00721   <span class="keywordflow">if</span>( level &lt;= niveau_debug )
00722     rc = DisplayLogFlux_valist( flux, format, arguments ) ;
00723   <span class="keywordflow">else</span>
00724     rc = SUCCES ;
00725   
00726   va_end( arguments) ;
00727   
00728   <span class="keywordflow">return</span> rc;
00729   
00730 } <span class="comment">/* DisplayLogFluxLevel */</span>
00731 
00732 
<a name="l00733"></a><a class="code" href="log__functions_8c.html#a77">00733</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a77">DisplayLogFdLevel</a>( <span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... ) 
00734 {
00735   va_list arguments ;
00736   <span class="keywordtype">int</span> rc;
00737   
00738   va_start( arguments, format ) ;
00739   
00740   <span class="keywordflow">if</span>( level &lt;= niveau_debug )
00741     rc = DisplayLogFd_valist( fd, format, arguments ) ;
00742   <span class="keywordflow">else</span>
00743     rc = SUCCES ;
00744   
00745   va_end( arguments) ;
00746   
00747   <span class="keywordflow">return</span> rc;
00748   
00749 } <span class="comment">/* DisplayLogFdLevel */</span>
00750 
<a name="l00751"></a><a class="code" href="log__functions_8c.html#a78">00751</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a78">DisplayLogLevel</a>( <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... ) 
00752 {
00753   va_list arguments ;
00754   <span class="keywordtype">int</span> rc;
00755   
00756   va_start( arguments, format ) ;
00757   
00758   <span class="keywordflow">if</span>( level &lt;= niveau_debug )
00759     rc = DisplayLog_valist( format, arguments ) ;
00760   <span class="keywordflow">else</span>
00761     rc = SUCCES ;
00762   
00763   va_end( arguments) ;
00764   
00765   <span class="keywordflow">return</span> rc;  
00766   
00767 } <span class="comment">/* DisplayLogLevel */</span>
00768 
00769 
<a name="l00770"></a><a class="code" href="log__functions_8c.html#a79">00770</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a79">DisplayLogPathLevel</a>( <span class="keywordtype">char</span> * path, <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... ) 
00771 {
00772   va_list arguments ;
00773   <span class="keywordtype">int</span> rc;
00774   
00775   va_start( arguments, format ) ;
00776   
00777   <span class="keywordflow">if</span>( level &lt;= niveau_debug )
00778     rc = DisplayLogPath_valist( path, format, arguments ) ;
00779   <span class="keywordflow">else</span>
00780     rc = SUCCES ;
00781   
00782   va_end( arguments) ;
00783  
00784   <span class="keywordflow">return</span> rc;
00785   
00786 } <span class="comment">/* DisplayLogPathLevel */</span>
00787 
00788 <span class="comment">/*</span>
00789 <span class="comment"> *</span>
00790 <span class="comment"> * Les routines de gestions des messages d'erreur </span>
00791 <span class="comment"> *</span>
00792 <span class="comment"> */</span>
00793 
<a name="l00794"></a><a class="code" href="log__functions_8c.html#a80">00794</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a80">AddFamilyError</a>( <span class="keywordtype">int</span> num_family, <span class="keywordtype">char</span> * name_family, family_error_t * tab_err ) 
00795 {
00796   <span class="keywordtype">int</span> i = 0 ;
00797 
00798   <span class="comment">/* Le numero de la family est entre -1 et MAX_NUM_FAMILY */</span>
00799   <span class="keywordflow">if</span>( ( num_family &lt; -1 ) || ( num_family &gt;= MAX_NUM_FAMILY ) )
00800     <span class="keywordflow">return</span> -1 ;
00801   
00802   <span class="comment">/* On n'occupe pas 0 car ce sont les erreurs du systeme */</span>
00803   <span class="keywordflow">if</span>( num_family == 0 )
00804     <span class="keywordflow">return</span> -1 ;
00805   
00806   <span class="comment">/* On cherche une entree vacante */</span>
00807   <span class="keywordflow">for</span>( i = 0 ; i &lt; MAX_NUM_FAMILY ; i++ )
00808     <span class="keywordflow">if</span>( tab_family[i].num_family == UNUSED_SLOT )
00809       break ;
00810   
00811   <span class="comment">/* On verifie que la table n'est pas pleine */</span>
00812   <span class="keywordflow">if</span>( i == MAX_NUM_FAMILY )
00813     <span class="keywordflow">return</span> -1 ;
00814   
00815   tab_family[i].num_family = (num_family != -1)?num_family:i ;
00816   tab_family[i].tab_err = tab_err ;
00817   strcpy( tab_family[i].name_family, name_family ) ;
00818   
00819   <span class="keywordflow">return</span> tab_family[i].num_family ;
00820 } <span class="comment">/* AddFamilyError */</span>
00821 
<a name="l00822"></a><a class="code" href="log__functions_8c.html#a81">00822</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a81">RemoveFamilyError</a>( <span class="keywordtype">int</span> num_family )
00823 {
00824   <span class="keywordtype">int</span> i = 0 ;
00825   
00826   <span class="keywordflow">for</span>( i = 0 ; i &lt; MAX_NUM_FAMILY ; i++ ) 
00827     <span class="keywordflow">if</span>( tab_family[i].num_family == num_family )
00828       {
00829         tab_family[i].num_family = UNUSED_SLOT ;
00830         <span class="keywordflow">return</span> i ;
00831       }
00832       
00833   <span class="comment">/* Sinon on retourne -1 */</span>
00834   <span class="keywordflow">return</span> -1 ;
00835 } <span class="comment">/* RemoveFamilyError */</span>
00836 
<a name="l00837"></a><a class="code" href="log__functions_8c.html#a82">00837</a> <span class="keywordtype">char</span> * <a class="code" href="log__functions_8c.html#a82">ReturnNameFamilyError</a>( <span class="keywordtype">int</span> num_family )
00838 {
00839   <span class="keywordtype">int</span> i = 0 ;
00840   
00841   <span class="keywordflow">for</span>( i = 0 ; i &lt; MAX_NUM_FAMILY ; i++ ) 
00842     <span class="keywordflow">if</span>( tab_family[i].num_family == num_family )
00843       {
00844          <span class="comment">/* A quoi sert cette ligne ??????!!!!!! */</span>
00845         <span class="comment">/* tab_family[i].num_family = UNUSED_SLOT ; */</span>
00846         <span class="keywordflow">return</span> tab_family[i].name_family ;
00847       }
00848 
00849   <span class="comment">/* Sinon on retourne NULL */</span>
00850   <span class="keywordflow">return</span> NULL ; 
00851 } <span class="comment">/* ReturnFamilyError */</span>
00852 
00853           
00854 <span class="comment">/* Cette fonction trouve une family dans le tabelau des familys d'erreurs */</span>
00855 <span class="keyword">static</span>  family_error_t * TrouveTabErr( <span class="keywordtype">int</span> num_family )
00856 {
00857   <span class="keywordtype">int</span> i = 0 ;
00858   
00859   <span class="keywordflow">for</span>( i = 0 ; i &lt; MAX_NUM_FAMILY ; i++ )
00860     {            
00861       <span class="keywordflow">if</span>( tab_family[i].num_family == num_family ){
00862         <span class="keywordflow">return</span> tab_family[i].tab_err ;
00863       }
00864     }
00865   
00866   <span class="comment">/* Sinon on retourne NULL */</span>
00867   <span class="keywordflow">return</span> NULL ;
00868 }  <span class="comment">/* TrouveTabErr */</span>
00869 
00870 
00871 <span class="keyword">static</span> family_error_t TrouveErr( family_error_t * tab_err , <span class="keywordtype">int</span> num )
00872 {
00873   <span class="keywordtype">int</span> i = 0 ;
00874   family_error_t returned_err ;
00875   
00876   <span class="keywordflow">do</span>
00877     {
00878       
00879       <span class="keywordflow">if</span>( tab_err[i].numero == num || tab_err[i].numero == ERR_NULL )
00880         {
00881           returned_err =  tab_err[i] ;
00882           break ;
00883         }
00884       
00885       i += 1 ;
00886     } <span class="keywordflow">while</span>( 1 ) ;
00887   
00888   <span class="keywordflow">return</span> returned_err ;
00889 } <span class="comment">/* TrouveErr */</span>
00890 
00891 
00892 <span class="keyword">static</span> <span class="keywordtype">int</span> FaireLogError( <span class="keywordtype">char</span> * buffer, <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne )
00893 {
00894   family_error_t * tab_err = NULL ;
00895   family_error_t the_error ;
00896 
00897   <span class="comment">/* Find the family */</span>
00898   <span class="keywordflow">if</span>( ( tab_err = TrouveTabErr( num_family ) ) == NULL )
00899     <span class="keywordflow">return</span> -1 ;
00900   
00901   <span class="comment">/* find the error */</span>
00902   the_error = TrouveErr( tab_err, num_error ) ;
00903     
00904   <span class="keywordflow">if</span>( status == 0 )
00905     {
00906       <span class="keywordflow">return</span> sprintf( buffer, <span class="stringliteral">"Error %s : %s : status %d : Line %d"</span>, 
00907                       the_error.label, 
00908                       the_error.msg, 
00909                       status, 
00910                       ma_ligne ) ;
00911     }
00912   <span class="keywordflow">else</span>
00913     {
00914       <span class="keywordflow">return</span> sprintf( buffer, <span class="stringliteral">"Error %s : %s : status %d : %s : Line %d"</span>, 
00915                       the_error.label, 
00916                       the_error.msg, 
00917                       status, 
00918                       strerror( status ), 
00919                       ma_ligne ) ;
00920     }
00921 } <span class="comment">/* FaireLogError */</span>
00922 
<a name="l00923"></a><a class="code" href="log__functions_8c.html#a86">00923</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a86">DisplayErrorStringLine</a>( <span class="keywordtype">char</span> * tampon, <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne ) 
00924 {
00925   <span class="keywordtype">char</span> buffer[STR_LEN_TXT] ;
00926     
00927   <span class="keywordflow">if</span>( FaireLogError( buffer, num_family, num_error, status, ma_ligne ) == -1 ) 
00928     <span class="keywordflow">return</span> -1 ;
00929   
00930   <span class="keywordflow">return</span> <a class="code" href="log__functions_8c.html#a66">DisplayLogString</a>( tampon, <span class="stringliteral">"%s"</span>, buffer ) ;
00931 } <span class="comment">/* DisplayErrorStringLine */</span>
00932 
<a name="l00933"></a><a class="code" href="log__functions_8c.html#a87">00933</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a87">DisplayErrorFluxLine</a>( FILE * flux, <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne )
00934 {
00935   <span class="keywordtype">char</span> buffer[STR_LEN_TXT] ;
00936   
00937   <span class="keywordflow">if</span>( FaireLogError( buffer, num_family, num_error, status, ma_ligne ) == -1 )
00938     <span class="keywordflow">return</span> -1 ;
00939   
00940   <span class="keywordflow">return</span> <a class="code" href="log__functions_8c.html#a70">DisplayLogFlux</a>( flux, <span class="stringliteral">"%s"</span>, buffer ) ;
00941 } <span class="comment">/* DisplayErrorFluxLine */</span>
00942 
<a name="l00943"></a><a class="code" href="log__functions_8c.html#a88">00943</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a88">DisplayErrorFdLine</a>( <span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne )
00944 {
00945   <span class="keywordtype">char</span> buffer[STR_LEN_TXT] ;
00946   
00947   <span class="keywordflow">if</span>( FaireLogError( buffer, num_family, num_error, status, ma_ligne ) == -1 )
00948     <span class="keywordflow">return</span> -1 ;
00949   
00950   <span class="keywordflow">return</span> <a class="code" href="log__functions_8c.html#a68">DisplayLogFd</a>( fd, <span class="stringliteral">"%s"</span>, buffer ) ;
00951 } <span class="comment">/* DisplayErrorFdLine */</span>
00952 
<a name="l00953"></a><a class="code" href="log__functions_8c.html#a89">00953</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a89">DisplayErrorLogLine</a>( <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne )
00954 {
00955   <span class="keywordtype">char</span> buffer[STR_LEN_TXT] ;
00956   
00957   <span class="keywordflow">if</span>( FaireLogError( buffer, num_family, num_error, status, ma_ligne ) == -1 )
00958     <span class="keywordflow">return</span> -1 ;
00959   
00960   <span class="keywordflow">return</span> <a class="code" href="log__functions_8c.html#a74">DisplayLog</a>( <span class="stringliteral">"%s"</span>, buffer ) ;
00961 } <span class="comment">/* DisplayErrorLogLine */</span>
00962 
00963 
00964 
00965 <span class="comment">/* Les routines de gestion du descripteur de journal */</span>
<a name="l00966"></a><a class="code" href="log__functions_8c.html#a90">00966</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a90">AddLogStreamJd</a>( log_t * pjd, type_log_stream_t type, desc_log_stream_t desc_voie, 
00967                   niveau_t niveau, aiguillage_t aiguillage )
00968 {
00969   log_stream_t * nouvelle_voie ;
00970   
00971   <span class="comment">/* On alloue une nouvelle voie */</span>
00972   <span class="keywordflow">if</span>( ( nouvelle_voie = (log_stream_t *)malloc( <span class="keyword">sizeof</span>( log_stream_t ) )) == NULL )
00973     <span class="keywordflow">return</span> -1 ;
00974      
00975   nouvelle_voie-&gt;desc       = desc_voie ;  
00976 
00977   nouvelle_voie-&gt;type       = type ;
00978   nouvelle_voie-&gt;niveau     = niveau ;
00979   nouvelle_voie-&gt;aiguillage = aiguillage ;
00980   nouvelle_voie-&gt;suivante   = NULL ;
00981   
00982   <span class="keywordflow">if</span>( pjd-&gt;nb_voies == 0 )
00983     {
00984       pjd-&gt;liste_voies = nouvelle_voie ;
00985       pjd-&gt;fin_liste_voies = nouvelle_voie ;
00986     }
00987   <span class="keywordflow">else</span>
00988     {
00989       pjd-&gt;fin_liste_voies-&gt;suivante = nouvelle_voie ;
00990       pjd-&gt;fin_liste_voies = nouvelle_voie ;
00991     }
00992   
00993   pjd-&gt;nb_voies   += 1 ;
00994   <span class="keywordflow">return</span> 0 ;
00995 }
00996 
<a name="l00997"></a><a class="code" href="log__functions_8c.html#a91">00997</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a91">DisplayLogJdLevel</a>( log_t jd, <span class="keywordtype">int</span> level, <span class="keywordtype">char</span> * format, ... ) 
00998 {
00999   va_list arguments ;
01000   <span class="keywordtype">int</span> ecrire_msg = 0 ;
01001   log_stream_t * pvoie = NULL ;
01002     
01003   <span class="comment">/* On regarde pour toutes les voies */</span>
01004     <span class="keywordflow">for</span>( pvoie = jd.liste_voies ; pvoie != NULL ; pvoie = pvoie-&gt;suivante ) 
01005     {
01006       <span class="comment">/* restart from first arg for each log stream */</span>
01007       va_start( arguments, format ) ;
01008       
01009       ecrire_msg = 0 ;
01010       
01011       <span class="keywordflow">switch</span>( pvoie-&gt;aiguillage )
01012         {
01013         <span class="keywordflow">case</span> SUP:
01014           <span class="comment">/* Attention a l'ordre des gravites (inverse) */</span>
01015           <span class="keywordflow">if</span>( (<span class="keywordtype">unsigned</span> int)level &lt;= pvoie-&gt;niveau )
01016             ecrire_msg = 1 ;
01017           break ;
01018 
01019         <span class="keywordflow">case</span> INF:
01020           <span class="comment">/* Attention, l'ordre est inverse */</span>
01021           <span class="keywordflow">if</span>( (<span class="keywordtype">unsigned</span> int)level &gt;= pvoie-&gt;niveau )
01022             ecrire_msg = 1 ;
01023           
01024           break ;
01025         <span class="keywordflow">case</span> EXACT:
01026           <span class="keywordflow">if</span>( (<span class="keywordtype">unsigned</span> int)level == pvoie-&gt;niveau )
01027             ecrire_msg = 1 ;    
01028           break ;
01029         <span class="keywordflow">default</span>:
01030           <span class="keywordflow">break</span>;
01031         } <span class="comment">/* switch */</span>
01032       
01033       <span class="comment">/* Ecriture du message */</span>
01034       <span class="keywordflow">if</span>( ecrire_msg == 1 )
01035         {
01036           <span class="keywordflow">switch</span>( pvoie-&gt;type )
01037             {
01038             <span class="keywordflow">case</span> V_STREAM:
01039               DisplayLogFlux_valist( pvoie-&gt;desc.flux, format, arguments ) ;
01040               break ;
01041               
01042             <span class="keywordflow">case</span> V_BUFFER:
01043               DisplayLogString_valist( pvoie-&gt;desc.buffer, format, arguments ) ;
01044               break ;
01045               
01046             <span class="keywordflow">case</span> V_FILE:
01047               DisplayLogPath_valist( pvoie-&gt;desc.path, format, arguments ) ;
01048               break ;
01049               
01050             <span class="keywordflow">case</span> V_FD:
01051               DisplayLogFd_valist( pvoie-&gt;desc.fd, format, arguments ) ;
01052               break ;
01053               
01054             <span class="keywordflow">default</span>:
01055               break ;
01056             } <span class="comment">/* switch */</span> 
01057         } <span class="comment">/* if */</span>
01058         
01059       <span class="comment">/* restart from first arg for each log stream */</span>
01060       va_end( arguments );
01061       
01062     } <span class="comment">/* for */</span>
01063     
01064     
01065   
01066   <span class="keywordflow">return</span> SUCCES ;
01067 } <span class="comment">/* DisplayLogFdLevel */</span>
01068 
01069 
01070 <span class="comment">/* Comme la precedente, mais on ecrit a tous les coups */</span>
<a name="l01071"></a><a class="code" href="log__functions_8c.html#a92">01071</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a92">DisplayLogJd</a>( log_t jd, <span class="keywordtype">char</span> * format, ... ) 
01072 {
01073   va_list arguments ;
01074   log_stream_t * pvoie = NULL ;
01075     
01076   <span class="comment">/* On regarde pour toutes les voies */</span>
01077   <span class="keywordflow">for</span>( pvoie = jd.liste_voies ; pvoie != NULL ; pvoie = pvoie-&gt;suivante )
01078     {
01079       <span class="comment">/* restart from first arg for each log stream. */</span>
01080       va_start( arguments, format ) ;
01081       
01082       <span class="keywordflow">switch</span>( pvoie-&gt;type )
01083         {
01084         <span class="keywordflow">case</span> V_STREAM:
01085           DisplayLogFlux_valist( pvoie-&gt;desc.flux, format, arguments ) ;
01086           break ;
01087           
01088         <span class="keywordflow">case</span> V_BUFFER:
01089           DisplayLogString_valist( pvoie-&gt;desc.buffer, format, arguments ) ;
01090           break ;
01091           
01092         <span class="keywordflow">case</span> V_FILE:
01093           DisplayLogPath_valist( pvoie-&gt;desc.path, format, arguments ) ;
01094           break ;
01095           
01096         <span class="keywordflow">case</span> V_FD:
01097           DisplayLogFd_valist( pvoie-&gt;desc.fd, format, arguments ) ;
01098           break ;
01099           
01100         <span class="keywordflow">default</span>:
01101           break ;
01102             } <span class="comment">/* switch */</span> 
01103             
01104         <span class="comment">/* restart from first arg for each log stream. */</span>
01105         va_end( arguments );    
01106 
01107     } <span class="comment">/* for */</span>
01108   
01109     
01110   <span class="keywordflow">return</span> SUCCES ;
01111 } <span class="comment">/* DisplayLogFdLevel */</span>
01112 
<a name="l01113"></a><a class="code" href="log__functions_8c.html#a93">01113</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a93">DisplayErrorJdLine</a>( log_t jd, <span class="keywordtype">int</span> num_family, <span class="keywordtype">int</span> num_error, <span class="keywordtype">int</span> status, <span class="keywordtype">int</span> ma_ligne )
01114 {
01115   <span class="keywordtype">char</span> buffer[STR_LEN_TXT] ;
01116   
01117   <span class="keywordflow">if</span>( FaireLogError( buffer, num_family, num_error, status, ma_ligne ) == -1 )
01118     <span class="keywordflow">return</span> -1 ;
01119   
01120   <span class="keywordflow">return</span> <a class="code" href="log__functions_8c.html#a92">DisplayLogJd</a>( jd, <span class="stringliteral">"%s"</span>, buffer ) ;
01121 } <span class="comment">/* DisplayErrorFluxLine */</span>
01122 
01123 <span class="comment">/* Un sprintf personnalisé */</span>
01124 <span class="comment">/* Cette macro est utilisee a chaque fois que l'on avance d'un pas dans le parsing */</span>
<a name="l01125"></a><a class="code" href="log__functions_8c.html#a8">01125</a> <span class="preprocessor">#define ONE_STEP  do { iterformat +=1 ; len += 1; } while(0)</span>
01126 <span class="preprocessor"></span>
<a name="l01127"></a><a class="code" href="log__functions_8c.html#a9">01127</a> <span class="preprocessor">#define NO_TYPE       0</span>
<a name="l01128"></a><a class="code" href="log__functions_8c.html#a10">01128</a> <span class="preprocessor"></span><span class="preprocessor">#define INT_TYPE      1</span>
<a name="l01129"></a><a class="code" href="log__functions_8c.html#a11">01129</a> <span class="preprocessor"></span><span class="preprocessor">#define LONG_TYPE     2</span>
<a name="l01130"></a><a class="code" href="log__functions_8c.html#a12">01130</a> <span class="preprocessor"></span><span class="preprocessor">#define CHAR_TYPE     3</span>
<a name="l01131"></a><a class="code" href="log__functions_8c.html#a13">01131</a> <span class="preprocessor"></span><span class="preprocessor">#define STRING_TYPE   4</span>
<a name="l01132"></a><a class="code" href="log__functions_8c.html#a14">01132</a> <span class="preprocessor"></span><span class="preprocessor">#define FLOAT_TYPE    5</span>
<a name="l01133"></a><a class="code" href="log__functions_8c.html#a15">01133</a> <span class="preprocessor"></span><span class="preprocessor">#define DOUBLE_TYPE   6</span>
<a name="l01134"></a><a class="code" href="log__functions_8c.html#a16">01134</a> <span class="preprocessor"></span><span class="preprocessor">#define POINTEUR_TYPE 7</span>
01135 <span class="preprocessor"></span>
01136 <span class="comment">/* Type specifiques a la log */</span>
<a name="l01137"></a><a class="code" href="log__functions_8c.html#a17">01137</a> <span class="preprocessor">#define EXTENDED_TYPE 8</span>
01138 <span class="preprocessor"></span>
<a name="l01139"></a><a class="code" href="log__functions_8c.html#a18">01139</a> <span class="preprocessor">#define STATUS_SHORT       1</span>
<a name="l01140"></a><a class="code" href="log__functions_8c.html#a19">01140</a> <span class="preprocessor"></span><span class="preprocessor">#define STATUS_LONG        2</span>
<a name="l01141"></a><a class="code" href="log__functions_8c.html#a20">01141</a> <span class="preprocessor"></span><span class="preprocessor">#define CONTEXTE_SHORT     3</span>
<a name="l01142"></a><a class="code" href="log__functions_8c.html#a21">01142</a> <span class="preprocessor"></span><span class="preprocessor">#define CONTEXTE_LONG      4</span>
<a name="l01143"></a><a class="code" href="log__functions_8c.html#a22">01143</a> <span class="preprocessor"></span><span class="preprocessor">#define ERREUR_SHORT       5</span>
<a name="l01144"></a><a class="code" href="log__functions_8c.html#a23">01144</a> <span class="preprocessor"></span><span class="preprocessor">#define ERREUR_LONG        6</span>
<a name="l01145"></a><a class="code" href="log__functions_8c.html#a24">01145</a> <span class="preprocessor"></span><span class="preprocessor">#define ERRNUM_SHORT       7</span>
<a name="l01146"></a><a class="code" href="log__functions_8c.html#a25">01146</a> <span class="preprocessor"></span><span class="preprocessor">#define ERRNUM_LONG        8</span>
<a name="l01147"></a><a class="code" href="log__functions_8c.html#a26">01147</a> <span class="preprocessor"></span><span class="preprocessor">#define ERRCTX_SHORT       9</span>
<a name="l01148"></a><a class="code" href="log__functions_8c.html#a27">01148</a> <span class="preprocessor"></span><span class="preprocessor">#define ERRCTX_LONG        10</span>
<a name="l01149"></a><a class="code" href="log__functions_8c.html#a28">01149</a> <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_ERR_FAMILY  11</span>
<a name="l01150"></a><a class="code" href="log__functions_8c.html#a29">01150</a> <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_CTX_FAMILY  12</span>
01151 <span class="preprocessor"></span>
01152 
<a name="l01153"></a><a class="code" href="log__functions_8c.html#a30">01153</a> <span class="preprocessor">#define NO_LONG 0</span>
<a name="l01154"></a><a class="code" href="log__functions_8c.html#a31">01154</a> <span class="preprocessor"></span><span class="preprocessor">#define SHORT_LG 1</span>
<a name="l01155"></a><a class="code" href="log__functions_8c.html#a32">01155</a> <span class="preprocessor"></span><span class="preprocessor">#define LONG_LG 2 </span>
<a name="l01156"></a><a class="code" href="log__functions_8c.html#a33">01156</a> <span class="preprocessor"></span><span class="preprocessor">#define LONG_LONG_LG 3 </span>
01157 <span class="preprocessor"></span>
<a name="l01158"></a><a class="code" href="log__functions_8c.html#a34">01158</a> <span class="preprocessor">#define MAX_STR_TOK 1024</span>
01159 <span class="preprocessor"></span>
01160 
<a name="l01161"></a><a class="code" href="log__functions_8c.html#a94">01161</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a94">log_vsnprintf</a>( <span class="keywordtype">char</span> * out, size_t taille, <span class="keywordtype">char</span> * format, va_list arguments )
01162 {
01163   <span class="keywordtype">char</span> * iterformat    = NULL ;
01164   <span class="keywordtype">char</span> subformat[MAX_STR_TOK] ;
01165   <span class="keywordtype">char</span> tmpout[MAX_STR_TOK] ;
01166   <span class="keywordtype">int</span> type = NO_TYPE ;
01167   <span class="keywordtype">int</span> typelg = NO_LONG ;
01168   <span class="keywordtype">int</span> type_ext = 0 ;
01169   <span class="keywordtype">char</span> * ptrsub = NULL ;
01170   <span class="keywordtype">char</span> * endofstr = NULL ;
01171   <span class="keywordtype">int</span> len = 0 ;
01172   <span class="keywordtype">int</span> precision_in_valist = 0 ;
01173   <span class="keywordtype">int</span> retval = 0 ;
01174 
01175   <span class="keywordtype">int</span> err_family = ERR_POSIX ;
01176   <span class="keywordtype">int</span> ctx_family = ERR_SYS ;
01177   <span class="keywordtype">int</span>    numero ;
01178   <span class="keywordtype">char</span> * label ;
01179   <span class="keywordtype">char</span> * msg ;
01180 
01181   <span class="keywordtype">int</span>    tmpnumero ;
01182   <span class="keywordtype">char</span> * tmplabel ;
01183   <span class="keywordtype">char</span> * tmpmsg ;
01184   family_error_t * tab_err ;
01185   family_error_t the_error ;
01186   
01187 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01188 <span class="preprocessor"></span>  printf(  <span class="stringliteral">"##### Le format est #%s#\n"</span>, format ) ;
01189 <span class="preprocessor">#endif</span>
01190 <span class="preprocessor"></span>  
01191   <span class="comment">/* Phase d'init */</span>
01192   out[0] = <span class="charliteral">'\0'</span> ;
01193   iterformat = format ;
01194   ptrsub = subformat ;
01195 
01196   <span class="keywordflow">do</span>
01197     {
01198       <span class="comment">/* reinit var length for each %&lt;smthg&gt; */</span>
01199       type = NO_TYPE ;
01200       typelg = NO_LONG ;
01201      
01202       ptrsub = iterformat ;
01203       endofstr = iterformat ;
01204       len = 0 ;
01205       
01206       <span class="comment">/* On affiche d'abord tout ce qui est avant un % */</span>
01207       <span class="keywordflow">while</span>( *iterformat != <span class="charliteral">'\0'</span> &amp;&amp; *iterformat != <span class="charliteral">'%'</span> )
01208         {
01209 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01210 <span class="preprocessor"></span>          printf( <span class="stringliteral">"##### iterformat = #%s#\n"</span>, iterformat ) ;
01211 <span class="preprocessor">#endif</span>
01212 <span class="preprocessor"></span>          ONE_STEP ;
01213         }
01214              
01215       <span class="keywordflow">if</span>( *iterformat == <span class="charliteral">'\0'</span>) 
01216         break ;
01217       <span class="keywordflow">else</span>
01218         endofstr = iterformat ;
01219       
01220 
01221       <span class="comment">/* Je vire le premier caractere (qui est forcement un '%') */</span>
01222       ONE_STEP ;
01223       
01224        <span class="comment">/* On traite les arguments positionnels */</span>
01225       <span class="keywordflow">while</span>( isdigit( *iterformat ) || *iterformat == <span class="charliteral">'$'</span> ) 
01226         { 
01227           ONE_STEP ;
01228         }
01229 
01230       <span class="comment">/* </span>
01231 <span class="comment">       * une boucle qui traite des caracterers de formatage, infini sauf quand un caractere qui n'est pas de </span>
01232 <span class="comment">       * formattage est rencontree qui produit un break ;</span>
01233 <span class="comment">       */</span>
01234       <span class="keywordflow">do</span>
01235         {
01236           
01237           <span class="keywordflow">switch</span>( *iterformat )
01238             {
01239               <span class="comment">/* ATTENTION </span>
01240 <span class="comment">               *  /!\ Une serie de case sans break !!!! </span>
01241 <span class="comment">               */</span>
01242             <span class="keywordflow">case</span> <span class="charliteral">' '</span> :
01243               <span class="comment">/* Un espace est utilise a la place d'un signe. */</span>
01244             <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
01245               <span class="comment">/* Un signe + explicite */</span>
01246             <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
01247               <span class="comment">/* un signe - */</span>
01248             <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
01249               <span class="comment">/* utilisation d'une forme alternative */</span>
01250             <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
01251               <span class="comment">/* Pour forcer l'emploi de padding par des 0 sur des champs de taille fixe */</span>
01252             <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
01253               <span class="comment">/* Pour les formats internationaux */</span>
01254               ONE_STEP ;
01255               continue ; <span class="comment">/* On repasse dans la boucle */</span>
01256               
01257             <span class="keywordflow">default</span> :
01258               <span class="comment">/* Fin de ce type de caracteres */</span>
01259               break ;
01260             }
01261           break ;
01262         } <span class="keywordflow">while</span>( 1 ) ; <span class="comment">/* Pas vraiment une boucle infinie en fait */</span>
01263       
01264       <span class="comment">/* La taille du champ */</span>
01265       <span class="keywordflow">if</span>( *iterformat == <span class="charliteral">'*'</span> ) 
01266         {
01267           <span class="comment">/* On garde le '*' */</span>
01268           ONE_STEP ;
01269 
01270           <span class="comment">/* on lit la precision dans les arguments */</span>
01271           precision_in_valist += 1 ;
01272           
01273           <span class="comment">/* On garde la taille du champs */</span>
01274           <span class="keywordflow">while</span>( isdigit( *iterformat ) || *iterformat == <span class="charliteral">'$'</span> ) 
01275             { 
01276               ONE_STEP ;
01277             }
01278         } <span class="comment">/* if( *iterformat == '*' ) */</span>
01279 
01280       <span class="comment">/* La precision */</span>
01281       <span class="keywordflow">if</span>( *iterformat == <span class="charliteral">'.'</span> ) 
01282         {
01283           <span class="comment">/* On garde le '.' */</span>
01284           ONE_STEP ;
01285           
01286           <span class="keywordflow">if</span>(  *iterformat == <span class="charliteral">'*'</span> ) 
01287             {
01288                <span class="comment">/* On garde le '*' */</span>
01289               ONE_STEP ;
01290     
01291               <span class="comment">/* On garde la taille du champs */</span>
01292               <span class="keywordflow">while</span>( isdigit( *iterformat ) || *iterformat == <span class="charliteral">'$'</span> ) 
01293                 { 
01294                   ONE_STEP ;
01295                 }
01296             } <span class="comment">/* if( *iterformat == '*' ) */</span>
01297           <span class="keywordflow">else</span> 
01298             {
01299               <span class="keywordflow">if</span>( isdigit( *iterformat ) )
01300                 {
01301                   
01302                   <span class="keywordflow">while</span>( isdigit( *iterformat ) || *iterformat == <span class="charliteral">'$'</span> ) 
01303                     { 
01304                       ONE_STEP ;
01305                     }
01306                 } <span class="comment">/*  if( isdigit( *iterformat ) */</span>
01307               <span class="keywordflow">else</span>
01308                 {
01309                   <span class="comment">/* Le cas %.? est traite comme %.0? */</span>
01310                   ONE_STEP ;
01311                 }
01312               
01313             } <span class="comment">/* if( *iterformat == '.' )  */</span>
01314         }
01315       
01316       <span class="comment">/* On s'occupe a present des doubles quantificateurs, types ll */</span> 
01317       <span class="keywordflow">switch</span>( *iterformat )
01318         {
01319         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01320           <span class="comment">/* ce sont des short ints ou bien des char */</span>
01321           typelg = SHORT_LG ;
01322           ONE_STEP ;
01323           break ;
01324         <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
01325           <span class="comment">/* long doubles et long ints */</span>
01326           typelg = LONG_LG ;
01327           ONE_STEP ;
01328           break ;
01329         <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
01330           <span class="comment">/* long long */</span>  
01331           typelg = LONG_LG ;
01332           ONE_STEP ;
01333           break ;
01334         <span class="keywordflow">case</span> <span class="charliteral">'z'</span>:
01335         <span class="keywordflow">case</span> <span class="charliteral">'Z'</span>:
01336           <span class="comment">/* Les entiers sont des size */</span>
01337           typelg = LONG_LG ;
01338           ONE_STEP ;
01339           break ;
01340         <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
01341         <span class="keywordflow">case</span> <span class="charliteral">'j'</span>:
01342           typelg = LONG_LG ;
01343           ONE_STEP ;
01344           break ;
01345         <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
01346           <span class="comment">/* long int, peut etre double */</span>
01347           ONE_STEP;
01348           typelg = LONG_LG ;
01349           <span class="keywordflow">if</span>( *iterformat == <span class="charliteral">'l'</span> )
01350             {
01351               ONE_STEP ;
01352               typelg = LONG_LONG_LG ;
01353             }
01354           break ;
01355         <span class="keywordflow">default</span>:
01356           break ;
01357         }
01358       
01359       
01360   
01361       <span class="comment">/* A present, l'identificateur de type */</span>
01362       type = NO_TYPE ;
01363       
01364       <span class="keywordflow">switch</span>( *iterformat )
01365         {
01366         <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
01367         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
01368         <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
01369         <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
01370         <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
01371         <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
01372           <span class="comment">/* Des entiers */</span>
01373           type = INT_TYPE ;
01374           ONE_STEP ;
01375           break ;
01376         <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
01377         <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
01378         <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
01379         <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
01380         <span class="keywordflow">case</span> <span class="charliteral">'g'</span>:
01381         <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
01382         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
01383         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
01384           <span class="comment">/* Des flottants */</span>
01385           type = DOUBLE_TYPE ;
01386           ONE_STEP ;
01387           break ;
01388         <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
01389         <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
01390           <span class="comment">/* Des caracteres */</span>
01391           type = CHAR_TYPE ;
01392           ONE_STEP ;
01393           break ;
01394         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
01395         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
01396           <span class="comment">/* Des chaines de caracteres a zero terminal */</span>
01397           type = STRING_TYPE ;
01398           ONE_STEP ;
01399           break ;
01400         <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
01401           <span class="comment">/* La chose en un pointeur */</span>
01402           type = POINTEUR_TYPE ;
01403           ONE_STEP ;
01404           break ;
01405         <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
01406           <span class="comment">/* Le monstrueux passage de pointeur, trou beant pour les shellcodes, je ne le gere pas volontairement */</span>
01407           type = POINTEUR_TYPE  ;
01408           ONE_STEP ;
01409           break ;
01410         <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
01411           <span class="comment">/* le caractere %, tout simplement */</span>
01412           type = NO_TYPE ;
01413           ONE_STEP ;
01414           break ;
01415         <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
01416           <span class="comment">/* Un status, dans sa version courte */</span>
01417           type = EXTENDED_TYPE ;
01418           type_ext = STATUS_SHORT ;
01419           ONE_STEP ;
01420           break ;
01421         <span class="keywordflow">case</span> <span class="charliteral">'B'</span>:
01422           <span class="comment">/* Un status, dans sa version longue */</span>
01423           type = EXTENDED_TYPE ;
01424           type_ext = STATUS_LONG ;
01425           ONE_STEP ;
01426           break ;
01427         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
01428           <span class="comment">/* Un contexte, dans sa version courte */</span>
01429           type = EXTENDED_TYPE ;
01430           type_ext = CONTEXTE_SHORT ;
01431           ONE_STEP ;
01432           break ;
01433         <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
01434           <span class="comment">/* Un contexte, dans sa version longue */</span>
01435           type = EXTENDED_TYPE ;
01436           type_ext = CONTEXTE_LONG ;
01437           ONE_STEP ;
01438           break ;
01439         <span class="keywordflow">case</span> <span class="charliteral">'y'</span>:
01440           <span class="comment">/* Une log_error, en version courte */</span>
01441            type = EXTENDED_TYPE ;
01442            type_ext = ERREUR_SHORT ;
01443            ONE_STEP ;
01444           break ;
01445         <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
01446           <span class="comment">/* Une log_error, en version longue */</span>
01447           type = EXTENDED_TYPE ;
01448           type_ext = ERREUR_LONG ;
01449           ONE_STEP ;
01450           break ;
01451         <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
01452           <span class="comment">/* Un  numero d'erreur, en version courte */</span>
01453           type = EXTENDED_TYPE ;
01454           type_ext = ERRNUM_SHORT ;
01455           ONE_STEP ;
01456           break ;
01457         <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
01458           <span class="comment">/* Un  numero d'erreur, en version longue */</span>
01459           type = EXTENDED_TYPE ;
01460           type_ext = ERRNUM_LONG ;
01461           ONE_STEP ;
01462           break ;
01463         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
01464           <span class="comment">/* Un contexte d'erreur, en version courte */</span>
01465           type = EXTENDED_TYPE ;
01466           type_ext = ERRCTX_SHORT ;
01467           ONE_STEP ;
01468           break ;
01469         <span class="keywordflow">case</span> <span class="charliteral">'V'</span>:
01470           <span class="comment">/* Un contexte d'erreur, en version longue */</span>
01471           type = EXTENDED_TYPE ;
01472           type_ext = ERRCTX_LONG ;
01473           ONE_STEP ;
01474           break ;
01475         <span class="keywordflow">case</span> <span class="charliteral">'J'</span>:
01476           <span class="comment">/* Changement de family par defaut, pour les erreurs */</span>
01477           type = EXTENDED_TYPE ;
01478           type_ext = CHANGE_ERR_FAMILY ;
01479           ONE_STEP ;
01480           break ;
01481         <span class="keywordflow">case</span> <span class="charliteral">'K'</span>:
01482           <span class="comment">/* Changement de family par defaut, pour les contexte */</span>
01483           type = EXTENDED_TYPE ;
01484           type_ext = CHANGE_CTX_FAMILY ;
01485           ONE_STEP ;
01486           break ;
01487         <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
01488         <span class="keywordflow">default</span>:
01489           break ;
01490         }
01491 
01492       strncpy( subformat, ptrsub, len ) ;
01493       subformat[len] = <span class="charliteral">'\0'</span> ;
01494 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01495 <span class="preprocessor"></span>      printf( <span class="stringliteral">"##### iterformat +1  = #%s# \n"</span>, iterformat ) ;
01496       printf( <span class="stringliteral">"subformat = #%s# len =%d\n"</span>, subformat, len  ) ;
01497 <span class="preprocessor">#endif</span>
01498 <span class="preprocessor"></span>      
01499       <span class="keywordflow">if</span>( type != EXTENDED_TYPE )
01500         { 
01501           va_list tmp_args;
01502           
01503           <span class="comment">/* vsnprintf may modify arguments */</span>
01504           va_copy( tmp_args, arguments );
01505            
01506           <span class="comment">/* Composition de la sortie avec vsprintf */</span>
01507           retval += vsnprintf( tmpout, taille, subformat, tmp_args ) ;
01508           
01509           <span class="comment">/* free this temporary copy */</span>
01510           va_end( tmp_args );
01511           
01512           <span class="comment">/*</span>
01513 <span class="comment">           * Si un truc genre %*.*d est utilise, on doit consommer un entier qui contient la precision pour chaque "*"</span>
01514 <span class="comment">           */</span>
01515           <span class="keywordflow">while</span>( precision_in_valist != 0 )
01516             {
01517               va_arg( arguments, <span class="keywordtype">int</span> ) ;
01518               precision_in_valist -= 1 ;
01519             }
01520       
01521         
01522           <span class="comment">/* Je vais prendre un argument dans la va_list selon le format */</span>
01523           <span class="keywordflow">switch</span>( typelg )
01524             {
01525             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a31">SHORT_LG</a> :
01526               va_arg( arguments, <span class="keywordtype">int</span> ) ;
01527               break ;
01528               
01529             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a30">NO_LONG</a>:
01530               <span class="keywordflow">switch</span>( type )
01531                 {
01532                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a10">INT_TYPE</a> :
01533                   va_arg( arguments, <span class="keywordtype">int</span> ) ;
01534                   break ;
01535                   
01536                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a11">LONG_TYPE</a>:
01537                   va_arg( arguments, <span class="keywordtype">long</span> ) ;
01538                   break ;
01539                   
01540                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a14">FLOAT_TYPE</a>:
01541                   <span class="comment">/* float is promoted to double when passed through "..." */</span>
01542                   va_arg( arguments, <span class="keywordtype">double</span> ) ;
01543                   break ;
01544                   
01545                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a15">DOUBLE_TYPE</a>:
01546                   va_arg( arguments, <span class="keywordtype">double</span> ) ;
01547                   break ;
01548                   
01549                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a12">CHAR_TYPE</a>:
01550                   <span class="comment">/* char is promoted to int when passed through "..." */</span>
01551                   va_arg( arguments, <span class="keywordtype">int</span> ) ;
01552                   break ;
01553                   
01554                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a16">POINTEUR_TYPE</a>:
01555                   va_arg( arguments, <span class="keywordtype">void</span> *) ;
01556                   break ;
01557                   
01558                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a13">STRING_TYPE</a>:
01559                   va_arg( arguments, <span class="keywordtype">char</span> *) ;
01560                   break ;    
01561                 }
01562               
01563               break ;     
01564               
01565             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a32">LONG_LG</a> :
01566               <span class="keywordflow">switch</span>( type )
01567                 {
01568                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a10">INT_TYPE</a> :
01569                   va_arg( arguments, <span class="keywordtype">long</span> <span class="keywordtype">int</span> ) ;
01570                   break ;
01571                   
01572                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a11">LONG_TYPE</a>:
01573                   va_arg( arguments, <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> ) ;
01574                   break ;
01575                   
01576                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a14">FLOAT_TYPE</a>:
01577                   va_arg( arguments, <span class="keywordtype">double</span> ) ;
01578                   break ;
01579                   
01580                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a15">DOUBLE_TYPE</a>:
01581                   va_arg( arguments, <span class="keywordtype">long</span> <span class="keywordtype">double</span> ) ;
01582                   break ;
01583                 }
01584 
01585             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a33">LONG_LONG_LG</a> :
01586               <span class="keywordflow">switch</span>( type )
01587                 {
01588                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a10">INT_TYPE</a> :
01589                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a11">LONG_TYPE</a>:
01590                   va_arg( arguments, <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> ) ;
01591                   break ;
01592                   
01593                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a14">FLOAT_TYPE</a>:
01594                 <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a15">DOUBLE_TYPE</a>:
01595                   va_arg( arguments, <span class="keywordtype">long</span> <span class="keywordtype">double</span> ) ;
01596                   break ;
01597                 }
01598               
01599               break ;
01600             }
01601         } <span class="comment">/* if( type != EXTENDED_TYPE ) */</span>
01602       <span class="keywordflow">else</span>
01603         {
01604           <span class="comment">/* Cette macro (un peu crade), extrait une family_error_t des arguments variables */</span>
01605 <span class="preprocessor">#define VA_ARG_ERREUR_T numero = va_arg( arguments, long ) ; label  = va_arg( arguments, char * ) ; msg    = va_arg( arguments, char *)</span>
01606 <span class="preprocessor"></span>
01607 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01608 <span class="preprocessor"></span>          printf( <span class="stringliteral">"====&gt; Un type etendu \n"</span> ) ;
01609           printf( <span class="stringliteral">"====&gt; subformat = #%s#\n"</span>, subformat ) ;
01610           printf( <span class="stringliteral">"====&gt; out = #%s#\n"</span>, out ) ;
01611 <span class="preprocessor">#endif</span>
01612 <span class="preprocessor"></span>          
01613           <span class="comment">/* si le subformat est de type "toto titi tutu %X",</span>
01614 <span class="comment">           * on ajoute le "toto titi tutu " dans la chaine de sortie */</span>
01615           <span class="keywordflow">if</span>(  strlen( subformat ) &gt;2 )
01616              strncat( out, subformat,strlen( subformat )-2);
01617           
01618           <span class="keywordflow">switch</span>( type_ext )
01619             {
01620             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a18">STATUS_SHORT</a>:
01621             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a20">CONTEXTE_SHORT</a>:
01622               VA_ARG_ERREUR_T ;
01623               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d)"</span>, label, numero) ;
01624               break ;
01625               
01626             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a19">STATUS_LONG</a>:
01627             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a21">CONTEXTE_LONG</a>:
01628               VA_ARG_ERREUR_T ;
01629               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d) : '%s'"</span>, label, numero, msg ) ;
01630               break ;
01631               
01632             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a22">ERREUR_SHORT</a>:
01633               VA_ARG_ERREUR_T ;
01634               tmpnumero = numero ; tmplabel = label ; tmpmsg = msg ;
01635               VA_ARG_ERREUR_T ;
01636               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s %s(%d)"</span>,  tmplabel,label, numero ) ;
01637               break ;
01638               
01639             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a23">ERREUR_LONG</a>:
01640               VA_ARG_ERREUR_T ;
01641               tmpnumero = numero ; tmplabel = label ; tmpmsg = msg ;
01642               VA_ARG_ERREUR_T ;
01643               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d) : '%s' -&gt; %s(%d) : '%s'"</span>, 
01644                          tmplabel, tmpnumero, tmpmsg,  label, numero, msg ) ;
01645               break ;
01646               
01647             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a28">CHANGE_ERR_FAMILY</a>:
01648               <span class="comment">/* On assigne un nouvelle family d'erreur */</span>
01649               err_family = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01650               tmpout[0] = <span class="charliteral">'\0'</span> ; <span class="comment">/* Chaine vide */</span>
01651               break ;
01652               
01653             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a29">CHANGE_CTX_FAMILY</a>:
01654               <span class="comment">/* On assigne une nouvelle family de contexte */</span>
01655               ctx_family = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01656               tmpout[0] = <span class="charliteral">'\0'</span> ;
01657               break ;
01658               
01659             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a24">ERRNUM_SHORT</a>:
01660               <span class="comment">/* Un numero d'erreur dans la family courante (ERR_POSIX par defaut) */</span>
01661               <span class="keywordflow">if</span> ((tab_err = TrouveTabErr( err_family ))==NULL) {
01662                 snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>,<span class="stringliteral">"?"</span>);
01663                 <span class="keywordflow">break</span>;
01664               }
01665               numero = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01666               the_error = TrouveErr( tab_err, numero ) ;
01667               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d)"</span>, the_error.label, the_error.numero ) ;
01668               break ;
01669               
01670             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a25">ERRNUM_LONG</a>:
01671               <span class="comment">/* Un numero d'erreur dans la family courante (ERR_POSIX par defaut) */</span>
01672               <span class="keywordflow">if</span> ((tab_err = TrouveTabErr( err_family ))==NULL) {
01673                 snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>,<span class="stringliteral">"?"</span>);
01674                 <span class="keywordflow">break</span>;
01675               }
01676               numero = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01677               the_error = TrouveErr( tab_err, numero ) ;
01678               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d) : '%s'"</span>, the_error.label, the_error.numero, 
01679                         the_error.msg ) ;
01680               break ;
01681               
01682             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a26">ERRCTX_SHORT</a>:
01683               <span class="comment">/* Un numero de contexte dans la family courante (ERR_SYS par defaut) */</span>
01684               <span class="keywordflow">if</span> ((tab_err = TrouveTabErr( ctx_family ))==NULL) {
01685                 snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>,<span class="stringliteral">"?"</span>);
01686                 <span class="keywordflow">break</span>;
01687               }
01688               numero = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01689               the_error = TrouveErr( tab_err, numero ) ;
01690               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d)"</span>, the_error.label, the_error.numero ) ;
01691               break ;
01692               
01693             <span class="keywordflow">case</span> <a class="code" href="log__functions_8c.html#a27">ERRCTX_LONG</a>:
01694               <span class="comment">/* Un numero de contexte dans la family courante (ERR_SYS par defaut) */</span>
01695               <span class="keywordflow">if</span> ((tab_err = TrouveTabErr( ctx_family ))==NULL) {
01696                 snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>,<span class="stringliteral">"?"</span>);
01697                 <span class="keywordflow">break</span>;
01698               }
01699               numero = va_arg( arguments, <span class="keywordtype">int</span> ) ;
01700               the_error = TrouveErr( tab_err, numero ) ;
01701               snprintf( tmpout, <a class="code" href="log__functions_8c.html#a34">MAX_STR_TOK</a>, <span class="stringliteral">"%s(%d) : '%s'"</span>, the_error.label, numero, the_error.msg ) ;
01702               break ;
01703 
01704             } <span class="comment">/* switch */</span>
01705           
01706         } <span class="comment">/* else */</span>
01707 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01708 <span class="preprocessor"></span>      printf( <span class="stringliteral">"====&gt; tmpout = #%s#\n"</span>, tmpout ) ;
01709 <span class="preprocessor">#endif</span>
01710 <span class="preprocessor"></span>      strncat( out, tmpout, taille ) ;
01711 
01712 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01713 <span class="preprocessor"></span>      printf( <span class="stringliteral">"====&gt; out = #%s#\n"</span>, out ) ;
01714       printf( <span class="stringliteral">"=================\n"</span>) ;
01715 <span class="preprocessor">#endif</span>
01716 <span class="preprocessor"></span>    } <span class="keywordflow">while</span>( *iterformat != <span class="charliteral">'\0'</span> ) ;
01717 
01718   <span class="comment">/* Le pas oublie la fin du format, qui est tout a la queue */</span>
01719 <span class="preprocessor">#ifdef _DEBUG_LOG</span>
01720 <span class="preprocessor"></span>  printf( <span class="stringliteral">"DEBUG : ptrsub = #%s#   endofstr = #%s#\n"</span>, ptrsub, endofstr ) ;
01721 <span class="preprocessor">#endif</span>
01722 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( *endofstr == <span class="charliteral">'%'</span> )
01723     ptrsub = iterformat ; <span class="comment">/* Pour clore l'iteration */</span>
01724   strncat( out, ptrsub, taille ) ;  
01725   
01726 
01727   <span class="keywordflow">return</span> retval ;
01728 } <span class="comment">/* mon_vsprintf */</span>
01729 
01730 
<a name="l01731"></a><a class="code" href="log__functions_8c.html#a95">01731</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a95">log_sprintf</a>( <span class="keywordtype">char</span> * out, <span class="keywordtype">char</span> * format, ... )
01732 {
01733   va_list arguments ;
01734   <span class="keywordtype">int</span> rc;
01735   
01736   va_start( arguments, format ) ;
01737   rc = log_vsprintf( out, format, arguments ) ;
01738   va_end( arguments );
01739   
01740   <span class="keywordflow">return</span> rc;
01741 }
01742 
<a name="l01743"></a><a class="code" href="log__functions_8c.html#a96">01743</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a96">log_snprintf</a>( <span class="keywordtype">char</span> * out, size_t n, <span class="keywordtype">char</span> * format, ... )
01744 {
01745   va_list arguments ;
01746   <span class="keywordtype">int</span> rc;
01747 
01748   va_start( arguments, format ) ;
01749   rc =<a class="code" href="log__functions_8c.html#a94">log_vsnprintf</a>( out, n, format, arguments ) ;
01750   va_end( arguments );
01751   
01752   <span class="keywordflow">return</span> rc;  
01753 }
01754 
<a name="l01755"></a><a class="code" href="log__functions_8c.html#a97">01755</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a97">log_fprintf</a>( FILE * file, <span class="keywordtype">char</span> * format, ... )
01756 {
01757   va_list arguments ;
01758   <span class="keywordtype">char</span> tmpstr[LOG_MAX_STRLEN] ;
01759   <span class="keywordtype">int</span> rc ;
01760   
01761   va_start( arguments, format ) ;
01762   memset( tmpstr, 0, LOG_MAX_STRLEN) ;
01763   rc = <a class="code" href="log__functions_8c.html#a94">log_vsnprintf</a>( tmpstr, LOG_MAX_STRLEN, format, arguments ) ;
01764   va_end( arguments ) ;
01765   fputs( tmpstr, file ) ;
01766   <span class="keywordflow">return</span> rc ;
01767 }
01768 
<a name="l01769"></a><a class="code" href="log__functions_8c.html#a98">01769</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a98">log_vfprintf</a>( FILE * file , <span class="keywordtype">char</span> * format, va_list arguments )
01770 {
01771   <span class="keywordtype">char</span> tmpstr[LOG_MAX_STRLEN] ;
01772   <span class="keywordtype">int</span> rc ;
01773   
01774   memset( tmpstr, 0, LOG_MAX_STRLEN) ;
01775   rc = <a class="code" href="log__functions_8c.html#a94">log_vsnprintf</a>( tmpstr, LOG_MAX_STRLEN, format, arguments ) ;
01776   fputs( tmpstr, file ) ;
01777   <span class="keywordflow">return</span> rc ;
01778 }
01779 
<a name="l01780"></a><a class="code" href="log__functions_8c.html#a99">01780</a> <span class="keywordtype">int</span> <a class="code" href="log__functions_8c.html#a99">log_printf</a>( <span class="keywordtype">char</span> * format, ... )
01781 {
01782   va_list arguments ;
01783   <span class="keywordtype">int</span> rc;
01784   
01785   va_start( arguments, format ) ;  
01786   rc = <a class="code" href="log__functions_8c.html#a98">log_vfprintf</a>( stdout, format, arguments ) ;
01787   va_end( arguments );
01788   
01789   <span class="keywordflow">return</span> rc;
01790 }
01791 
01792 
01793     
01794   <span class="comment">/* </span>
01795 <span class="comment"> * Pour info : Les tags de printf dont on peut se servir:</span>
01796 <span class="comment"> * w DMNOPQTUWX </span>
01797 <span class="comment"> */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:24 2008 for Log Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
