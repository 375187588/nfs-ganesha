<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Id Mapper: idmapper_cache.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>idmapper_cache.c</h1><a href="idmapper__cache_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00086 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 
00091 
00092 <span class="preprocessor">#include "HashData.h"</span>
00093 <span class="preprocessor">#include "HashTable.h"</span>
00094 <span class="preprocessor">#include "log_functions.h"</span>
00095 <span class="preprocessor">#include "stuff_alloc.h"</span>
00096 <span class="preprocessor">#include "nfs_core.h"</span>
00097 <span class="preprocessor">#include "nfs_exports.h"</span>
00098 <span class="preprocessor">#include "config_parsing.h"</span>
00099 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00100 <span class="preprocessor">#include &lt;string.h&gt;</span>
00101 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00102 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00103 <span class="preprocessor">#include &lt;grp.h&gt;</span>
00104 
00105 size_t <a class="code" href="idmapper__cache_8c.html#a5">strnlen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t maxlen);
00106 
00107 
00108 <span class="comment">/* Hashtable used to cache the hostname, accessed by their IP addess */</span>
<a name="l00109"></a><a class="code" href="idmapper__cache_8c.html#a0">00109</a> hash_table_t            * ht_pwnam ;
<a name="l00110"></a><a class="code" href="idmapper__cache_8c.html#a1">00110</a> hash_table_t            * ht_grnam ;
<a name="l00111"></a><a class="code" href="idmapper__cache_8c.html#a2">00111</a> hash_table_t            * ht_pwuid ;
<a name="l00112"></a><a class="code" href="idmapper__cache_8c.html#a3">00112</a> hash_table_t            * ht_grgid ;
00113 <span class="keyword">extern</span> nfs_parameter_t    nfs_param ;
00114 
00115 
00116 
<a name="l00132"></a><a class="code" href="idmapper__cache_8c.html#a6">00132</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="idmapper__cache_8c.html#a6">idmapper_value_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00133 {
00134   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  sum = 0 ;
00135   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i = 0 ;
00136   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c ;
00137 
00138   <span class="comment">/* Compute the sum of all the characters */</span>
00139   <span class="keywordflow">for</span>( i = 0 , c = ((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[0] ; ((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[i] != <span class="charliteral">'\0'</span> ; c=((<span class="keywordtype">char</span> *)buffclef-&gt;pdata)[++i], sum += c ) ;
00140 
00141   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> long)( sum % p_hparam-&gt;index_size ) ;
00142 } <span class="comment">/*  ip_name_value_hash_func */</span>
00143 
<a name="l00144"></a><a class="code" href="idmapper__cache_8c.html#a7">00144</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="idmapper__cache_8c.html#a7">namemapper_value_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00145 {
00146    <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> long)(buffclef-&gt;pdata)  % p_hparam-&gt;index_size ) ;
00147 }
00148 
<a name="l00163"></a><a class="code" href="idmapper__cache_8c.html#a8">00163</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="idmapper__cache_8c.html#a8">idmapper_rbt_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00164 {
00165   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result ;
00166 
00167   <span class="keywordflow">if</span>( <a class="code" href="idmapper__cache_8c.html#a18">idmap_compute_hash_value</a>( (<span class="keywordtype">char</span> *)buffclef-&gt;pdata,
00168                                 (uint32_t *) &amp;result ) != ID_MAPPER_SUCCESS )
00169         <span class="keywordflow">return</span> 0 ;
00170 
00171   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> long)result ;
00172 } <span class="comment">/* ip_name_rbt_hash_func */</span>
00173 
<a name="l00174"></a><a class="code" href="idmapper__cache_8c.html#a9">00174</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="idmapper__cache_8c.html#a9">namemapper_rbt_hash_func</a>( hash_parameter_t * p_hparam, hash_buffer_t * buffclef )
00175 {
00176    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> long)(buffclef-&gt;pdata)  ;
00177 }
<a name="l00191"></a><a class="code" href="idmapper__cache_8c.html#a10">00191</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a10">compare_idmapper</a>(  hash_buffer_t * buff1, hash_buffer_t * buff2 )
00192 {
00193   <span class="keywordflow">return</span> strncmp( (<span class="keywordtype">char</span> *)(buff1-&gt;pdata), (<span class="keywordtype">char</span> *)(buff2-&gt;pdata), PWENT_MAX_LEN ) ;
00194 } <span class="comment">/* compare_xid */</span>
00195 
<a name="l00196"></a><a class="code" href="idmapper__cache_8c.html#a11">00196</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a11">compare_namemapper</a>(  hash_buffer_t * buff1, hash_buffer_t * buff2 )
00197 {
00198   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> xid1 = (<span class="keywordtype">unsigned</span> long)(buff1-&gt;pdata) ;
00199   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> xid2 = (<span class="keywordtype">unsigned</span> long)(buff2-&gt;pdata) ;
00200 
00201   <span class="keywordflow">return</span> (xid1 == xid2)?0:1 ;
00202 } <span class="comment">/* compare_xid */</span>
00203 
00204 
<a name="l00218"></a><a class="code" href="idmapper__cache_8c.html#a12">00218</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a12">display_idmapper_key</a>( hash_buffer_t * pbuff, <span class="keywordtype">char</span> * str )
00219 {
00220   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"%s"</span>,
00221                   (<span class="keywordtype">char</span> *)(pbuff-&gt;pdata) );
00222 } <span class="comment">/* display_idmapper */</span>
00223 
<a name="l00237"></a><a class="code" href="idmapper__cache_8c.html#a13">00237</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a13">display_idmapper_val</a>( hash_buffer_t * pbuff, <span class="keywordtype">char</span> * str )
00238 {
00239   <span class="keywordflow">return</span> sprintf( str, <span class="stringliteral">"%lu"</span>,
00240                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(pbuff-&gt;pdata) ) ;
00241 } <span class="comment">/* display_idmapper_val */</span>
00242 
<a name="l00254"></a><a class="code" href="idmapper__cache_8c.html#a14">00254</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a14">idmap_uid_init</a>( nfs_idmap_cache_parameter_t param )
00255 {
00256   <span class="keywordflow">if</span>( ( <a class="code" href="idmapper__cache_8c.html#a0">ht_pwnam</a> = HashTable_Init( param.hash_param ) ) == NULL )
00257     {
00258         DisplayLog( <span class="stringliteral">"NFS ID MAPPER: Cannot init IDMAP_UID cache"</span> ) ;
00259         <span class="keywordflow">return</span> -1 ;
00260     }
00261  
00262   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00263 } <span class="comment">/* idmap_uid_init */</span>
00264 
<a name="l00265"></a><a class="code" href="idmapper__cache_8c.html#a15">00265</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a15">idmap_uname_init</a>( nfs_idmap_cache_parameter_t param )
00266 {
00267   <span class="keywordflow">if</span>( ( <a class="code" href="idmapper__cache_8c.html#a2">ht_pwuid</a> = HashTable_Init( param.hash_param ) ) == NULL )
00268     {
00269         DisplayLog( <span class="stringliteral">"NFS ID MAPPER: Cannot init IDMAP_UNAME cache"</span> ) ;
00270         <span class="keywordflow">return</span> -1 ;
00271     }
00272 
00273   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00274 } <span class="comment">/* idmap_uid_init */</span>
00275 
<a name="l00287"></a><a class="code" href="idmapper__cache_8c.html#a16">00287</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a16">idmap_gid_init</a>( nfs_idmap_cache_parameter_t param )
00288 {
00289   <span class="keywordflow">if</span>( ( <a class="code" href="idmapper__cache_8c.html#a1">ht_grnam</a> = HashTable_Init( param.hash_param ) ) == NULL )
00290     {
00291         DisplayLog( <span class="stringliteral">"NFS ID MAPPER: Cannot init IDMAP_GID cache"</span> ) ;
00292         <span class="keywordflow">return</span> -1 ;
00293     }
00294  
00295   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00296 } <span class="comment">/* idmap_uid_init */</span>
00297 
<a name="l00298"></a><a class="code" href="idmapper__cache_8c.html#a17">00298</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a17">idmap_gname_init</a>( nfs_idmap_cache_parameter_t param )
00299 {
00300   <span class="keywordflow">if</span>( ( <a class="code" href="idmapper__cache_8c.html#a3">ht_grgid</a> = HashTable_Init( param.hash_param ) ) == NULL )
00301     {
00302         DisplayLog( <span class="stringliteral">"NFS ID MAPPER: Cannot init IDMAP_GNAME cache"</span> ) ;
00303         <span class="keywordflow">return</span> -1 ;
00304     }
00305 
00306   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00307 } <span class="comment">/* idmap_uid_init */</span>
00308 
00309 
<a name="l00318"></a><a class="code" href="idmapper__cache_8c.html#a18">00318</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a18">idmap_compute_hash_value</a>( <span class="keywordtype">char</span>      * name,
00319                               uint32_t  * phashval )
00320 {
00321   <span class="keywordtype">char</span>         padded_name[PWENT_MAX_LEN] ;
00322   uint64_t     computed_value = 0 ;
00323   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i              = 0 ;
00324   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset         = 0 ;
00325   uint64_t     extract        = 0 ;
00326   uint64_t     sum            = 0 ;
00327   uint64_t     i1 ;
00328   uint64_t     i2 ;
00329   uint64_t     i3 ;
00330   uint64_t     i4 ;
00331   uint64_t     i5 ;
00332   uint64_t     i6 ;
00333   uint64_t     i7 ;
00334   uint64_t     i8 ;
00335   uint64_t     i9 ;
00336   uint64_t     l  ;
00337 
00338   <span class="keywordflow">if</span>( name == NULL || phashval == NULL )
00339     <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00340 
00341   memset( padded_name, 0, PWENT_MAX_LEN ) ;
00342 
00343   <span class="comment">/* Copy the string to the padded one */</span>
00344   <span class="keywordflow">for</span>( i = 0 ; i &lt; <a class="code" href="idmapper__cache_8c.html#a5">strnlen</a>( name, PWENT_MAX_LEN ) ; padded_name[i] = name[i], i++ ) ;
00345 
00346 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_PWHASH_COMPUTE</span>
00347 <span class="preprocessor"></span>  printf( <span class="stringliteral">"#%s# :"</span>, padded_name ) ; 
00348 <span class="preprocessor">#endif</span>
00349 <span class="preprocessor"></span>
00350   <span class="comment">/* For each 9 character pack:</span>
00351 <span class="comment">   *   - keep the 7 first bit (the 8th is often 0: ascii string) </span>
00352 <span class="comment">   *   - pack 7x9 bit to 63 bits using xor</span>
00353 <span class="comment">   *   - xor the last 8th bit to a single 0 , or-ed with the rest</span>
00354 <span class="comment">   * Proceeding with the next 9 bytes pack will produce a new value that is xored with the </span>
00355 <span class="comment">   * one of the previous iteration */</span>
00356 
00357   <span class="keywordflow">for</span>( offset = 0 ; offset &lt; PWENT_MAX_LEN ; offset += 9 )
00358     {
00359       <span class="comment">/* input name is ascii string, remove 8th bit on each byte, not significant */</span>
00360       i1 = padded_name[offset+0] &amp; 0x7F ;
00361       i2 = (uint64_t)( padded_name[offset+1] &amp; 0x7F ) &lt;&lt; 7 ; 
00362       i3 = (uint64_t)( padded_name[offset+2] &amp; 0x7F ) &lt;&lt; 14 ; 
00363       i4 = (uint64_t)( padded_name[offset+3] &amp; 0x7F ) &lt;&lt; 21 ; 
00364       i5 = (uint64_t)( padded_name[offset+4] &amp; 0x7F ) &lt;&lt; 28 ; 
00365       i6 = (uint64_t)( padded_name[offset+5] &amp; 0x7F ) &lt;&lt; 35 ; 
00366       i7 = (uint64_t)( padded_name[offset+6] &amp; 0x7F ) &lt;&lt; 42 ; 
00367       i8 = (uint64_t)( padded_name[offset+7] &amp; 0x7F ) &lt;&lt; 49 ; 
00368       i9 = (uint64_t)( padded_name[offset+8] &amp; 0x7F ) &lt;&lt; 56 ; 
00369 
00370   sum = (uint64_t)padded_name[offset+0] +
00371         (uint64_t)padded_name[offset+1] +
00372         (uint64_t)padded_name[offset+2] +
00373         (uint64_t)padded_name[offset+3] +
00374         (uint64_t)padded_name[offset+4] +
00375         (uint64_t)padded_name[offset+5] +
00376         (uint64_t)padded_name[offset+6] +
00377         (uint64_t)padded_name[offset+7] +
00378         (uint64_t)padded_name[offset+8] ;
00379 
00380 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_PWHASH_COMPUTE</span>
00381 <span class="preprocessor"></span>      printf( <span class="stringliteral">"|%llx |%llx |%llx |%llx |%llx |%llx |%llx |%llx |%llx | = "</span>,
00382              i1, i2, i3, i4, i5, i6, i7, i8, i9 ) ;
00383 <span class="preprocessor">#endif</span>
00384 <span class="preprocessor"></span>
00385       <span class="comment">/* Get xor combibation of all the 8h bit */</span>
00386       l = ( padded_name[offset+0] &amp; 0x80 ) ^
00387           ( padded_name[offset+1] &amp; 0x80 ) ^
00388           ( padded_name[offset+2] &amp; 0x80 ) ^
00389           ( padded_name[offset+3] &amp; 0x80 ) ^
00390           ( padded_name[offset+4] &amp; 0x80 ) ^
00391           ( padded_name[offset+5] &amp; 0x80 ) ^
00392           ( padded_name[offset+6] &amp; 0x80 ) ^
00393           ( padded_name[offset+7] &amp; 0x80 ) ^
00394           ( padded_name[offset+8] &amp; 0x80 ) ;
00395     
00396       extract = i1 ^ i2 ^ i3 ^ i4 ^ i5 ^ i6 ^ i7 ^ i8 ^ i9 | l ;
00397 
00398 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_PWHASH_COMPUTE</span>
00399 <span class="preprocessor"></span>      printf( <span class="stringliteral">"%llx "</span>, extract ) ; 
00400 <span class="preprocessor">#endif</span>
00401 <span class="preprocessor"></span>
00402       computed_value ^= extract ;
00403       computed_value ^= sum ;
00404     }
00405 <span class="preprocessor">#ifdef WITH_PRINTF_DEBUG_PWHASH_COMPUTE</span>
00406 <span class="preprocessor"></span>  printf( <span class="stringliteral">"\n"</span> ) ; 
00407 <span class="preprocessor">#endif</span>
00408 <span class="preprocessor"></span>
00409     computed_value = (computed_value &gt;&gt; 32 ) + (computed_value &amp; 0x00000000FFFFFFFFLL ) ;
00410 
00411   *phashval = (uint32_t)computed_value ;
00412 
00413 
00414   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00415 } <span class="comment">/* idmap_compute_hash_value */</span>
00416 
<a name="l00430"></a><a class="code" href="idmapper__cache_8c.html#a19">00430</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( hash_table_t  * ht,
00431                <span class="keywordtype">char</span>          * key,
00432                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    val )
00433 {
00434   hash_buffer_t     buffkey  ;
00435   hash_buffer_t     buffdata ;
00436   <span class="keywordtype">int</span>               rc ;
00437   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     local_val = (<span class="keywordtype">unsigned</span> long)val ;
00438 
00439   <span class="keywordflow">if</span>( ht == NULL || key == NULL )
00440     <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00441 
00442   <span class="keywordflow">if</span>( ( buffkey.pdata = (caddr_t)Mem_Alloc( PWENT_MAX_LEN ) ) == NULL )
00443     <span class="keywordflow">return</span> ID_MAPPER_INSERT_MALLOC_ERROR ;
00444 
00445   <span class="comment">/* Build the key */</span>
00446   strncpy( (<span class="keywordtype">char</span>*)(buffkey.pdata), key, PWENT_MAX_LEN ) ;
00447   buffkey.len = PWENT_MAX_LEN ;
00448 
00449   <span class="comment">/* Build the value */</span>
00450   buffdata.pdata = (caddr_t)local_val ;
00451   buffdata.len   = <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> long ) ;
00452 
00453   rc = HashTable_Test_And_Set( ht, &amp;buffkey, &amp;buffdata, HASHTABLE_SET_HOW_SET_NO_OVERWRITE ) ;
00454 
00455   <span class="keywordflow">if</span>( rc != HASHTABLE_SUCCESS &amp;&amp; rc != HASHTABLE_ERROR_KEY_ALREADY_EXISTS )
00456      <span class="keywordflow">return</span> ID_MAPPER_INSERT_MALLOC_ERROR ;
00457 
00458   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00459 } <span class="comment">/* idmap_add */</span>
00460 
<a name="l00461"></a><a class="code" href="idmapper__cache_8c.html#a20">00461</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( hash_table_t  * ht,
00462                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    key,
00463                  <span class="keywordtype">char</span> *          val )
00464 {
00465   hash_buffer_t     buffkey  ;
00466   hash_buffer_t     buffdata ;
00467   <span class="keywordtype">int</span>               rc = 0 ;
00468   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     local_key = (<span class="keywordtype">unsigned</span> long)key ;
00469 
00470   <span class="keywordflow">if</span>( ht == NULL || val == NULL )
00471     <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00472 
00473   <span class="keywordflow">if</span>( ( buffdata.pdata = (caddr_t)Mem_Alloc( PWENT_MAX_LEN ) ) == NULL )
00474     <span class="keywordflow">return</span> ID_MAPPER_INSERT_MALLOC_ERROR ;
00475 
00476   <span class="comment">/* Build the data */</span>
00477   strncpy( (<span class="keywordtype">char</span>*)(buffdata.pdata), val, PWENT_MAX_LEN ) ;
00478   buffdata.len = PWENT_MAX_LEN ;
00479 
00480   <span class="comment">/* Build the value */</span>
00481   buffkey.pdata = (caddr_t)local_key ;
00482   buffkey.len   = <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> int ) ;
00483 
00484   rc = HashTable_Test_And_Set( ht, &amp;buffkey, &amp;buffdata, HASHTABLE_SET_HOW_SET_NO_OVERWRITE ) ;
00485 
00486   <span class="keywordflow">if</span>( rc != HASHTABLE_SUCCESS &amp;&amp; rc != HASHTABLE_ERROR_KEY_ALREADY_EXISTS )
00487      <span class="keywordflow">return</span> ID_MAPPER_INSERT_MALLOC_ERROR ;
00488 
00489   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00490 } <span class="comment">/* idmap_add */</span>
00491 
00492 
00493 
<a name="l00494"></a><a class="code" href="idmapper__cache_8c.html#a21">00494</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a21">uidmap_add</a>(  <span class="keywordtype">char</span> * key,  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  val )
00495 {
00496   <span class="keywordtype">int</span> rc1 = 0 ; 
00497   <span class="keywordtype">int</span> rc2 = 0 ;  
00498 
00499   rc1 = <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( <a class="code" href="idmapper__cache_8c.html#a0">ht_pwnam</a>, key, val ) ;
00500   rc2 = <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( <a class="code" href="idmapper__cache_8c.html#a2">ht_pwuid</a>, val, key ) ;
00501 
00502   <span class="keywordflow">if</span>( rc1 != ID_MAPPER_SUCCESS )
00503      <span class="keywordflow">return</span> rc1 ;
00504   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc2 != ID_MAPPER_SUCCESS )
00505       <span class="keywordflow">return</span> rc2 ;
00506 
00507   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00508 } <span class="comment">/* uidmap_add */</span>
00509 
<a name="l00510"></a><a class="code" href="idmapper__cache_8c.html#a22">00510</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a22">unamemap_add</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key, <span class="keywordtype">char</span> *  val )
00511 {
00512   <span class="keywordtype">int</span> rc1 = 0 ;
00513   <span class="keywordtype">int</span> rc2 = 0 ;
00514   
00515   rc1 = <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( <a class="code" href="idmapper__cache_8c.html#a2">ht_pwuid</a>, key, val ) ;
00516   rc2 = <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( <a class="code" href="idmapper__cache_8c.html#a0">ht_pwnam</a>, val, key ) ;
00517 
00518   <span class="keywordflow">if</span>( rc1 != ID_MAPPER_SUCCESS )
00519      <span class="keywordflow">return</span> rc1 ;
00520   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc2 != ID_MAPPER_SUCCESS )
00521       <span class="keywordflow">return</span> rc2 ;
00522 
00523   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00524 } <span class="comment">/* unamemap_add */</span>
00525 
<a name="l00526"></a><a class="code" href="idmapper__cache_8c.html#a23">00526</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a23">gidmap_add</a>(  <span class="keywordtype">char</span> * key,  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  val )
00527 {
00528   <span class="keywordtype">int</span> rc1 = 0 ;
00529   <span class="keywordtype">int</span> rc2 = 0 ;  
00530 
00531   rc1 = <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( <a class="code" href="idmapper__cache_8c.html#a1">ht_grnam</a>, key, val ) ;
00532   rc2 = <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( <a class="code" href="idmapper__cache_8c.html#a3">ht_grgid</a>, val, key ) ;
00533 
00534   <span class="keywordflow">if</span>( rc1 != ID_MAPPER_SUCCESS )
00535      <span class="keywordflow">return</span> rc1 ;
00536   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc2 != ID_MAPPER_SUCCESS )
00537      <span class="keywordflow">return</span> rc2 ;
00538 
00539   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00540 } <span class="comment">/* gidmap_add */</span>
00541 
<a name="l00542"></a><a class="code" href="idmapper__cache_8c.html#a24">00542</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a24">gnamemap_add</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key, <span class="keywordtype">char</span> *  val )
00543 {
00544   <span class="keywordtype">int</span> rc1 = 0 ;
00545   <span class="keywordtype">int</span> rc2 = 0 ;
00546 
00547   rc1 = <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( <a class="code" href="idmapper__cache_8c.html#a3">ht_grgid</a>, key, val ) ;
00548   rc2 = <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( <a class="code" href="idmapper__cache_8c.html#a1">ht_grnam</a>, val, key ) ;
00549 
00550   <span class="keywordflow">if</span>( rc1 != ID_MAPPER_SUCCESS )
00551      <span class="keywordflow">return</span> rc1 ;
00552   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc2 != ID_MAPPER_SUCCESS )
00553      <span class="keywordflow">return</span> rc2 ;
00554 
00555   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00556 } <span class="comment">/* gnamemap_add */</span>
00557 
<a name="l00571"></a><a class="code" href="idmapper__cache_8c.html#a25">00571</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a25">idmap_get</a>( hash_table_t   * ht,
00572                <span class="keywordtype">char</span>           * key,
00573                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  * pval )
00574 {
00575   hash_buffer_t     buffkey  ;
00576   hash_buffer_t     buffval ;
00577   <span class="keywordtype">int</span>               status ;
00578 
00579   <span class="keywordflow">if</span>( ht == NULL || key == NULL || pval == NULL )
00580     <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00581 
00582   buffkey.pdata = (caddr_t)key ;
00583   buffkey.len   = PWENT_MAX_LEN ;
00584 
00585   <span class="keywordflow">if</span>( HashTable_Get( ht, &amp;buffkey, &amp;buffval ) == HASHTABLE_SUCCESS )
00586     {
00587         *pval = (<span class="keywordtype">unsigned</span> long)buffval.pdata ;
00588 
00589         status = ID_MAPPER_SUCCESS ;
00590     }
00591   <span class="keywordflow">else</span>
00592     {
00593         status = ID_MAPPER_NOT_FOUND ;
00594     }
00595   
00596   <span class="keywordflow">return</span> status ;
00597 } <span class="comment">/* idmap_get */</span>
00598 
<a name="l00599"></a><a class="code" href="idmapper__cache_8c.html#a26">00599</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a26">namemap_get</a>( hash_table_t  * ht,
00600                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    key,
00601                  <span class="keywordtype">char</span>          * pval )
00602 {
00603   hash_buffer_t     buffkey  ;
00604   hash_buffer_t     buffval ;
00605   <span class="keywordtype">int</span>               status ;
00606   <span class="keywordtype">long</span>              local_key = (long)key ;
00607 
00608   <span class="keywordflow">if</span>( ht == NULL || pval == NULL )
00609     <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00610 
00611   buffval.pdata = (caddr_t)local_key ;
00612   buffval.len   = <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> long ) ;
00613 
00614   <span class="keywordflow">if</span>( HashTable_Get( ht, &amp;buffkey, &amp;buffval ) == HASHTABLE_SUCCESS )
00615     {
00616         strncpy( pval, (<span class="keywordtype">char</span> *)buffval.pdata , PWENT_MAX_LEN ) ;
00617 
00618         status = ID_MAPPER_SUCCESS ;
00619     }
00620   <span class="keywordflow">else</span>
00621     {
00622         status = ID_MAPPER_NOT_FOUND ;
00623     }
00624   
00625   <span class="keywordflow">return</span> status ;
00626 } <span class="comment">/* idmap_get */</span>
00627 
<a name="l00628"></a><a class="code" href="idmapper__cache_8c.html#a27">00628</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a27">uidmap_get</a>( <span class="keywordtype">char</span>          * key,
00629                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  * pval )
00630 {
00631    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a25">idmap_get</a>( <a class="code" href="idmapper__cache_8c.html#a0">ht_pwnam</a>, key, pval ) ;
00632 }
00633 
<a name="l00634"></a><a class="code" href="idmapper__cache_8c.html#a28">00634</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a28">unamemap_get</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   key, 
00635                   <span class="keywordtype">char</span>         * val ) 
00636 {
00637    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a26">namemap_get</a>( <a class="code" href="idmapper__cache_8c.html#a2">ht_pwuid</a>, key, val ) ;
00638 }
00639 
<a name="l00640"></a><a class="code" href="idmapper__cache_8c.html#a29">00640</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a29">gidmap_get</a>( <span class="keywordtype">char</span>          * key,
00641                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  * pval )
00642 {
00643    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a25">idmap_get</a>( <a class="code" href="idmapper__cache_8c.html#a1">ht_grnam</a>, key, pval ) ;
00644 }
00645 
<a name="l00646"></a><a class="code" href="idmapper__cache_8c.html#a30">00646</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a30">gnamemap_get</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   key, 
00647                   <span class="keywordtype">char</span>         * val ) 
00648 {
00649    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a26">namemap_get</a>( <a class="code" href="idmapper__cache_8c.html#a3">ht_grgid</a>, key, val ) ;
00650 }
00651 
<a name="l00664"></a><a class="code" href="idmapper__cache_8c.html#a31">00664</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a31">idmap_remove</a>( hash_table_t  * ht,
00665                   <span class="keywordtype">char</span>          * key )
00666 {
00667    hash_buffer_t     buffkey, old_key  ;
00668    <span class="keywordtype">int</span>               status ;  
00669 
00670    <span class="keywordflow">if</span>( ht == NULL || key == NULL )
00671       <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00672 
00673    buffkey.pdata = (caddr_t)key ;
00674    buffkey.len   = PWENT_MAX_LEN ;
00675 
00676    <span class="keywordflow">if</span>( HashTable_Del( ht, &amp;buffkey, &amp;old_key, NULL ) == HASHTABLE_SUCCESS )
00677      {
00678         status = ID_MAPPER_SUCCESS ;
00679         Mem_Free( old_key.pdata ) ;
00680      }
00681    <span class="keywordflow">else</span>
00682      {
00683         status = ID_MAPPER_NOT_FOUND ;
00684      }
00685     
00686    <span class="keywordflow">return</span> status ;
00687 } <span class="comment">/* idmap_remove */</span>
00688 
<a name="l00689"></a><a class="code" href="idmapper__cache_8c.html#a32">00689</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a32">namemap_remove</a>( hash_table_t  * ht,
00690                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    key )
00691 {
00692    hash_buffer_t     buffkey, old_data  ;
00693    hash_data_t   *   pbuffdata = NULL ;
00694    <span class="keywordtype">int</span>               status ;  
00695    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     local_key = (<span class="keywordtype">unsigned</span> long)key ;
00696 
00697    <span class="keywordflow">if</span>( ht == NULL )
00698       <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00699 
00700    buffkey.pdata = (caddr_t)local_key ;
00701    buffkey.len   = <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> long ) ;
00702 
00703    <span class="keywordflow">if</span>( HashTable_Del( ht, &amp;buffkey, NULL, &amp;old_data ) == HASHTABLE_SUCCESS )
00704      {
00705         status = ID_MAPPER_SUCCESS ;
00706         Mem_Free( old_data.pdata ) ;
00707      }
00708    <span class="keywordflow">else</span>
00709      {
00710         status = ID_MAPPER_NOT_FOUND ;
00711      }
00712     
00713    <span class="keywordflow">return</span> status ;
00714 } <span class="comment">/* idmap_remove */</span>
00715 
00716 
<a name="l00717"></a><a class="code" href="idmapper__cache_8c.html#a33">00717</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a33">uidmap_remove</a>( <span class="keywordtype">char</span> * key )
00718 {
00719    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a31">idmap_remove</a>( <a class="code" href="idmapper__cache_8c.html#a0">ht_pwnam</a>, key ) ;
00720 }
00721 
<a name="l00722"></a><a class="code" href="idmapper__cache_8c.html#a34">00722</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a34">unamemap_remove</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key )
00723 {
00724    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a32">namemap_remove</a>( <a class="code" href="idmapper__cache_8c.html#a2">ht_pwuid</a>, key ) ;
00725 }
00726                 
<a name="l00727"></a><a class="code" href="idmapper__cache_8c.html#a35">00727</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a35">gidmap_remove</a>( <span class="keywordtype">char</span> * key )
00728 {
00729    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a31">idmap_remove</a>( <a class="code" href="idmapper__cache_8c.html#a1">ht_grnam</a>, key ) ;
00730 }
00731 
<a name="l00732"></a><a class="code" href="idmapper__cache_8c.html#a36">00732</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a36">gnamemap_remove</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key )
00733 {
00734    <span class="keywordflow">return</span> <a class="code" href="idmapper__cache_8c.html#a32">namemap_remove</a>( <a class="code" href="idmapper__cache_8c.html#a3">ht_grgid</a>, key ) ;
00735 }
00736 
<a name="l00745"></a><a class="code" href="idmapper__cache_8c.html#a37">00745</a> <span class="keywordtype">int</span> <a class="code" href="idmapper__cache_8c.html#a37">idmap_populate</a>( <span class="keywordtype">char</span> * path, idmap_type_t maptype ) 
00746 {
00747   config_file_t config_file ;
00748   <span class="keywordtype">int</span>            blk_index ;
00749   <span class="keywordtype">int</span>            var_max ;
00750   <span class="keywordtype">int</span>            var_index ;
00751   <span class="keywordtype">int</span>            err ;
00752   <span class="keywordtype">char</span>         * key_name ;
00753   <span class="keywordtype">char</span>         * key_value ;
00754   <span class="keywordtype">char</span>           label[MAXNAMLEN] ;
00755   hash_table_t * ht = NULL ;
00756   hash_table_t * ht_reverse = NULL ;
00757   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   value = 0 ;
00758   <span class="keywordtype">int</span>            rc = 0 ;
00759 
00760   config_file = config_ParseFile( path );
00761 
00762   <span class="keywordflow">if</span>( !config_file )
00763    { 
00764      DisplayLog( <span class="stringliteral">"Can't open file %s"</span>, path ) ;
00765 
00766      <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00767    }
00768  
00769    <span class="keywordflow">switch</span>( maptype )
00770     {
00771         <span class="keywordflow">case</span> UIDMAP_TYPE:
00772            strncpy( label, CONF_LABEL_UID_MAPPER_TABLE, MAXNAMLEN ) ;
00773            ht = ht_pwnam ;
00774            ht_reverse = ht_pwuid ;
00775            break ;
00776 
00777         <span class="keywordflow">case</span> GIDMAP_TYPE:
00778            strncpy( label, CONF_LABEL_GID_MAPPER_TABLE, MAXNAMLEN ) ;
00779            ht = ht_grnam ;
00780            ht_reverse = ht_grgid ;
00781            break ;
00782 
00783         <span class="keywordflow">default</span>:
00784            <span class="comment">/* Using incoherent value */</span>
00785            <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00786            break ;
00787      }
00788             
00789                 
00790 
00791    <span class="comment">/* Get the config BLOCK */</span>
00792   <span class="keywordflow">if</span>( ( blk_index = config_GetBlockIndexByName( config_file, label ) ) &lt; 0 )
00793     {
00794       DisplayLog( <span class="stringliteral">"Can't get label %s in file %s"</span>, label, path ) ;
00795       <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00796     }
00797 
00798   var_max = config_GetNbKeys( config_file, blk_index ) ;
00799 
00800   <span class="keywordflow">for</span>( var_index = 0 ; var_index &lt; var_max ; var_index++ )
00801     {
00802       <span class="comment">/* Get key's name */</span>
00803       <span class="keywordflow">if</span>( ( err = config_GetKeyValue( config_file,
00804                                       blk_index,
00805                                       var_index,
00806                                       &amp;key_name,
00807                                       &amp;key_value ) ) != 0 )
00808         {
00809           fprintf(stderr, <span class="stringliteral">"Error reading key[%d] from section \"%s\" of configuration file.\n"</span>,
00810                   var_index, label ) ;
00811           <span class="keywordflow">return</span> ID_MAPPER_INVALID_ARGUMENT ;
00812         }
00813 
00814         value = atoi( key_value ) ;
00815 
00816         <span class="keywordflow">if</span>( ( rc = <a class="code" href="idmapper__cache_8c.html#a19">idmap_add</a>( ht, key_name, value ) ) != ID_MAPPER_SUCCESS )
00817           <span class="keywordflow">return</span> rc ;
00818 
00819 
00820         <span class="keywordflow">if</span>( ( rc = <a class="code" href="idmapper__cache_8c.html#a20">namemap_add</a>( ht_reverse, value, key_name ) ) !=  ID_MAPPER_SUCCESS )
00821           <span class="keywordflow">return</span> rc ;
00822 
00823     }
00824 
00825   <span class="comment">/* HashTable_Print( ht ) ; */</span>
00826   <span class="comment">/* HashTable_Print( ht_reverse ) ; */</span>
00827 
00828   <span class="keywordflow">return</span> ID_MAPPER_SUCCESS ;
00829 } <span class="comment">/* idmap_populate_by_conf */</span>
00830 
00831 
<a name="l00847"></a><a class="code" href="idmapper__cache_8c.html#a38">00847</a> <span class="keywordtype">void</span> <a class="code" href="idmapper__cache_8c.html#a38">idmap_get_stats</a>(  idmap_type_t maptype , hash_stat_t * phstat, hash_stat_t * phstat_reverse )
00848 {
00849   hash_table_t * ht = NULL ;
00850   hash_table_t * ht_reverse = NULL ;
00851 
00852   <span class="keywordflow">switch</span>( maptype )
00853     {
00854         <span class="keywordflow">case</span> UIDMAP_TYPE:
00855            ht = ht_pwnam ;
00856            ht_reverse = ht_pwuid ;
00857            break ;
00858 
00859         <span class="keywordflow">case</span> GIDMAP_TYPE:
00860            ht = ht_grnam ;
00861            ht_reverse = ht_grgid ;
00862            break ;
00863 
00864         <span class="keywordflow">default</span>:
00865            <span class="comment">/* Using incoherent value */</span>
00866            return ;
00867            break ;
00868      }
00869 
00870 
00871   HashTable_GetStats( ht, phstat ) ;
00872   HashTable_GetStats( ht_reverse, phstat_reverse ) ;
00873 
00874 } <span class="comment">/* idmap_get_stats */</span>
00875 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:23 2008 for Id Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
