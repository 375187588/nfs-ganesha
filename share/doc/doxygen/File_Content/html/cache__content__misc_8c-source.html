<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>File Content layer: cache_content_misc.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cache_content_misc.c</h1><a href="cache__content__misc_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Ce logiciel est un serveur implementant le protocole NFS.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Ce logiciel est régi par la licence CeCILL soumise au droit français et</span>
00012 <span class="comment"> * respectant les principes de diffusion des logiciels libres. Vous pouvez</span>
00013 <span class="comment"> * utiliser, modifier et/ou redistribuer ce programme sous les conditions</span>
00014 <span class="comment"> * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA</span>
00015 <span class="comment"> * sur le site "http://www.cecill.info".</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * En contrepartie de l'accessibilité au code source et des droits de copie,</span>
00018 <span class="comment"> * de modification et de redistribution accordés par cette licence, il n'est</span>
00019 <span class="comment"> * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,</span>
00020 <span class="comment"> * seule une responsabilité restreinte pèse sur l'auteur du programme,  le</span>
00021 <span class="comment"> * titulaire des droits patrimoniaux et les concédants successifs.</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> * A cet égard  l'attention de l'utilisateur est attirée sur les risques</span>
00024 <span class="comment"> * associés au chargement,  à l'utilisation,  à la modification et/ou au</span>
00025 <span class="comment"> * développement et à la reproduction du logiciel par l'utilisateur étant</span>
00026 <span class="comment"> * donné sa spécificité de logiciel libre, qui peut le rendre complexe à</span>
00027 <span class="comment"> * manipuler et qui le réserve donc à des développeurs et des professionnels</span>
00028 <span class="comment"> * avertis possédant  des  connaissances  informatiques approfondies.  Les</span>
00029 <span class="comment"> * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du</span>
00030 <span class="comment"> * logiciel à leurs besoins dans des conditions permettant d'assurer la</span>
00031 <span class="comment"> * sécurité de leurs systèmes et ou de leurs données et, plus généralement,</span>
00032 <span class="comment"> * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez</span>
00035 <span class="comment"> * pris connaissance de la licence CeCILL, et que vous en avez accepté les</span>
00036 <span class="comment"> * termes.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * ---------------------</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> * Copyright CEA/DAM/DIF (2005)</span>
00041 <span class="comment"> *  Contributor: Philippe DENIEL  philippe.deniel@cea.fr</span>
00042 <span class="comment"> *               Thomas LEIBOVICI thomas.leibovici@cea.fr</span>
00043 <span class="comment"> *</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * This software is a server that implements the NFS protocol.</span>
00046 <span class="comment"> * </span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * This software is governed by the CeCILL  license under French law and</span>
00049 <span class="comment"> * abiding by the rules of distribution of free software.  You can  use,</span>
00050 <span class="comment"> * modify and/ or redistribute the software under the terms of the CeCILL</span>
00051 <span class="comment"> * license as circulated by CEA, CNRS and INRIA at the following URL</span>
00052 <span class="comment"> * "http://www.cecill.info".</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> * As a counterpart to the access to the source code and  rights to copy,</span>
00055 <span class="comment"> * modify and redistribute granted by the license, users are provided only</span>
00056 <span class="comment"> * with a limited warranty  and the software's author,  the holder of the</span>
00057 <span class="comment"> * economic rights,  and the successive licensors  have only  limited</span>
00058 <span class="comment"> * liability.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * In this respect, the user's attention is drawn to the risks associated</span>
00061 <span class="comment"> * with loading,  using,  modifying and/or developing or reproducing the</span>
00062 <span class="comment"> * software by the user in light of its specific status of free software,</span>
00063 <span class="comment"> * that may mean  that it is complicated to manipulate,  and  that  also</span>
00064 <span class="comment"> therefore means  that it is reserved for developers  and  experienced</span>
00065 <span class="comment"> * professionals having in-depth computer knowledge. Users are therefore</span>
00066 <span class="comment"> * encouraged to load and test the software's suitability as regards their</span>
00067 <span class="comment"> * requirements in conditions enabling the security of their systems and/or</span>
00068 <span class="comment"> * data to be ensured and,  more generally, to use and operate it in the</span>
00069 <span class="comment"> * same conditions as regards security.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * The fact that you are presently reading this means that you have had</span>
00072 <span class="comment"> * knowledge of the CeCILL license and that you accept its terms.</span>
00073 <span class="comment"> * ---------------------------------------</span>
00074 <span class="comment"> */</span>
00075 
00088 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00090 <span class="preprocessor">#endif</span>
00091 <span class="preprocessor"></span>
00092 <span class="preprocessor">#include "fsal.h"</span>
00093 <span class="preprocessor">#include "LRU_List.h"</span>
00094 <span class="preprocessor">#include "log_functions.h"</span>
00095 <span class="preprocessor">#include "HashData.h"</span>
00096 <span class="preprocessor">#include "HashTable.h"</span>
00097 <span class="preprocessor">#include "cache_inode.h"</span>
00098 <span class="preprocessor">#include "cache_content.h"</span>
00099 <span class="preprocessor">#include "stuff_alloc.h"</span>
00100 <span class="preprocessor">#include "nfs_exports.h"</span>
00101 
00102 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00103 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00104 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00105 <span class="preprocessor">#include &lt;time.h&gt;</span>
00106 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00107 <span class="preprocessor">#include &lt;string.h&gt;</span>
00108 <span class="preprocessor">#include &lt;sys/vfs.h&gt;</span>
00109 <span class="preprocessor">#include &lt;libgen.h&gt;</span>
00110 
<a name="l00111"></a><a class="code" href="cache__content__misc_8c.html#a2">00111</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cache_content_dir_errno ;
00112  
00113  
00114 <span class="comment">/* HashFileID4 : creates a 16bits hash of the 64bits fileid4 buffer.</span>
00115 <span class="comment"> *</span>
00116 <span class="comment"> * @param fileid4 [IN] 64bits fileid to be hashed.</span>
00117 <span class="comment"> */</span>
<a name="l00118"></a><a class="code" href="cache__content__misc_8c.html#a3">00118</a> <span class="keywordtype">short</span> <a class="code" href="cache__content__misc_8c.html#a3">HashFileID4</a>( u_int64_t fileid4 )
00119 {  
00120   <span class="keywordtype">int</span> i;  
00121   <span class="keywordtype">short</span> hash_val = 0;
00122     
00123   <span class="keywordflow">for</span> ( i = 0; i &lt;= 56; i += 8 )
00124   {
00125 <span class="preprocessor">#define ALPHABET_LEN      16</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define PRIME_16BITS   65521</span>
00127 <span class="preprocessor"></span>    
00128     hash_val = ( hash_val * <a class="code" href="cache__content__misc_8c.html#a0">ALPHABET_LEN</a> + ((fileid4 &gt;&gt; i) &amp; 0xFF) ) % PRIME_16BITS;
00129   }
00130   
00131   <span class="keywordflow">return</span> hash_val;
00132 }
00133 
00134  
<a name="l00150"></a><a class="code" href="cache__content__misc_8c.html#a4">00150</a> cache_content_status_t <a class="code" href="cache__content__misc_8c.html#a4">cache_content_create_name</a>( <span class="keywordtype">char</span>                     * path,
00151                                                   cache_content_nametype_t   type,
00152                                                   fsal_op_context_t        * pcontext,
00153                                                   cache_entry_t            * pentry_inode,
00154                                                   cache_content_client_t   * pclient )
00155 {
00156   fsal_status_t             fsal_status ;
00157   u_int64_t                 fileid4 ; <span class="comment">/* Don't want to include nfs_prot.h at this level */</span>
00158   fsal_handle_t           * pfsal_handle = NULL ;
00159   cache_inode_status_t      cache_status ;
00160   <span class="keywordtype">char</span>                      entrydir[MAXPATHLEN];
00161   <span class="keywordtype">int</span>                       i, nb_char;
00162   <span class="keywordtype">short</span>                     hash_val;
00163   
00164   <span class="keywordflow">if</span>( ( pfsal_handle = cache_inode_get_fsal_handle( pentry_inode, &amp;cache_status ) ) == NULL )
00165     {
00166       <span class="comment">/* stat */</span>
00167       pclient-&gt;stat.func_stats.nb_err_unrecover[CACHE_CONTENT_NEW_ENTRY] += 1 ;
00168       
00169       <span class="keywordflow">return</span> CACHE_CONTENT_BAD_CACHE_INODE_ENTRY ;
00170     }
00171 
00172   <span class="comment">/* Get the digest for the handle, for computing an entry name */</span>
00173   fsal_status = FSAL_DigestHandle( pcontext-&gt;export_context,    
00174                                    FSAL_DIGEST_FILEID4 ,
00175                                    pfsal_handle,
00176                                    (caddr_t)&amp;fileid4 ) ;
00177 
00178   <span class="keywordflow">if</span>( FSAL_IS_ERROR( fsal_status ) ) 
00179     <span class="keywordflow">return</span> CACHE_CONTENT_FSAL_ERROR ;
00180   
00181 
00182   <span class="comment">/* computes a 16bits hash of the 64bits fileid4 buffer */</span>
00183   hash_val = <a class="code" href="cache__content__misc_8c.html#a3">HashFileID4</a>( fileid4 );
00184     
00185   
00186   <span class="comment">/* for limiting the number of entries into each datacache directory</span>
00187 <span class="comment">   * we create 256 subdirectories on 2 levels, depending on the entry's fileid.</span>
00188 <span class="comment">   */</span>
00189   nb_char = snprintf( entrydir, MAXPATHLEN, <span class="stringliteral">"%s/export_id=%d"</span>,
00190                       pclient-&gt;cache_dir, 0 ) ;
00191   
00192   <span class="keywordflow">for</span> ( i = 0; i &lt;= 8 ; i += 8 )
00193   {
00194     <span class="comment">/* concatenation of hashval */</span>
00195     nb_char += snprintf( (<span class="keywordtype">char</span> *)(entrydir + nb_char), MAXPATHLEN - nb_char,
00196                           <span class="stringliteral">"/%02hhX"</span>, (<span class="keywordtype">char</span>)((hash_val &gt;&gt; i) &amp; 0xFF) );
00197     
00198     <span class="comment">/* creating the directory if necessary */</span>
00199     <span class="keywordflow">if</span> ( (mkdir( entrydir, 0750 ) != 0) &amp;&amp; ( errno != EEXIST ) )
00200     {
00201       <span class="keywordflow">return</span> CACHE_CONTENT_LOCAL_CACHE_ERROR;
00202     }
00203   }  
00204   
00205   <span class="comment">/* Create files for caching the entry: index file */</span>
00206   <span class="keywordflow">switch</span>( type )
00207     {
00208     <span class="keywordflow">case</span> CACHE_CONTENT_DATA_FILE:
00209       snprintf( path, MAXPATHLEN, <span class="stringliteral">"%s/node=%llx.data"</span>, entrydir, fileid4 ) ;
00210       break ;
00211       
00212     <span class="keywordflow">case</span> CACHE_CONTENT_INDEX_FILE:
00213       snprintf( path, MAXPATHLEN, <span class="stringliteral">"%s/node=%llx.index"</span>, entrydir, fileid4 ) ;
00214       break ;
00215 
00216     <span class="keywordflow">case</span> CACHE_CONTENT_DIR:
00217       snprintf( path, 
00218                 MAXPATHLEN, 
00219                 <span class="stringliteral">"%s/export_id=%d"</span>, 
00220                 pclient-&gt;cache_dir, 
00221                 0 ) ;
00222       break ;
00223       
00224     <span class="keywordflow">default</span>:
00225       <span class="keywordflow">return</span> CACHE_CONTENT_INVALID_ARGUMENT ;
00226     }
00227   
00228   <span class="keywordflow">return</span> CACHE_CONTENT_SUCCESS ;
00229 } <span class="comment">/* cache_content_create_name */</span>
00230 
<a name="l00242"></a><a class="code" href="cache__content__misc_8c.html#a5">00242</a> <span class="keywordtype">int</span> <a class="code" href="cache__content__misc_8c.html#a5">cache_content_get_export_id</a>( <span class="keywordtype">char</span> * dirname )
00243 {
00244   <span class="keywordtype">int</span> exportid ;
00245   
00246   <span class="keywordflow">if</span>( strncmp( dirname, <span class="stringliteral">"export_id="</span>, strlen( <span class="stringliteral">"export_id="</span> ) ) )
00247     <span class="keywordflow">return</span> -1 ;
00248   
00249   <span class="keywordflow">if</span>( sscanf( dirname, <span class="stringliteral">"export_id=%d"</span>, &amp;exportid ) == 0 )
00250     <span class="keywordflow">return</span> -1 ;
00251   <span class="keywordflow">else</span>
00252     <span class="keywordflow">return</span> exportid ;
00253 } <span class="comment">/* cache_content_get_export_id */</span>
00254 
00255 
<a name="l00267"></a><a class="code" href="cache__content__misc_8c.html#a6">00267</a> u_int64_t <a class="code" href="cache__content__misc_8c.html#a6">cache_content_get_inum</a>( <span class="keywordtype">char</span> * filename )
00268 {
00269   u_int64_t inum ;
00270   <span class="keywordtype">char</span> buff[MAXNAMLEN];
00271   <span class="keywordtype">char</span> * bname = NULL;
00272   
00273   <span class="comment">/* splits the dirent-&gt;d_name into path and filename */</span>
00274   strncpy( buff, filename, MAXNAMLEN );
00275   bname = basename( buff );  
00276   
00277   <span class="keywordflow">if</span>( strncmp( bname, <span class="stringliteral">"node="</span>, strlen( <span class="stringliteral">"node="</span> ) ) )
00278     <span class="keywordflow">return</span> 0 ;
00279   
00280   <span class="keywordflow">if</span>( strncmp( bname + strlen( bname ) -5, <span class="stringliteral">"index"</span>, NAME_MAX ) )
00281     <span class="keywordflow">return</span> 0 ;
00282   
00283   <span class="keywordflow">if</span>( sscanf( bname, <span class="stringliteral">"node=%llx.index"</span>, &amp;inum ) == 0 )
00284     <span class="keywordflow">return</span> 0 ;
00285   <span class="keywordflow">else</span>
00286     <span class="keywordflow">return</span> inum ;
00287 } <span class="comment">/* cache_content_get_inum */</span>
00288 
00289 
00290 
<a name="l00304"></a><a class="code" href="cache__content__misc_8c.html#a7">00304</a> <span class="keywordtype">int</span> <a class="code" href="cache__content__misc_8c.html#a7">cache_content_get_datapath</a>( <span class="keywordtype">char</span> * basepath, u_int64_t inum, <span class="keywordtype">char</span> * datapath )
00305 {
00306    <span class="keywordtype">short</span>       hash_val;
00307    
00308    hash_val = <a class="code" href="cache__content__misc_8c.html#a3">HashFileID4</a>( inum );
00309 
00310    snprintf( datapath, MAXPATHLEN, <span class="stringliteral">"%s/%02hhX/%02hhX/node=%llx.data"</span>, basepath,
00311        (<span class="keywordtype">char</span>)((hash_val) &amp; 0xFF),
00312        (<span class="keywordtype">char</span>)((hash_val &gt;&gt; 8) &amp; 0xFF),
00313        inum ) ;
00314 <span class="preprocessor">#ifdef _DEBUG_CACHE_CONTENT</span>
00315 <span class="preprocessor"></span>  DisplayLogLevel( NIV_FULL_DEBUG, <span class="stringliteral">"cache_content_get_datapath : datapath ----&gt; %s"</span>, datapath ) ;
00316 <span class="preprocessor">#endif</span>
00317 <span class="preprocessor"></span>
00318    <span class="comment">/* it is ok, we now return 0 */</span>
00319   <span class="keywordflow">return</span> 0;
00320 } <span class="comment">/* cache_content_get_datapath */</span>
00321 
00322 
00323 
<a name="l00337"></a><a class="code" href="cache__content__misc_8c.html#a8">00337</a> off_t <a class="code" href="cache__content__misc_8c.html#a8">cache_content_recover_size</a>( <span class="keywordtype">char</span> * basepath, u_int64_t inum )
00338 {
00339    <span class="keywordtype">char</span>        path[MAXPATHLEN] ;
00340    <span class="keyword">struct </span>stat buffstat ;
00341    <span class="keywordtype">short</span>       hash_val;
00342    
00343    <a class="code" href="cache__content__misc_8c.html#a7">cache_content_get_datapath</a>( basepath, inum, path );
00344    
00345    <span class="keywordflow">if</span>( stat( path, &amp;buffstat ) !=0 )
00346      {  
00347         DisplayLog( <span class="stringliteral">"Failure in cache_content_recover_size while stat on local cache: path=%s errno = %u"</span>, path, errno ) ;
00348 
00349         <span class="keywordflow">return</span> -1 ;
00350      }
00351 
00352 <span class="preprocessor">#ifdef _DEBUG_CACHE_CONTENT</span>
00353 <span class="preprocessor"></span>   DisplayLogLevel( NIV_FULL_DEBUG, <span class="stringliteral">"path ----&gt; %s %llu\n"</span>, path, buffstat.st_size ) ;
00354 <span class="preprocessor">#endif</span>
00355 <span class="preprocessor"></span>
00356    <span class="comment">/* Stat is ok, we now return the size */</span>
00357   <span class="keywordflow">return</span> buffstat.st_size ;
00358 } <span class="comment">/* cache_content_recover_size */</span>
00359 
00360 
<a name="l00372"></a><a class="code" href="cache__content__misc_8c.html#a9">00372</a> off_t <a class="code" href="cache__content__misc_8c.html#a9">cache_content_get_cached_size</a>( cache_content_entry_t * pentry )
00373 {
00374    <span class="keyword">struct </span>stat buffstat ;
00375 
00376    <span class="keywordflow">if</span>( stat( pentry-&gt;local_fs_entry.cache_path_data, &amp;buffstat ) !=0 )
00377        {
00378         DisplayLog( <span class="stringliteral">"Failure in cache_content_get_cached_size while stat on local cache: path=%s errno = %u"</span>, 
00379                     pentry-&gt;local_fs_entry.cache_path_index, errno ) ;
00380 
00381         <span class="keywordflow">return</span> -1 ;
00382      }
00383 
00384   <span class="comment">/* Stat is ok, we now return the size */</span>
00385 
00386   <span class="keywordflow">return</span> buffstat.st_size ;
00387 
00388 } <span class="comment">/* cache_content_get_cached_size */</span>
<a name="l00400"></a><a class="code" href="cache__content__misc_8c.html#a10">00400</a> cache_inode_status_t <a class="code" href="cache__content__misc_8c.html#a10">cache_content_error_convert</a>( cache_content_status_t status ) 
00401 {
00402   cache_inode_status_t converted_status ;
00403   
00404   <span class="keywordflow">switch</span>( status )
00405     {
00406     <span class="keywordflow">case</span> CACHE_CONTENT_SUCCESS:
00407       converted_status = CACHE_INODE_SUCCESS ;
00408       break ;
00409       
00410     <span class="keywordflow">case</span> CACHE_CONTENT_INVALID_ARGUMENT:
00411       converted_status = CACHE_INODE_INVALID_ARGUMENT ;
00412       break ;
00413       
00414     <span class="keywordflow">case</span> CACHE_CONTENT_BAD_CACHE_INODE_ENTRY:
00415       converted_status = CACHE_INODE_INVALID_ARGUMENT ;
00416       break ;
00417       
00418     <span class="keywordflow">case</span> CACHE_CONTENT_ENTRY_EXISTS:
00419       converted_status = CACHE_INODE_ENTRY_EXISTS ;
00420       break ;
00421       
00422     <span class="keywordflow">case</span>  CACHE_CONTENT_FSAL_ERROR:
00423       converted_status = CACHE_INODE_FSAL_ERROR ;
00424       break ;
00425       
00426     <span class="keywordflow">case</span> CACHE_CONTENT_LOCAL_CACHE_ERROR:
00427       converted_status = CACHE_INODE_CACHE_CONTENT_ERROR ;
00428       break ;
00429       
00430     <span class="keywordflow">case</span> CACHE_CONTENT_MALLOC_ERROR:
00431       converted_status = CACHE_INODE_MALLOC_ERROR  ;
00432       break ;
00433     
00434     <span class="keywordflow">case</span> CACHE_CONTENT_LRU_ERROR:
00435       converted_status = CACHE_INODE_LRU_ERROR  ;
00436       break ;
00437 
00438     <span class="keywordflow">default</span>:
00439       converted_status = CACHE_INODE_INVALID_ARGUMENT ;
00440       break ;
00441     }
00442   
00443   <span class="keywordflow">return</span> converted_status ;
00444 } <span class="comment">/* cache_content_error_convert */</span>
00445 
00446 
<a name="l00459"></a><a class="code" href="cache__content__misc_8c.html#a11">00459</a> off_t <a class="code" href="cache__content__misc_8c.html#a11">cache_content_fsal_seek_convert</a>( fsal_seek_t seek, cache_content_status_t * pstatus )
00460 {
00461   off_t offset = 0 ;
00462   
00463   <span class="keywordflow">if</span>( seek.whence != FSAL_SEEK_SET )
00464     *pstatus = CACHE_CONTENT_INVALID_ARGUMENT ;
00465   <span class="keywordflow">else</span>
00466     {
00467       *pstatus = CACHE_CONTENT_SUCCESS ;
00468       offset = (off_t)seek.offset ;
00469     }
00470   
00471   <span class="keywordflow">return</span> offset ;
00472 } <span class="comment">/* cache_content_fsal_seek_convert */</span>
00473 
<a name="l00486"></a><a class="code" href="cache__content__misc_8c.html#a12">00486</a> size_t <a class="code" href="cache__content__misc_8c.html#a12">cache_content_fsal_size_convert</a>( fsal_size_t size, cache_content_status_t * pstatus ) 
00487 {
00488   size_t taille ;
00489 
00490   *pstatus = CACHE_CONTENT_SUCCESS ;
00491   taille = (size_t)size ;
00492   
00493   <span class="keywordflow">return</span> taille ;
00494 } <span class="comment">/* cache_content_fsal_size_convert */</span>
00495 
<a name="l00508"></a><a class="code" href="cache__content__misc_8c.html#a13">00508</a> cache_content_status_t <a class="code" href="cache__content__misc_8c.html#a13">cache_content_prepare_directories</a>( exportlist_t           * pexportlist, 
00509                                                           <span class="keywordtype">char</span>                   * cache_dir,
00510                                                           cache_content_status_t * pstatus  ) 
00511 {
00512   exportlist_t * pexport = NULL  ;
00513   <span class="keywordtype">char</span>           cache_sub_dir[MAXPATHLEN] ;
00514   
00515   <span class="comment">/* Does the cache root directory exist ? */</span>
00516   <span class="keywordflow">if</span>( access( cache_dir, F_OK ) == -1 )
00517     {
00518       <span class="comment">/* Create the cache root directory */</span>
00519       <span class="keywordflow">if</span>( mkdir( cache_dir, 0750 ) == -1 )
00520         <span class="keywordflow">return</span> CACHE_CONTENT_LOCAL_CACHE_ERROR ;
00521     }
00522 
00523   <span class="comment">/* Create the sub directories if needed */</span>
00524   <span class="keywordflow">for</span>( pexport = pexportlist ; pexport != NULL ; pexport = pexport-&gt;next )
00525     {
00526       <span class="comment">/* Create a directory only if the export entry is to be datya cached */</span>
00527       <span class="keywordflow">if</span>( pexport-&gt;options &amp; EXPORT_OPTION_USE_DATACACHE )
00528         {
00529           snprintf( cache_sub_dir, MAXPATHLEN, <span class="stringliteral">"%s/export_id=%d"</span>,  cache_dir, 0 ) ;
00530           
00531           <span class="keywordflow">if</span>( access( cache_sub_dir, F_OK ) == -1 )
00532             {
00533               <span class="comment">/* Create the cache  directory */</span>
00534               <span class="keywordflow">if</span>( mkdir( cache_sub_dir, 0750 ) == -1 )
00535                 <span class="keywordflow">return</span> CACHE_CONTENT_LOCAL_CACHE_ERROR ;
00536             }
00537         }
00538     }
00539   
00540   <span class="comment">/* If this point is reached, everything went ok */</span>
00541   <span class="keywordflow">return</span> CACHE_CONTENT_SUCCESS ;
00542 } <span class="comment">/* cache_content_prepare_directories */</span>
00543 
00544 
<a name="l00560"></a><a class="code" href="cache__content__misc_8c.html#a14">00560</a> cache_content_status_t <a class="code" href="cache__content__misc_8c.html#a14">cache_content_valid</a>( cache_content_entry_t *  pentry,
00561                                             cache_inode_op_t         op,
00562                                             cache_content_client_t * pclient )
00563 {
00564   <span class="comment">/* /!\ NOTE THIS CAREFULLY: entry is supposed to be locked when this function is called !! */</span>
00565 
00566   LRU_status_t         lru_status ;
00567   LRU_entry_t        * plru_entry = NULL ;
00568 <span class="preprocessor">#ifndef _NO_BUDDY_SYSTEM</span>
00569 <span class="preprocessor"></span>  buddy_stats_t        bstats;
00570 <span class="preprocessor">#endif</span>
00571 <span class="preprocessor"></span>
00572   <span class="keywordflow">if</span>( pentry == NULL )
00573     <span class="keywordflow">return</span> CACHE_CONTENT_INVALID_ARGUMENT ;
00574 
00575   <span class="comment">/* Invalidate former entry if needed */</span>
00576   <span class="keywordflow">if</span>( pentry-&gt;gc_lru != NULL &amp;&amp; pentry-&gt;gc_lru_entry )
00577     {
00578       <span class="keywordflow">if</span>( LRU_invalidate( pentry-&gt;gc_lru, pentry-&gt;gc_lru_entry ) != LRU_LIST_SUCCESS )
00579         {
00580           RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00581           <span class="keywordflow">return</span>  CACHE_CONTENT_LRU_ERROR ;
00582         }
00583     }
00584 
00585   <span class="keywordflow">if</span>( ( plru_entry = LRU_new_entry( pclient-&gt;lru_gc, &amp;lru_status ) ) == NULL )
00586     {
00587       RELEASE_PREALLOC(  pentry, pclient-&gt;pool_entry,  next_alloc ) ;
00588       <span class="keywordflow">return</span> CACHE_CONTENT_LRU_ERROR ;
00589     }
00590   plru_entry-&gt;buffdata.pdata = (caddr_t)pentry ;
00591   plru_entry-&gt;buffdata.len = <span class="keyword">sizeof</span>( cache_entry_t ) ;
00592 
00593   <span class="comment">/* Setting the anchors */</span>
00594   pentry-&gt;gc_lru = pclient-&gt;lru_gc ;
00595   pentry-&gt;gc_lru_entry = plru_entry ;
00596 
00597   <span class="comment">/* Update internal md */</span>
00598   pentry-&gt;internal_md.valid_state = VALID ;
00599 
00600   <span class="keywordflow">switch</span>( op ) 
00601    {
00602         <span class="keywordflow">case</span> CACHE_CONTENT_OP_GET:
00603            pentry-&gt;internal_md.read_time = time( NULL ) ;
00604            break ;
00605 
00606         <span class="keywordflow">case</span> CACHE_CONTENT_OP_SET:
00607            pentry-&gt;internal_md.mod_time = time( NULL ) ;
00608            pentry-&gt;internal_md.refresh_time = pentry-&gt;internal_md.mod_time ;
00609            pentry-&gt;local_fs_entry.sync_state = FLUSH_NEEDED ;
00610            break ;
00611 
00612         <span class="keywordflow">case</span> CACHE_CONTENT_OP_FLUSH:
00613            pentry-&gt;internal_md.mod_time = time( NULL ) ;
00614            pentry-&gt;internal_md.refresh_time = pentry-&gt;internal_md.mod_time ;
00615            pentry-&gt;local_fs_entry.sync_state = SYNC_OK ;
00616            break ;
00617    }
00618 
00619    <span class="comment">/* Add a call to the GC counter */</span>
00620   pclient-&gt;call_since_last_gc += 1 ;
00621 
00622   <span class="comment">/* Call LRU_gc_invalid to get ride of the unused invalid lru entries */</span>
00623   <span class="keywordflow">if</span>( LRU_gc_invalid( pclient-&gt;lru_gc, NULL ) != LRU_LIST_SUCCESS )
00624     <span class="keywordflow">return</span> CACHE_CONTENT_LRU_ERROR ;
00625 
00626   <span class="keywordflow">return</span>  CACHE_CONTENT_SUCCESS ;
00627 } <span class="comment">/* cache_content_valid */</span>
00628 
00629 
00630 
<a name="l00650"></a><a class="code" href="cache__content__misc_8c.html#a15">00650</a> cache_content_status_t <a class="code" href="cache__content__misc_8c.html#a15">cache_content_check_threshold</a>( <span class="keywordtype">char</span>          * datacache_path,
00651                                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    threshold_min,
00652                                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    threshold_max,
00653                                                       <span class="keywordtype">int</span>           * p_bool_overflow,
00654                                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> * p_blocks_to_lwm )
00655 {
00656   <span class="keywordtype">char</span> fspath[MAXPATHLEN];
00657   <span class="keyword">struct </span>statfs info_fs;
00658   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> total_user_blocs, dispo_hw, dispo_lw;
00659   <span class="keywordtype">double</span> tx_used, hw, lw;
00660   
00661   <span class="comment">/* defensive checks */</span>
00662   
00663   <span class="keywordflow">if</span> ( !datacache_path || !p_bool_overflow || !p_blocks_to_lwm
00664       || (threshold_min&gt;threshold_max) || (threshold_max &gt; 100) )
00665       <span class="keywordflow">return</span> CACHE_CONTENT_INVALID_ARGUMENT ;
00666     
00667   <span class="comment">/* cross mountpoint */</span>  
00668   
00669   snprintf(fspath, MAXPATHLEN ,<span class="stringliteral">"%s/."</span>, datacache_path );
00670   
00671   <span class="comment">/* retieve FS info */</span>
00672   
00673   <span class="keywordflow">if</span> ( statfs(fspath, &amp;info_fs) != 0 )
00674   {
00675         DisplayLog( <span class="stringliteral">"Error getting local filesystem info: path=%s errno=%u\n"</span>, fspath, errno );
00676     <span class="keywordflow">return</span> CACHE_CONTENT_LOCAL_CACHE_ERROR ;
00677   }
00678   
00679   <span class="comment">/* Compute thresholds and total block count.</span>
00680 <span class="comment">   * Those formulas are based on the df's code:</span>
00681 <span class="comment">   * used = f_blocks - available_to_root</span>
00682 <span class="comment">   *      = f_blocks - f_bfree</span>
00683 <span class="comment">   * total = used + available</span>
00684 <span class="comment">   *       = f_blocks - f_bfree + f_bavail</span>
00685 <span class="comment">   */</span>
00686   hw = (double)threshold_max; <span class="comment">/* cast to double */</span>
00687   lw = (double)threshold_min; <span class="comment">/* cast to double */</span>
00688   
00689   total_user_blocs = ( info_fs.f_blocks + info_fs.f_bavail - info_fs.f_bfree );
00690   dispo_hw = (<span class="keywordtype">unsigned</span> long) ((( 100.0 - hw ) * total_user_blocs ) / 100.0 );
00691   dispo_lw = (<span class="keywordtype">unsigned</span> long) ((( 100.0 - lw ) * total_user_blocs ) / 100.0 );
00692   
00693   tx_used = 100.0 * ((double)info_fs.f_blocks-(double)info_fs.f_bfree) /
00694              ((double)info_fs.f_blocks+(double)info_fs.f_bavail-(double)info_fs.f_bfree);
00695     
00696   DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"Datacache: %s: %.2f%% used, low_wm = %.2f%%, high_wm = %.2f%%"</span>,
00697                    datacache_path, tx_used, lw, hw );
00698   
00699   <span class="comment">/* threshold test */</span>
00700   
00701   <span class="comment">/* if the threshold is under high watermark, nothing to do */</span>
00702   
00703   <span class="keywordflow">if</span> ( tx_used &lt; hw )
00704   {
00705     *p_bool_overflow = FALSE;
00706     *p_blocks_to_lwm = 0;
00707     DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"Datacache: no purge needed"</span> );
00708   }
00709   <span class="keywordflow">else</span>
00710   {
00711     *p_bool_overflow = TRUE;
00712     *p_blocks_to_lwm = dispo_lw - info_fs.f_bavail;
00713     DisplayLogLevel( NIV_EVENT, <span class="stringliteral">"Datacache: need to purge %lu blocks for reaching low WM"</span>, *p_blocks_to_lwm );
00714   }
00715   
00716   <span class="keywordflow">return</span> CACHE_CONTENT_SUCCESS;  
00717   
00718 }                                                      
00719 
<a name="l00729"></a><a class="code" href="cache__content__misc_8c.html#a16">00729</a> <span class="keywordtype">int</span> <a class="code" href="cache__content__misc_8c.html#a16">cache_content_local_cache_opendir</a>( <span class="keywordtype">char</span> * cache_dir, cache_content_dirinfo_t * pdirectory )
00730 {
00731   pdirectory-&gt;level0_dir = NULL ;
00732   pdirectory-&gt;level1_dir = NULL ;
00733   pdirectory-&gt;level2_dir = NULL ;
00734   pdirectory-&gt;level1_cnt = 0 ;
00735   pdirectory-&gt;cookie0    = NULL ;
00736   pdirectory-&gt;cookie1    = NULL ;
00737   pdirectory-&gt;cookie2    = NULL ;
00738   strcpy(  pdirectory-&gt;level0_path, <span class="stringliteral">""</span> ) ;
00739   strcpy(  pdirectory-&gt;level1_name, <span class="stringliteral">""</span> ) ;
00740   strcpy(  pdirectory-&gt;level2_name, <span class="stringliteral">""</span> ) ;
00741 
00742   <span class="comment">/* opens the top level directory */</span>
00743   <span class="keywordflow">if</span>( ( pdirectory-&gt;level0_dir = opendir( cache_dir )) == NULL )
00744    {
00745     <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno ;
00746     <span class="keywordflow">return</span> FALSE ;
00747    }
00748   <span class="keywordflow">else</span>
00749   {
00750     <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = 0 ;
00751     strncpy( pdirectory-&gt;level0_path, cache_dir, MAXPATHLEN );
00752   }
00753 
00754   pdirectory-&gt;level1_cnt = 0;
00755   <span class="keywordflow">return</span> TRUE ;
00756 } <span class="comment">/* cache_content_local_cache_opendir */</span>
00757 
00758 
<a name="l00773"></a><a class="code" href="cache__content__misc_8c.html#a17">00773</a> cache_content_status_t <a class="code" href="cache__content__misc_8c.html#a17">cache_content_test_cached</a>( cache_entry_t                 * pentry_inode,
00774                                                   cache_content_client_t        * pclient,
00775                                                   fsal_op_context_t             * pcontext,
00776                                                   cache_content_status_t        * pstatus ) 
00777 {
00778   cache_content_status_t status ;
00779   <span class="keywordtype">char</span>                   cache_path_index[MAXPATHLEN] ;
00780 
00781   <span class="keywordflow">if</span>( pstatus == NULL )
00782     <span class="keywordflow">return</span> CACHE_CONTENT_INVALID_ARGUMENT ;
00783 
00784   <span class="keywordflow">if</span>( pentry_inode == NULL || pclient == NULL || pcontext == NULL )
00785     {
00786         *pstatus = CACHE_CONTENT_INVALID_ARGUMENT ;
00787         <span class="keywordflow">return</span> *pstatus ;
00788     }
00789 
00790   <span class="comment">/* Build the cache index path */</span>
00791   <span class="keywordflow">if</span>( ( *pstatus = <a class="code" href="cache__content__misc_8c.html#a4">cache_content_create_name</a>( cache_path_index,
00792                                               CACHE_CONTENT_INDEX_FILE,
00793                                               pcontext,
00794                                               pentry_inode, 
00795                                               pclient ) ) != CACHE_CONTENT_SUCCESS )
00796         {
00797            <span class="keywordflow">return</span>  *pstatus ;
00798         }
00799   
00800 
00801    <span class="comment">/* Check if the file exists */</span> 
00802    <span class="keywordflow">if</span>( access( cache_path_index, F_OK ) == 0 )
00803     {
00804       <span class="comment">/* File is accessible and exists */</span>
00805       *pstatus = CACHE_CONTENT_SUCCESS ;
00806       <span class="keywordflow">return</span> CACHE_CONTENT_SUCCESS ;
00807     }
00808 
00809    <span class="comment">/* No access */</span> 
00810    *pstatus = CACHE_CONTENT_NOT_FOUND ;
00811    <span class="keywordflow">return</span> CACHE_CONTENT_NOT_FOUND ;
00812 
00813 } <span class="comment">/* cache_content_test_cached */</span>
00814 
00815 
<a name="l00827"></a><a class="code" href="cache__content__misc_8c.html#a18">00827</a> <span class="keywordtype">int</span> <a class="code" href="cache__content__misc_8c.html#a18">cache_content_local_cache_dir_iter</a>( cache_content_dirinfo_t * directory,
00828                                         <span class="keyword">struct</span> dirent           * pdir_entry,
00829                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              index,
00830                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              mod )
00831 {
00832     <span class="keywordtype">int</span> rc_readdir = 0 ;
00833 
00834     <span class="comment">/* sanity check */</span>
00835     <span class="keywordflow">if</span> ( directory == NULL || pdir_entry == NULL )
00836     {
00837       <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = EFAULT;
00838       <span class="keywordflow">return</span> FALSE ;
00839     }
00840 
00841     <span class="keywordflow">do</span> {
00842       
00843       errno = 0;
00844             
00845       <span class="comment">/* if the lowest level directory is not opened,</span>
00846 <span class="comment">       * proceed a readdir, on the topper level directory,</span>
00847 <span class="comment">       * and so on.</span>
00848 <span class="comment">       */</span>
00849       <span class="keywordflow">if</span> ( directory-&gt;level2_dir != NULL )
00850       {
00851         rc_readdir = readdir_r( directory-&gt;level2_dir, pdir_entry, &amp;(directory-&gt;cookie2) ) ;
00852 
00853         <span class="keywordflow">if</span>( rc_readdir == 0 &amp;&amp; directory-&gt;cookie2 != NULL ) 
00854         {
00855           <span class="keywordtype">char</span> d_name_save[MAXNAMLEN];
00856         
00857  
00858           <span class="comment">/* go to the next loop if the entry is . or .. */</span>
00859            <span class="keywordflow">if</span>( !strcmp( <span class="stringliteral">"."</span>, pdir_entry-&gt;d_name ) || !strcmp( <span class="stringliteral">".."</span>, pdir_entry-&gt;d_name )  ) 
00860              <span class="keywordflow">continue</span>; 
00861       
00862 <span class="preprocessor">#ifdef _DEBUG_CACHE_CONTENT</span>
00863 <span class="preprocessor"></span>          printf( <span class="stringliteral">"iterator --&gt; %s/%s/%s/%s\n"</span>,directory-&gt;level0_path,
00864                   directory-&gt;level1_name, directory-&gt;level2_name,
00865                   pdir_entry-&gt;d_name );
00866 <span class="preprocessor">#endif</span>
00867 <span class="preprocessor"></span>
00868           <span class="comment">/* the d_name must actually be the relative path from</span>
00869 <span class="comment">           * the cache directory path, so that a file can be</span>
00870 <span class="comment">           * accessed using &lt;rootpath&gt;/&lt;d_name&gt; path.</span>
00871 <span class="comment">           */</span>
00872           strncpy( d_name_save, pdir_entry-&gt;d_name, MAXNAMLEN );
00873           snprintf( pdir_entry-&gt;d_name, MAXNAMLEN, <span class="stringliteral">"%s/%s/%s"</span>,
00874               directory-&gt;level1_name, directory-&gt;level2_name, d_name_save );
00875           
00876           <span class="keywordflow">return</span> TRUE;
00877         }
00878         <span class="keywordflow">else</span>
00879         {
00880           <span class="comment">/* test if it is an error or an end of dir */</span>
00881           <span class="keywordflow">if</span> ( errno != 0 )
00882           {
00883             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno;
00884             <span class="keywordflow">return</span> TRUE;
00885           }
00886           <span class="keywordflow">else</span>
00887           {
00888             <span class="comment">/* the lowest level entry dir is finished,</span>
00889 <span class="comment">             * must proceed a readdir on the topper level</span>
00890 <span class="comment">             */</span>
00891             closedir( directory-&gt;level2_dir ); 
00892             directory-&gt;level2_dir = NULL;
00893             <span class="comment">/* go to next loop */</span>
00894           }
00895         }
00896       }
00897       <span class="comment">/* continue directory at level 1 */</span>
00898       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( directory-&gt;level1_dir != NULL )
00899       {
00900         <span class="keywordflow">if</span> ( mod &lt;= 1 )
00901         {
00902           <span class="comment">/* list all dirs */</span>
00903           rc_readdir = readdir_r( directory-&gt;level1_dir , pdir_entry, &amp;(directory-&gt;cookie1) ) ;
00904           directory-&gt;level1_cnt += 1;          
00905         }
00906         <span class="keywordflow">else</span>
00907         {
00908           rc_readdir = readdir_r( directory-&gt;level1_dir, pdir_entry, &amp;(directory-&gt;cookie1) ) ;
00909           directory-&gt;level1_cnt ++;
00910 
00911 <span class="preprocessor">#ifdef _DEBUG_CACHE_CONTENT</span>
00912 <span class="preprocessor"></span>          printf( <span class="stringliteral">"---&gt; directory-&gt;level1_cnt=%u mod=%u index=%u modulocalcule=%u name=%s\n"</span>,
00913                   directory-&gt;level1_cnt, mod, index, directory-&gt;level1_cnt % mod, pdir_entry-&gt;d_name ) ;
00914 <span class="preprocessor">#endif</span>
00915 <span class="preprocessor"></span> 
00916           <span class="comment">/* skip entry if  cnt % mod == index */</span>
00917           <span class="keywordflow">if</span> ( ( directory-&gt;level1_cnt % mod != index ) )
00918             <span class="keywordflow">continue</span>;
00919         }
00920 
00921         <span class="keywordflow">if</span>( rc_readdir == 0  &amp;&amp; directory-&gt;cookie1 != NULL )
00922         {
00923           <span class="keywordtype">char</span> dirpath[MAXPATHLEN];
00924               
00925           <span class="comment">/* go to the next loop if this is the . or .. entry */</span>
00926           <span class="keywordflow">if</span> ( !strcmp( <span class="stringliteral">"."</span>, pdir_entry-&gt;d_name ) || !strcmp( <span class="stringliteral">".."</span>, pdir_entry-&gt;d_name ) )
00927             <span class="keywordflow">continue</span>;
00928           
00929           strncpy( directory-&gt;level2_name, pdir_entry-&gt;d_name, MAXNAMLEN );
00930           
00931           <span class="comment">/* must now open the entry as the level2 directory */</span>
00932           snprintf ( dirpath, MAXPATHLEN, <span class="stringliteral">"%s/%s/%s"</span>, 
00933                      directory-&gt;level0_path,
00934                      directory-&gt;level1_name,
00935                      directory-&gt;level2_name ); 
00936           
00937           <span class="keywordflow">if</span>( ( directory-&gt;level2_dir = opendir( dirpath )) == NULL )
00938           {
00939             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno ;
00940             <span class="keywordflow">return</span> FALSE ;
00941           }
00942         }
00943         <span class="keywordflow">else</span>
00944         {
00945           <span class="comment">/* test if it is an error or an end of dir */</span>
00946           <span class="keywordflow">if</span> ( errno != 0 )
00947           {
00948             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno;
00949             <span class="keywordflow">return</span> TRUE;
00950           }
00951           <span class="keywordflow">else</span>
00952           {
00953             <span class="comment">/* the lowest level entry dir is finished,</span>
00954 <span class="comment">             * must proceed a readdir on the topper level</span>
00955 <span class="comment">             */</span>
00956             closedir( directory-&gt;level1_dir );            
00957             directory-&gt;level1_dir = NULL;
00958           }
00959         }
00960       }
00961       <span class="comment">/* continue directory at level 0 */</span>
00962       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( directory-&gt;level0_dir != NULL )
00963       {
00964 
00965         rc_readdir = readdir_r( directory-&gt;level0_dir, pdir_entry, &amp;(directory-&gt;cookie0 ) ) ;
00966 
00967         <span class="keywordflow">if</span>( rc_readdir == 0 &amp;&amp; directory-&gt;cookie0 != NULL ) 
00968         {
00969           <span class="keywordtype">char</span> dirpath[MAXPATHLEN];
00970               
00971           <span class="comment">/* go to the next loop if this is the . or .. entry */</span>
00972           <span class="keywordflow">if</span> ( !strcmp( <span class="stringliteral">"."</span>, pdir_entry-&gt;d_name ) || !strcmp( <span class="stringliteral">".."</span>, pdir_entry-&gt;d_name ) )
00973             <span class="keywordflow">continue</span>;
00974           
00975           strncpy( directory-&gt;level1_name, pdir_entry-&gt;d_name, MAXNAMLEN );
00976           
00977           <span class="comment">/* must now open the entry as the level1 directory */</span>
00978           snprintf ( dirpath, MAXPATHLEN, <span class="stringliteral">"%s/%s"</span>, 
00979                      directory-&gt;level0_path,
00980                      directory-&gt;level1_name );
00981           
00982           directory-&gt;level1_cnt = 0;
00983           
00984           <span class="keywordflow">if</span>( ( directory-&gt;level1_dir = opendir( dirpath )) == NULL )
00985           {
00986             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno ;
00987             <span class="keywordflow">return</span> TRUE;
00988           }          
00989         }
00990         <span class="keywordflow">else</span> 
00991         {
00992           <span class="comment">/* test if it is an error or an end of dir */</span>
00993           <span class="keywordflow">if</span> ( errno != 0 )
00994           {
00995             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = errno;
00996             <span class="keywordflow">return</span> TRUE;
00997           }
00998           <span class="keywordflow">else</span>
00999           {
01000             <span class="comment">/* we are at the end of the level directory</span>
01001 <span class="comment">             * return End of Dir</span>
01002 <span class="comment">             */</span>
01003             <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = 0;
01004             <span class="keywordflow">return</span> FALSE;
01005           }
01006         }
01007       }
01008       <span class="keywordflow">else</span>
01009       {
01010         <span class="comment">/* invalid base directory descriptor */</span>
01011         <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = EINVAL;
01012         <span class="keywordflow">return</span> TRUE;        
01013       }
01014       
01015     } <span class="keywordflow">while</span> ( 1 );
01016         
01017     <a class="code" href="cache__content__emergency__flush_8c.html#a0">cache_content_dir_errno</a> = -1 ;
01018     <span class="comment">/* should never happen */</span>
01019     <span class="keywordflow">return</span> TRUE ;
01020     
01021 } <span class="comment">/* cache_content_local_cache_dir_iter */</span>
01022 
01023 
01024 
<a name="l01034"></a><a class="code" href="cache__content__misc_8c.html#a19">01034</a> <span class="keywordtype">void</span> <a class="code" href="cache__content__misc_8c.html#a19">cache_content_local_cache_closedir</a>( cache_content_dirinfo_t * directory )
01035 {
01036   <span class="keywordflow">if</span> ( directory != NULL)
01037   {
01038     <span class="keywordflow">if</span> ( directory-&gt;level2_dir != NULL )
01039     {
01040       closedir( directory-&gt;level2_dir ) ;
01041       directory-&gt;level2_dir = NULL ;
01042     }
01043     
01044     <span class="keywordflow">if</span> ( directory-&gt;level1_dir != NULL )
01045     {
01046       closedir( directory-&gt;level1_dir ) ;
01047       directory-&gt;level1_dir = NULL ;
01048     }
01049     
01050     <span class="keywordflow">if</span> ( directory-&gt;level0_dir != NULL )
01051     {
01052       closedir( directory-&gt;level0_dir ) ;
01053       directory-&gt;level0_dir = NULL ;
01054     }
01055   }
01056 } <span class="comment">/* cache_content_local_cache_closedir */</span>
01057 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Apr 9 08:24:20 2008 for File Content layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
