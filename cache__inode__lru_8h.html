<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>nfs-ganesha: cache_inode_lru.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">nfs-ganesha&#160;<span id="projectnumber">1.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>cache_inode_lru.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Constant-time cache inode cache management implementation.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cache__inode_8h_source.html">cache_inode.h</a>&quot;</code><br/>
</div>
<p><a href="cache__inode__lru_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlru__state.html">lru_state</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a9755b2d1771ba6b5fb6589c8bbbf2e73">LRU_N_Q_LANES</a>&#160;&#160;&#160;7</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a3867104f4ebef1bafec0d6f67a62b00b">cache_inode_lru_pkginit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a2da5e5fd9af43a7f17a5646baa47a82d">cache_inode_lru_pkgshutdown</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#af99a7e8e461fafaf070ee72d1deab584">cache_inode_lru_get</a> (<a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> *status, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-use or allocate an entry.  <a href="#af99a7e8e461fafaf070ee72d1deab584"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a35ad414c74b3fc59dfe0b72767b0057e">cache_inode_lru_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags) <a class="el" href="struct____attribute____.html">__attribute__</a>((warn_unused_result))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference.  <a href="#a35ad414c74b3fc59dfe0b72767b0057e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#af2406fc0968f41f94a70a2940beffddf">cache_inode_lru_kill</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the sentinel refcount safely.  <a href="#af2406fc0968f41f94a70a2940beffddf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a84096eac6e9589aed54c83040a4b0b2a">cache_inode_lru_unref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry, <a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquish a reference.  <a href="#a84096eac6e9589aed54c83040a4b0b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#aa5483629caef00dab52c51a1269037d2">lru_wake_thread</a> (<a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the LRU thread to free FDs.  <a href="#aa5483629caef00dab52c51a1269037d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a96bb243e361cf38c5ae8ac4c50c108f1">cache_inode_inc_pin_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let the state layer pin an entry.  <a href="#a96bb243e361cf38c5ae8ac4c50c108f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#aa1259fe625e57dd73a21c1105aaf8be3">cache_inode_unpinnable</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make it impossible to pin an entry.  <a href="#aa1259fe625e57dd73a21c1105aaf8be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a9b53565faa2bf3bb8a20467385b35e03">cache_inode_dec_pin_ref</a> (<a class="el" href="structcache__entry__t.html">cache_entry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let the state layer rlease a pin.  <a href="#a9b53565faa2bf3bb8a20467385b35e03"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlru__state.html">lru_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#a1e6338e569a2a798614f74e92539b8d9">lru_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cache__inode__lru_8h.html#afa15c96d409e40624b34e0d85b5df32c">open_fd_count</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Constant-time cache inode cache management implementation. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Matt Benjamin </dd></dl>
<h2><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h2>
<p>This module implements a constant-time cache management strategy based on LRU. Some ideas are taken from 2Q [Johnson and Shasha 1994] and MQ [Zhou, Chen, Li 2004]. In this system, cache management does interact with cache entry lifecycle. Also, the cache size high- and low- water mark management is maintained, but executes asynchronously to avoid inline request delay. Cache management operations execute in constant time, as expected with LRU (and MQ).</p>
<p>Cache entries in use by a currently-active protocol request (or other operation) have a positive refcount, and threfore should not be present at the cold end of an lru queue if the cache is well-sized.</p>
<p>Cache entries with lock and open state are not eligible for collection under ordinary circumstances, so are kept on a separate lru_pinned list to retain constant time. </p>

<p>Definition in file <a class="el" href="cache__inode__lru_8h_source.html">cache_inode_lru.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9755b2d1771ba6b5fb6589c8bbbf2e73"></a><!-- doxytag: member="cache_inode_lru.h::LRU_N_Q_LANES" ref="a9755b2d1771ba6b5fb6589c8bbbf2e73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LRU_N_Q_LANES&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cache__inode__lru_8h_source.html#l00155">155</a> of file <a class="el" href="cache__inode__lru_8h_source.html">cache_inode_lru.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9b53565faa2bf3bb8a20467385b35e03"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_dec_pin_ref" ref="a9b53565faa2bf3bb8a20467385b35e03" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_dec_pin_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to let the state layer rlease a pin. </p>
<p>This function moves the given entry out of the pinned queue fragment for its lane. If the entry is not pinned, it is a no-op.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the entry was moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01211">1211</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a96bb243e361cf38c5ae8ac4c50c108f1"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_inc_pin_ref" ref="a96bb243e361cf38c5ae8ac4c50c108f1" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_inc_pin_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to let the state layer pin an entry. </p>
<p>This function moves the given entry to the pinned queue fragment for its lane. If the entry is already pinned, it is a no-op.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the entry was moved. </td></tr>
    <tr><td class="paramname">CACHE_INODE_DEAD_ENTRY</td><td>if the entry is in the process of disposal </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01155">1155</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="af99a7e8e461fafaf070ee72d1deab584"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_get" ref="af99a7e8e461fafaf070ee72d1deab584" args="(cache_inode_status_t *status, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcache__entry__t.html">cache_entry_t</a>* cache_inode_lru_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-use or allocate an entry. </p>
<p>This function repurposes a resident entry in the LRU system if the system is above low-water mark, and allocates a new one otherwise. On success, this function always returns an entry with two references (one for the sentinel, one to allow the caller's use.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Returned status </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags governing call</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CACHE_INODE_SUCCESS or error. </dd></dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01056">1056</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="af2406fc0968f41f94a70a2940beffddf"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_kill" ref="af2406fc0968f41f94a70a2940beffddf" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the sentinel refcount safely. </p>
<p>This function decrements the refcount by one unless the LRU_FLAG_KILLED bit is set in the flags word. This is intended to allow a function that needs to remove an extra refcount (the sentinel) to be called multiple times without causing an underflow.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to decrement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01307">1307</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3867104f4ebef1bafec0d6f67a62b00b"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_pkginit" ref="a3867104f4ebef1bafec0d6f67a62b00b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_pkginit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize subsystem </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00876">876</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2da5e5fd9af43a7f17a5646baa47a82d"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_pkgshutdown" ref="a2da5e5fd9af43a7f17a5646baa47a82d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_pkgshutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown subsystem </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01032">1032</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a35ad414c74b3fc59dfe0b72767b0057e"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_ref" ref="a35ad414c74b3fc59dfe0b72767b0057e" args="(cache_entry_t *entry, uint32_t flags) __attribute__((warn_unused_result))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a> cache_inode_lru_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference. </p>
<p>This function acquires a reference on the given cache entry, if the entry is still live. Terrible things will happen if you call this function and don't check its return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry on which to get a reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags indicating the type of reference sought</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">CACHE_INODE_SUCCESS</td><td>if the reference was acquired </td></tr>
    <tr><td class="paramname">CACHE_INODE_DEAD_ENTRY</td><td>if the object is being disposed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01247">1247</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="a84096eac6e9589aed54c83040a4b0b2a"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_lru_unref" ref="a84096eac6e9589aed54c83040a4b0b2a" args="(cache_entry_t *entry, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_lru_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relinquish a reference. </p>
<p>This function relinquishes a reference on the given cache entry. It follows the disposal/recycling lock discipline given at the beginning of the file.</p>
<p>The supplied entry is always either unlocked or destroyed by the time this function returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry on which to release a reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Currently significant are and LRU_FLAG_LOCKED (indicating that the caller holds the LRU mutex lock for this entry.) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01337">1337</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa1259fe625e57dd73a21c1105aaf8be3"></a><!-- doxytag: member="cache_inode_lru.h::cache_inode_unpinnable" ref="aa1259fe625e57dd73a21c1105aaf8be3" args="(cache_entry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_inode_unpinnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcache__entry__t.html">cache_entry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make it impossible to pin an entry. </p>
<p>This function makes it impossible to pin an entry, but does not unpin it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>The entry to be moved </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01191">1191</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa5483629caef00dab52c51a1269037d2"></a><!-- doxytag: member="cache_inode_lru.h::lru_wake_thread" ref="aa5483629caef00dab52c51a1269037d2" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lru_wake_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wake the LRU thread to free FDs. </p>
<p>This function wakes the LRU reaper thread to free FDs and should be called when we are over the high water mark.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags to affect the wake (currently none) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l01397">1397</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a1e6338e569a2a798614f74e92539b8d9"></a><!-- doxytag: member="cache_inode_lru.h::lru_state" ref="a1e6338e569a2a798614f74e92539b8d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlru__state.html">lru_state</a> <a class="el" href="structlru__state.html">lru_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00124">124</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
<a class="anchor" id="afa15c96d409e40624b34e0d85b5df32c"></a><!-- doxytag: member="cache_inode_lru.h::open_fd_count" ref="afa15c96d409e40624b34e0d85b5df32c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="cache__inode__lru_8h.html#afa15c96d409e40624b34e0d85b5df32c">open_fd_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a global counter of files opened by cache_inode. This is preliminary expected to go away. Problems with this method are that it overcounts file descriptors for FSALs that don't use them for open files, and, under the Lieb Rearchitecture, FSALs will be responsible for caching their own file descriptors, with interfaces for Cache_Inode to interrogate them as to usage or instruct them to close them. </p>

<p>Definition at line <a class="el" href="cache__inode__lru_8c_source.html#l00178">178</a> of file <a class="el" href="cache__inode__lru_8c_source.html">cache_inode_lru.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 21 2012 for nfs-ganesha by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
